/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 5149:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(4114);
__webpack_require__(6573);
__webpack_require__(8100);
__webpack_require__(7936);
__webpack_require__(7642);
__webpack_require__(8004);
__webpack_require__(3853);
__webpack_require__(5876);
__webpack_require__(2475);
__webpack_require__(5024);
__webpack_require__(1698);
__webpack_require__(7467);
__webpack_require__(4732);
__webpack_require__(9577);
__webpack_require__(4603);
__webpack_require__(7566);
__webpack_require__(8721);
!function (e) {
  if (true) module.exports = e();else {}
}(function () {
  return function () {
    return function e(t, r, n) {
      function i(s, a) {
        if (!r[s]) {
          if (!t[s]) {
            var l = undefined;
            if (!a && l) return require(s, !0);
            if (o) return o(s, !0);
            var u = new Error("Cannot find module '" + s + "'");
            throw u.code = "MODULE_NOT_FOUND", u;
          }
          var c = r[s] = {
            exports: {}
          };
          t[s][0].call(c.exports, function (e) {
            return i(t[s][1][e] || e);
          }, c, c.exports, e, t, r, n);
        }
        return r[s].exports;
      }
      for (var o = undefined, s = 0; s < n.length; s++) i(n[s]);
      return i;
    };
  }()({
    1: [function (e, t, r) {
      (function (r, n) {
        (function () {
          "use strict";

          const i = e("events").EventEmitter,
            o = e("./store"),
            s = e("./topic-alias-recv"),
            a = e("./topic-alias-send"),
            l = e("mqtt-packet"),
            u = e("./default-message-id-provider"),
            c = e("readable-stream").Writable,
            h = e("inherits"),
            f = e("reinterval"),
            p = e("rfdc/default"),
            d = e("./validations"),
            g = e("xtend"),
            y = e("debug")("mqttjs:client"),
            b = r ? r.nextTick : function (e) {
              setTimeout(e, 0);
            },
            m = n.setImmediate || function (e) {
              b(e);
            },
            v = {
              keepalive: 60,
              reschedulePings: !0,
              protocolId: "MQTT",
              protocolVersion: 4,
              reconnectPeriod: 1e3,
              connectTimeout: 3e4,
              clean: !0,
              resubscribe: !0
            },
            w = {
              0: "",
              1: "Unacceptable protocol version",
              2: "Identifier rejected",
              3: "Server unavailable",
              4: "Bad username or password",
              5: "Not authorized",
              16: "No matching subscribers",
              17: "No subscription existed",
              128: "Unspecified error",
              129: "Malformed Packet",
              130: "Protocol Error",
              131: "Implementation specific error",
              132: "Unsupported Protocol Version",
              133: "Client Identifier not valid",
              134: "Bad User Name or Password",
              135: "Not authorized",
              136: "Server unavailable",
              137: "Server busy",
              138: "Banned",
              139: "Server shutting down",
              140: "Bad authentication method",
              141: "Keep Alive timeout",
              142: "Session taken over",
              143: "Topic Filter invalid",
              144: "Topic Name invalid",
              145: "Packet identifier in use",
              146: "Packet Identifier not found",
              147: "Receive Maximum exceeded",
              148: "Topic Alias invalid",
              149: "Packet too large",
              150: "Message rate too high",
              151: "Quota exceeded",
              152: "Administrative action",
              153: "Payload format invalid",
              154: "Retain not supported",
              155: "QoS not supported",
              156: "Use another server",
              157: "Server moved",
              158: "Shared Subscriptions not supported",
              159: "Connection rate exceeded",
              160: "Maximum connect time",
              161: "Subscription Identifiers not supported",
              162: "Wildcard Subscriptions not supported"
            };
          function _(e, t) {
            let r;
            t.properties && (r = t.properties.topicAlias);
            let n = t.topic.toString();
            if (0 === n.length) {
              if (void 0 === r) return new Error("Unregistered Topic Alias");
              if (void 0 === (n = e.topicAliasSend.getTopicByAlias(r))) return new Error("Unregistered Topic Alias");
              t.topic = n;
            }
            r && delete t.properties.topicAlias;
          }
          function k(e, t, r) {
            y("sendPacket :: packet: %O", t), y("sendPacket :: emitting `packetsend`"), e.emit("packetsend", t), y("sendPacket :: writing to stream");
            const n = l.writeToStream(t, e.stream, e.options);
            y("sendPacket :: writeToStream result %s", n), !n && r && r !== E ? (y("sendPacket :: handle events on `drain` once through callback."), e.stream.once("drain", r)) : r && (y("sendPacket :: invoking cb"), r());
          }
          function S(e, t, r, n) {
            y("storeAndSend :: store packet with cmd %s to outgoingStore", t.cmd);
            let i,
              o = t;
            if ("publish" === o.cmd && (o = p(t), i = _(e, o))) return r && r(i);
            e.outgoingStore.put(o, function (i) {
              if (i) return r && r(i);
              n(), k(e, t, r);
            });
          }
          function E(e) {
            y("nop ::", e);
          }
          function C(e, t) {
            let r;
            const n = this;
            if (!(this instanceof C)) return new C(e, t);
            for (r in this.options = t || {}, v) void 0 === this.options[r] ? this.options[r] = v[r] : this.options[r] = t[r];
            y("MqttClient :: options.protocol", t.protocol), y("MqttClient :: options.protocolVersion", t.protocolVersion), y("MqttClient :: options.username", t.username), y("MqttClient :: options.keepalive", t.keepalive), y("MqttClient :: options.reconnectPeriod", t.reconnectPeriod), y("MqttClient :: options.rejectUnauthorized", t.rejectUnauthorized), y("MqttClient :: options.topicAliasMaximum", t.topicAliasMaximum), this.options.clientId = "string" == typeof t.clientId ? t.clientId : "mqttjs_" + Math.random().toString(16).substr(2, 8), y("MqttClient :: clientId", this.options.clientId), this.options.customHandleAcks = 5 === t.protocolVersion && t.customHandleAcks ? t.customHandleAcks : function () {
              arguments[3](0);
            }, this.streamBuilder = e, this.messageIdProvider = void 0 === this.options.messageIdProvider ? new u() : this.options.messageIdProvider, this.outgoingStore = t.outgoingStore || new o(), this.incomingStore = t.incomingStore || new o(), this.queueQoSZero = void 0 === t.queueQoSZero || t.queueQoSZero, this._resubscribeTopics = {}, this.messageIdToTopic = {}, this.pingTimer = null, this.connected = !1, this.disconnecting = !1, this.queue = [], this.connackTimer = null, this.reconnectTimer = null, this._storeProcessing = !1, this._packetIdsDuringStoreProcessing = {}, this._storeProcessingQueue = [], this.outgoing = {}, this._firstConnection = !0, t.topicAliasMaximum > 0 && (t.topicAliasMaximum > 65535 ? y("MqttClient :: options.topicAliasMaximum is out of range") : this.topicAliasRecv = new s(t.topicAliasMaximum)), this.on("connect", function () {
              const e = this.queue;
              y("connect :: sending queued packets"), function t() {
                const r = e.shift();
                y("deliver :: entry %o", r);
                let i = null;
                if (!r) return void n._resubscribe();
                i = r.packet, y("deliver :: call _sendPacket for %o", i);
                let o = !0;
                i.messageId && 0 !== i.messageId && (n.messageIdProvider.register(i.messageId) || (o = !1)), o ? n._sendPacket(i, function (e) {
                  r.cb && r.cb(e), t();
                }) : (y("messageId: %d has already used. The message is skipped and removed.", i.messageId), t());
              }();
            }), this.on("close", function () {
              y("close :: connected set to `false`"), this.connected = !1, y("close :: clearing connackTimer"), clearTimeout(this.connackTimer), y("close :: clearing ping timer"), null !== n.pingTimer && (n.pingTimer.clear(), n.pingTimer = null), this.topicAliasRecv && this.topicAliasRecv.clear(), y("close :: calling _setupReconnect"), this._setupReconnect();
            }), i.call(this), y("MqttClient :: setting up stream"), this._setupStream();
          }
          h(C, i), C.prototype._setupStream = function () {
            const e = this,
              t = new c(),
              r = l.parser(this.options);
            let n = null;
            const i = [];
            function o() {
              if (i.length) b(s);else {
                const e = n;
                n = null, e();
              }
            }
            function s() {
              y("work :: getting next packet in queue");
              const t = i.shift();
              if (t) y("work :: packet pulled from queue"), e._handlePacket(t, o);else {
                y("work :: no packets in queue");
                const e = n;
                n = null, y("work :: done flag is %s", !!e), e && e();
              }
            }
            y("_setupStream :: calling method to clear reconnect"), this._clearReconnect(), y("_setupStream :: using streamBuilder provided to client to create stream"), this.stream = this.streamBuilder(this), r.on("packet", function (e) {
              y("parser :: on packet push to packets array."), i.push(e);
            }), t._write = function (e, t, i) {
              n = i, y("writable stream :: parsing buffer"), r.parse(e), s();
            }, y("_setupStream :: pipe stream to writable stream"), this.stream.pipe(t), this.stream.on("error", function (t) {
              y("streamErrorHandler :: error", t.message), t.code ? (y("streamErrorHandler :: emitting error"), e.emit("error", t)) : E(t);
            }), this.stream.on("close", function () {
              var t;
              y("(%s)stream :: on close", e.options.clientId), (t = e.outgoing) && (y("flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function"), Object.keys(t).forEach(function (e) {
                t[e].volatile && "function" == typeof t[e].cb && (t[e].cb(new Error("Connection closed")), delete t[e]);
              })), y("stream: emit close to MqttClient"), e.emit("close");
            }), y("_setupStream: sending packet `connect`");
            const a = Object.create(this.options);
            if (a.cmd = "connect", this.topicAliasRecv && (a.properties || (a.properties = {}), this.topicAliasRecv && (a.properties.topicAliasMaximum = this.topicAliasRecv.max)), k(this, a), r.on("error", this.emit.bind(this, "error")), this.options.properties) {
              if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) return e.end(() => this.emit("error", new Error("Packet has no Authentication Method"))), this;
              if (this.options.properties.authenticationMethod && this.options.authPacket && "object" == typeof this.options.authPacket) {
                k(this, g({
                  cmd: "auth",
                  reasonCode: 0
                }, this.options.authPacket));
              }
            }
            this.stream.setMaxListeners(1e3), clearTimeout(this.connackTimer), this.connackTimer = setTimeout(function () {
              y("!!connectTimeout hit!! Calling _cleanUp with force `true`"), e._cleanUp(!0);
            }, this.options.connectTimeout);
          }, C.prototype._handlePacket = function (e, t) {
            const r = this.options;
            if (5 === r.protocolVersion && r.properties && r.properties.maximumPacketSize && r.properties.maximumPacketSize < e.length) return this.emit("error", new Error("exceeding packets size " + e.cmd)), this.end({
              reasonCode: 149,
              properties: {
                reasonString: "Maximum packet size was exceeded"
              }
            }), this;
            switch (y("_handlePacket :: emitting packetreceive"), this.emit("packetreceive", e), e.cmd) {
              case "publish":
                this._handlePublish(e, t);
                break;
              case "puback":
              case "pubrec":
              case "pubcomp":
              case "suback":
              case "unsuback":
                this._handleAck(e), t();
                break;
              case "pubrel":
                this._handlePubrel(e, t);
                break;
              case "connack":
                this._handleConnack(e), t();
                break;
              case "auth":
                this._handleAuth(e), t();
                break;
              case "pingresp":
                this._handlePingresp(e), t();
                break;
              case "disconnect":
                this._handleDisconnect(e), t();
            }
          }, C.prototype._checkDisconnecting = function (e) {
            return this.disconnecting && (e && e !== E ? e(new Error("client disconnecting")) : this.emit("error", new Error("client disconnecting"))), this.disconnecting;
          }, C.prototype.publish = function (e, t, r, n) {
            y("publish :: message `%s` to topic `%s`", t, e);
            const i = this.options;
            "function" == typeof r && (n = r, r = null);
            if (r = g({
              qos: 0,
              retain: !1,
              dup: !1
            }, r), this._checkDisconnecting(n)) return this;
            const o = this,
              s = function () {
                let s = 0;
                if ((1 === r.qos || 2 === r.qos) && null === (s = o._nextId())) return y("No messageId left"), !1;
                const a = {
                  cmd: "publish",
                  topic: e,
                  payload: t,
                  qos: r.qos,
                  retain: r.retain,
                  messageId: s,
                  dup: r.dup
                };
                switch (5 === i.protocolVersion && (a.properties = r.properties), y("publish :: qos", r.qos), r.qos) {
                  case 1:
                  case 2:
                    o.outgoing[a.messageId] = {
                      volatile: !1,
                      cb: n || E
                    }, y("MqttClient:publish: packet cmd: %s", a.cmd), o._sendPacket(a, void 0, r.cbStorePut);
                    break;
                  default:
                    y("MqttClient:publish: packet cmd: %s", a.cmd), o._sendPacket(a, n, r.cbStorePut);
                }
                return !0;
              };
            return (this._storeProcessing || this._storeProcessingQueue.length > 0 || !s()) && this._storeProcessingQueue.push({
              invoke: s,
              cbStorePut: r.cbStorePut,
              callback: n
            }), this;
          }, C.prototype.subscribe = function () {
            const e = this,
              t = new Array(arguments.length);
            for (let e = 0; e < arguments.length; e++) t[e] = arguments[e];
            const r = [];
            let n = t.shift();
            const i = n.resubscribe;
            let o = t.pop() || E,
              s = t.pop();
            const a = this.options.protocolVersion;
            delete n.resubscribe, "string" == typeof n && (n = [n]), "function" != typeof o && (s = o, o = E);
            const l = d.validateTopics(n);
            if (null !== l) return m(o, new Error("Invalid topic " + l)), this;
            if (this._checkDisconnecting(o)) return y("subscribe: discconecting true"), this;
            const u = {
              qos: 0
            };
            if (5 === a && (u.nl = !1, u.rap = !1, u.rh = 0), s = g(u, s), Array.isArray(n) ? n.forEach(function (t) {
              if (y("subscribe: array topic %s", t), !Object.prototype.hasOwnProperty.call(e._resubscribeTopics, t) || e._resubscribeTopics[t].qos < s.qos || i) {
                const e = {
                  topic: t,
                  qos: s.qos
                };
                5 === a && (e.nl = s.nl, e.rap = s.rap, e.rh = s.rh, e.properties = s.properties), y("subscribe: pushing topic `%s` and qos `%s` to subs list", e.topic, e.qos), r.push(e);
              }
            }) : Object.keys(n).forEach(function (t) {
              if (y("subscribe: object topic %s", t), !Object.prototype.hasOwnProperty.call(e._resubscribeTopics, t) || e._resubscribeTopics[t].qos < n[t].qos || i) {
                const e = {
                  topic: t,
                  qos: n[t].qos
                };
                5 === a && (e.nl = n[t].nl, e.rap = n[t].rap, e.rh = n[t].rh, e.properties = s.properties), y("subscribe: pushing `%s` to subs list", e), r.push(e);
              }
            }), !r.length) return o(null, []), this;
            const c = function () {
              const t = e._nextId();
              if (null === t) return y("No messageId left"), !1;
              const n = {
                cmd: "subscribe",
                subscriptions: r,
                qos: 1,
                retain: !1,
                dup: !1,
                messageId: t
              };
              if (s.properties && (n.properties = s.properties), e.options.resubscribe) {
                y("subscribe :: resubscribe true");
                const t = [];
                r.forEach(function (r) {
                  if (e.options.reconnectPeriod > 0) {
                    const n = {
                      qos: r.qos
                    };
                    5 === a && (n.nl = r.nl || !1, n.rap = r.rap || !1, n.rh = r.rh || 0, n.properties = r.properties), e._resubscribeTopics[r.topic] = n, t.push(r.topic);
                  }
                }), e.messageIdToTopic[n.messageId] = t;
              }
              return e.outgoing[n.messageId] = {
                volatile: !0,
                cb: function (e, t) {
                  if (!e) {
                    const e = t.granted;
                    for (let t = 0; t < e.length; t += 1) r[t].qos = e[t];
                  }
                  o(e, r);
                }
              }, y("subscribe :: call _sendPacket"), e._sendPacket(n), !0;
            };
            return (this._storeProcessing || this._storeProcessingQueue.length > 0 || !c()) && this._storeProcessingQueue.push({
              invoke: c,
              callback: o
            }), this;
          }, C.prototype.unsubscribe = function () {
            const e = this,
              t = new Array(arguments.length);
            for (let e = 0; e < arguments.length; e++) t[e] = arguments[e];
            let r = t.shift(),
              n = t.pop() || E,
              i = t.pop();
            "string" == typeof r && (r = [r]), "function" != typeof n && (i = n, n = E);
            const o = d.validateTopics(r);
            if (null !== o) return m(n, new Error("Invalid topic " + o)), this;
            if (e._checkDisconnecting(n)) return this;
            const s = function () {
              const t = e._nextId();
              if (null === t) return y("No messageId left"), !1;
              const o = {
                cmd: "unsubscribe",
                qos: 1,
                messageId: t
              };
              return "string" == typeof r ? o.unsubscriptions = [r] : Array.isArray(r) && (o.unsubscriptions = r), e.options.resubscribe && o.unsubscriptions.forEach(function (t) {
                delete e._resubscribeTopics[t];
              }), "object" == typeof i && i.properties && (o.properties = i.properties), e.outgoing[o.messageId] = {
                volatile: !0,
                cb: n
              }, y("unsubscribe: call _sendPacket"), e._sendPacket(o), !0;
            };
            return (this._storeProcessing || this._storeProcessingQueue.length > 0 || !s()) && this._storeProcessingQueue.push({
              invoke: s,
              callback: n
            }), this;
          }, C.prototype.end = function (e, t, r) {
            const n = this;
            function i() {
              y("end :: (%s) :: finish :: calling _cleanUp with force %s", n.options.clientId, e), n._cleanUp(e, () => {
                y("end :: finish :: calling process.nextTick on closeStores"), b(function () {
                  y("end :: closeStores: closing incoming and outgoing stores"), n.disconnected = !0, n.incomingStore.close(function (e) {
                    n.outgoingStore.close(function (t) {
                      if (y("end :: closeStores: emitting end"), n.emit("end"), r) {
                        const n = e || t;
                        y("end :: closeStores: invoking callback with args"), r(n);
                      }
                    });
                  }), n._deferredReconnect && n._deferredReconnect();
                }.bind(n));
              }, t);
            }
            return y("end :: (%s)", this.options.clientId), null != e && "boolean" == typeof e || (r = t || E, t = e, e = !1, "object" != typeof t && (r = t, t = null, "function" != typeof r && (r = E))), "object" != typeof t && (r = t, t = null), y("end :: cb? %s", !!r), r = r || E, this.disconnecting ? (r(), this) : (this._clearReconnect(), this.disconnecting = !0, !e && Object.keys(this.outgoing).length > 0 ? (y("end :: (%s) :: calling finish in 10ms once outgoing is empty", n.options.clientId), this.once("outgoingEmpty", setTimeout.bind(null, i, 10))) : (y("end :: (%s) :: immediately calling finish", n.options.clientId), i()), this);
          }, C.prototype.removeOutgoingMessage = function (e) {
            const t = this.outgoing[e] ? this.outgoing[e].cb : null;
            return delete this.outgoing[e], this.outgoingStore.del({
              messageId: e
            }, function () {
              t(new Error("Message removed"));
            }), this;
          }, C.prototype.reconnect = function (e) {
            y("client reconnect");
            const t = this,
              r = function () {
                e ? (t.options.incomingStore = e.incomingStore, t.options.outgoingStore = e.outgoingStore) : (t.options.incomingStore = null, t.options.outgoingStore = null), t.incomingStore = t.options.incomingStore || new o(), t.outgoingStore = t.options.outgoingStore || new o(), t.disconnecting = !1, t.disconnected = !1, t._deferredReconnect = null, t._reconnect();
              };
            return this.disconnecting && !this.disconnected ? this._deferredReconnect = r : r(), this;
          }, C.prototype._reconnect = function () {
            y("_reconnect: emitting reconnect to client"), this.emit("reconnect"), this.connected ? (this.end(() => {
              this._setupStream();
            }), y("client already connected. disconnecting first.")) : (y("_reconnect: calling _setupStream"), this._setupStream());
          }, C.prototype._setupReconnect = function () {
            const e = this;
            !e.disconnecting && !e.reconnectTimer && e.options.reconnectPeriod > 0 ? (this.reconnecting || (y("_setupReconnect :: emit `offline` state"), this.emit("offline"), y("_setupReconnect :: set `reconnecting` to `true`"), this.reconnecting = !0), y("_setupReconnect :: setting reconnectTimer for %d ms", e.options.reconnectPeriod), e.reconnectTimer = setInterval(function () {
              y("reconnectTimer :: reconnect triggered!"), e._reconnect();
            }, e.options.reconnectPeriod)) : y("_setupReconnect :: doing nothing...");
          }, C.prototype._clearReconnect = function () {
            y("_clearReconnect : clearing reconnect timer"), this.reconnectTimer && (clearInterval(this.reconnectTimer), this.reconnectTimer = null);
          }, C.prototype._cleanUp = function (e, t) {
            const r = arguments[2];
            if (t && (y("_cleanUp :: done callback provided for on stream close"), this.stream.on("close", t)), y("_cleanUp :: forced? %s", e), e) 0 === this.options.reconnectPeriod && this.options.clean && (n = this.outgoing) && (y("flush: queue exists? %b", !!n), Object.keys(n).forEach(function (e) {
              "function" == typeof n[e].cb && (n[e].cb(new Error("Connection closed")), delete n[e]);
            })), y("_cleanUp :: (%s) :: destroying stream", this.options.clientId), this.stream.destroy();else {
              const e = g({
                cmd: "disconnect"
              }, r);
              y("_cleanUp :: (%s) :: call _sendPacket with disconnect packet", this.options.clientId), this._sendPacket(e, m.bind(null, this.stream.end.bind(this.stream)));
            }
            var n;
            this.disconnecting || (y("_cleanUp :: client not disconnecting. Clearing and resetting reconnect."), this._clearReconnect(), this._setupReconnect()), null !== this.pingTimer && (y("_cleanUp :: clearing pingTimer"), this.pingTimer.clear(), this.pingTimer = null), t && !this.connected && (y("_cleanUp :: (%s) :: removing stream `done` callback `close` listener", this.options.clientId), this.stream.removeListener("close", t), t());
          }, C.prototype._sendPacket = function (e, t, r) {
            y("_sendPacket :: (%s) ::  start", this.options.clientId), r = r || E, t = t || E;
            const n = function (e, t) {
              if (5 === e.options.protocolVersion && "publish" === t.cmd) {
                let r;
                t.properties && (r = t.properties.topicAlias);
                const n = t.topic.toString();
                if (e.topicAliasSend) {
                  if (r) {
                    if (0 !== n.length && (y("applyTopicAlias :: register topic: %s - alias: %d", n, r), !e.topicAliasSend.put(n, r))) return y("applyTopicAlias :: error out of range. topic: %s - alias: %d", n, r), new Error("Sending Topic Alias out of range");
                  } else 0 !== n.length && (e.options.autoAssignTopicAlias ? (r = e.topicAliasSend.getAliasByTopic(n)) ? (t.topic = "", t.properties = {
                    ...t.properties,
                    topicAlias: r
                  }, y("applyTopicAlias :: auto assign(use) topic: %s - alias: %d", n, r)) : (r = e.topicAliasSend.getLruAlias(), e.topicAliasSend.put(n, r), t.properties = {
                    ...t.properties,
                    topicAlias: r
                  }, y("applyTopicAlias :: auto assign topic: %s - alias: %d", n, r)) : e.options.autoUseTopicAlias && (r = e.topicAliasSend.getAliasByTopic(n)) && (t.topic = "", t.properties = {
                    ...t.properties,
                    topicAlias: r
                  }, y("applyTopicAlias :: auto use topic: %s - alias: %d", n, r)));
                } else if (r) return y("applyTopicAlias :: error out of range. topic: %s - alias: %d", n, r), new Error("Sending Topic Alias out of range");
              }
            }(this, e);
            if (n) t(n);else {
              if (!this.connected) return "auth" === e.cmd ? (this._shiftPingInterval(), void k(this, e, t)) : (y("_sendPacket :: client not connected. Storing packet offline."), void this._storePacket(e, t, r));
              switch (this._shiftPingInterval(), e.cmd) {
                case "publish":
                  break;
                case "pubrel":
                  return void S(this, e, t, r);
                default:
                  return void k(this, e, t);
              }
              switch (e.qos) {
                case 2:
                case 1:
                  S(this, e, t, r);
                  break;
                case 0:
                default:
                  k(this, e, t);
              }
              y("_sendPacket :: (%s) ::  end", this.options.clientId);
            }
          }, C.prototype._storePacket = function (e, t, r) {
            y("_storePacket :: packet: %o", e), y("_storePacket :: cb? %s", !!t), r = r || E;
            let n = e;
            if ("publish" === n.cmd) {
              const r = _(this, n = p(e));
              if (r) return t && t(r);
            }
            0 === (n.qos || 0) && this.queueQoSZero || "publish" !== n.cmd ? this.queue.push({
              packet: n,
              cb: t
            }) : n.qos > 0 ? (t = this.outgoing[n.messageId] ? this.outgoing[n.messageId].cb : null, this.outgoingStore.put(n, function (e) {
              if (e) return t && t(e);
              r();
            })) : t && t(new Error("No connection to broker"));
          }, C.prototype._setupPingTimer = function () {
            y("_setupPingTimer :: keepalive %d (seconds)", this.options.keepalive);
            const e = this;
            !this.pingTimer && this.options.keepalive && (this.pingResp = !0, this.pingTimer = f(function () {
              e._checkPing();
            }, 1e3 * this.options.keepalive));
          }, C.prototype._shiftPingInterval = function () {
            this.pingTimer && this.options.keepalive && this.options.reschedulePings && this.pingTimer.reschedule(1e3 * this.options.keepalive);
          }, C.prototype._checkPing = function () {
            y("_checkPing :: checking ping..."), this.pingResp ? (y("_checkPing :: ping response received. Clearing flag and sending `pingreq`"), this.pingResp = !1, this._sendPacket({
              cmd: "pingreq"
            })) : (y("_checkPing :: calling _cleanUp with force true"), this._cleanUp(!0));
          }, C.prototype._handlePingresp = function () {
            this.pingResp = !0;
          }, C.prototype._handleConnack = function (e) {
            y("_handleConnack");
            const t = this.options,
              r = 5 === t.protocolVersion ? e.reasonCode : e.returnCode;
            if (clearTimeout(this.connackTimer), delete this.topicAliasSend, e.properties) {
              if (e.properties.topicAliasMaximum) {
                if (e.properties.topicAliasMaximum > 65535) return void this.emit("error", new Error("topicAliasMaximum from broker is out of range"));
                e.properties.topicAliasMaximum > 0 && (this.topicAliasSend = new a(e.properties.topicAliasMaximum));
              }
              e.properties.serverKeepAlive && t.keepalive && (t.keepalive = e.properties.serverKeepAlive, this._shiftPingInterval()), e.properties.maximumPacketSize && (t.properties || (t.properties = {}), t.properties.maximumPacketSize = e.properties.maximumPacketSize);
            }
            if (0 === r) this.reconnecting = !1, this._onConnect(e);else if (r > 0) {
              const e = new Error("Connection refused: " + w[r]);
              e.code = r, this.emit("error", e);
            }
          }, C.prototype._handleAuth = function (e) {
            const t = this.options.protocolVersion,
              r = 5 === t ? e.reasonCode : e.returnCode;
            if (5 !== t) {
              const e = new Error("Protocol error: Auth packets are only supported in MQTT 5. Your version:" + t);
              return e.code = r, void this.emit("error", e);
            }
            const n = this;
            this.handleAuth(e, function (e, t) {
              if (e) n.emit("error", e);else if (24 === r) n.reconnecting = !1, n._sendPacket(t);else {
                const t = new Error("Connection refused: " + w[r]);
                e.code = r, n.emit("error", t);
              }
            });
          }, C.prototype.handleAuth = function (e, t) {
            t();
          }, C.prototype._handlePublish = function (e, t) {
            y("_handlePublish: packet %o", e), t = void 0 !== t ? t : E;
            let r = e.topic.toString();
            const n = e.payload,
              i = e.qos,
              o = e.messageId,
              s = this,
              a = this.options,
              l = [0, 16, 128, 131, 135, 144, 145, 151, 153];
            if (5 === this.options.protocolVersion) {
              let t;
              if (e.properties && (t = e.properties.topicAlias), void 0 !== t) if (0 === r.length) {
                if (!(t > 0 && t <= 65535)) return y("_handlePublish :: topic alias out of range. alias: %d", t), void this.emit("error", new Error("Received Topic Alias is out of range"));
                {
                  const e = this.topicAliasRecv.getTopicByAlias(t);
                  if (!e) return y("_handlePublish :: unregistered topic alias. alias: %d", t), void this.emit("error", new Error("Received unregistered Topic Alias"));
                  y("_handlePublish :: topic complemented by alias. topic: %s - alias: %d", r = e, t);
                }
              } else {
                if (!this.topicAliasRecv.put(r, t)) return y("_handlePublish :: topic alias out of range. alias: %d", t), void this.emit("error", new Error("Received Topic Alias is out of range"));
                y("_handlePublish :: registered topic: %s - alias: %d", r, t);
              }
            }
            switch (y("_handlePublish: qos %d", i), i) {
              case 2:
                a.customHandleAcks(r, n, e, function (r, n) {
                  return r instanceof Error || (n = r, r = null), r ? s.emit("error", r) : -1 === l.indexOf(n) ? s.emit("error", new Error("Wrong reason code for pubrec")) : void (n ? s._sendPacket({
                    cmd: "pubrec",
                    messageId: o,
                    reasonCode: n
                  }, t) : s.incomingStore.put(e, function () {
                    s._sendPacket({
                      cmd: "pubrec",
                      messageId: o
                    }, t);
                  }));
                });
                break;
              case 1:
                a.customHandleAcks(r, n, e, function (i, a) {
                  return i instanceof Error || (a = i, i = null), i ? s.emit("error", i) : -1 === l.indexOf(a) ? s.emit("error", new Error("Wrong reason code for puback")) : (a || s.emit("message", r, n, e), void s.handleMessage(e, function (e) {
                    if (e) return t && t(e);
                    s._sendPacket({
                      cmd: "puback",
                      messageId: o,
                      reasonCode: a
                    }, t);
                  }));
                });
                break;
              case 0:
                this.emit("message", r, n, e), this.handleMessage(e, t);
                break;
              default:
                y("_handlePublish: unknown QoS. Doing nothing.");
            }
          }, C.prototype.handleMessage = function (e, t) {
            t();
          }, C.prototype._handleAck = function (e) {
            const t = e.messageId,
              r = e.cmd;
            let n = null;
            const i = this.outgoing[t] ? this.outgoing[t].cb : null,
              o = this;
            let s;
            if (i) {
              switch (y("_handleAck :: packet type", r), r) {
                case "pubcomp":
                case "puback":
                  {
                    const r = e.reasonCode;
                    r && r > 0 && 16 !== r && ((s = new Error("Publish error: " + w[r])).code = r, i(s, e)), delete this.outgoing[t], this.outgoingStore.del(e, i), this.messageIdProvider.deallocate(t), this._invokeStoreProcessingQueue();
                    break;
                  }
                case "pubrec":
                  {
                    n = {
                      cmd: "pubrel",
                      qos: 2,
                      messageId: t
                    };
                    const r = e.reasonCode;
                    r && r > 0 && 16 !== r ? ((s = new Error("Publish error: " + w[r])).code = r, i(s, e)) : this._sendPacket(n);
                    break;
                  }
                case "suback":
                  delete this.outgoing[t], this.messageIdProvider.deallocate(t);
                  for (let r = 0; r < e.granted.length; r++) if (0 != (128 & e.granted[r])) {
                    const e = this.messageIdToTopic[t];
                    e && e.forEach(function (e) {
                      delete o._resubscribeTopics[e];
                    });
                  }
                  this._invokeStoreProcessingQueue(), i(null, e);
                  break;
                case "unsuback":
                  delete this.outgoing[t], this.messageIdProvider.deallocate(t), this._invokeStoreProcessingQueue(), i(null);
                  break;
                default:
                  o.emit("error", new Error("unrecognized packet type"));
              }
              this.disconnecting && 0 === Object.keys(this.outgoing).length && this.emit("outgoingEmpty");
            } else y("_handleAck :: Server sent an ack in error. Ignoring.");
          }, C.prototype._handlePubrel = function (e, t) {
            y("handling pubrel packet"), t = void 0 !== t ? t : E;
            const r = this,
              n = {
                cmd: "pubcomp",
                messageId: e.messageId
              };
            r.incomingStore.get(e, function (e, i) {
              e ? r._sendPacket(n, t) : (r.emit("message", i.topic, i.payload, i), r.handleMessage(i, function (e) {
                if (e) return t(e);
                r.incomingStore.del(i, E), r._sendPacket(n, t);
              }));
            });
          }, C.prototype._handleDisconnect = function (e) {
            this.emit("disconnect", e);
          }, C.prototype._nextId = function () {
            return this.messageIdProvider.allocate();
          }, C.prototype.getLastMessageId = function () {
            return this.messageIdProvider.getLastAllocated();
          }, C.prototype._resubscribe = function () {
            y("_resubscribe");
            const e = Object.keys(this._resubscribeTopics);
            if (!this._firstConnection && (this.options.clean || 5 === this.options.protocolVersion && !this.connackPacket.sessionPresent) && e.length > 0) if (this.options.resubscribe) {
              if (5 === this.options.protocolVersion) {
                y("_resubscribe: protocolVersion 5");
                for (let t = 0; t < e.length; t++) {
                  const r = {};
                  r[e[t]] = this._resubscribeTopics[e[t]], r.resubscribe = !0, this.subscribe(r, {
                    properties: r[e[t]].properties
                  });
                }
              } else this._resubscribeTopics.resubscribe = !0, this.subscribe(this._resubscribeTopics);
            } else this._resubscribeTopics = {};
            this._firstConnection = !1;
          }, C.prototype._onConnect = function (e) {
            if (this.disconnected) return void this.emit("connect", e);
            const t = this;
            this.connackPacket = e, this.messageIdProvider.clear(), this._setupPingTimer(), this.connected = !0, function r() {
              let n = t.outgoingStore.createStream();
              function i() {
                t._storeProcessing = !1, t._packetIdsDuringStoreProcessing = {};
              }
              function o() {
                n.destroy(), n = null, t._flushStoreProcessingQueue(), i();
              }
              t.once("close", o), n.on("error", function (e) {
                i(), t._flushStoreProcessingQueue(), t.removeListener("close", o), t.emit("error", e);
              }), n.on("end", function () {
                let n = !0;
                for (const e in t._packetIdsDuringStoreProcessing) if (!t._packetIdsDuringStoreProcessing[e]) {
                  n = !1;
                  break;
                }
                n ? (i(), t.removeListener("close", o), t._invokeAllStoreProcessingQueue(), t.emit("connect", e)) : r();
              }), function e() {
                if (!n) return;
                t._storeProcessing = !0;
                const r = n.read(1);
                let i;
                r ? t._packetIdsDuringStoreProcessing[r.messageId] ? e() : t.disconnecting || t.reconnectTimer ? n.destroy && n.destroy() : (i = t.outgoing[r.messageId] ? t.outgoing[r.messageId].cb : null, t.outgoing[r.messageId] = {
                  volatile: !1,
                  cb: function (t, r) {
                    i && i(t, r), e();
                  }
                }, t._packetIdsDuringStoreProcessing[r.messageId] = !0, t.messageIdProvider.register(r.messageId) ? t._sendPacket(r) : y("messageId: %d has already used.", r.messageId)) : n.once("readable", e);
              }();
            }();
          }, C.prototype._invokeStoreProcessingQueue = function () {
            if (this._storeProcessingQueue.length > 0) {
              const e = this._storeProcessingQueue[0];
              if (e && e.invoke()) return this._storeProcessingQueue.shift(), !0;
            }
            return !1;
          }, C.prototype._invokeAllStoreProcessingQueue = function () {
            for (; this._invokeStoreProcessingQueue(););
          }, C.prototype._flushStoreProcessingQueue = function () {
            for (const e of this._storeProcessingQueue) e.cbStorePut && e.cbStorePut(new Error("Connection closed")), e.callback && e.callback(new Error("Connection closed"));
            this._storeProcessingQueue.splice(0);
          }, t.exports = C;
        }).call(this);
      }).call(this, e("_process"), "undefined" != typeof __webpack_require__.g ? __webpack_require__.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {
      "./default-message-id-provider": 7,
      "./store": 8,
      "./topic-alias-recv": 9,
      "./topic-alias-send": 10,
      "./validations": 11,
      _process: 50,
      debug: 18,
      events: 22,
      inherits: 24,
      "mqtt-packet": 40,
      "readable-stream": 69,
      reinterval: 70,
      "rfdc/default": 71,
      xtend: 81
    }],
    2: [function (e, t, r) {
      "use strict";

      const {
          Buffer: n
        } = e("buffer"),
        i = e("readable-stream").Transform,
        o = e("duplexify");
      let s,
        a,
        l,
        u = !1;
      t.exports = function (e, t) {
        if (t.hostname = t.hostname || t.host, !t.hostname) throw new Error("Could not determine host. Specify host manually.");
        const r = "MQIsdp" === t.protocolId && 3 === t.protocolVersion ? "mqttv3.1" : "mqtt";
        !function (e) {
          e.hostname || (e.hostname = "localhost"), e.path || (e.path = "/"), e.wsOptions || (e.wsOptions = {});
        }(t);
        const c = function (e, t) {
          const r = "alis" === e.protocol ? "wss" : "ws";
          let n = r + "://" + e.hostname + e.path;
          return e.port && 80 !== e.port && 443 !== e.port && (n = r + "://" + e.hostname + ":" + e.port + e.path), "function" == typeof e.transformWsUrl && (n = e.transformWsUrl(n, e, t)), n;
        }(t, e);
        return (s = t.my).connectSocket({
          url: c,
          protocols: r
        }), a = function () {
          const e = new i();
          return e._write = function (e, t, r) {
            s.sendSocketMessage({
              data: e.buffer,
              success: function () {
                r();
              },
              fail: function () {
                r(new Error());
              }
            });
          }, e._flush = function (e) {
            s.closeSocket({
              success: function () {
                e();
              }
            });
          }, e;
        }(), l = o.obj(), u || (u = !0, s.onSocketOpen(function () {
          l.setReadable(a), l.setWritable(a), l.emit("connect");
        }), s.onSocketMessage(function (e) {
          if ("string" == typeof e.data) {
            const t = n.from(e.data, "base64");
            a.push(t);
          } else {
            const t = new FileReader();
            t.addEventListener("load", function () {
              let e = t.result;
              e = e instanceof ArrayBuffer ? n.from(e) : n.from(e, "utf8"), a.push(e);
            }), t.readAsArrayBuffer(e.data);
          }
        }), s.onSocketClose(function () {
          l.end(), l.destroy();
        }), s.onSocketError(function (e) {
          l.destroy(e);
        })), l;
      };
    }, {
      buffer: 17,
      duplexify: 20,
      "readable-stream": 69
    }],
    3: [function (e, t, r) {
      "use strict";

      const n = e("net"),
        i = e("debug")("mqttjs:tcp");
      t.exports = function (e, t) {
        t.port = t.port || 1883, t.hostname = t.hostname || t.host || "localhost";
        const r = t.port,
          o = t.hostname;
        return i("port %d and host %s", r, o), n.createConnection(r, o);
      };
    }, {
      debug: 18,
      net: 16
    }],
    4: [function (e, t, r) {
      "use strict";

      const n = e("tls"),
        i = e("net"),
        o = e("debug")("mqttjs:tls");
      t.exports = function (e, t) {
        t.port = t.port || 8883, t.host = t.hostname || t.host || "localhost", 0 === i.isIP(t.host) && (t.servername = t.host), t.rejectUnauthorized = !1 !== t.rejectUnauthorized, delete t.path, o("port %d host %s rejectUnauthorized %b", t.port, t.host, t.rejectUnauthorized);
        const r = n.connect(t);
        function s(n) {
          t.rejectUnauthorized && e.emit("error", n), r.end();
        }
        return r.on("secureConnect", function () {
          t.rejectUnauthorized && !r.authorized ? r.emit("error", new Error("TLS not authorized")) : r.removeListener("error", s);
        }), r.on("error", s), r;
      };
    }, {
      debug: 18,
      net: 16,
      tls: 16
    }],
    5: [function (e, t, r) {
      (function (r) {
        (function () {
          "use strict";

          const {
              Buffer: n
            } = e("buffer"),
            i = e("ws"),
            o = e("debug")("mqttjs:ws"),
            s = e("duplexify"),
            a = e("readable-stream").Transform,
            l = ["rejectUnauthorized", "ca", "cert", "key", "pfx", "passphrase"],
            u = void 0 !== r && "browser" === r.title || "function" == typeof __webpack_require__;
          function c(e, t) {
            let r = e.protocol + "://" + e.hostname + ":" + e.port + e.path;
            return "function" == typeof e.transformWsUrl && (r = e.transformWsUrl(r, e, t)), r;
          }
          function h(e) {
            const t = e;
            return e.hostname || (t.hostname = "localhost"), e.port || ("wss" === e.protocol ? t.port = 443 : t.port = 80), e.path || (t.path = "/"), e.wsOptions || (t.wsOptions = {}), u || "wss" !== e.protocol || l.forEach(function (r) {
              Object.prototype.hasOwnProperty.call(e, r) && !Object.prototype.hasOwnProperty.call(e.wsOptions, r) && (t.wsOptions[r] = e[r]);
            }), t;
          }
          t.exports = u ? function (e, t) {
            let r;
            o("browserStreamBuilder");
            const i = function (e) {
                const t = h(e);
                if (t.hostname || (t.hostname = t.host), !t.hostname) {
                  if ("undefined" == typeof document) throw new Error("Could not determine host. Specify host manually.");
                  const e = new URL(document.URL);
                  t.hostname = e.hostname, t.port || (t.port = e.port);
                }
                return void 0 === t.objectMode && (t.objectMode = !(!0 === t.binary || void 0 === t.binary)), t;
              }(t).browserBufferSize || 524288,
              l = t.browserBufferTimeout || 1e3,
              u = !t.objectMode,
              f = function (e, t) {
                const r = "MQIsdp" === t.protocolId && 3 === t.protocolVersion ? "mqttv3.1" : "mqtt",
                  n = c(t, e),
                  i = new WebSocket(n, [r]);
                return i.binaryType = "arraybuffer", i;
              }(e, t),
              p = function (e, t, r) {
                const n = new a({
                  objectModeMode: e.objectMode
                });
                return n._write = t, n._flush = r, n;
              }(t, function e(t, r, o) {
                f.bufferedAmount > i && setTimeout(e, l, t, r, o), u && "string" == typeof t && (t = n.from(t, "utf8"));
                try {
                  f.send(t);
                } catch (e) {
                  return o(e);
                }
                o();
              }, function (e) {
                f.close(), e();
              });
            t.objectMode || (p._writev = v), p.on("close", () => {
              f.close();
            });
            const d = void 0 !== f.addEventListener;
            function g() {
              r.setReadable(p), r.setWritable(p), r.emit("connect");
            }
            function y() {
              r.end(), r.destroy();
            }
            function b(e) {
              r.destroy(e);
            }
            function m(e) {
              let t = e.data;
              t = t instanceof ArrayBuffer ? n.from(t) : n.from(t, "utf8"), p.push(t);
            }
            function v(e, t) {
              const r = new Array(e.length);
              for (let t = 0; t < e.length; t++) "string" == typeof e[t].chunk ? r[t] = n.from(e[t], "utf8") : r[t] = e[t].chunk;
              this._write(n.concat(r), "binary", t);
            }
            return f.readyState === f.OPEN ? r = p : (r = r = s(void 0, void 0, t), t.objectMode || (r._writev = v), d ? f.addEventListener("open", g) : f.onopen = g), r.socket = f, d ? (f.addEventListener("close", y), f.addEventListener("error", b), f.addEventListener("message", m)) : (f.onclose = y, f.onerror = b, f.onmessage = m), r;
          } : function (e, t) {
            o("streamBuilder");
            const r = h(t),
              n = c(r, e),
              s = function (e, t, r) {
                o("createWebSocket"), o("protocol: " + r.protocolId + " " + r.protocolVersion);
                const n = "MQIsdp" === r.protocolId && 3 === r.protocolVersion ? "mqttv3.1" : "mqtt";
                return o("creating new Websocket for url: " + t + " and protocol: " + n), new i(t, [n], r.wsOptions);
              }(0, n, r),
              a = i.createWebSocketStream(s, r.wsOptions);
            return a.url = n, s.on("close", () => {
              a.destroy();
            }), a;
          };
        }).call(this);
      }).call(this, e("_process"));
    }, {
      _process: 50,
      buffer: 17,
      debug: 18,
      duplexify: 20,
      "readable-stream": 69,
      ws: 80
    }],
    6: [function (e, t, r) {
      "use strict";

      const {
          Buffer: n
        } = e("buffer"),
        i = e("readable-stream").Transform,
        o = e("duplexify");
      let s, a, l;
      t.exports = function (e, t) {
        if (t.hostname = t.hostname || t.host, !t.hostname) throw new Error("Could not determine host. Specify host manually.");
        const r = "MQIsdp" === t.protocolId && 3 === t.protocolVersion ? "mqttv3.1" : "mqtt";
        !function (e) {
          e.hostname || (e.hostname = "localhost"), e.path || (e.path = "/"), e.wsOptions || (e.wsOptions = {});
        }(t);
        const u = function (e, t) {
          const r = "wxs" === e.protocol ? "wss" : "ws";
          let n = r + "://" + e.hostname + e.path;
          return e.port && 80 !== e.port && 443 !== e.port && (n = r + "://" + e.hostname + ":" + e.port + e.path), "function" == typeof e.transformWsUrl && (n = e.transformWsUrl(n, e, t)), n;
        }(t, e);
        s = wx.connectSocket({
          url: u,
          protocols: [r]
        }), a = function () {
          const e = new i();
          return e._write = function (e, t, r) {
            s.send({
              data: e.buffer,
              success: function () {
                r();
              },
              fail: function (e) {
                r(new Error(e));
              }
            });
          }, e._flush = function (e) {
            s.close({
              success: function () {
                e();
              }
            });
          }, e;
        }(), (l = o.obj())._destroy = function (e, t) {
          s.close({
            success: function () {
              t && t(e);
            }
          });
        };
        const c = l.destroy;
        return l.destroy = function () {
          l.destroy = c;
          const e = this;
          setTimeout(function () {
            s.close({
              fail: function () {
                e._destroy(new Error());
              }
            });
          }, 0);
        }.bind(l), s.onOpen(function () {
          l.setReadable(a), l.setWritable(a), l.emit("connect");
        }), s.onMessage(function (e) {
          let t = e.data;
          t = t instanceof ArrayBuffer ? n.from(t) : n.from(t, "utf8"), a.push(t);
        }), s.onClose(function () {
          l.end(), l.destroy();
        }), s.onError(function (e) {
          l.destroy(new Error(e.errMsg));
        }), l;
      };
    }, {
      buffer: 17,
      duplexify: 20,
      "readable-stream": 69
    }],
    7: [function (e, t, r) {
      "use strict";

      function n() {
        if (!(this instanceof n)) return new n();
        this.nextId = Math.max(1, Math.floor(65535 * Math.random()));
      }
      n.prototype.allocate = function () {
        const e = this.nextId++;
        return 65536 === this.nextId && (this.nextId = 1), e;
      }, n.prototype.getLastAllocated = function () {
        return 1 === this.nextId ? 65535 : this.nextId - 1;
      }, n.prototype.register = function (e) {
        return !0;
      }, n.prototype.deallocate = function (e) {}, n.prototype.clear = function () {}, t.exports = n;
    }, {}],
    8: [function (e, t, r) {
      "use strict";

      const n = e("xtend"),
        i = e("readable-stream").Readable,
        o = {
          objectMode: !0
        },
        s = {
          clean: !0
        };
      function a(e) {
        if (!(this instanceof a)) return new a(e);
        this.options = e || {}, this.options = n(s, e), this._inflights = new Map();
      }
      a.prototype.put = function (e, t) {
        return this._inflights.set(e.messageId, e), t && t(), this;
      }, a.prototype.createStream = function () {
        const e = new i(o),
          t = [];
        let r = !1,
          n = 0;
        return this._inflights.forEach(function (e, r) {
          t.push(e);
        }), e._read = function () {
          !r && n < t.length ? this.push(t[n++]) : this.push(null);
        }, e.destroy = function () {
          if (r) return;
          const e = this;
          r = !0, setTimeout(function () {
            e.emit("close");
          }, 0);
        }, e;
      }, a.prototype.del = function (e, t) {
        return (e = this._inflights.get(e.messageId)) ? (this._inflights.delete(e.messageId), t(null, e)) : t && t(new Error("missing packet")), this;
      }, a.prototype.get = function (e, t) {
        return (e = this._inflights.get(e.messageId)) ? t(null, e) : t && t(new Error("missing packet")), this;
      }, a.prototype.close = function (e) {
        this.options.clean && (this._inflights = null), e && e();
      }, t.exports = a;
    }, {
      "readable-stream": 69,
      xtend: 81
    }],
    9: [function (e, t, r) {
      "use strict";

      function n(e) {
        if (!(this instanceof n)) return new n(e);
        this.aliasToTopic = {}, this.max = e;
      }
      n.prototype.put = function (e, t) {
        return !(0 === t || t > this.max) && (this.aliasToTopic[t] = e, this.length = Object.keys(this.aliasToTopic).length, !0);
      }, n.prototype.getTopicByAlias = function (e) {
        return this.aliasToTopic[e];
      }, n.prototype.clear = function () {
        this.aliasToTopic = {};
      }, t.exports = n;
    }, {}],
    10: [function (e, t, r) {
      "use strict";

      const n = e("lru-cache"),
        i = e("number-allocator").NumberAllocator;
      function o(e) {
        if (!(this instanceof o)) return new o(e);
        e > 0 && (this.aliasToTopic = new n({
          max: e
        }), this.topicToAlias = {}, this.numberAllocator = new i(1, e), this.max = e, this.length = 0);
      }
      o.prototype.put = function (e, t) {
        if (0 === t || t > this.max) return !1;
        const r = this.aliasToTopic.get(t);
        return r && delete this.topicToAlias[r], this.aliasToTopic.set(t, e), this.topicToAlias[e] = t, this.numberAllocator.use(t), this.length = this.aliasToTopic.length, !0;
      }, o.prototype.getTopicByAlias = function (e) {
        return this.aliasToTopic.get(e);
      }, o.prototype.getAliasByTopic = function (e) {
        const t = this.topicToAlias[e];
        return void 0 !== t && this.aliasToTopic.get(t), t;
      }, o.prototype.clear = function () {
        this.aliasToTopic.reset(), this.topicToAlias = {}, this.numberAllocator.clear(), this.length = 0;
      }, o.prototype.getLruAlias = function () {
        const e = this.numberAllocator.firstVacant();
        return e || this.aliasToTopic.keys()[this.aliasToTopic.length - 1];
      }, t.exports = o;
    }, {
      "lru-cache": 37,
      "number-allocator": 46
    }],
    11: [function (e, t, r) {
      "use strict";

      function n(e) {
        const t = e.split("/");
        for (let e = 0; e < t.length; e++) if ("+" !== t[e]) {
          if ("#" === t[e]) return e === t.length - 1;
          if (-1 !== t[e].indexOf("+") || -1 !== t[e].indexOf("#")) return !1;
        }
        return !0;
      }
      t.exports = {
        validateTopics: function (e) {
          if (0 === e.length) return "empty_topic_list";
          for (let t = 0; t < e.length; t++) if (!n(e[t])) return e[t];
          return null;
        }
      };
    }, {}],
    12: [function (e, t, r) {
      (function (r) {
        (function () {
          "use strict";

          const n = e("../client"),
            i = e("../store"),
            o = e("url"),
            s = e("xtend"),
            a = e("debug")("mqttjs"),
            l = {};
          function u(e, t) {
            if (a("connecting to an MQTT broker..."), "object" != typeof e || t || (t = e, e = null), t = t || {}, e) {
              const r = o.parse(e, !0);
              if (null != r.port && (r.port = Number(r.port)), null === (t = s(r, t)).protocol) throw new Error("Missing protocol");
              t.protocol = t.protocol.replace(/:$/, "");
            }
            if (function (e) {
              let t;
              e.auth && ((t = e.auth.match(/^(.+):(.+)$/)) ? (e.username = t[1], e.password = t[2]) : e.username = e.auth);
            }(t), t.query && "string" == typeof t.query.clientId && (t.clientId = t.query.clientId), t.cert && t.key) {
              if (!t.protocol) throw new Error("Missing secure protocol key");
              if (-1 === ["mqtts", "wss", "wxs", "alis"].indexOf(t.protocol)) switch (t.protocol) {
                case "mqtt":
                  t.protocol = "mqtts";
                  break;
                case "ws":
                  t.protocol = "wss";
                  break;
                case "wx":
                  t.protocol = "wxs";
                  break;
                case "ali":
                  t.protocol = "alis";
                  break;
                default:
                  throw new Error('Unknown protocol for secure connection: "' + t.protocol + '"!');
              }
            }
            if (!l[t.protocol]) {
              const e = -1 !== ["mqtts", "wss"].indexOf(t.protocol);
              t.protocol = ["mqtt", "mqtts", "ws", "wss", "wx", "wxs", "ali", "alis"].filter(function (t, r) {
                return (!e || r % 2 != 0) && "function" == typeof l[t];
              })[0];
            }
            if (!1 === t.clean && !t.clientId) throw new Error("Missing clientId for unclean clients");
            t.protocol && (t.defaultProtocol = t.protocol);
            const r = new n(function (e) {
              return t.servers && (e._reconnectCount && e._reconnectCount !== t.servers.length || (e._reconnectCount = 0), t.host = t.servers[e._reconnectCount].host, t.port = t.servers[e._reconnectCount].port, t.protocol = t.servers[e._reconnectCount].protocol ? t.servers[e._reconnectCount].protocol : t.defaultProtocol, t.hostname = t.host, e._reconnectCount++), a("calling streambuilder for", t.protocol), l[t.protocol](e, t);
            }, t);
            return r.on("error", function () {}), r;
          }
          void 0 !== r && "browser" !== r.title || "function" != typeof __webpack_require__ ? (l.mqtt = e("./tcp"), l.tcp = e("./tcp"), l.ssl = e("./tls"), l.tls = e("./tls"), l.mqtts = e("./tls")) : (l.wx = e("./wx"), l.wxs = e("./wx"), l.ali = e("./ali"), l.alis = e("./ali")), l.ws = e("./ws"), l.wss = e("./ws"), t.exports = u, t.exports.connect = u, t.exports.MqttClient = n, t.exports.Store = i;
        }).call(this);
      }).call(this, e("_process"));
    }, {
      "../client": 1,
      "../store": 8,
      "./ali": 2,
      "./tcp": 3,
      "./tls": 4,
      "./ws": 5,
      "./wx": 6,
      _process: 50,
      debug: 18,
      url: 76,
      xtend: 81
    }],
    13: [function (e, t, r) {
      "use strict";

      r.byteLength = function (e) {
        var t = u(e),
          r = t[0],
          n = t[1];
        return 3 * (r + n) / 4 - n;
      }, r.toByteArray = function (e) {
        var t,
          r,
          n = u(e),
          s = n[0],
          a = n[1],
          l = new o(function (e, t, r) {
            return 3 * (t + r) / 4 - r;
          }(0, s, a)),
          c = 0,
          h = a > 0 ? s - 4 : s;
        for (r = 0; r < h; r += 4) t = i[e.charCodeAt(r)] << 18 | i[e.charCodeAt(r + 1)] << 12 | i[e.charCodeAt(r + 2)] << 6 | i[e.charCodeAt(r + 3)], l[c++] = t >> 16 & 255, l[c++] = t >> 8 & 255, l[c++] = 255 & t;
        2 === a && (t = i[e.charCodeAt(r)] << 2 | i[e.charCodeAt(r + 1)] >> 4, l[c++] = 255 & t);
        1 === a && (t = i[e.charCodeAt(r)] << 10 | i[e.charCodeAt(r + 1)] << 4 | i[e.charCodeAt(r + 2)] >> 2, l[c++] = t >> 8 & 255, l[c++] = 255 & t);
        return l;
      }, r.fromByteArray = function (e) {
        for (var t, r = e.length, i = r % 3, o = [], s = 0, a = r - i; s < a; s += 16383) o.push(c(e, s, s + 16383 > a ? a : s + 16383));
        1 === i ? (t = e[r - 1], o.push(n[t >> 2] + n[t << 4 & 63] + "==")) : 2 === i && (t = (e[r - 2] << 8) + e[r - 1], o.push(n[t >> 10] + n[t >> 4 & 63] + n[t << 2 & 63] + "="));
        return o.join("");
      };
      for (var n = [], i = [], o = "undefined" != typeof Uint8Array ? Uint8Array : Array, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0, l = s.length; a < l; ++a) n[a] = s[a], i[s.charCodeAt(a)] = a;
      function u(e) {
        var t = e.length;
        if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
        var r = e.indexOf("=");
        return -1 === r && (r = t), [r, r === t ? 0 : 4 - r % 4];
      }
      function c(e, t, r) {
        for (var i, o, s = [], a = t; a < r; a += 3) i = (e[a] << 16 & 16711680) + (e[a + 1] << 8 & 65280) + (255 & e[a + 2]), s.push(n[(o = i) >> 18 & 63] + n[o >> 12 & 63] + n[o >> 6 & 63] + n[63 & o]);
        return s.join("");
      }
      i["-".charCodeAt(0)] = 62, i["_".charCodeAt(0)] = 63;
    }, {}],
    14: [function (e, t, r) {
      "use strict";

      const {
          Buffer: n
        } = e("buffer"),
        i = Symbol.for("BufferList");
      function o(e) {
        if (!(this instanceof o)) return new o(e);
        o._init.call(this, e);
      }
      o._init = function (e) {
        Object.defineProperty(this, i, {
          value: !0
        }), this._bufs = [], this.length = 0, e && this.append(e);
      }, o.prototype._new = function (e) {
        return new o(e);
      }, o.prototype._offset = function (e) {
        if (0 === e) return [0, 0];
        let t = 0;
        for (let r = 0; r < this._bufs.length; r++) {
          const n = t + this._bufs[r].length;
          if (e < n || r === this._bufs.length - 1) return [r, e - t];
          t = n;
        }
      }, o.prototype._reverseOffset = function (e) {
        const t = e[0];
        let r = e[1];
        for (let e = 0; e < t; e++) r += this._bufs[e].length;
        return r;
      }, o.prototype.get = function (e) {
        if (e > this.length || e < 0) return;
        const t = this._offset(e);
        return this._bufs[t[0]][t[1]];
      }, o.prototype.slice = function (e, t) {
        return "number" == typeof e && e < 0 && (e += this.length), "number" == typeof t && t < 0 && (t += this.length), this.copy(null, 0, e, t);
      }, o.prototype.copy = function (e, t, r, i) {
        if (("number" != typeof r || r < 0) && (r = 0), ("number" != typeof i || i > this.length) && (i = this.length), r >= this.length) return e || n.alloc(0);
        if (i <= 0) return e || n.alloc(0);
        const o = !!e,
          s = this._offset(r),
          a = i - r;
        let l = a,
          u = o && t || 0,
          c = s[1];
        if (0 === r && i === this.length) {
          if (!o) return 1 === this._bufs.length ? this._bufs[0] : n.concat(this._bufs, this.length);
          for (let t = 0; t < this._bufs.length; t++) this._bufs[t].copy(e, u), u += this._bufs[t].length;
          return e;
        }
        if (l <= this._bufs[s[0]].length - c) return o ? this._bufs[s[0]].copy(e, t, c, c + l) : this._bufs[s[0]].slice(c, c + l);
        o || (e = n.allocUnsafe(a));
        for (let t = s[0]; t < this._bufs.length; t++) {
          const r = this._bufs[t].length - c;
          if (!(l > r)) {
            this._bufs[t].copy(e, u, c, c + l), u += r;
            break;
          }
          this._bufs[t].copy(e, u, c), u += r, l -= r, c && (c = 0);
        }
        return e.length > u ? e.slice(0, u) : e;
      }, o.prototype.shallowSlice = function (e, t) {
        if (e = e || 0, t = "number" != typeof t ? this.length : t, e < 0 && (e += this.length), t < 0 && (t += this.length), e === t) return this._new();
        const r = this._offset(e),
          n = this._offset(t),
          i = this._bufs.slice(r[0], n[0] + 1);
        return 0 === n[1] ? i.pop() : i[i.length - 1] = i[i.length - 1].slice(0, n[1]), 0 !== r[1] && (i[0] = i[0].slice(r[1])), this._new(i);
      }, o.prototype.toString = function (e, t, r) {
        return this.slice(t, r).toString(e);
      }, o.prototype.consume = function (e) {
        if (e = Math.trunc(e), Number.isNaN(e) || e <= 0) return this;
        for (; this._bufs.length;) {
          if (!(e >= this._bufs[0].length)) {
            this._bufs[0] = this._bufs[0].slice(e), this.length -= e;
            break;
          }
          e -= this._bufs[0].length, this.length -= this._bufs[0].length, this._bufs.shift();
        }
        return this;
      }, o.prototype.duplicate = function () {
        const e = this._new();
        for (let t = 0; t < this._bufs.length; t++) e.append(this._bufs[t]);
        return e;
      }, o.prototype.append = function (e) {
        if (null == e) return this;
        if (e.buffer) this._appendBuffer(n.from(e.buffer, e.byteOffset, e.byteLength));else if (Array.isArray(e)) for (let t = 0; t < e.length; t++) this.append(e[t]);else if (this._isBufferList(e)) for (let t = 0; t < e._bufs.length; t++) this.append(e._bufs[t]);else "number" == typeof e && (e = e.toString()), this._appendBuffer(n.from(e));
        return this;
      }, o.prototype._appendBuffer = function (e) {
        this._bufs.push(e), this.length += e.length;
      }, o.prototype.indexOf = function (e, t, r) {
        if (void 0 === r && "string" == typeof t && (r = t, t = void 0), "function" == typeof e || Array.isArray(e)) throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
        if ("number" == typeof e ? e = n.from([e]) : "string" == typeof e ? e = n.from(e, r) : this._isBufferList(e) ? e = e.slice() : Array.isArray(e.buffer) ? e = n.from(e.buffer, e.byteOffset, e.byteLength) : n.isBuffer(e) || (e = n.from(e)), t = Number(t || 0), isNaN(t) && (t = 0), t < 0 && (t = this.length + t), t < 0 && (t = 0), 0 === e.length) return t > this.length ? this.length : t;
        const i = this._offset(t);
        let o = i[0],
          s = i[1];
        for (; o < this._bufs.length; o++) {
          const t = this._bufs[o];
          for (; s < t.length;) {
            if (t.length - s >= e.length) {
              const r = t.indexOf(e, s);
              if (-1 !== r) return this._reverseOffset([o, r]);
              s = t.length - e.length + 1;
            } else {
              const t = this._reverseOffset([o, s]);
              if (this._match(t, e)) return t;
              s++;
            }
          }
          s = 0;
        }
        return -1;
      }, o.prototype._match = function (e, t) {
        if (this.length - e < t.length) return !1;
        for (let r = 0; r < t.length; r++) if (this.get(e + r) !== t[r]) return !1;
        return !0;
      }, function () {
        const e = {
          readDoubleBE: 8,
          readDoubleLE: 8,
          readFloatBE: 4,
          readFloatLE: 4,
          readInt32BE: 4,
          readInt32LE: 4,
          readUInt32BE: 4,
          readUInt32LE: 4,
          readInt16BE: 2,
          readInt16LE: 2,
          readUInt16BE: 2,
          readUInt16LE: 2,
          readInt8: 1,
          readUInt8: 1,
          readIntBE: null,
          readIntLE: null,
          readUIntBE: null,
          readUIntLE: null
        };
        for (const t in e) !function (t) {
          o.prototype[t] = null === e[t] ? function (e, r) {
            return this.slice(e, e + r)[t](0, r);
          } : function (r = 0) {
            return this.slice(r, r + e[t])[t](0);
          };
        }(t);
      }(), o.prototype._isBufferList = function (e) {
        return e instanceof o || o.isBufferList(e);
      }, o.isBufferList = function (e) {
        return null != e && e[i];
      }, t.exports = o;
    }, {
      buffer: 17
    }],
    15: [function (e, t, r) {
      "use strict";

      const n = e("readable-stream").Duplex,
        i = e("inherits"),
        o = e("./BufferList");
      function s(e) {
        if (!(this instanceof s)) return new s(e);
        if ("function" == typeof e) {
          this._callback = e;
          const t = function (e) {
            this._callback && (this._callback(e), this._callback = null);
          }.bind(this);
          this.on("pipe", function (e) {
            e.on("error", t);
          }), this.on("unpipe", function (e) {
            e.removeListener("error", t);
          }), e = null;
        }
        o._init.call(this, e), n.call(this);
      }
      i(s, n), Object.assign(s.prototype, o.prototype), s.prototype._new = function (e) {
        return new s(e);
      }, s.prototype._write = function (e, t, r) {
        this._appendBuffer(e), "function" == typeof r && r();
      }, s.prototype._read = function (e) {
        if (!this.length) return this.push(null);
        e = Math.min(e, this.length), this.push(this.slice(0, e)), this.consume(e);
      }, s.prototype.end = function (e) {
        n.prototype.end.call(this, e), this._callback && (this._callback(null, this.slice()), this._callback = null);
      }, s.prototype._destroy = function (e, t) {
        this._bufs.length = 0, this.length = 0, t(e);
      }, s.prototype._isBufferList = function (e) {
        return e instanceof s || e instanceof o || s.isBufferList(e);
      }, s.isBufferList = o.isBufferList, t.exports = s, t.exports.BufferListStream = s, t.exports.BufferList = o;
    }, {
      "./BufferList": 14,
      inherits: 24,
      "readable-stream": 69
    }],
    16: [function (e, t, r) {}, {}],
    17: [function (e, t, r) {
      (function (t) {
        (function () {
          "use strict";

          var t = e("base64-js"),
            n = e("ieee754");
          r.Buffer = s, r.SlowBuffer = function (e) {
            +e != e && (e = 0);
            return s.alloc(+e);
          }, r.INSPECT_MAX_BYTES = 50;
          var i = 2147483647;
          function o(e) {
            if (e > i) throw new RangeError('The value "' + e + '" is invalid for option "size"');
            var t = new Uint8Array(e);
            return t.__proto__ = s.prototype, t;
          }
          function s(e, t, r) {
            if ("number" == typeof e) {
              if ("string" == typeof t) throw new TypeError('The "string" argument must be of type string. Received type number');
              return u(e);
            }
            return a(e, t, r);
          }
          function a(e, t, r) {
            if ("string" == typeof e) return function (e, t) {
              "string" == typeof t && "" !== t || (t = "utf8");
              if (!s.isEncoding(t)) throw new TypeError("Unknown encoding: " + t);
              var r = 0 | f(e, t),
                n = o(r),
                i = n.write(e, t);
              i !== r && (n = n.slice(0, i));
              return n;
            }(e, t);
            if (ArrayBuffer.isView(e)) return c(e);
            if (null == e) throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
            if (q(e, ArrayBuffer) || e && q(e.buffer, ArrayBuffer)) return function (e, t, r) {
              if (t < 0 || e.byteLength < t) throw new RangeError('"offset" is outside of buffer bounds');
              if (e.byteLength < t + (r || 0)) throw new RangeError('"length" is outside of buffer bounds');
              var n;
              n = void 0 === t && void 0 === r ? new Uint8Array(e) : void 0 === r ? new Uint8Array(e, t) : new Uint8Array(e, t, r);
              return n.__proto__ = s.prototype, n;
            }(e, t, r);
            if ("number" == typeof e) throw new TypeError('The "value" argument must not be of type number. Received type number');
            var n = e.valueOf && e.valueOf();
            if (null != n && n !== e) return s.from(n, t, r);
            var i = function (e) {
              if (s.isBuffer(e)) {
                var t = 0 | h(e.length),
                  r = o(t);
                return 0 === r.length ? r : (e.copy(r, 0, 0, t), r);
              }
              if (void 0 !== e.length) return "number" != typeof e.length || D(e.length) ? o(0) : c(e);
              if ("Buffer" === e.type && Array.isArray(e.data)) return c(e.data);
            }(e);
            if (i) return i;
            if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e[Symbol.toPrimitive]) return s.from(e[Symbol.toPrimitive]("string"), t, r);
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
          }
          function l(e) {
            if ("number" != typeof e) throw new TypeError('"size" argument must be of type number');
            if (e < 0) throw new RangeError('The value "' + e + '" is invalid for option "size"');
          }
          function u(e) {
            return l(e), o(e < 0 ? 0 : 0 | h(e));
          }
          function c(e) {
            for (var t = e.length < 0 ? 0 : 0 | h(e.length), r = o(t), n = 0; n < t; n += 1) r[n] = 255 & e[n];
            return r;
          }
          function h(e) {
            if (e >= i) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
            return 0 | e;
          }
          function f(e, t) {
            if (s.isBuffer(e)) return e.length;
            if (ArrayBuffer.isView(e) || q(e, ArrayBuffer)) return e.byteLength;
            if ("string" != typeof e) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
            var r = e.length,
              n = arguments.length > 2 && !0 === arguments[2];
            if (!n && 0 === r) return 0;
            for (var i = !1;;) switch (t) {
              case "ascii":
              case "latin1":
              case "binary":
                return r;
              case "utf8":
              case "utf-8":
                return L(e).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return 2 * r;
              case "hex":
                return r >>> 1;
              case "base64":
                return j(e).length;
              default:
                if (i) return n ? -1 : L(e).length;
                t = ("" + t).toLowerCase(), i = !0;
            }
          }
          function p(e, t, r) {
            var n = e[t];
            e[t] = e[r], e[r] = n;
          }
          function d(e, t, r, n, i) {
            if (0 === e.length) return -1;
            if ("string" == typeof r ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), D(r = +r) && (r = i ? 0 : e.length - 1), r < 0 && (r = e.length + r), r >= e.length) {
              if (i) return -1;
              r = e.length - 1;
            } else if (r < 0) {
              if (!i) return -1;
              r = 0;
            }
            if ("string" == typeof t && (t = s.from(t, n)), s.isBuffer(t)) return 0 === t.length ? -1 : g(e, t, r, n, i);
            if ("number" == typeof t) return t &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : g(e, [t], r, n, i);
            throw new TypeError("val must be string, number or Buffer");
          }
          function g(e, t, r, n, i) {
            var o,
              s = 1,
              a = e.length,
              l = t.length;
            if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
              if (e.length < 2 || t.length < 2) return -1;
              s = 2, a /= 2, l /= 2, r /= 2;
            }
            function u(e, t) {
              return 1 === s ? e[t] : e.readUInt16BE(t * s);
            }
            if (i) {
              var c = -1;
              for (o = r; o < a; o++) if (u(e, o) === u(t, -1 === c ? 0 : o - c)) {
                if (-1 === c && (c = o), o - c + 1 === l) return c * s;
              } else -1 !== c && (o -= o - c), c = -1;
            } else for (r + l > a && (r = a - l), o = r; o >= 0; o--) {
              for (var h = !0, f = 0; f < l; f++) if (u(e, o + f) !== u(t, f)) {
                h = !1;
                break;
              }
              if (h) return o;
            }
            return -1;
          }
          function y(e, t, r, n) {
            r = Number(r) || 0;
            var i = e.length - r;
            n ? (n = Number(n)) > i && (n = i) : n = i;
            var o = t.length;
            n > o / 2 && (n = o / 2);
            for (var s = 0; s < n; ++s) {
              var a = parseInt(t.substr(2 * s, 2), 16);
              if (D(a)) return s;
              e[r + s] = a;
            }
            return s;
          }
          function b(e, t, r, n) {
            return U(L(t, e.length - r), e, r, n);
          }
          function m(e, t, r, n) {
            return U(function (e) {
              for (var t = [], r = 0; r < e.length; ++r) t.push(255 & e.charCodeAt(r));
              return t;
            }(t), e, r, n);
          }
          function v(e, t, r, n) {
            return m(e, t, r, n);
          }
          function w(e, t, r, n) {
            return U(j(t), e, r, n);
          }
          function _(e, t, r, n) {
            return U(function (e, t) {
              for (var r, n, i, o = [], s = 0; s < e.length && !((t -= 2) < 0); ++s) r = e.charCodeAt(s), n = r >> 8, i = r % 256, o.push(i), o.push(n);
              return o;
            }(t, e.length - r), e, r, n);
          }
          function k(e, r, n) {
            return 0 === r && n === e.length ? t.fromByteArray(e) : t.fromByteArray(e.slice(r, n));
          }
          function S(e, t, r) {
            r = Math.min(e.length, r);
            for (var n = [], i = t; i < r;) {
              var o,
                s,
                a,
                l,
                u = e[i],
                c = null,
                h = u > 239 ? 4 : u > 223 ? 3 : u > 191 ? 2 : 1;
              if (i + h <= r) switch (h) {
                case 1:
                  u < 128 && (c = u);
                  break;
                case 2:
                  128 == (192 & (o = e[i + 1])) && (l = (31 & u) << 6 | 63 & o) > 127 && (c = l);
                  break;
                case 3:
                  o = e[i + 1], s = e[i + 2], 128 == (192 & o) && 128 == (192 & s) && (l = (15 & u) << 12 | (63 & o) << 6 | 63 & s) > 2047 && (l < 55296 || l > 57343) && (c = l);
                  break;
                case 4:
                  o = e[i + 1], s = e[i + 2], a = e[i + 3], 128 == (192 & o) && 128 == (192 & s) && 128 == (192 & a) && (l = (15 & u) << 18 | (63 & o) << 12 | (63 & s) << 6 | 63 & a) > 65535 && l < 1114112 && (c = l);
              }
              null === c ? (c = 65533, h = 1) : c > 65535 && (c -= 65536, n.push(c >>> 10 & 1023 | 55296), c = 56320 | 1023 & c), n.push(c), i += h;
            }
            return function (e) {
              var t = e.length;
              if (t <= E) return String.fromCharCode.apply(String, e);
              var r = "",
                n = 0;
              for (; n < t;) r += String.fromCharCode.apply(String, e.slice(n, n += E));
              return r;
            }(n);
          }
          r.kMaxLength = i, s.TYPED_ARRAY_SUPPORT = function () {
            try {
              var e = new Uint8Array(1);
              return e.__proto__ = {
                __proto__: Uint8Array.prototype,
                foo: function () {
                  return 42;
                }
              }, 42 === e.foo();
            } catch (e) {
              return !1;
            }
          }(), s.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(s.prototype, "parent", {
            enumerable: !0,
            get: function () {
              if (s.isBuffer(this)) return this.buffer;
            }
          }), Object.defineProperty(s.prototype, "offset", {
            enumerable: !0,
            get: function () {
              if (s.isBuffer(this)) return this.byteOffset;
            }
          }), "undefined" != typeof Symbol && null != Symbol.species && s[Symbol.species] === s && Object.defineProperty(s, Symbol.species, {
            value: null,
            configurable: !0,
            enumerable: !1,
            writable: !1
          }), s.poolSize = 8192, s.from = function (e, t, r) {
            return a(e, t, r);
          }, s.prototype.__proto__ = Uint8Array.prototype, s.__proto__ = Uint8Array, s.alloc = function (e, t, r) {
            return function (e, t, r) {
              return l(e), e <= 0 ? o(e) : void 0 !== t ? "string" == typeof r ? o(e).fill(t, r) : o(e).fill(t) : o(e);
            }(e, t, r);
          }, s.allocUnsafe = function (e) {
            return u(e);
          }, s.allocUnsafeSlow = function (e) {
            return u(e);
          }, s.isBuffer = function (e) {
            return null != e && !0 === e._isBuffer && e !== s.prototype;
          }, s.compare = function (e, t) {
            if (q(e, Uint8Array) && (e = s.from(e, e.offset, e.byteLength)), q(t, Uint8Array) && (t = s.from(t, t.offset, t.byteLength)), !s.isBuffer(e) || !s.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            if (e === t) return 0;
            for (var r = e.length, n = t.length, i = 0, o = Math.min(r, n); i < o; ++i) if (e[i] !== t[i]) {
              r = e[i], n = t[i];
              break;
            }
            return r < n ? -1 : n < r ? 1 : 0;
          }, s.isEncoding = function (e) {
            switch (String(e).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return !0;
              default:
                return !1;
            }
          }, s.concat = function (e, t) {
            if (!Array.isArray(e)) throw new TypeError('"list" argument must be an Array of Buffers');
            if (0 === e.length) return s.alloc(0);
            var r;
            if (void 0 === t) for (t = 0, r = 0; r < e.length; ++r) t += e[r].length;
            var n = s.allocUnsafe(t),
              i = 0;
            for (r = 0; r < e.length; ++r) {
              var o = e[r];
              if (q(o, Uint8Array) && (o = s.from(o)), !s.isBuffer(o)) throw new TypeError('"list" argument must be an Array of Buffers');
              o.copy(n, i), i += o.length;
            }
            return n;
          }, s.byteLength = f, s.prototype._isBuffer = !0, s.prototype.swap16 = function () {
            var e = this.length;
            if (e % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var t = 0; t < e; t += 2) p(this, t, t + 1);
            return this;
          }, s.prototype.swap32 = function () {
            var e = this.length;
            if (e % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var t = 0; t < e; t += 4) p(this, t, t + 3), p(this, t + 1, t + 2);
            return this;
          }, s.prototype.swap64 = function () {
            var e = this.length;
            if (e % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var t = 0; t < e; t += 8) p(this, t, t + 7), p(this, t + 1, t + 6), p(this, t + 2, t + 5), p(this, t + 3, t + 4);
            return this;
          }, s.prototype.toString = function () {
            var e = this.length;
            return 0 === e ? "" : 0 === arguments.length ? S(this, 0, e) : function (e, t, r) {
              var n = !1;
              if ((void 0 === t || t < 0) && (t = 0), t > this.length) return "";
              if ((void 0 === r || r > this.length) && (r = this.length), r <= 0) return "";
              if ((r >>>= 0) <= (t >>>= 0)) return "";
              for (e || (e = "utf8");;) switch (e) {
                case "hex":
                  return x(this, t, r);
                case "utf8":
                case "utf-8":
                  return S(this, t, r);
                case "ascii":
                  return C(this, t, r);
                case "latin1":
                case "binary":
                  return T(this, t, r);
                case "base64":
                  return k(this, t, r);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return A(this, t, r);
                default:
                  if (n) throw new TypeError("Unknown encoding: " + e);
                  e = (e + "").toLowerCase(), n = !0;
              }
            }.apply(this, arguments);
          }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function (e) {
            if (!s.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
            return this === e || 0 === s.compare(this, e);
          }, s.prototype.inspect = function () {
            var e = "",
              t = r.INSPECT_MAX_BYTES;
            return e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (e += " ... "), "<Buffer " + e + ">";
          }, s.prototype.compare = function (e, t, r, n, i) {
            if (q(e, Uint8Array) && (e = s.from(e, e.offset, e.byteLength)), !s.isBuffer(e)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
            if (void 0 === t && (t = 0), void 0 === r && (r = e ? e.length : 0), void 0 === n && (n = 0), void 0 === i && (i = this.length), t < 0 || r > e.length || n < 0 || i > this.length) throw new RangeError("out of range index");
            if (n >= i && t >= r) return 0;
            if (n >= i) return -1;
            if (t >= r) return 1;
            if (t >>>= 0, r >>>= 0, n >>>= 0, i >>>= 0, this === e) return 0;
            for (var o = i - n, a = r - t, l = Math.min(o, a), u = this.slice(n, i), c = e.slice(t, r), h = 0; h < l; ++h) if (u[h] !== c[h]) {
              o = u[h], a = c[h];
              break;
            }
            return o < a ? -1 : a < o ? 1 : 0;
          }, s.prototype.includes = function (e, t, r) {
            return -1 !== this.indexOf(e, t, r);
          }, s.prototype.indexOf = function (e, t, r) {
            return d(this, e, t, r, !0);
          }, s.prototype.lastIndexOf = function (e, t, r) {
            return d(this, e, t, r, !1);
          }, s.prototype.write = function (e, t, r, n) {
            if (void 0 === t) n = "utf8", r = this.length, t = 0;else if (void 0 === r && "string" == typeof t) n = t, r = this.length, t = 0;else {
              if (!isFinite(t)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
              t >>>= 0, isFinite(r) ? (r >>>= 0, void 0 === n && (n = "utf8")) : (n = r, r = void 0);
            }
            var i = this.length - t;
            if ((void 0 === r || r > i) && (r = i), e.length > 0 && (r < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
            n || (n = "utf8");
            for (var o = !1;;) switch (n) {
              case "hex":
                return y(this, e, t, r);
              case "utf8":
              case "utf-8":
                return b(this, e, t, r);
              case "ascii":
                return m(this, e, t, r);
              case "latin1":
              case "binary":
                return v(this, e, t, r);
              case "base64":
                return w(this, e, t, r);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return _(this, e, t, r);
              default:
                if (o) throw new TypeError("Unknown encoding: " + n);
                n = ("" + n).toLowerCase(), o = !0;
            }
          }, s.prototype.toJSON = function () {
            return {
              type: "Buffer",
              data: Array.prototype.slice.call(this._arr || this, 0)
            };
          };
          var E = 4096;
          function C(e, t, r) {
            var n = "";
            r = Math.min(e.length, r);
            for (var i = t; i < r; ++i) n += String.fromCharCode(127 & e[i]);
            return n;
          }
          function T(e, t, r) {
            var n = "";
            r = Math.min(e.length, r);
            for (var i = t; i < r; ++i) n += String.fromCharCode(e[i]);
            return n;
          }
          function x(e, t, r) {
            var n = e.length;
            (!t || t < 0) && (t = 0), (!r || r < 0 || r > n) && (r = n);
            for (var i = "", o = t; o < r; ++o) i += N(e[o]);
            return i;
          }
          function A(e, t, r) {
            for (var n = e.slice(t, r), i = "", o = 0; o < n.length; o += 2) i += String.fromCharCode(n[o] + 256 * n[o + 1]);
            return i;
          }
          function I(e, t, r) {
            if (e % 1 != 0 || e < 0) throw new RangeError("offset is not uint");
            if (e + t > r) throw new RangeError("Trying to access beyond buffer length");
          }
          function P(e, t, r, n, i, o) {
            if (!s.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (t > i || t < o) throw new RangeError('"value" argument is out of bounds');
            if (r + n > e.length) throw new RangeError("Index out of range");
          }
          function O(e, t, r, n, i, o) {
            if (r + n > e.length) throw new RangeError("Index out of range");
            if (r < 0) throw new RangeError("Index out of range");
          }
          function B(e, t, r, i, o) {
            return t = +t, r >>>= 0, o || O(e, 0, r, 4), n.write(e, t, r, i, 23, 4), r + 4;
          }
          function R(e, t, r, i, o) {
            return t = +t, r >>>= 0, o || O(e, 0, r, 8), n.write(e, t, r, i, 52, 8), r + 8;
          }
          s.prototype.slice = function (e, t) {
            var r = this.length;
            e = ~~e, t = void 0 === t ? r : ~~t, e < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r), t < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r), t < e && (t = e);
            var n = this.subarray(e, t);
            return n.__proto__ = s.prototype, n;
          }, s.prototype.readUIntLE = function (e, t, r) {
            e >>>= 0, t >>>= 0, r || I(e, t, this.length);
            for (var n = this[e], i = 1, o = 0; ++o < t && (i *= 256);) n += this[e + o] * i;
            return n;
          }, s.prototype.readUIntBE = function (e, t, r) {
            e >>>= 0, t >>>= 0, r || I(e, t, this.length);
            for (var n = this[e + --t], i = 1; t > 0 && (i *= 256);) n += this[e + --t] * i;
            return n;
          }, s.prototype.readUInt8 = function (e, t) {
            return e >>>= 0, t || I(e, 1, this.length), this[e];
          }, s.prototype.readUInt16LE = function (e, t) {
            return e >>>= 0, t || I(e, 2, this.length), this[e] | this[e + 1] << 8;
          }, s.prototype.readUInt16BE = function (e, t) {
            return e >>>= 0, t || I(e, 2, this.length), this[e] << 8 | this[e + 1];
          }, s.prototype.readUInt32LE = function (e, t) {
            return e >>>= 0, t || I(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3];
          }, s.prototype.readUInt32BE = function (e, t) {
            return e >>>= 0, t || I(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
          }, s.prototype.readIntLE = function (e, t, r) {
            e >>>= 0, t >>>= 0, r || I(e, t, this.length);
            for (var n = this[e], i = 1, o = 0; ++o < t && (i *= 256);) n += this[e + o] * i;
            return n >= (i *= 128) && (n -= Math.pow(2, 8 * t)), n;
          }, s.prototype.readIntBE = function (e, t, r) {
            e >>>= 0, t >>>= 0, r || I(e, t, this.length);
            for (var n = t, i = 1, o = this[e + --n]; n > 0 && (i *= 256);) o += this[e + --n] * i;
            return o >= (i *= 128) && (o -= Math.pow(2, 8 * t)), o;
          }, s.prototype.readInt8 = function (e, t) {
            return e >>>= 0, t || I(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e];
          }, s.prototype.readInt16LE = function (e, t) {
            e >>>= 0, t || I(e, 2, this.length);
            var r = this[e] | this[e + 1] << 8;
            return 32768 & r ? 4294901760 | r : r;
          }, s.prototype.readInt16BE = function (e, t) {
            e >>>= 0, t || I(e, 2, this.length);
            var r = this[e + 1] | this[e] << 8;
            return 32768 & r ? 4294901760 | r : r;
          }, s.prototype.readInt32LE = function (e, t) {
            return e >>>= 0, t || I(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
          }, s.prototype.readInt32BE = function (e, t) {
            return e >>>= 0, t || I(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
          }, s.prototype.readFloatLE = function (e, t) {
            return e >>>= 0, t || I(e, 4, this.length), n.read(this, e, !0, 23, 4);
          }, s.prototype.readFloatBE = function (e, t) {
            return e >>>= 0, t || I(e, 4, this.length), n.read(this, e, !1, 23, 4);
          }, s.prototype.readDoubleLE = function (e, t) {
            return e >>>= 0, t || I(e, 8, this.length), n.read(this, e, !0, 52, 8);
          }, s.prototype.readDoubleBE = function (e, t) {
            return e >>>= 0, t || I(e, 8, this.length), n.read(this, e, !1, 52, 8);
          }, s.prototype.writeUIntLE = function (e, t, r, n) {
            (e = +e, t >>>= 0, r >>>= 0, n) || P(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
            var i = 1,
              o = 0;
            for (this[t] = 255 & e; ++o < r && (i *= 256);) this[t + o] = e / i & 255;
            return t + r;
          }, s.prototype.writeUIntBE = function (e, t, r, n) {
            (e = +e, t >>>= 0, r >>>= 0, n) || P(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
            var i = r - 1,
              o = 1;
            for (this[t + i] = 255 & e; --i >= 0 && (o *= 256);) this[t + i] = e / o & 255;
            return t + r;
          }, s.prototype.writeUInt8 = function (e, t, r) {
            return e = +e, t >>>= 0, r || P(this, e, t, 1, 255, 0), this[t] = 255 & e, t + 1;
          }, s.prototype.writeUInt16LE = function (e, t, r) {
            return e = +e, t >>>= 0, r || P(this, e, t, 2, 65535, 0), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2;
          }, s.prototype.writeUInt16BE = function (e, t, r) {
            return e = +e, t >>>= 0, r || P(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2;
          }, s.prototype.writeUInt32LE = function (e, t, r) {
            return e = +e, t >>>= 0, r || P(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e, t + 4;
          }, s.prototype.writeUInt32BE = function (e, t, r) {
            return e = +e, t >>>= 0, r || P(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4;
          }, s.prototype.writeIntLE = function (e, t, r, n) {
            if (e = +e, t >>>= 0, !n) {
              var i = Math.pow(2, 8 * r - 1);
              P(this, e, t, r, i - 1, -i);
            }
            var o = 0,
              s = 1,
              a = 0;
            for (this[t] = 255 & e; ++o < r && (s *= 256);) e < 0 && 0 === a && 0 !== this[t + o - 1] && (a = 1), this[t + o] = (e / s >> 0) - a & 255;
            return t + r;
          }, s.prototype.writeIntBE = function (e, t, r, n) {
            if (e = +e, t >>>= 0, !n) {
              var i = Math.pow(2, 8 * r - 1);
              P(this, e, t, r, i - 1, -i);
            }
            var o = r - 1,
              s = 1,
              a = 0;
            for (this[t + o] = 255 & e; --o >= 0 && (s *= 256);) e < 0 && 0 === a && 0 !== this[t + o + 1] && (a = 1), this[t + o] = (e / s >> 0) - a & 255;
            return t + r;
          }, s.prototype.writeInt8 = function (e, t, r) {
            return e = +e, t >>>= 0, r || P(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1;
          }, s.prototype.writeInt16LE = function (e, t, r) {
            return e = +e, t >>>= 0, r || P(this, e, t, 2, 32767, -32768), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2;
          }, s.prototype.writeInt16BE = function (e, t, r) {
            return e = +e, t >>>= 0, r || P(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2;
          }, s.prototype.writeInt32LE = function (e, t, r) {
            return e = +e, t >>>= 0, r || P(this, e, t, 4, 2147483647, -2147483648), this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4;
          }, s.prototype.writeInt32BE = function (e, t, r) {
            return e = +e, t >>>= 0, r || P(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4;
          }, s.prototype.writeFloatLE = function (e, t, r) {
            return B(this, e, t, !0, r);
          }, s.prototype.writeFloatBE = function (e, t, r) {
            return B(this, e, t, !1, r);
          }, s.prototype.writeDoubleLE = function (e, t, r) {
            return R(this, e, t, !0, r);
          }, s.prototype.writeDoubleBE = function (e, t, r) {
            return R(this, e, t, !1, r);
          }, s.prototype.copy = function (e, t, r, n) {
            if (!s.isBuffer(e)) throw new TypeError("argument should be a Buffer");
            if (r || (r = 0), n || 0 === n || (n = this.length), t >= e.length && (t = e.length), t || (t = 0), n > 0 && n < r && (n = r), n === r) return 0;
            if (0 === e.length || 0 === this.length) return 0;
            if (t < 0) throw new RangeError("targetStart out of bounds");
            if (r < 0 || r >= this.length) throw new RangeError("Index out of range");
            if (n < 0) throw new RangeError("sourceEnd out of bounds");
            n > this.length && (n = this.length), e.length - t < n - r && (n = e.length - t + r);
            var i = n - r;
            if (this === e && "function" == typeof Uint8Array.prototype.copyWithin) this.copyWithin(t, r, n);else if (this === e && r < t && t < n) for (var o = i - 1; o >= 0; --o) e[o + t] = this[o + r];else Uint8Array.prototype.set.call(e, this.subarray(r, n), t);
            return i;
          }, s.prototype.fill = function (e, t, r, n) {
            if ("string" == typeof e) {
              if ("string" == typeof t ? (n = t, t = 0, r = this.length) : "string" == typeof r && (n = r, r = this.length), void 0 !== n && "string" != typeof n) throw new TypeError("encoding must be a string");
              if ("string" == typeof n && !s.isEncoding(n)) throw new TypeError("Unknown encoding: " + n);
              if (1 === e.length) {
                var i = e.charCodeAt(0);
                ("utf8" === n && i < 128 || "latin1" === n) && (e = i);
              }
            } else "number" == typeof e && (e &= 255);
            if (t < 0 || this.length < t || this.length < r) throw new RangeError("Out of range index");
            if (r <= t) return this;
            var o;
            if (t >>>= 0, r = void 0 === r ? this.length : r >>> 0, e || (e = 0), "number" == typeof e) for (o = t; o < r; ++o) this[o] = e;else {
              var a = s.isBuffer(e) ? e : s.from(e, n),
                l = a.length;
              if (0 === l) throw new TypeError('The value "' + e + '" is invalid for argument "value"');
              for (o = 0; o < r - t; ++o) this[o + t] = a[o % l];
            }
            return this;
          };
          var M = /[^+/0-9A-Za-z-_]/g;
          function N(e) {
            return e < 16 ? "0" + e.toString(16) : e.toString(16);
          }
          function L(e, t) {
            var r;
            t = t || 1 / 0;
            for (var n = e.length, i = null, o = [], s = 0; s < n; ++s) {
              if ((r = e.charCodeAt(s)) > 55295 && r < 57344) {
                if (!i) {
                  if (r > 56319) {
                    (t -= 3) > -1 && o.push(239, 191, 189);
                    continue;
                  }
                  if (s + 1 === n) {
                    (t -= 3) > -1 && o.push(239, 191, 189);
                    continue;
                  }
                  i = r;
                  continue;
                }
                if (r < 56320) {
                  (t -= 3) > -1 && o.push(239, 191, 189), i = r;
                  continue;
                }
                r = 65536 + (i - 55296 << 10 | r - 56320);
              } else i && (t -= 3) > -1 && o.push(239, 191, 189);
              if (i = null, r < 128) {
                if ((t -= 1) < 0) break;
                o.push(r);
              } else if (r < 2048) {
                if ((t -= 2) < 0) break;
                o.push(r >> 6 | 192, 63 & r | 128);
              } else if (r < 65536) {
                if ((t -= 3) < 0) break;
                o.push(r >> 12 | 224, r >> 6 & 63 | 128, 63 & r | 128);
              } else {
                if (!(r < 1114112)) throw new Error("Invalid code point");
                if ((t -= 4) < 0) break;
                o.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, 63 & r | 128);
              }
            }
            return o;
          }
          function j(e) {
            return t.toByteArray(function (e) {
              if ((e = (e = e.split("=")[0]).trim().replace(M, "")).length < 2) return "";
              for (; e.length % 4 != 0;) e += "=";
              return e;
            }(e));
          }
          function U(e, t, r, n) {
            for (var i = 0; i < n && !(i + r >= t.length || i >= e.length); ++i) t[i + r] = e[i];
            return i;
          }
          function q(e, t) {
            return e instanceof t || null != e && null != e.constructor && null != e.constructor.name && e.constructor.name === t.name;
          }
          function D(e) {
            return e != e;
          }
        }).call(this);
      }).call(this, e("buffer").Buffer);
    }, {
      "base64-js": 13,
      buffer: 17,
      ieee754: 23
    }],
    18: [function (e, t, r) {
      (function (n) {
        (function () {
          r.formatArgs = function (e) {
            if (e[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e[0] + (this.useColors ? "%c " : " ") + "+" + t.exports.humanize(this.diff), !this.useColors) return;
            const r = "color: " + this.color;
            e.splice(1, 0, r, "color: inherit");
            let n = 0,
              i = 0;
            e[0].replace(/%[a-zA-Z%]/g, e => {
              "%%" !== e && "%c" === e && (i = ++n);
            }), e.splice(i, 0, r);
          }, r.save = function (e) {
            try {
              e ? r.storage.setItem("debug", e) : r.storage.removeItem("debug");
            } catch (e) {}
          }, r.load = function () {
            let e;
            try {
              e = r.storage.getItem("debug");
            } catch (e) {}
            !e && void 0 !== n && "env" in n && (e = n.env.DEBUG);
            return e;
          }, r.useColors = function () {
            if ("undefined" != typeof window && window.process && ("renderer" === window.process.type || window.process.__nwjs)) return !0;
            if ("undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return !1;
            return "undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
          }, r.storage = function () {
            try {
              return localStorage;
            } catch (e) {}
          }(), r.destroy = (() => {
            let e = !1;
            return () => {
              e || (e = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
            };
          })(), r.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], r.log = console.debug || console.log || (() => {}), t.exports = e("./common")(r);
          const {
            formatters: i
          } = t.exports;
          i.j = function (e) {
            try {
              return JSON.stringify(e);
            } catch (e) {
              return "[UnexpectedJSONParseError]: " + e.message;
            }
          };
        }).call(this);
      }).call(this, e("_process"));
    }, {
      "./common": 19,
      _process: 50
    }],
    19: [function (e, t, r) {
      t.exports = function (t) {
        function r(e) {
          let t,
            i,
            o,
            s = null;
          function a(...e) {
            if (!a.enabled) return;
            const n = a,
              i = Number(new Date()),
              o = i - (t || i);
            n.diff = o, n.prev = t, n.curr = i, t = i, e[0] = r.coerce(e[0]), "string" != typeof e[0] && e.unshift("%O");
            let s = 0;
            e[0] = e[0].replace(/%([a-zA-Z%])/g, (t, i) => {
              if ("%%" === t) return "%";
              s++;
              const o = r.formatters[i];
              if ("function" == typeof o) {
                const r = e[s];
                t = o.call(n, r), e.splice(s, 1), s--;
              }
              return t;
            }), r.formatArgs.call(n, e), (n.log || r.log).apply(n, e);
          }
          return a.namespace = e, a.useColors = r.useColors(), a.color = r.selectColor(e), a.extend = n, a.destroy = r.destroy, Object.defineProperty(a, "enabled", {
            enumerable: !0,
            configurable: !1,
            get: () => null !== s ? s : (i !== r.namespaces && (i = r.namespaces, o = r.enabled(e)), o),
            set: e => {
              s = e;
            }
          }), "function" == typeof r.init && r.init(a), a;
        }
        function n(e, t) {
          const n = r(this.namespace + (void 0 === t ? ":" : t) + e);
          return n.log = this.log, n;
        }
        function i(e) {
          return e.toString().substring(2, e.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        return r.debug = r, r.default = r, r.coerce = function (e) {
          return e instanceof Error ? e.stack || e.message : e;
        }, r.disable = function () {
          const e = [...r.names.map(i), ...r.skips.map(i).map(e => "-" + e)].join(",");
          return r.enable(""), e;
        }, r.enable = function (e) {
          let t;
          r.save(e), r.namespaces = e, r.names = [], r.skips = [];
          const n = ("string" == typeof e ? e : "").split(/[\s,]+/),
            i = n.length;
          for (t = 0; t < i; t++) n[t] && ("-" === (e = n[t].replace(/\*/g, ".*?"))[0] ? r.skips.push(new RegExp("^" + e.substr(1) + "$")) : r.names.push(new RegExp("^" + e + "$")));
        }, r.enabled = function (e) {
          if ("*" === e[e.length - 1]) return !0;
          let t, n;
          for (t = 0, n = r.skips.length; t < n; t++) if (r.skips[t].test(e)) return !1;
          for (t = 0, n = r.names.length; t < n; t++) if (r.names[t].test(e)) return !0;
          return !1;
        }, r.humanize = e("ms"), r.destroy = function () {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }, Object.keys(t).forEach(e => {
          r[e] = t[e];
        }), r.names = [], r.skips = [], r.formatters = {}, r.selectColor = function (e) {
          let t = 0;
          for (let r = 0; r < e.length; r++) t = (t << 5) - t + e.charCodeAt(r), t |= 0;
          return r.colors[Math.abs(t) % r.colors.length];
        }, r.enable(r.load()), r;
      };
    }, {
      ms: 45
    }],
    20: [function (e, t, r) {
      (function (r, n) {
        (function () {
          var i = e("readable-stream"),
            o = e("end-of-stream"),
            s = e("inherits"),
            a = e("stream-shift"),
            l = n.from && n.from !== Uint8Array.from ? n.from([0]) : new n([0]),
            u = function (e, t) {
              e._corked ? e.once("uncork", t) : t();
            },
            c = function (e, t) {
              return function (r) {
                r ? function (e, t) {
                  e._autoDestroy && e.destroy(t);
                }(e, "premature close" === r.message ? null : r) : t && !e._ended && e.end();
              };
            },
            h = function () {},
            f = function (e, t, r) {
              if (!(this instanceof f)) return new f(e, t, r);
              i.Duplex.call(this, r), this._writable = null, this._readable = null, this._readable2 = null, this._autoDestroy = !r || !1 !== r.autoDestroy, this._forwardDestroy = !r || !1 !== r.destroy, this._forwardEnd = !r || !1 !== r.end, this._corked = 1, this._ondrain = null, this._drained = !1, this._forwarding = !1, this._unwrite = null, this._unread = null, this._ended = !1, this.destroyed = !1, e && this.setWritable(e), t && this.setReadable(t);
            };
          s(f, i.Duplex), f.obj = function (e, t, r) {
            return r || (r = {}), r.objectMode = !0, r.highWaterMark = 16, new f(e, t, r);
          }, f.prototype.cork = function () {
            1 == ++this._corked && this.emit("cork");
          }, f.prototype.uncork = function () {
            this._corked && 0 == --this._corked && this.emit("uncork");
          }, f.prototype.setWritable = function (e) {
            if (this._unwrite && this._unwrite(), this.destroyed) e && e.destroy && e.destroy();else if (null !== e && !1 !== e) {
              var t = this,
                n = o(e, {
                  writable: !0,
                  readable: !1
                }, c(this, this._forwardEnd)),
                i = function () {
                  var e = t._ondrain;
                  t._ondrain = null, e && e();
                };
              this._unwrite && r.nextTick(i), this._writable = e, this._writable.on("drain", i), this._unwrite = function () {
                t._writable.removeListener("drain", i), n();
              }, this.uncork();
            } else this.end();
          }, f.prototype.setReadable = function (e) {
            if (this._unread && this._unread(), this.destroyed) e && e.destroy && e.destroy();else {
              if (null === e || !1 === e) return this.push(null), void this.resume();
              var t,
                r = this,
                n = o(e, {
                  writable: !1,
                  readable: !0
                }, c(this)),
                s = function () {
                  r._forward();
                },
                a = function () {
                  r.push(null);
                };
              this._drained = !0, this._readable = e, this._readable2 = e._readableState ? e : (t = e, new i.Readable({
                objectMode: !0,
                highWaterMark: 16
              }).wrap(t)), this._readable2.on("readable", s), this._readable2.on("end", a), this._unread = function () {
                r._readable2.removeListener("readable", s), r._readable2.removeListener("end", a), n();
              }, this._forward();
            }
          }, f.prototype._read = function () {
            this._drained = !0, this._forward();
          }, f.prototype._forward = function () {
            if (!this._forwarding && this._readable2 && this._drained) {
              var e;
              for (this._forwarding = !0; this._drained && null !== (e = a(this._readable2));) this.destroyed || (this._drained = this.push(e));
              this._forwarding = !1;
            }
          }, f.prototype.destroy = function (e, t) {
            if (t || (t = h), this.destroyed) return t(null);
            this.destroyed = !0;
            var n = this;
            r.nextTick(function () {
              n._destroy(e), t(null);
            });
          }, f.prototype._destroy = function (e) {
            if (e) {
              var t = this._ondrain;
              this._ondrain = null, t ? t(e) : this.emit("error", e);
            }
            this._forwardDestroy && (this._readable && this._readable.destroy && this._readable.destroy(), this._writable && this._writable.destroy && this._writable.destroy()), this.emit("close");
          }, f.prototype._write = function (e, t, r) {
            if (!this.destroyed) return this._corked ? u(this, this._write.bind(this, e, t, r)) : e === l ? this._finish(r) : this._writable ? void (!1 === this._writable.write(e) ? this._ondrain = r : this.destroyed || r()) : r();
          }, f.prototype._finish = function (e) {
            var t = this;
            this.emit("preend"), u(this, function () {
              var r, n;
              r = t._forwardEnd && t._writable, n = function () {
                !1 === t._writableState.prefinished && (t._writableState.prefinished = !0), t.emit("prefinish"), u(t, e);
              }, r ? r._writableState && r._writableState.finished ? n() : r._writableState ? r.end(n) : (r.end(), n()) : n();
            });
          }, f.prototype.end = function (e, t, r) {
            return "function" == typeof e ? this.end(null, null, e) : "function" == typeof t ? this.end(e, null, t) : (this._ended = !0, e && this.write(e), this._writableState.ending || this._writableState.destroyed || this.write(l), i.Writable.prototype.end.call(this, r));
          }, t.exports = f;
        }).call(this);
      }).call(this, e("_process"), e("buffer").Buffer);
    }, {
      _process: 50,
      buffer: 17,
      "end-of-stream": 21,
      inherits: 24,
      "readable-stream": 69,
      "stream-shift": 74
    }],
    21: [function (e, t, r) {
      (function (r) {
        (function () {
          var n = e("once"),
            i = function () {},
            o = function (e, t, s) {
              if ("function" == typeof t) return o(e, null, t);
              t || (t = {}), s = n(s || i);
              var a = e._writableState,
                l = e._readableState,
                u = t.readable || !1 !== t.readable && e.readable,
                c = t.writable || !1 !== t.writable && e.writable,
                h = !1,
                f = function () {
                  e.writable || p();
                },
                p = function () {
                  c = !1, u || s.call(e);
                },
                d = function () {
                  u = !1, c || s.call(e);
                },
                g = function (t) {
                  s.call(e, t ? new Error("exited with error code: " + t) : null);
                },
                y = function (t) {
                  s.call(e, t);
                },
                b = function () {
                  r.nextTick(m);
                },
                m = function () {
                  if (!h) return (!u || l && l.ended && !l.destroyed) && (!c || a && a.ended && !a.destroyed) ? void 0 : s.call(e, new Error("premature close"));
                },
                v = function () {
                  e.req.on("finish", p);
                };
              return !function (e) {
                return e.setHeader && "function" == typeof e.abort;
              }(e) ? c && !a && (e.on("end", f), e.on("close", f)) : (e.on("complete", p), e.on("abort", b), e.req ? v() : e.on("request", v)), function (e) {
                return e.stdio && Array.isArray(e.stdio) && 3 === e.stdio.length;
              }(e) && e.on("exit", g), e.on("end", d), e.on("finish", p), !1 !== t.error && e.on("error", y), e.on("close", b), function () {
                h = !0, e.removeListener("complete", p), e.removeListener("abort", b), e.removeListener("request", v), e.req && e.req.removeListener("finish", p), e.removeListener("end", f), e.removeListener("close", f), e.removeListener("finish", p), e.removeListener("exit", g), e.removeListener("end", d), e.removeListener("error", y), e.removeListener("close", b);
              };
            };
          t.exports = o;
        }).call(this);
      }).call(this, e("_process"));
    }, {
      _process: 50,
      once: 48
    }],
    22: [function (e, t, r) {
      var n = Object.create || function (e) {
          var t = function () {};
          return t.prototype = e, new t();
        },
        i = Object.keys || function (e) {
          var t = [];
          for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.push(r);
          return r;
        },
        o = Function.prototype.bind || function (e) {
          var t = this;
          return function () {
            return t.apply(e, arguments);
          };
        };
      function s() {
        this._events && Object.prototype.hasOwnProperty.call(this, "_events") || (this._events = n(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
      }
      t.exports = s, s.EventEmitter = s, s.prototype._events = void 0, s.prototype._maxListeners = void 0;
      var a,
        l = 10;
      try {
        var u = {};
        Object.defineProperty && Object.defineProperty(u, "x", {
          value: 0
        }), a = 0 === u.x;
      } catch (e) {
        a = !1;
      }
      function c(e) {
        return void 0 === e._maxListeners ? s.defaultMaxListeners : e._maxListeners;
      }
      function h(e, t, r, i) {
        var o, s, a;
        if ("function" != typeof r) throw new TypeError('"listener" argument must be a function');
        if ((s = e._events) ? (s.newListener && (e.emit("newListener", t, r.listener ? r.listener : r), s = e._events), a = s[t]) : (s = e._events = n(null), e._eventsCount = 0), a) {
          if ("function" == typeof a ? a = s[t] = i ? [r, a] : [a, r] : i ? a.unshift(r) : a.push(r), !a.warned && (o = c(e)) && o > 0 && a.length > o) {
            a.warned = !0;
            var l = new Error("Possible EventEmitter memory leak detected. " + a.length + ' "' + String(t) + '" listeners added. Use emitter.setMaxListeners() to increase limit.');
            l.name = "MaxListenersExceededWarning", l.emitter = e, l.type = t, l.count = a.length, "object" == typeof console && console.warn && console.warn("%s: %s", l.name, l.message);
          }
        } else a = s[t] = r, ++e._eventsCount;
        return e;
      }
      function f() {
        if (!this.fired) switch (this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length) {
          case 0:
            return this.listener.call(this.target);
          case 1:
            return this.listener.call(this.target, arguments[0]);
          case 2:
            return this.listener.call(this.target, arguments[0], arguments[1]);
          case 3:
            return this.listener.call(this.target, arguments[0], arguments[1], arguments[2]);
          default:
            for (var e = new Array(arguments.length), t = 0; t < e.length; ++t) e[t] = arguments[t];
            this.listener.apply(this.target, e);
        }
      }
      function p(e, t, r) {
        var n = {
            fired: !1,
            wrapFn: void 0,
            target: e,
            type: t,
            listener: r
          },
          i = o.call(f, n);
        return i.listener = r, n.wrapFn = i, i;
      }
      function d(e, t, r) {
        var n = e._events;
        if (!n) return [];
        var i = n[t];
        return i ? "function" == typeof i ? r ? [i.listener || i] : [i] : r ? function (e) {
          for (var t = new Array(e.length), r = 0; r < t.length; ++r) t[r] = e[r].listener || e[r];
          return t;
        }(i) : y(i, i.length) : [];
      }
      function g(e) {
        var t = this._events;
        if (t) {
          var r = t[e];
          if ("function" == typeof r) return 1;
          if (r) return r.length;
        }
        return 0;
      }
      function y(e, t) {
        for (var r = new Array(t), n = 0; n < t; ++n) r[n] = e[n];
        return r;
      }
      a ? Object.defineProperty(s, "defaultMaxListeners", {
        enumerable: !0,
        get: function () {
          return l;
        },
        set: function (e) {
          if ("number" != typeof e || e < 0 || e != e) throw new TypeError('"defaultMaxListeners" must be a positive number');
          l = e;
        }
      }) : s.defaultMaxListeners = l, s.prototype.setMaxListeners = function (e) {
        if ("number" != typeof e || e < 0 || isNaN(e)) throw new TypeError('"n" argument must be a positive number');
        return this._maxListeners = e, this;
      }, s.prototype.getMaxListeners = function () {
        return c(this);
      }, s.prototype.emit = function (e) {
        var t,
          r,
          n,
          i,
          o,
          s,
          a = "error" === e;
        if (s = this._events) a = a && null == s.error;else if (!a) return !1;
        if (a) {
          if (arguments.length > 1 && (t = arguments[1]), t instanceof Error) throw t;
          var l = new Error('Unhandled "error" event. (' + t + ")");
          throw l.context = t, l;
        }
        if (!(r = s[e])) return !1;
        var u = "function" == typeof r;
        switch (n = arguments.length) {
          case 1:
            !function (e, t, r) {
              if (t) e.call(r);else for (var n = e.length, i = y(e, n), o = 0; o < n; ++o) i[o].call(r);
            }(r, u, this);
            break;
          case 2:
            !function (e, t, r, n) {
              if (t) e.call(r, n);else for (var i = e.length, o = y(e, i), s = 0; s < i; ++s) o[s].call(r, n);
            }(r, u, this, arguments[1]);
            break;
          case 3:
            !function (e, t, r, n, i) {
              if (t) e.call(r, n, i);else for (var o = e.length, s = y(e, o), a = 0; a < o; ++a) s[a].call(r, n, i);
            }(r, u, this, arguments[1], arguments[2]);
            break;
          case 4:
            !function (e, t, r, n, i, o) {
              if (t) e.call(r, n, i, o);else for (var s = e.length, a = y(e, s), l = 0; l < s; ++l) a[l].call(r, n, i, o);
            }(r, u, this, arguments[1], arguments[2], arguments[3]);
            break;
          default:
            for (i = new Array(n - 1), o = 1; o < n; o++) i[o - 1] = arguments[o];
            !function (e, t, r, n) {
              if (t) e.apply(r, n);else for (var i = e.length, o = y(e, i), s = 0; s < i; ++s) o[s].apply(r, n);
            }(r, u, this, i);
        }
        return !0;
      }, s.prototype.addListener = function (e, t) {
        return h(this, e, t, !1);
      }, s.prototype.on = s.prototype.addListener, s.prototype.prependListener = function (e, t) {
        return h(this, e, t, !0);
      }, s.prototype.once = function (e, t) {
        if ("function" != typeof t) throw new TypeError('"listener" argument must be a function');
        return this.on(e, p(this, e, t)), this;
      }, s.prototype.prependOnceListener = function (e, t) {
        if ("function" != typeof t) throw new TypeError('"listener" argument must be a function');
        return this.prependListener(e, p(this, e, t)), this;
      }, s.prototype.removeListener = function (e, t) {
        var r, i, o, s, a;
        if ("function" != typeof t) throw new TypeError('"listener" argument must be a function');
        if (!(i = this._events)) return this;
        if (!(r = i[e])) return this;
        if (r === t || r.listener === t) 0 == --this._eventsCount ? this._events = n(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, r.listener || t));else if ("function" != typeof r) {
          for (o = -1, s = r.length - 1; s >= 0; s--) if (r[s] === t || r[s].listener === t) {
            a = r[s].listener, o = s;
            break;
          }
          if (o < 0) return this;
          0 === o ? r.shift() : function (e, t) {
            for (var r = t, n = r + 1, i = e.length; n < i; r += 1, n += 1) e[r] = e[n];
            e.pop();
          }(r, o), 1 === r.length && (i[e] = r[0]), i.removeListener && this.emit("removeListener", e, a || t);
        }
        return this;
      }, s.prototype.removeAllListeners = function (e) {
        var t, r, o;
        if (!(r = this._events)) return this;
        if (!r.removeListener) return 0 === arguments.length ? (this._events = n(null), this._eventsCount = 0) : r[e] && (0 == --this._eventsCount ? this._events = n(null) : delete r[e]), this;
        if (0 === arguments.length) {
          var s,
            a = i(r);
          for (o = 0; o < a.length; ++o) "removeListener" !== (s = a[o]) && this.removeAllListeners(s);
          return this.removeAllListeners("removeListener"), this._events = n(null), this._eventsCount = 0, this;
        }
        if ("function" == typeof (t = r[e])) this.removeListener(e, t);else if (t) for (o = t.length - 1; o >= 0; o--) this.removeListener(e, t[o]);
        return this;
      }, s.prototype.listeners = function (e) {
        return d(this, e, !0);
      }, s.prototype.rawListeners = function (e) {
        return d(this, e, !1);
      }, s.listenerCount = function (e, t) {
        return "function" == typeof e.listenerCount ? e.listenerCount(t) : g.call(e, t);
      }, s.prototype.listenerCount = g, s.prototype.eventNames = function () {
        return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
      };
    }, {}],
    23: [function (e, t, r) {
      r.read = function (e, t, r, n, i) {
        var o,
          s,
          a = 8 * i - n - 1,
          l = (1 << a) - 1,
          u = l >> 1,
          c = -7,
          h = r ? i - 1 : 0,
          f = r ? -1 : 1,
          p = e[t + h];
        for (h += f, o = p & (1 << -c) - 1, p >>= -c, c += a; c > 0; o = 256 * o + e[t + h], h += f, c -= 8);
        for (s = o & (1 << -c) - 1, o >>= -c, c += n; c > 0; s = 256 * s + e[t + h], h += f, c -= 8);
        if (0 === o) o = 1 - u;else {
          if (o === l) return s ? NaN : 1 / 0 * (p ? -1 : 1);
          s += Math.pow(2, n), o -= u;
        }
        return (p ? -1 : 1) * s * Math.pow(2, o - n);
      }, r.write = function (e, t, r, n, i, o) {
        var s,
          a,
          l,
          u = 8 * o - i - 1,
          c = (1 << u) - 1,
          h = c >> 1,
          f = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
          p = n ? 0 : o - 1,
          d = n ? 1 : -1,
          g = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
        for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, s = c) : (s = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -s)) < 1 && (s--, l *= 2), (t += s + h >= 1 ? f / l : f * Math.pow(2, 1 - h)) * l >= 2 && (s++, l /= 2), s + h >= c ? (a = 0, s = c) : s + h >= 1 ? (a = (t * l - 1) * Math.pow(2, i), s += h) : (a = t * Math.pow(2, h - 1) * Math.pow(2, i), s = 0)); i >= 8; e[r + p] = 255 & a, p += d, a /= 256, i -= 8);
        for (s = s << i | a, u += i; u > 0; e[r + p] = 255 & s, p += d, s /= 256, u -= 8);
        e[r + p - d] |= 128 * g;
      };
    }, {}],
    24: [function (e, t, r) {
      "function" == typeof Object.create ? t.exports = function (e, t) {
        t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
          constructor: {
            value: e,
            enumerable: !1,
            writable: !0,
            configurable: !0
          }
        }));
      } : t.exports = function (e, t) {
        if (t) {
          e.super_ = t;
          var r = function () {};
          r.prototype = t.prototype, e.prototype = new r(), e.prototype.constructor = e;
        }
      };
    }, {}],
    25: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      });
      var n = function () {
        function e(e, t) {
          this.color = !0, this.key = void 0, this.value = void 0, this.parent = void 0, this.brother = void 0, this.leftChild = void 0, this.rightChild = void 0, this.key = e, this.value = t;
        }
        return e.prototype.rotateLeft = function () {
          var e = this.parent,
            t = this.brother,
            r = this.leftChild,
            n = this.rightChild;
          if (!n) throw new Error("unknown error");
          var i = n.leftChild,
            o = n.rightChild;
          return e && (e.leftChild === this ? e.leftChild = n : e.rightChild === this && (e.rightChild = n)), n.parent = e, n.brother = t, n.leftChild = this, n.rightChild = o, t && (t.brother = n), this.parent = n, this.brother = o, this.leftChild = r, this.rightChild = i, o && (o.parent = n, o.brother = this), r && (r.parent = this, r.brother = i), i && (i.parent = this, i.brother = r), n;
        }, e.prototype.rotateRight = function () {
          var e = this.parent,
            t = this.brother,
            r = this.leftChild;
          if (!r) throw new Error("unknown error");
          var n = this.rightChild,
            i = r.leftChild,
            o = r.rightChild;
          return e && (e.leftChild === this ? e.leftChild = r : e.rightChild === this && (e.rightChild = r)), r.parent = e, r.brother = t, r.leftChild = i, r.rightChild = this, t && (t.brother = r), i && (i.parent = r, i.brother = this), this.parent = r, this.brother = i, this.leftChild = o, this.rightChild = n, o && (o.parent = this, o.brother = n), n && (n.parent = this, n.brother = o), r;
        }, e.prototype.remove = function () {
          if (this.leftChild || this.rightChild) throw new Error("can only remove leaf node");
          this.parent && (this === this.parent.leftChild ? this.parent.leftChild = void 0 : this === this.parent.rightChild && (this.parent.rightChild = void 0)), this.brother && (this.brother.brother = void 0), this.key = void 0, this.value = void 0, this.parent = void 0, this.brother = void 0;
        }, e.TreeNodeColorType = {
          red: !0,
          black: !1
        }, e;
      }();
      Object.freeze(n), r.default = n;
    }, {}],
    26: [function (e, t, r) {
      "use strict";

      var n = this && this.__generator || function (e, t) {
        var r,
          n,
          i,
          o,
          s = {
            label: 0,
            sent: function () {
              if (1 & i[0]) throw i[1];
              return i[1];
            },
            trys: [],
            ops: []
          };
        return o = {
          next: a(0),
          throw: a(1),
          return: a(2)
        }, "function" == typeof Symbol && (o[Symbol.iterator] = function () {
          return this;
        }), o;
        function a(o) {
          return function (a) {
            return function (o) {
              if (r) throw new TypeError("Generator is already executing.");
              for (; s;) try {
                if (r = 1, n && (i = 2 & o[0] ? n.return : o[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, o[1])).done) return i;
                switch (n = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                  case 0:
                  case 1:
                    i = o;
                    break;
                  case 4:
                    return s.label++, {
                      value: o[1],
                      done: !1
                    };
                  case 5:
                    s.label++, n = o[1], o = [0];
                    continue;
                  case 7:
                    o = s.ops.pop(), s.trys.pop();
                    continue;
                  default:
                    if (!(i = (i = s.trys).length > 0 && i[i.length - 1]) && (6 === o[0] || 2 === o[0])) {
                      s = 0;
                      continue;
                    }
                    if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                      s.label = o[1];
                      break;
                    }
                    if (6 === o[0] && s.label < i[1]) {
                      s.label = i[1], i = o;
                      break;
                    }
                    if (i && s.label < i[2]) {
                      s.label = i[2], s.ops.push(o);
                      break;
                    }
                    i[2] && s.ops.pop(), s.trys.pop();
                    continue;
                }
                o = t.call(e, s);
              } catch (e) {
                o = [6, e], n = 0;
              } finally {
                r = i = 0;
              }
              if (5 & o[0]) throw o[1];
              return {
                value: o[0] ? o[1] : void 0,
                done: !0
              };
            }([o, a]);
          };
        }
      };
      function i(e) {
        var t = this;
        void 0 === e && (e = []);
        var r = [],
          o = 0,
          s = 0,
          a = 0,
          l = 0,
          u = 0,
          c = 0;
        this.size = function () {
          return c;
        }, this.empty = function () {
          return 0 === c;
        }, this.clear = function () {
          o = a = s = l = u = c = 0, f.call(this, i.bucketSize), c = 0;
        }, this.front = function () {
          return r[o][s];
        }, this.back = function () {
          return r[a][l];
        }, this.forEach = function (e) {
          if (!this.empty()) {
            var t = 0;
            if (o !== a) {
              for (u = s; u < i.bucketSize; ++u) e(r[o][u], t++);
              for (u = o + 1; u < a; ++u) for (var n = 0; n < i.bucketSize; ++n) e(r[u][n], t++);
              for (u = 0; u <= l; ++u) e(r[a][u], t++);
            } else for (var u = s; u <= l; ++u) e(r[o][u], t++);
          }
        };
        var h = function (e) {
          var t = o * i.bucketSize + s,
            r = t + e,
            n = a * i.bucketSize + l;
          if (r < t || r > n) throw new Error("pos should more than 0 and less than queue's size");
          return {
            curNodeBucketIndex: Math.floor(r / i.bucketSize),
            curNodePointerIndex: r % i.bucketSize
          };
        };
        this.getElementByPos = function (e) {
          var t = h(e),
            n = t.curNodeBucketIndex,
            i = t.curNodePointerIndex;
          return r[n][i];
        }, this.eraseElementByPos = function (e) {
          var t = this;
          if (e < 0 || e > c) throw new Error("pos should more than 0 and less than queue's size");
          if (0 === e) this.popFront();else if (e === this.size()) this.popBack();else {
            for (var r = [], n = e + 1; n < c; ++n) r.push(this.getElementByPos(n));
            this.cut(e), this.popBack(), r.forEach(function (e) {
              return t.pushBack(e);
            });
          }
        }, this.eraseElementByValue = function (e) {
          if (!this.empty()) {
            var t = [];
            this.forEach(function (r) {
              r !== e && t.push(r);
            });
            for (var r = t.length, n = 0; n < r; ++n) this.setElementByPos(n, t[n]);
            this.cut(r - 1);
          }
        };
        var f = function (e) {
          for (var t = [], n = e * i.sigma, h = Math.max(Math.ceil(n / i.bucketSize), 2), f = 0; f < h; ++f) t.push(new Array(i.bucketSize));
          var p = Math.ceil(e / i.bucketSize),
            d = Math.floor(h / 2) - Math.floor(p / 2),
            g = d,
            y = 0;
          if (this.size()) for (f = 0; f < p; ++f) {
            for (var b = 0; b < i.bucketSize; ++b) if (t[d + f][b] = this.front(), this.popFront(), this.empty()) {
              g = d + f, y = b;
              break;
            }
            if (this.empty()) break;
          }
          r = t, o = d, s = 0, a = g, l = y, u = h, c = e;
        };
        this.pushBack = function (e) {
          this.empty() || (a === u - 1 && l === i.bucketSize - 1 && f.call(this, this.size()), l < i.bucketSize - 1 ? ++l : a < u - 1 && (++a, l = 0)), ++c, r[a][l] = e;
        }, this.popBack = function () {
          this.empty() || (1 !== this.size() && (l > 0 ? --l : o < a && (--a, l = i.bucketSize - 1)), c > 0 && --c);
        }, this.setElementByPos = function (e, t) {
          var n = h(e),
            i = n.curNodeBucketIndex,
            o = n.curNodePointerIndex;
          r[i][o] = t;
        }, this.insert = function (e, t, r) {
          var n = this;
          if (void 0 === r && (r = 1), 0 === e) for (; r--;) this.pushFront(t);else if (e === this.size()) for (; r--;) this.pushBack(t);else {
            for (var i = [], o = e; o < c; ++o) i.push(this.getElementByPos(o));
            this.cut(e - 1);
            for (o = 0; o < r; ++o) this.pushBack(t);
            i.forEach(function (e) {
              return n.pushBack(e);
            });
          }
        }, this.find = function (e) {
          if (o === a) {
            for (var t = s; t <= l; ++t) if (r[o][t] === e) return !0;
            return !1;
          }
          for (t = s; t < i.bucketSize; ++t) if (r[o][t] === e) return !0;
          for (t = o + 1; t < a; ++t) for (var n = 0; n < i.bucketSize; ++n) if (r[t][n] === e) return !0;
          for (t = 0; t <= l; ++t) if (r[a][t] === e) return !0;
          return !1;
        }, this.reverse = function () {
          for (var e = 0, t = c - 1; e < t;) {
            var r = this.getElementByPos(e);
            this.setElementByPos(e, this.getElementByPos(t)), this.setElementByPos(t, r), ++e, --t;
          }
        }, this.unique = function () {
          if (!this.empty()) {
            var e = [],
              t = this.front();
            this.forEach(function (r, n) {
              0 !== n && r === t || (e.push(r), t = r);
            });
            for (var r = 0; r < c; ++r) this.setElementByPos(r, e[r]);
            this.cut(e.length - 1);
          }
        }, this.sort = function (e) {
          var t = [];
          this.forEach(function (e) {
            t.push(e);
          }), t.sort(e);
          for (var r = 0; r < c; ++r) this.setElementByPos(r, t[r]);
        }, this.pushFront = function (e) {
          this.empty() || (0 === o && 0 === s && f.call(this, this.size()), s > 0 ? --s : o > 0 && (--o, s = i.bucketSize - 1)), ++c, r[o][s] = e;
        }, this.popFront = function () {
          this.empty() || (1 !== this.size() && (s < i.bucketSize - 1 ? ++s : o < a && (++o, s = 0)), c > 0 && --c);
        }, this.shrinkToFit = function () {
          var e = this,
            t = [];
          this.forEach(function (e) {
            t.push(e);
          });
          var n = t.length;
          r = [];
          for (var o = Math.ceil(n / i.bucketSize), s = 0; s < o; ++s) r.push(new Array(i.bucketSize));
          this.clear(), t.forEach(function (t) {
            return e.pushBack(t);
          });
        }, this.cut = function (e) {
          if (e < 0) this.clear();else {
            var t = h(e),
              r = t.curNodeBucketIndex,
              n = t.curNodePointerIndex;
            a = r, l = n, c = e + 1;
          }
        }, this[Symbol.iterator] = function () {
          return function () {
            var e, t;
            return n(this, function (n) {
              switch (n.label) {
                case 0:
                  if (0 === c) return [2];
                  if (o !== a) return [3, 5];
                  t = s, n.label = 1;
                case 1:
                  return t <= l ? [4, r[o][t]] : [3, 4];
                case 2:
                  n.sent(), n.label = 3;
                case 3:
                  return ++t, [3, 1];
                case 4:
                  return [2];
                case 5:
                  t = s, n.label = 6;
                case 6:
                  return t < i.bucketSize ? [4, r[o][t]] : [3, 9];
                case 7:
                  n.sent(), n.label = 8;
                case 8:
                  return ++t, [3, 6];
                case 9:
                  t = o + 1, n.label = 10;
                case 10:
                  if (!(t < a)) return [3, 15];
                  e = 0, n.label = 11;
                case 11:
                  return e < i.bucketSize ? [4, r[t][e]] : [3, 14];
                case 12:
                  n.sent(), n.label = 13;
                case 13:
                  return ++e, [3, 11];
                case 14:
                  return ++t, [3, 10];
                case 15:
                  t = 0, n.label = 16;
                case 16:
                  return t <= l ? [4, r[a][t]] : [3, 19];
                case 17:
                  n.sent(), n.label = 18;
                case 18:
                  return ++t, [3, 16];
                case 19:
                  return [2];
              }
            });
          }();
        }, function () {
          var n = i.bucketSize;
          e.size ? n = e.size() : e.length && (n = e.length);
          var s = n * i.sigma;
          u = Math.ceil(s / i.bucketSize), u = Math.max(u, 3);
          for (var l = 0; l < u; ++l) r.push(new Array(i.bucketSize));
          var c = Math.ceil(n / i.bucketSize);
          o = Math.floor(u / 2) - Math.floor(c / 2), a = o, e.forEach(function (e) {
            return t.pushBack(e);
          });
        }(), Object.freeze(this);
      }
      Object.defineProperty(r, "__esModule", {
        value: !0
      }), i.sigma = 3, i.bucketSize = 5e3, Object.freeze(i), r.default = i;
    }, {}],
    27: [function (e, t, r) {
      "use strict";

      var n = this && this.__generator || function (e, t) {
          var r,
            n,
            i,
            o,
            s = {
              label: 0,
              sent: function () {
                if (1 & i[0]) throw i[1];
                return i[1];
              },
              trys: [],
              ops: []
            };
          return o = {
            next: a(0),
            throw: a(1),
            return: a(2)
          }, "function" == typeof Symbol && (o[Symbol.iterator] = function () {
            return this;
          }), o;
          function a(o) {
            return function (a) {
              return function (o) {
                if (r) throw new TypeError("Generator is already executing.");
                for (; s;) try {
                  if (r = 1, n && (i = 2 & o[0] ? n.return : o[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, o[1])).done) return i;
                  switch (n = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                    case 0:
                    case 1:
                      i = o;
                      break;
                    case 4:
                      return s.label++, {
                        value: o[1],
                        done: !1
                      };
                    case 5:
                      s.label++, n = o[1], o = [0];
                      continue;
                    case 7:
                      o = s.ops.pop(), s.trys.pop();
                      continue;
                    default:
                      if (!(i = (i = s.trys).length > 0 && i[i.length - 1]) && (6 === o[0] || 2 === o[0])) {
                        s = 0;
                        continue;
                      }
                      if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                        s.label = o[1];
                        break;
                      }
                      if (6 === o[0] && s.label < i[1]) {
                        s.label = i[1], i = o;
                        break;
                      }
                      if (i && s.label < i[2]) {
                        s.label = i[2], s.ops.push(o);
                        break;
                      }
                      i[2] && s.ops.pop(), s.trys.pop();
                      continue;
                  }
                  o = t.call(e, s);
                } catch (e) {
                  o = [6, e], n = 0;
                } finally {
                  r = i = 0;
                }
                if (5 & o[0]) throw o[1];
                return {
                  value: o[0] ? o[1] : void 0,
                  done: !0
                };
              }([o, a]);
            };
          }
        },
        i = this && this.__values || function (e) {
          var t = "function" == typeof Symbol && Symbol.iterator,
            r = t && e[t],
            n = 0;
          if (r) return r.call(e);
          if (e && "number" == typeof e.length) return {
            next: function () {
              return e && n >= e.length && (e = void 0), {
                value: e && e[n++],
                done: !e
              };
            }
          };
          throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
      Object.defineProperty(r, "__esModule", {
        value: !0
      });
      var o = e("../LinkList/LinkList"),
        s = e("../Map/Map");
      function a(e, t, r) {
        var l = this;
        if (void 0 === e && (e = []), void 0 === t && (t = a.initSize), r = r || function (e) {
          var t,
            r,
            n = 0,
            o = "";
          if ("number" == typeof e) n = ((n = Math.floor(e)) << 5) - n, n &= n;else {
            o = "string" != typeof e ? JSON.stringify(e) : e;
            try {
              for (var s = i(o), a = s.next(); !a.done; a = s.next()) {
                n = (n << 5) - n + a.value.charCodeAt(0), n &= n;
              }
            } catch (e) {
              t = {
                error: e
              };
            } finally {
              try {
                a && !a.done && (r = s.return) && r.call(s);
              } finally {
                if (t) throw t.error;
              }
            }
          }
          return n ^= n >>> 16;
        }, 0 != (t & t - 1)) throw new Error("initBucketNum must be 2 to the power of n");
        var u = 0,
          c = [],
          h = Math.max(a.initSize, Math.min(a.maxSize, t));
        this.size = function () {
          return u;
        }, this.empty = function () {
          return 0 === u;
        }, this.clear = function () {
          u = 0, h = t, c = [];
        }, this.forEach = function (e) {
          var t = 0;
          c.forEach(function (r) {
            r.forEach(function (r) {
              e(r, t++);
            });
          });
        };
        this.setElement = function (e, t) {
          var n, l;
          if (null === e || void 0 === e) throw new Error("to avoid some unnecessary errors, we don't suggest you insert null or undefined here");
          if (null !== t && void 0 !== t) {
            var f = r(e) & h - 1;
            if (c[f]) {
              var p = c[f].size();
              if (c[f] instanceof o.default) {
                try {
                  for (var d = i(c[f]), g = d.next(); !g.done; g = d.next()) {
                    var y = g.value;
                    if (y.key === e) return void (y.value = t);
                  }
                } catch (e) {
                  n = {
                    error: e
                  };
                } finally {
                  try {
                    g && !g.done && (l = d.return) && l.call(d);
                  } finally {
                    if (n) throw n.error;
                  }
                }
                c[f].pushBack({
                  key: e,
                  value: t
                }), c[f].size() >= a.treeifyThreshold && (c[f] = new s.default(c[f]));
              } else c[f].setElement(e, t);
              var b = c[f].size();
              u += b - p;
            } else ++u, c[f] = new o.default([{
              key: e,
              value: t
            }]);
            u > h * a.sigma && function (e) {
              if (!(e >= a.maxSize)) {
                h = 2 * e;
                var t = [];
                c.forEach(function (n, i) {
                  if (!n.empty()) {
                    if (n instanceof o.default && 1 === n.size()) {
                      var l = n.front(),
                        u = l.key,
                        f = l.value;
                      t[r(u) & h - 1] = new o.default([{
                        key: u,
                        value: f
                      }]);
                    } else if (n instanceof s.default) {
                      var p = new o.default(),
                        d = new o.default();
                      n.forEach(function (t) {
                        0 == (r(t.key) & e) ? p.pushBack(t) : d.pushBack(t);
                      }), p.size() > a.untreeifyThreshold ? t[i] = new s.default(p) : p.size() && (t[i] = p), d.size() > a.untreeifyThreshold ? t[i + e] = new s.default(d) : d.size() && (t[i + e] = d);
                    } else {
                      var g = new o.default(),
                        y = new o.default();
                      n.forEach(function (t) {
                        0 == (r(t.key) & e) ? g.pushBack(t) : y.pushBack(t);
                      }), g.size() && (t[i] = g), y.size() && (t[i + e] = y);
                    }
                    c[i].clear();
                  }
                }), c = t;
              }
            }.call(this, h);
          } else this.eraseElementByKey(e);
        }, this.getElementByKey = function (e) {
          var t,
            n,
            o = r(e) & h - 1;
          if (c[o]) {
            if (c[o] instanceof s.default) return c[o].getElementByKey(e);
            try {
              for (var a = i(c[o]), l = a.next(); !l.done; l = a.next()) {
                var u = l.value;
                if (u.key === e) return u.value;
              }
            } catch (e) {
              t = {
                error: e
              };
            } finally {
              try {
                l && !l.done && (n = a.return) && n.call(a);
              } finally {
                if (t) throw t.error;
              }
            }
          }
        }, this.eraseElementByKey = function (e) {
          var t,
            n,
            l = r(e) & h - 1;
          if (c[l]) {
            var f = c[l].size();
            if (c[l] instanceof s.default) c[l].eraseElementByKey(e), c[l].size() <= a.untreeifyThreshold && (c[l] = new o.default(c[l]));else {
              var p = -1;
              try {
                for (var d = i(c[l]), g = d.next(); !g.done; g = d.next()) {
                  if (++p, g.value.key === e) {
                    c[l].eraseElementByPos(p);
                    break;
                  }
                }
              } catch (e) {
                t = {
                  error: e
                };
              } finally {
                try {
                  g && !g.done && (n = d.return) && n.call(d);
                } finally {
                  if (t) throw t.error;
                }
              }
            }
            var y = c[l].size();
            u += y - f;
          }
        }, this.find = function (e) {
          var t,
            n,
            o = r(e) & h - 1;
          if (!c[o]) return !1;
          if (c[o] instanceof s.default) return c[o].find(e);
          try {
            for (var a = i(c[o]), l = a.next(); !l.done; l = a.next()) {
              if (l.value.key === e) return !0;
            }
          } catch (e) {
            t = {
              error: e
            };
          } finally {
            try {
              l && !l.done && (n = a.return) && n.call(a);
            } finally {
              if (t) throw t.error;
            }
          }
          return !1;
        }, this[Symbol.iterator] = function () {
          return function () {
            var e, t, r, o, s, a;
            return n(this, function (n) {
              switch (n.label) {
                case 0:
                  e = 0, n.label = 1;
                case 1:
                  if (!(e < h)) return [3, 10];
                  for (; e < h && !c[e];) ++e;
                  if (e >= h) return [3, 10];
                  n.label = 2;
                case 2:
                  n.trys.push([2, 7, 8, 9]), s = void 0, t = i(c[e]), r = t.next(), n.label = 3;
                case 3:
                  return r.done ? [3, 6] : [4, r.value];
                case 4:
                  n.sent(), n.label = 5;
                case 5:
                  return r = t.next(), [3, 3];
                case 6:
                  return [3, 9];
                case 7:
                  return o = n.sent(), s = {
                    error: o
                  }, [3, 9];
                case 8:
                  try {
                    r && !r.done && (a = t.return) && a.call(t);
                  } finally {
                    if (s) throw s.error;
                  }
                  return [7];
                case 9:
                  return ++e, [3, 1];
                case 10:
                  return [2];
              }
            });
          }();
        }, e.forEach(function (e) {
          var t = e.key,
            r = e.value;
          return l.setElement(t, r);
        }), Object.freeze(this);
      }
      a.initSize = 16, a.maxSize = 1 << 30, a.sigma = .75, a.treeifyThreshold = 8, a.untreeifyThreshold = 6, a.minTreeifySize = 64, Object.freeze(a), r.default = a;
    }, {
      "../LinkList/LinkList": 29,
      "../Map/Map": 30
    }],
    28: [function (e, t, r) {
      "use strict";

      var n = this && this.__generator || function (e, t) {
          var r,
            n,
            i,
            o,
            s = {
              label: 0,
              sent: function () {
                if (1 & i[0]) throw i[1];
                return i[1];
              },
              trys: [],
              ops: []
            };
          return o = {
            next: a(0),
            throw: a(1),
            return: a(2)
          }, "function" == typeof Symbol && (o[Symbol.iterator] = function () {
            return this;
          }), o;
          function a(o) {
            return function (a) {
              return function (o) {
                if (r) throw new TypeError("Generator is already executing.");
                for (; s;) try {
                  if (r = 1, n && (i = 2 & o[0] ? n.return : o[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, o[1])).done) return i;
                  switch (n = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                    case 0:
                    case 1:
                      i = o;
                      break;
                    case 4:
                      return s.label++, {
                        value: o[1],
                        done: !1
                      };
                    case 5:
                      s.label++, n = o[1], o = [0];
                      continue;
                    case 7:
                      o = s.ops.pop(), s.trys.pop();
                      continue;
                    default:
                      if (!(i = (i = s.trys).length > 0 && i[i.length - 1]) && (6 === o[0] || 2 === o[0])) {
                        s = 0;
                        continue;
                      }
                      if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                        s.label = o[1];
                        break;
                      }
                      if (6 === o[0] && s.label < i[1]) {
                        s.label = i[1], i = o;
                        break;
                      }
                      if (i && s.label < i[2]) {
                        s.label = i[2], s.ops.push(o);
                        break;
                      }
                      i[2] && s.ops.pop(), s.trys.pop();
                      continue;
                  }
                  o = t.call(e, s);
                } catch (e) {
                  o = [6, e], n = 0;
                } finally {
                  r = i = 0;
                }
                if (5 & o[0]) throw o[1];
                return {
                  value: o[0] ? o[1] : void 0,
                  done: !0
                };
              }([o, a]);
            };
          }
        },
        i = this && this.__values || function (e) {
          var t = "function" == typeof Symbol && Symbol.iterator,
            r = t && e[t],
            n = 0;
          if (r) return r.call(e);
          if (e && "number" == typeof e.length) return {
            next: function () {
              return e && n >= e.length && (e = void 0), {
                value: e && e[n++],
                done: !e
              };
            }
          };
          throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
      Object.defineProperty(r, "__esModule", {
        value: !0
      });
      var o = e("../Set/Set"),
        s = e("../LinkList/LinkList");
      function a(e, t, r) {
        var l = this;
        if (void 0 === e && (e = []), void 0 === t && (t = a.initSize), r = r || function (e) {
          var t = 0,
            r = "";
          if ("number" == typeof e) t = ((t = Math.floor(e)) << 5) - t, t &= t;else {
            r = "string" != typeof e ? JSON.stringify(e) : e;
            for (var n = 0; n < r.length; n++) {
              t = (t << 5) - t + r.charCodeAt(n), t &= t;
            }
          }
          return t ^= t >>> 16;
        }, 0 != (t & t - 1)) throw new Error("initBucketNum must be 2 to the power of n");
        var u = 0,
          c = [],
          h = Math.max(a.initSize, Math.min(a.maxSize, t));
        this.size = function () {
          return u;
        }, this.empty = function () {
          return 0 === u;
        }, this.clear = function () {
          u = 0, h = t, c = [];
        }, this.forEach = function (e) {
          var t = 0;
          c.forEach(function (r) {
            r.forEach(function (r) {
              e(r, t++);
            });
          });
        };
        this.insert = function (e) {
          if (null === e || void 0 === e) throw new Error("to avoid some unnecessary errors, we don't suggest you insert null or undefined here");
          var t = r(e) & h - 1;
          if (c[t]) {
            var n = c[t].size();
            if (c[t] instanceof s.default) {
              if (c[t].find(e)) return;
              c[t].pushBack(e), c[t].size() >= a.treeifyThreshold && (c[t] = new o.default(c[t]));
            } else c[t].insert(e);
            var i = c[t].size();
            u += i - n;
          } else c[t] = new s.default([e]), ++u;
          u > h * a.sigma && function (e) {
            if (!(e >= a.maxSize)) {
              h = 2 * e;
              var t = [];
              c.forEach(function (n, i) {
                if (!n.empty()) {
                  if (n instanceof s.default && 1 === n.size()) {
                    var l = n.front();
                    if (void 0 === l) throw new Error("unknown error");
                    t[r(l) & h - 1] = new s.default([l]);
                  } else if (n instanceof o.default) {
                    var u = new s.default(),
                      f = new s.default();
                    n.forEach(function (t) {
                      0 == (r(t) & e) ? u.pushBack(t) : f.pushBack(t);
                    }), u.size() > a.untreeifyThreshold ? t[i] = new o.default(u) : u.size() && (t[i] = u), f.size() > a.untreeifyThreshold ? t[i + e] = new o.default(f) : f.size() && (t[i + e] = f);
                  } else {
                    var p = new s.default(),
                      d = new s.default();
                    n.forEach(function (t) {
                      0 == (r(t) & e) ? p.pushBack(t) : d.pushBack(t);
                    }), p.size() && (t[i] = p), d.size() && (t[i + e] = d);
                  }
                  c[i].clear();
                }
              }), c = t;
            }
          }.call(this, h);
        }, this.eraseElementByValue = function (e) {
          var t = r(e) & h - 1;
          if (c[t]) {
            var n = c[t].size();
            c[t].eraseElementByValue(e), c[t] instanceof o.default && c[t].size() <= a.untreeifyThreshold && (c[t] = new s.default(c[t]));
            var i = c[t].size();
            u += i - n;
          }
        }, this.find = function (e) {
          var t = r(e) & h - 1;
          return !!c[t] && c[t].find(e);
        }, this[Symbol.iterator] = function () {
          return function () {
            var e, t, r, o, s, a;
            return n(this, function (n) {
              switch (n.label) {
                case 0:
                  e = 0, n.label = 1;
                case 1:
                  if (!(e < h)) return [3, 10];
                  for (; e < h && !c[e];) ++e;
                  if (e >= h) return [3, 10];
                  n.label = 2;
                case 2:
                  n.trys.push([2, 7, 8, 9]), s = void 0, t = i(c[e]), r = t.next(), n.label = 3;
                case 3:
                  return r.done ? [3, 6] : [4, r.value];
                case 4:
                  n.sent(), n.label = 5;
                case 5:
                  return r = t.next(), [3, 3];
                case 6:
                  return [3, 9];
                case 7:
                  return o = n.sent(), s = {
                    error: o
                  }, [3, 9];
                case 8:
                  try {
                    r && !r.done && (a = t.return) && a.call(t);
                  } finally {
                    if (s) throw s.error;
                  }
                  return [7];
                case 9:
                  return ++e, [3, 1];
                case 10:
                  return [2];
              }
            });
          }();
        }, e.forEach(function (e) {
          return l.insert(e);
        }), Object.freeze(this);
      }
      a.initSize = 16, a.maxSize = 1 << 30, a.sigma = .75, a.treeifyThreshold = 8, a.untreeifyThreshold = 6, a.minTreeifySize = 64, Object.freeze(a), r.default = a;
    }, {
      "../LinkList/LinkList": 29,
      "../Set/Set": 33
    }],
    29: [function (e, t, r) {
      "use strict";

      var n = this && this.__generator || function (e, t) {
        var r,
          n,
          i,
          o,
          s = {
            label: 0,
            sent: function () {
              if (1 & i[0]) throw i[1];
              return i[1];
            },
            trys: [],
            ops: []
          };
        return o = {
          next: a(0),
          throw: a(1),
          return: a(2)
        }, "function" == typeof Symbol && (o[Symbol.iterator] = function () {
          return this;
        }), o;
        function a(o) {
          return function (a) {
            return function (o) {
              if (r) throw new TypeError("Generator is already executing.");
              for (; s;) try {
                if (r = 1, n && (i = 2 & o[0] ? n.return : o[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, o[1])).done) return i;
                switch (n = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                  case 0:
                  case 1:
                    i = o;
                    break;
                  case 4:
                    return s.label++, {
                      value: o[1],
                      done: !1
                    };
                  case 5:
                    s.label++, n = o[1], o = [0];
                    continue;
                  case 7:
                    o = s.ops.pop(), s.trys.pop();
                    continue;
                  default:
                    if (!(i = (i = s.trys).length > 0 && i[i.length - 1]) && (6 === o[0] || 2 === o[0])) {
                      s = 0;
                      continue;
                    }
                    if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                      s.label = o[1];
                      break;
                    }
                    if (6 === o[0] && s.label < i[1]) {
                      s.label = i[1], i = o;
                      break;
                    }
                    if (i && s.label < i[2]) {
                      s.label = i[2], s.ops.push(o);
                      break;
                    }
                    i[2] && s.ops.pop(), s.trys.pop();
                    continue;
                }
                o = t.call(e, s);
              } catch (e) {
                o = [6, e], n = 0;
              } finally {
                r = i = 0;
              }
              if (5 & o[0]) throw o[1];
              return {
                value: o[0] ? o[1] : void 0,
                done: !0
              };
            }([o, a]);
          };
        }
      };
      Object.defineProperty(r, "__esModule", {
        value: !0
      });
      var i = function () {
        return function (e) {
          this.value = void 0, this.pre = void 0, this.next = void 0, this.value = e;
        };
      }();
      function o(e) {
        var t = this;
        void 0 === e && (e = []);
        var r = 0,
          o = void 0,
          s = void 0;
        this.size = function () {
          return r;
        }, this.empty = function () {
          return 0 === r;
        }, this.clear = function () {
          o = s = void 0, r = 0;
        }, this.front = function () {
          return null === o || void 0 === o ? void 0 : o.value;
        }, this.back = function () {
          return null === s || void 0 === s ? void 0 : s.value;
        }, this.forEach = function (e) {
          for (var t = o, r = 0; t;) {
            if (void 0 === t.value) throw new Error("unknown error");
            e(t.value, r++), t = t.next;
          }
        }, this.getElementByPos = function (e) {
          if (e < 0 || e >= r) throw new Error("pos must more then 0 and less then the list length");
          for (var t = o; e-- && t;) t = t.next;
          if (!t || void 0 === t.value) throw new Error("unknown error");
          return t.value;
        }, this.eraseElementByPos = function (e) {
          if (e < 0 || e >= r) throw new Error("erase pos must more then 0 and less then the list length");
          if (0 === e) this.popFront();else if (e === r - 1) this.popBack();else {
            for (var t = o; e--;) {
              if (!(null === t || void 0 === t ? void 0 : t.next)) throw new Error("unknown error");
              t = t.next;
            }
            if (!t || !t.pre || !t.next) throw new Error("unknown error");
            var n = t.pre,
              i = t.next;
            i.pre = n, n.next = i, r > 0 && --r;
          }
        }, this.eraseElementByValue = function (e) {
          for (; o && o.value === e;) this.popFront();
          for (; s && s.value === e;) this.popBack();
          if (o) for (var t = o; t;) {
            if (t.value === e) {
              var n = t.pre,
                i = t.next;
              i && (i.pre = n), n && (n.next = i), r > 0 && --r;
            }
            t = t.next;
          }
        }, this.pushBack = function (e) {
          if (null === e || void 0 === e) throw new Error("you can't push null or undefined here");
          ++r;
          var t = new i(e);
          s ? (s.next = t, t.pre = s, s = t) : o = s = t;
        }, this.popBack = function () {
          s && (r > 0 && --r, s && (o === s ? o = s = void 0 : (s = s.pre) && (s.next = void 0)));
        }, this.setElementByPos = function (e, t) {
          if (null === t || void 0 === t) throw new Error("you can't set null or undefined here");
          if (e < 0 || e >= r) throw new Error("pos must more then 0 and less then the list length");
          for (var n = o; e--;) {
            if (!n) throw new Error("unknown error");
            n = n.next;
          }
          n && (n.value = t);
        }, this.insert = function (e, t, n) {
          if (void 0 === n && (n = 1), null === t || void 0 === t) throw new Error("you can't insert null or undefined here");
          if (e < 0 || e > r) throw new Error("insert pos must more then 0 and less then or equal to the list length");
          if (n < 0) throw new Error("insert size must more than 0");
          if (0 === e) for (; n--;) this.pushFront(t);else if (e === r) for (; n--;) this.pushBack(t);else {
            for (var s = o, a = 1; a < e; ++a) {
              if (!(null === s || void 0 === s ? void 0 : s.next)) throw new Error("unknown error");
              s = null === s || void 0 === s ? void 0 : s.next;
            }
            if (!s) throw new Error("unknown error");
            var l = s.next;
            for (r += n; n--;) s.next = new i(t), s.next.pre = s, s = s.next;
            s.next = l, l && (l.pre = s);
          }
        }, this.find = function (e) {
          for (var t = o; t;) {
            if (t.value === e) return !0;
            t = t.next;
          }
          return !1;
        }, this.reverse = function () {
          for (var e = o, t = s, n = 0; e && t && 2 * n < r;) {
            var i = e.value;
            e.value = t.value, t.value = i, e = e.next, t = t.pre, ++n;
          }
        }, this.unique = function () {
          for (var e = o; e;) {
            for (var t = e; t && t.next && t.value === t.next.value;) t = t.next, r > 0 && --r;
            e.next = t.next, e.next && (e.next.pre = e), e = e.next;
          }
        }, this.sort = function (e) {
          var t = [];
          this.forEach(function (e) {
            t.push(e);
          }), t.sort(e);
          var r = o;
          t.forEach(function (e) {
            r && (r.value = e, r = r.next);
          });
        }, this.pushFront = function (e) {
          if (null === e || void 0 === e) throw new Error("you can't push null or undefined here");
          ++r;
          var t = new i(e);
          o ? (t.next = o, o.pre = t, o = t) : o = s = t;
        }, this.popFront = function () {
          o && (r > 0 && --r, o && (o === s ? o = s = void 0 : (o = o.next) && (o.pre = void 0)));
        }, this.merge = function (e) {
          var t = this,
            n = o;
          e.forEach(function (e) {
            for (; n && void 0 !== n.value && n.value <= e;) n = n.next;
            if (void 0 === n) t.pushBack(e), n = s;else if (n === o) t.pushFront(e), n = o;else {
              ++r;
              var a = n.pre;
              a && (a.next = new i(e), a.next.pre = a, a.next.next = n, n && (n.pre = a.next));
            }
          });
        }, this[Symbol.iterator] = function () {
          return function () {
            var e;
            return n(this, function (t) {
              switch (t.label) {
                case 0:
                  e = o, t.label = 1;
                case 1:
                  if (void 0 === e) return [3, 3];
                  if (!e.value) throw new Error("unknown error");
                  return [4, e.value];
                case 2:
                  return t.sent(), e = e.next, [3, 1];
                case 3:
                  return [2];
              }
            });
          }();
        }, e.forEach(function (e) {
          return t.pushBack(e);
        }), Object.freeze(this);
      }
      Object.freeze(o), r.default = o;
    }, {}],
    30: [function (e, t, r) {
      "use strict";

      var n = this && this.__generator || function (e, t) {
          var r,
            n,
            i,
            o,
            s = {
              label: 0,
              sent: function () {
                if (1 & i[0]) throw i[1];
                return i[1];
              },
              trys: [],
              ops: []
            };
          return o = {
            next: a(0),
            throw: a(1),
            return: a(2)
          }, "function" == typeof Symbol && (o[Symbol.iterator] = function () {
            return this;
          }), o;
          function a(o) {
            return function (a) {
              return function (o) {
                if (r) throw new TypeError("Generator is already executing.");
                for (; s;) try {
                  if (r = 1, n && (i = 2 & o[0] ? n.return : o[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, o[1])).done) return i;
                  switch (n = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                    case 0:
                    case 1:
                      i = o;
                      break;
                    case 4:
                      return s.label++, {
                        value: o[1],
                        done: !1
                      };
                    case 5:
                      s.label++, n = o[1], o = [0];
                      continue;
                    case 7:
                      o = s.ops.pop(), s.trys.pop();
                      continue;
                    default:
                      if (!(i = (i = s.trys).length > 0 && i[i.length - 1]) && (6 === o[0] || 2 === o[0])) {
                        s = 0;
                        continue;
                      }
                      if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                        s.label = o[1];
                        break;
                      }
                      if (6 === o[0] && s.label < i[1]) {
                        s.label = i[1], i = o;
                        break;
                      }
                      if (i && s.label < i[2]) {
                        s.label = i[2], s.ops.push(o);
                        break;
                      }
                      i[2] && s.ops.pop(), s.trys.pop();
                      continue;
                  }
                  o = t.call(e, s);
                } catch (e) {
                  o = [6, e], n = 0;
                } finally {
                  r = i = 0;
                }
                if (5 & o[0]) throw o[1];
                return {
                  value: o[0] ? o[1] : void 0,
                  done: !0
                };
              }([o, a]);
            };
          }
        },
        i = this && this.__values || function (e) {
          var t = "function" == typeof Symbol && Symbol.iterator,
            r = t && e[t],
            n = 0;
          if (r) return r.call(e);
          if (e && "number" == typeof e.length) return {
            next: function () {
              return e && n >= e.length && (e = void 0), {
                value: e && e[n++],
                done: !e
              };
            }
          };
          throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
      Object.defineProperty(r, "__esModule", {
        value: !0
      });
      var o = e("../Base/TreeNode");
      function s(e, t) {
        var r = this;
        void 0 === e && (e = []), t = t || function (e, t) {
          return e < t ? -1 : e > t ? 1 : 0;
        };
        var s = 0,
          a = new o.default();
        a.color = o.default.TreeNodeColorType.black, this.size = function () {
          return s;
        }, this.empty = function () {
          return 0 === s;
        }, this.clear = function () {
          s = 0, a.key = a.value = void 0, a.leftChild = a.rightChild = a.brother = void 0;
        };
        var l = function (e) {
            if (!e || void 0 === e.key) throw new Error("unknown error");
            return e.leftChild ? l(e.leftChild) : e;
          },
          u = function (e) {
            if (!e || void 0 === e.key) throw new Error("unknown error");
            return e.rightChild ? u(e.rightChild) : e;
          };
        this.front = function () {
          if (!this.empty()) {
            var e = l(a);
            if (void 0 === e.key || void 0 === e.value) throw new Error("unknown error");
            return {
              key: e.key,
              value: e.value
            };
          }
        }, this.back = function () {
          if (!this.empty()) {
            var e = u(a);
            if (void 0 === e.key || void 0 === e.value) throw new Error("unknown error");
            return {
              key: e.key,
              value: e.value
            };
          }
        }, this.forEach = function (e) {
          var t,
            r,
            n = 0;
          try {
            for (var o = i(this), s = o.next(); !s.done; s = o.next()) {
              e(s.value, n++);
            }
          } catch (e) {
            t = {
              error: e
            };
          } finally {
            try {
              s && !s.done && (r = o.return) && r.call(o);
            } finally {
              if (t) throw t.error;
            }
          }
        }, this.getElementByPos = function (e) {
          var t, r;
          if (e < 0 || e >= this.size()) throw new Error("pos must more than 0 and less than set's size");
          var n = 0;
          try {
            for (var o = i(this), s = o.next(); !s.done; s = o.next()) {
              var a = s.value;
              if (n === e) return a;
              ++n;
            }
          } catch (e) {
            t = {
              error: e
            };
          } finally {
            try {
              s && !s.done && (r = o.return) && r.call(o);
            } finally {
              if (t) throw t.error;
            }
          }
          throw new Error("unknown Error");
        };
        var c = function (e, r) {
          if (e && void 0 !== e.key && void 0 !== e.value) {
            var n = t(e.key, r);
            return 0 === n ? {
              key: e.key,
              value: e.value
            } : n < 0 ? c(e.rightChild, r) : c(e.leftChild, r) || {
              key: e.key,
              value: e.value
            };
          }
        };
        this.lowerBound = function (e) {
          return c(a, e);
        };
        var h = function (e, r) {
          if (e && void 0 !== e.key && void 0 !== e.value) return t(e.key, r) <= 0 ? h(e.rightChild, r) : h(e.leftChild, r) || {
            key: e.key,
            value: e.value
          };
        };
        this.upperBound = function (e) {
          return h(a, e);
        };
        var f = function (e, r) {
          if (e && void 0 !== e.key && void 0 !== e.value) {
            var n = t(e.key, r);
            return 0 === n ? {
              key: e.key,
              value: e.value
            } : n > 0 ? f(e.leftChild, r) : f(e.rightChild, r) || {
              key: e.key,
              value: e.value
            };
          }
        };
        this.reverseLowerBound = function (e) {
          return f(a, e);
        };
        var p = function (e, r) {
          if (e && void 0 !== e.key && void 0 !== e.value) return t(e.key, r) >= 0 ? p(e.leftChild, r) : p(e.rightChild, r) || {
            key: e.key,
            value: e.value
          };
        };
        this.reverseUpperBound = function (e) {
          return p(a, e);
        };
        var d = function (e) {
            var t = e.parent;
            if (!t) {
              if (e === a) return;
              throw new Error("unknown error");
            }
            if (e.color !== o.default.TreeNodeColorType.red) {
              var r = e.brother;
              if (!r) throw new Error("unknown error");
              if (e === t.leftChild) {
                if (r.color === o.default.TreeNodeColorType.red) {
                  r.color = o.default.TreeNodeColorType.black, t.color = o.default.TreeNodeColorType.red;
                  var n = t.rotateLeft();
                  a === t && (a = n), d(e);
                } else if (r.color === o.default.TreeNodeColorType.black) if (r.rightChild && r.rightChild.color === o.default.TreeNodeColorType.red) {
                  r.color = t.color, t.color = o.default.TreeNodeColorType.black, r.rightChild && (r.rightChild.color = o.default.TreeNodeColorType.black);
                  n = t.rotateLeft();
                  a === t && (a = n), e.color = o.default.TreeNodeColorType.black;
                } else if (r.rightChild && r.rightChild.color !== o.default.TreeNodeColorType.black || !r.leftChild || r.leftChild.color !== o.default.TreeNodeColorType.red) r.leftChild && r.leftChild.color !== o.default.TreeNodeColorType.black || r.rightChild && r.rightChild.color !== o.default.TreeNodeColorType.black || (r.color = o.default.TreeNodeColorType.red, d(t));else {
                  r.color = o.default.TreeNodeColorType.red, r.leftChild && (r.leftChild.color = o.default.TreeNodeColorType.black);
                  n = r.rotateRight();
                  a === r && (a = n), d(e);
                }
              } else if (e === t.rightChild) if (r.color === o.default.TreeNodeColorType.red) {
                r.color = o.default.TreeNodeColorType.black, t.color = o.default.TreeNodeColorType.red;
                n = t.rotateRight();
                a === t && (a = n), d(e);
              } else if (r.color === o.default.TreeNodeColorType.black) if (r.leftChild && r.leftChild.color === o.default.TreeNodeColorType.red) {
                r.color = t.color, t.color = o.default.TreeNodeColorType.black, r.leftChild && (r.leftChild.color = o.default.TreeNodeColorType.black);
                n = t.rotateRight();
                a === t && (a = n), e.color = o.default.TreeNodeColorType.black;
              } else if (r.leftChild && r.leftChild.color !== o.default.TreeNodeColorType.black || !r.rightChild || r.rightChild.color !== o.default.TreeNodeColorType.red) r.leftChild && r.leftChild.color !== o.default.TreeNodeColorType.black || r.rightChild && r.rightChild.color !== o.default.TreeNodeColorType.black || (r.color = o.default.TreeNodeColorType.red, d(t));else {
                r.color = o.default.TreeNodeColorType.red, r.rightChild && (r.rightChild.color = o.default.TreeNodeColorType.black);
                n = r.rotateLeft();
                a === r && (a = n), d(e);
              }
            } else e.color = o.default.TreeNodeColorType.black;
          },
          g = function (e) {
            for (var t = e; t.leftChild || t.rightChild;) {
              if (t.rightChild) {
                t = l(t.rightChild);
                var r = e.key;
                e.key = t.key, t.key = r;
                var n = e.value;
                e.value = t.value, t.value = n, e = t;
              }
              if (t.leftChild) {
                t = u(t.leftChild);
                r = e.key;
                e.key = t.key, t.key = r;
                n = e.value;
                e.value = t.value, t.value = n, e = t;
              }
            }
            d(t), t && t.remove(), --s, a.color = o.default.TreeNodeColorType.black;
          },
          y = function (e, t) {
            return !(!e || void 0 === e.key) && (!!y(e.leftChild, t) || !!t(e) || y(e.rightChild, t));
          };
        this.eraseElementByPos = function (e) {
          if (e < 0 || e >= s) throw new Error("pos must more than 0 and less than set's size");
          var t = 0;
          y(a, function (r) {
            return e === t ? (g(r), !0) : (++t, !1);
          });
        }, this.eraseElementByKey = function (e) {
          if (!this.empty()) {
            var r = v(a, e);
            void 0 !== r && void 0 !== r.key && 0 === t(r.key, e) && g(r);
          }
        };
        var b = function (e, r) {
            if (!e || void 0 === e.key) throw new Error("unknown error");
            var n = t(r, e.key);
            return n < 0 ? e.leftChild ? b(e.leftChild, r) : (e.leftChild = new o.default(), e.leftChild.parent = e, e.leftChild.brother = e.rightChild, e.rightChild && (e.rightChild.brother = e.leftChild), e.leftChild) : n > 0 ? e.rightChild ? b(e.rightChild, r) : (e.rightChild = new o.default(), e.rightChild.parent = e, e.rightChild.brother = e.leftChild, e.leftChild && (e.leftChild.brother = e.rightChild), e.rightChild) : e;
          },
          m = function (e) {
            var t = e.parent;
            if (!t) {
              if (e === a) return;
              throw new Error("unknown error");
            }
            if (t.color !== o.default.TreeNodeColorType.black && t.color === o.default.TreeNodeColorType.red) {
              var r = t.brother,
                n = t.parent;
              if (!n) throw new Error("unknown error");
              if (r && r.color === o.default.TreeNodeColorType.red) r.color = t.color = o.default.TreeNodeColorType.black, n.color = o.default.TreeNodeColorType.red, m(n);else if (!r || r.color === o.default.TreeNodeColorType.black) if (t === n.leftChild) {
                if (e === t.leftChild) {
                  t.color = o.default.TreeNodeColorType.black, n.color = o.default.TreeNodeColorType.red;
                  var i = n.rotateRight();
                  n === a && (a = i);
                } else if (e === t.rightChild) {
                  i = t.rotateLeft();
                  n === a && (a = i), m(t);
                }
              } else if (t === n.rightChild) if (e === t.leftChild) {
                i = t.rotateRight();
                n === a && (a = i), m(t);
              } else if (e === t.rightChild) {
                t.color = o.default.TreeNodeColorType.black, n.color = o.default.TreeNodeColorType.red;
                i = n.rotateLeft();
                n === a && (a = i);
              }
            }
          };
        this.setElement = function (e, r) {
          if (null === e || void 0 === e) throw new Error("to avoid some unnecessary errors, we don't suggest you insert null or undefined here");
          if (null !== r && void 0 !== r) {
            if (this.empty()) return ++s, a.key = e, a.value = r, void (a.color = o.default.TreeNodeColorType.black);
            var n = b(a, e);
            void 0 === n.key || 0 !== t(n.key, e) ? (++s, n.key = e, n.value = r, m(n), a.color = o.default.TreeNodeColorType.black) : n.value = r;
          } else this.eraseElementByKey(e);
        };
        var v = function (e, r) {
          if (e && void 0 !== e.key) {
            var n = t(r, e.key);
            return n < 0 ? v(e.leftChild, r) : n > 0 ? v(e.rightChild, r) : e;
          }
        };
        this.find = function (e) {
          return !!v(a, e);
        }, this.getElementByKey = function (e) {
          var t = v(a, e);
          if (void 0 === (null === t || void 0 === t ? void 0 : t.key) || void 0 === (null === t || void 0 === t ? void 0 : t.value)) throw new Error("unknown error");
          return t.value;
        }, this.union = function (e) {
          var t = this;
          e.forEach(function (e) {
            var r = e.key,
              n = e.value;
            return t.setElement(r, n);
          });
        }, this.getHeight = function () {
          if (this.empty()) return 0;
          var e = function (t) {
            return t ? Math.max(e(t.leftChild), e(t.rightChild)) + 1 : 1;
          };
          return e(a);
        };
        var w = function (e) {
          return n(this, function (t) {
            switch (t.label) {
              case 0:
                return e && void 0 !== e.key && void 0 !== e.value ? [5, i(w(e.leftChild))] : [2];
              case 1:
                return t.sent(), [4, {
                  key: e.key,
                  value: e.value
                }];
              case 2:
                return t.sent(), [5, i(w(e.rightChild))];
              case 3:
                return t.sent(), [2];
            }
          });
        };
        this[Symbol.iterator] = function () {
          return w(a);
        }, e.forEach(function (e) {
          var t = e.key,
            n = e.value;
          return r.setElement(t, n);
        }), Object.freeze(this);
      }
      Object.freeze(s), r.default = s;
    }, {
      "../Base/TreeNode": 25
    }],
    31: [function (e, t, r) {
      "use strict";

      function n(e, t) {
        void 0 === e && (e = []), t = t || function (e, t) {
          return e > t ? -1 : e < t ? 1 : 0;
        };
        var r = [];
        e.forEach(function (e) {
          return r.push(e);
        });
        var n = r.length,
          i = function (e, t) {
            if (e < 0 || e >= n) throw new Error("unknown error");
            if (t < 0 || t >= n) throw new Error("unknown error");
            var i = r[e];
            r[e] = r[t], r[t] = i;
          },
          o = function (e) {
            if (e < 0 || e >= n) throw new Error("unknown error");
            var o = 2 * e + 1,
              s = 2 * e + 2;
            o < n && t(r[e], r[o]) > 0 && i(e, o), s < n && t(r[e], r[s]) > 0 && i(e, s);
          };
        !function () {
          for (var e = Math.floor((n - 1) / 2); e >= 0; --e) for (var o = e, s = 2 * o + 1; s < n;) {
            var a = s + 1,
              l = s;
            if (a < n && t(r[s], r[a]) > 0 && (l = a), t(r[o], r[l]) <= 0) break;
            i(o, l), s = 2 * (o = l) + 1;
          }
        }(), this.size = function () {
          return n;
        }, this.empty = function () {
          return 0 === n;
        }, this.clear = function () {
          n = 0, r.length = 0;
        }, this.push = function (e) {
          if (r.push(e), 1 !== ++n) for (var i = n - 1; i > 0;) {
            var s = Math.floor((i - 1) / 2);
            if (t(r[s], e) <= 0) break;
            o(s), i = s;
          }
        }, this.pop = function () {
          if (!this.empty()) if (1 !== this.size()) {
            var e = r[n - 1];
            --n;
            for (var i = 0; i < this.size();) {
              var o = 2 * i + 1,
                s = 2 * i + 2;
              if (o >= this.size()) break;
              var a = o;
              if (s < this.size() && t(r[o], r[s]) > 0 && (a = s), t(r[a], e) >= 0) break;
              r[i] = r[a], i = a;
            }
            r[i] = e;
          } else --n;
        }, this.top = function () {
          return r[0];
        }, Object.freeze(this);
      }
      Object.defineProperty(r, "__esModule", {
        value: !0
      }), Object.freeze(n), r.default = n;
    }, {}],
    32: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      });
      var n = e("../LinkList/LinkList");
      function i(e) {
        void 0 === e && (e = []);
        var t = new n.default(e);
        this.size = function () {
          return t.size();
        }, this.empty = function () {
          return t.empty();
        }, this.clear = function () {
          t.clear();
        }, this.push = function (e) {
          t.pushBack(e);
        }, this.pop = function () {
          t.popFront();
        }, this.front = function () {
          return t.front();
        }, Object.freeze(this);
      }
      Object.freeze(i), r.default = i;
    }, {
      "../LinkList/LinkList": 29
    }],
    33: [function (e, t, r) {
      "use strict";

      var n = this && this.__generator || function (e, t) {
          var r,
            n,
            i,
            o,
            s = {
              label: 0,
              sent: function () {
                if (1 & i[0]) throw i[1];
                return i[1];
              },
              trys: [],
              ops: []
            };
          return o = {
            next: a(0),
            throw: a(1),
            return: a(2)
          }, "function" == typeof Symbol && (o[Symbol.iterator] = function () {
            return this;
          }), o;
          function a(o) {
            return function (a) {
              return function (o) {
                if (r) throw new TypeError("Generator is already executing.");
                for (; s;) try {
                  if (r = 1, n && (i = 2 & o[0] ? n.return : o[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, o[1])).done) return i;
                  switch (n = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                    case 0:
                    case 1:
                      i = o;
                      break;
                    case 4:
                      return s.label++, {
                        value: o[1],
                        done: !1
                      };
                    case 5:
                      s.label++, n = o[1], o = [0];
                      continue;
                    case 7:
                      o = s.ops.pop(), s.trys.pop();
                      continue;
                    default:
                      if (!(i = (i = s.trys).length > 0 && i[i.length - 1]) && (6 === o[0] || 2 === o[0])) {
                        s = 0;
                        continue;
                      }
                      if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                        s.label = o[1];
                        break;
                      }
                      if (6 === o[0] && s.label < i[1]) {
                        s.label = i[1], i = o;
                        break;
                      }
                      if (i && s.label < i[2]) {
                        s.label = i[2], s.ops.push(o);
                        break;
                      }
                      i[2] && s.ops.pop(), s.trys.pop();
                      continue;
                  }
                  o = t.call(e, s);
                } catch (e) {
                  o = [6, e], n = 0;
                } finally {
                  r = i = 0;
                }
                if (5 & o[0]) throw o[1];
                return {
                  value: o[0] ? o[1] : void 0,
                  done: !0
                };
              }([o, a]);
            };
          }
        },
        i = this && this.__values || function (e) {
          var t = "function" == typeof Symbol && Symbol.iterator,
            r = t && e[t],
            n = 0;
          if (r) return r.call(e);
          if (e && "number" == typeof e.length) return {
            next: function () {
              return e && n >= e.length && (e = void 0), {
                value: e && e[n++],
                done: !e
              };
            }
          };
          throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
      Object.defineProperty(r, "__esModule", {
        value: !0
      });
      var o = e("../Base/TreeNode");
      function s(e, t) {
        var r = this;
        void 0 === e && (e = []), t = t || function (e, t) {
          return e < t ? -1 : e > t ? 1 : 0;
        };
        var s = 0,
          a = new o.default();
        a.color = o.default.TreeNodeColorType.black, this.size = function () {
          return s;
        }, this.empty = function () {
          return 0 === s;
        }, this.clear = function () {
          s = 0, a.key = void 0, a.leftChild = a.rightChild = a.brother = a.parent = void 0, a.color = o.default.TreeNodeColorType.black;
        };
        var l = function (e) {
            if (!e || void 0 === e.key) throw new Error("unknown error");
            return e.leftChild ? l(e.leftChild) : e;
          },
          u = function (e) {
            if (!e || void 0 === e.key) throw new Error("unknown error");
            return e.rightChild ? u(e.rightChild) : e;
          };
        this.front = function () {
          if (!this.empty()) return l(a).key;
        }, this.back = function () {
          if (!this.empty()) return u(a).key;
        }, this.forEach = function (e) {
          var t,
            r,
            n = 0;
          try {
            for (var o = i(this), s = o.next(); !s.done; s = o.next()) {
              e(s.value, n++);
            }
          } catch (e) {
            t = {
              error: e
            };
          } finally {
            try {
              s && !s.done && (r = o.return) && r.call(o);
            } finally {
              if (t) throw t.error;
            }
          }
        }, this.getElementByPos = function (e) {
          var t, r;
          if (e < 0 || e >= this.size()) throw new Error("pos must more than 0 and less than set's size");
          var n = 0;
          try {
            for (var o = i(this), s = o.next(); !s.done; s = o.next()) {
              var a = s.value;
              if (n === e) return a;
              ++n;
            }
          } catch (e) {
            t = {
              error: e
            };
          } finally {
            try {
              s && !s.done && (r = o.return) && r.call(o);
            } finally {
              if (t) throw t.error;
            }
          }
          throw new Error("unknown error");
        };
        var c = function (e) {
            var t = e.parent;
            if (!t) {
              if (e === a) return;
              throw new Error("unknown error");
            }
            if (e.color !== o.default.TreeNodeColorType.red) {
              var r = e.brother;
              if (!r) throw new Error("unknown error");
              if (e === t.leftChild) {
                if (r.color === o.default.TreeNodeColorType.red) {
                  r.color = o.default.TreeNodeColorType.black, t.color = o.default.TreeNodeColorType.red;
                  var n = t.rotateLeft();
                  a === t && (a = n), c(e);
                } else if (r.color === o.default.TreeNodeColorType.black) if (r.rightChild && r.rightChild.color === o.default.TreeNodeColorType.red) {
                  r.color = t.color, t.color = o.default.TreeNodeColorType.black, r.rightChild && (r.rightChild.color = o.default.TreeNodeColorType.black);
                  n = t.rotateLeft();
                  a === t && (a = n), e.color = o.default.TreeNodeColorType.black;
                } else if (r.rightChild && r.rightChild.color !== o.default.TreeNodeColorType.black || !r.leftChild || r.leftChild.color !== o.default.TreeNodeColorType.red) r.leftChild && r.leftChild.color !== o.default.TreeNodeColorType.black || r.rightChild && r.rightChild.color !== o.default.TreeNodeColorType.black || (r.color = o.default.TreeNodeColorType.red, c(t));else {
                  r.color = o.default.TreeNodeColorType.red, r.leftChild && (r.leftChild.color = o.default.TreeNodeColorType.black);
                  n = r.rotateRight();
                  a === r && (a = n), c(e);
                }
              } else if (e === t.rightChild) if (r.color === o.default.TreeNodeColorType.red) {
                r.color = o.default.TreeNodeColorType.black, t.color = o.default.TreeNodeColorType.red;
                n = t.rotateRight();
                a === t && (a = n), c(e);
              } else if (r.color === o.default.TreeNodeColorType.black) if (r.leftChild && r.leftChild.color === o.default.TreeNodeColorType.red) {
                r.color = t.color, t.color = o.default.TreeNodeColorType.black, r.leftChild && (r.leftChild.color = o.default.TreeNodeColorType.black);
                n = t.rotateRight();
                a === t && (a = n), e.color = o.default.TreeNodeColorType.black;
              } else if (r.leftChild && r.leftChild.color !== o.default.TreeNodeColorType.black || !r.rightChild || r.rightChild.color !== o.default.TreeNodeColorType.red) r.leftChild && r.leftChild.color !== o.default.TreeNodeColorType.black || r.rightChild && r.rightChild.color !== o.default.TreeNodeColorType.black || (r.color = o.default.TreeNodeColorType.red, c(t));else {
                r.color = o.default.TreeNodeColorType.red, r.rightChild && (r.rightChild.color = o.default.TreeNodeColorType.black);
                n = r.rotateLeft();
                a === r && (a = n), c(e);
              }
            } else e.color = o.default.TreeNodeColorType.black;
          },
          h = function (e) {
            for (var t = e; t.leftChild || t.rightChild;) {
              if (t.rightChild) {
                t = l(t.rightChild);
                var r = e.key;
                e.key = t.key, t.key = r, e = t;
              }
              if (t.leftChild) {
                t = u(t.leftChild);
                r = e.key;
                e.key = t.key, t.key = r, e = t;
              }
            }
            c(t), t && t.remove(), --s, a.color = o.default.TreeNodeColorType.black;
          },
          f = function (e, t) {
            return !(!e || void 0 === e.key) && (!!f(e.leftChild, t) || !!t(e) || f(e.rightChild, t));
          };
        this.eraseElementByPos = function (e) {
          if (e < 0 || e >= s) throw new Error("pos must more than 0 and less than set's size");
          var t = 0;
          f(a, function (r) {
            return e === t ? (h(r), !0) : (++t, !1);
          });
        }, this.eraseElementByValue = function (e) {
          if (!this.empty()) {
            var r = g(a, e);
            void 0 !== r && void 0 !== r.key && 0 === t(r.key, e) && h(r);
          }
        };
        var p = function (e, r) {
            if (!e || void 0 === e.key) throw new Error("unknown error");
            var n = t(r, e.key);
            return n < 0 ? e.leftChild ? p(e.leftChild, r) : (e.leftChild = new o.default(), e.leftChild.parent = e, e.leftChild.brother = e.rightChild, e.rightChild && (e.rightChild.brother = e.leftChild), e.leftChild) : n > 0 ? e.rightChild ? p(e.rightChild, r) : (e.rightChild = new o.default(), e.rightChild.parent = e, e.rightChild.brother = e.leftChild, e.leftChild && (e.leftChild.brother = e.rightChild), e.rightChild) : e;
          },
          d = function (e) {
            var t = e.parent;
            if (!t) {
              if (e === a) return;
              throw new Error("unknown error");
            }
            if (t.color !== o.default.TreeNodeColorType.black && t.color === o.default.TreeNodeColorType.red) {
              var r = t.brother,
                n = t.parent;
              if (!n) throw new Error("unknown error");
              if (r && r.color === o.default.TreeNodeColorType.red) r.color = t.color = o.default.TreeNodeColorType.black, n.color = o.default.TreeNodeColorType.red, d(n);else if (!r || r.color === o.default.TreeNodeColorType.black) if (t === n.leftChild) {
                if (e === t.leftChild) {
                  t.color = o.default.TreeNodeColorType.black, n.color = o.default.TreeNodeColorType.red;
                  var i = n.rotateRight();
                  n === a && (a = i);
                } else if (e === t.rightChild) {
                  i = t.rotateLeft();
                  n === a && (a = i), d(t);
                }
              } else if (t === n.rightChild) if (e === t.leftChild) {
                i = t.rotateRight();
                n === a && (a = i), d(t);
              } else if (e === t.rightChild) {
                t.color = o.default.TreeNodeColorType.black, n.color = o.default.TreeNodeColorType.red;
                i = n.rotateLeft();
                n === a && (a = i);
              }
            }
          };
        this.insert = function (e) {
          if (null === e || void 0 === e) throw new Error("to avoid some unnecessary errors, we don't suggest you insert null or undefined here");
          if (this.empty()) return ++s, a.key = e, void (a.color = o.default.TreeNodeColorType.black);
          var r = p(a, e);
          void 0 !== r.key && 0 === t(r.key, e) || (++s, r.key = e, d(r), a.color = o.default.TreeNodeColorType.black);
        };
        var g = function (e, r) {
          if (e && void 0 !== e.key) {
            var n = t(r, e.key);
            return n < 0 ? g(e.leftChild, r) : n > 0 ? g(e.rightChild, r) : e;
          }
        };
        this.find = function (e) {
          var r = g(a, e);
          return void 0 !== r && void 0 !== r.key && 0 === t(r.key, e);
        };
        var y = function (e, r) {
          if (e && void 0 !== e.key) {
            var n = t(e.key, r);
            if (0 === n) return e.key;
            if (n < 0) return y(e.rightChild, r);
            var i = y(e.leftChild, r);
            return void 0 !== i ? i : e.key;
          }
        };
        this.lowerBound = function (e) {
          return y(a, e);
        };
        var b = function (e, r) {
          if (e && void 0 !== e.key) {
            if (t(e.key, r) <= 0) return b(e.rightChild, r);
            var n = b(e.leftChild, r);
            return void 0 !== n ? n : e.key;
          }
        };
        this.upperBound = function (e) {
          return b(a, e);
        };
        var m = function (e, r) {
          if (e && void 0 !== e.key) {
            var n = t(e.key, r);
            if (0 === n) return e.key;
            if (n > 0) return m(e.leftChild, r);
            var i = m(e.rightChild, r);
            return void 0 !== i ? i : e.key;
          }
        };
        this.reverseLowerBound = function (e) {
          return m(a, e);
        };
        var v = function (e, r) {
          if (e && void 0 !== e.key) {
            if (t(e.key, r) >= 0) return v(e.leftChild, r);
            var n = v(e.rightChild, r);
            return void 0 !== n ? n : e.key;
          }
        };
        this.reverseUpperBound = function (e) {
          return v(a, e);
        }, this.union = function (e) {
          var t = this;
          e.forEach(function (e) {
            return t.insert(e);
          });
        }, this.getHeight = function () {
          if (this.empty()) return 0;
          var e = function (t) {
            return t ? Math.max(e(t.leftChild), e(t.rightChild)) + 1 : 1;
          };
          return e(a);
        };
        var w = function (e) {
          return n(this, function (t) {
            switch (t.label) {
              case 0:
                return e && void 0 !== e.key ? [5, i(w(e.leftChild))] : [2];
              case 1:
                return t.sent(), [4, e.key];
              case 2:
                return t.sent(), [5, i(w(e.rightChild))];
              case 3:
                return t.sent(), [2];
            }
          });
        };
        this[Symbol.iterator] = function () {
          return w(a);
        }, e.forEach(function (e) {
          return r.insert(e);
        }), Object.freeze(this);
      }
      Object.freeze(s), r.default = s;
    }, {
      "../Base/TreeNode": 25
    }],
    34: [function (e, t, r) {
      "use strict";

      function n(e) {
        var t = this;
        void 0 === e && (e = []);
        var r = 0,
          n = [];
        this.size = function () {
          return r;
        }, this.empty = function () {
          return 0 === r;
        }, this.clear = function () {
          r = 0, n.length = 0;
        }, this.push = function (e) {
          n.push(e), ++r;
        }, this.pop = function () {
          n.pop(), r > 0 && --r;
        }, this.top = function () {
          return n[r - 1];
        }, e.forEach(function (e) {
          return t.push(e);
        }), Object.freeze(this);
      }
      Object.defineProperty(r, "__esModule", {
        value: !0
      }), Object.freeze(n), r.default = n;
    }, {}],
    35: [function (e, t, r) {
      "use strict";

      var n = this && this.__generator || function (e, t) {
          var r,
            n,
            i,
            o,
            s = {
              label: 0,
              sent: function () {
                if (1 & i[0]) throw i[1];
                return i[1];
              },
              trys: [],
              ops: []
            };
          return o = {
            next: a(0),
            throw: a(1),
            return: a(2)
          }, "function" == typeof Symbol && (o[Symbol.iterator] = function () {
            return this;
          }), o;
          function a(o) {
            return function (a) {
              return function (o) {
                if (r) throw new TypeError("Generator is already executing.");
                for (; s;) try {
                  if (r = 1, n && (i = 2 & o[0] ? n.return : o[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, o[1])).done) return i;
                  switch (n = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                    case 0:
                    case 1:
                      i = o;
                      break;
                    case 4:
                      return s.label++, {
                        value: o[1],
                        done: !1
                      };
                    case 5:
                      s.label++, n = o[1], o = [0];
                      continue;
                    case 7:
                      o = s.ops.pop(), s.trys.pop();
                      continue;
                    default:
                      if (!(i = (i = s.trys).length > 0 && i[i.length - 1]) && (6 === o[0] || 2 === o[0])) {
                        s = 0;
                        continue;
                      }
                      if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                        s.label = o[1];
                        break;
                      }
                      if (6 === o[0] && s.label < i[1]) {
                        s.label = i[1], i = o;
                        break;
                      }
                      if (i && s.label < i[2]) {
                        s.label = i[2], s.ops.push(o);
                        break;
                      }
                      i[2] && s.ops.pop(), s.trys.pop();
                      continue;
                  }
                  o = t.call(e, s);
                } catch (e) {
                  o = [6, e], n = 0;
                } finally {
                  r = i = 0;
                }
                if (5 & o[0]) throw o[1];
                return {
                  value: o[0] ? o[1] : void 0,
                  done: !0
                };
              }([o, a]);
            };
          }
        },
        i = this && this.__read || function (e, t) {
          var r = "function" == typeof Symbol && e[Symbol.iterator];
          if (!r) return e;
          var n,
            i,
            o = r.call(e),
            s = [];
          try {
            for (; (void 0 === t || t-- > 0) && !(n = o.next()).done;) s.push(n.value);
          } catch (e) {
            i = {
              error: e
            };
          } finally {
            try {
              n && !n.done && (r = o.return) && r.call(o);
            } finally {
              if (i) throw i.error;
            }
          }
          return s;
        },
        o = this && this.__spreadArray || function (e, t, r) {
          if (r || 2 === arguments.length) for (var n, i = 0, o = t.length; i < o; i++) !n && i in t || (n || (n = Array.prototype.slice.call(t, 0, i)), n[i] = t[i]);
          return e.concat(n || Array.prototype.slice.call(t));
        },
        s = this && this.__values || function (e) {
          var t = "function" == typeof Symbol && Symbol.iterator,
            r = t && e[t],
            n = 0;
          if (r) return r.call(e);
          if (e && "number" == typeof e.length) return {
            next: function () {
              return e && n >= e.length && (e = void 0), {
                value: e && e[n++],
                done: !e
              };
            }
          };
          throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
      function a(e) {
        var t = this;
        void 0 === e && (e = []);
        var r = 0,
          a = [];
        this.size = function () {
          return r;
        }, this.empty = function () {
          return 0 === r;
        }, this.clear = function () {
          r = 0, a.length = 0;
        }, this.front = function () {
          if (!this.empty()) return a[0];
        }, this.back = function () {
          if (!this.empty()) return a[r - 1];
        }, this.forEach = function (e) {
          a.forEach(e);
        }, this.getElementByPos = function (e) {
          if (e < 0 || e >= r) throw new Error("pos must more than 0 and less than vector's size");
          return a[e];
        }, this.eraseElementByPos = function (e) {
          if (e < 0 || e >= r) throw new Error("pos must more than 0 and less than vector's size");
          for (var t = e; t < r - 1; ++t) a[t] = a[t + 1];
          this.popBack();
        }, this.eraseElementByValue = function (e) {
          var t = [];
          this.forEach(function (r) {
            r !== e && t.push(r);
          }), t.forEach(function (e, t) {
            a[t] = e;
          });
          for (var n = t.length; r > n;) this.popBack();
        }, this.pushBack = function (e) {
          a.push(e), ++r;
        }, this.popBack = function () {
          a.pop(), r > 0 && --r;
        }, this.setElementByPos = function (e, t) {
          if (e < 0 || e >= r) throw new Error("pos must more than 0 and less than vector's size");
          a[e] = t;
        }, this.insert = function (e, t, n) {
          if (void 0 === n && (n = 1), e < 0 || e > r) throw new Error("pos must more than 0 and less than or equal to vector's size");
          a.splice.apply(a, o([e, 0], i(new Array(n).fill(t)), !1)), r += n;
        }, this.find = function (e) {
          return a.includes(e);
        }, this.reverse = function () {
          a.reverse();
        }, this.unique = function () {
          var e,
            t = [];
          this.forEach(function (r, n) {
            0 !== n && r === e || (t.push(r), e = r);
          }), t.forEach(function (e, t) {
            a[t] = e;
          });
          for (var n = t.length; r > n;) this.popBack();
        }, this.sort = function (e) {
          a.sort(e);
        }, this[Symbol.iterator] = function () {
          return function () {
            return n(this, function (e) {
              switch (e.label) {
                case 0:
                  return [5, s(a)];
                case 1:
                  return [2, e.sent()];
              }
            });
          }();
        }, e.forEach(function (e) {
          return t.pushBack(e);
        }), Object.freeze(this);
      }
      Object.defineProperty(r, "__esModule", {
        value: !0
      }), Object.freeze(a), r.default = a;
    }, {}],
    36: [function (e, t, r) {
      "use strict";

      Object.defineProperty(r, "__esModule", {
        value: !0
      }), r.HashMap = r.HashSet = r.Map = r.Set = r.PriorityQueue = r.Deque = r.LinkList = r.Queue = r.Stack = r.Vector = void 0;
      var n = e("./Vector/Vector");
      r.Vector = n.default;
      var i = e("./Stack/Stack");
      r.Stack = i.default;
      var o = e("./Queue/Queue");
      r.Queue = o.default;
      var s = e("./LinkList/LinkList");
      r.LinkList = s.default;
      var a = e("./Deque/Deque");
      r.Deque = a.default;
      var l = e("./PriorityQueue/PriorityQueue");
      r.PriorityQueue = l.default;
      var u = e("./Set/Set");
      r.Set = u.default;
      var c = e("./Map/Map");
      r.Map = c.default;
      var h = e("./HashSet/HashSet");
      r.HashSet = h.default;
      var f = e("./HashMap/HashMap");
      r.HashMap = f.default;
    }, {
      "./Deque/Deque": 26,
      "./HashMap/HashMap": 27,
      "./HashSet/HashSet": 28,
      "./LinkList/LinkList": 29,
      "./Map/Map": 30,
      "./PriorityQueue/PriorityQueue": 31,
      "./Queue/Queue": 32,
      "./Set/Set": 33,
      "./Stack/Stack": 34,
      "./Vector/Vector": 35
    }],
    37: [function (e, t, r) {
      "use strict";

      const n = e("yallist"),
        i = Symbol("max"),
        o = Symbol("length"),
        s = Symbol("lengthCalculator"),
        a = Symbol("allowStale"),
        l = Symbol("maxAge"),
        u = Symbol("dispose"),
        c = Symbol("noDisposeOnSet"),
        h = Symbol("lruList"),
        f = Symbol("cache"),
        p = Symbol("updateAgeOnGet"),
        d = () => 1;
      const g = (e, t, r) => {
          const n = e[f].get(t);
          if (n) {
            const t = n.value;
            if (y(e, t)) {
              if (m(e, n), !e[a]) return;
            } else r && (e[p] && (n.value.now = Date.now()), e[h].unshiftNode(n));
            return t.value;
          }
        },
        y = (e, t) => {
          if (!t || !t.maxAge && !e[l]) return !1;
          const r = Date.now() - t.now;
          return t.maxAge ? r > t.maxAge : e[l] && r > e[l];
        },
        b = e => {
          if (e[o] > e[i]) for (let t = e[h].tail; e[o] > e[i] && null !== t;) {
            const r = t.prev;
            m(e, t), t = r;
          }
        },
        m = (e, t) => {
          if (t) {
            const r = t.value;
            e[u] && e[u](r.key, r.value), e[o] -= r.length, e[f].delete(r.key), e[h].removeNode(t);
          }
        };
      class v {
        constructor(e, t, r, n, i) {
          this.key = e, this.value = t, this.length = r, this.now = n, this.maxAge = i || 0;
        }
      }
      const w = (e, t, r, n) => {
        let i = r.value;
        y(e, i) && (m(e, r), e[a] || (i = void 0)), i && t.call(n, i.value, i.key, e);
      };
      t.exports = class {
        constructor(e) {
          if ("number" == typeof e && (e = {
            max: e
          }), e || (e = {}), e.max && ("number" != typeof e.max || e.max < 0)) throw new TypeError("max must be a non-negative number");
          this[i] = e.max || 1 / 0;
          const t = e.length || d;
          if (this[s] = "function" != typeof t ? d : t, this[a] = e.stale || !1, e.maxAge && "number" != typeof e.maxAge) throw new TypeError("maxAge must be a number");
          this[l] = e.maxAge || 0, this[u] = e.dispose, this[c] = e.noDisposeOnSet || !1, this[p] = e.updateAgeOnGet || !1, this.reset();
        }
        set max(e) {
          if ("number" != typeof e || e < 0) throw new TypeError("max must be a non-negative number");
          this[i] = e || 1 / 0, b(this);
        }
        get max() {
          return this[i];
        }
        set allowStale(e) {
          this[a] = !!e;
        }
        get allowStale() {
          return this[a];
        }
        set maxAge(e) {
          if ("number" != typeof e) throw new TypeError("maxAge must be a non-negative number");
          this[l] = e, b(this);
        }
        get maxAge() {
          return this[l];
        }
        set lengthCalculator(e) {
          "function" != typeof e && (e = d), e !== this[s] && (this[s] = e, this[o] = 0, this[h].forEach(e => {
            e.length = this[s](e.value, e.key), this[o] += e.length;
          })), b(this);
        }
        get lengthCalculator() {
          return this[s];
        }
        get length() {
          return this[o];
        }
        get itemCount() {
          return this[h].length;
        }
        rforEach(e, t) {
          t = t || this;
          for (let r = this[h].tail; null !== r;) {
            const n = r.prev;
            w(this, e, r, t), r = n;
          }
        }
        forEach(e, t) {
          t = t || this;
          for (let r = this[h].head; null !== r;) {
            const n = r.next;
            w(this, e, r, t), r = n;
          }
        }
        keys() {
          return this[h].toArray().map(e => e.key);
        }
        values() {
          return this[h].toArray().map(e => e.value);
        }
        reset() {
          this[u] && this[h] && this[h].length && this[h].forEach(e => this[u](e.key, e.value)), this[f] = new Map(), this[h] = new n(), this[o] = 0;
        }
        dump() {
          return this[h].map(e => !y(this, e) && {
            k: e.key,
            v: e.value,
            e: e.now + (e.maxAge || 0)
          }).toArray().filter(e => e);
        }
        dumpLru() {
          return this[h];
        }
        set(e, t, r) {
          if ((r = r || this[l]) && "number" != typeof r) throw new TypeError("maxAge must be a number");
          const n = r ? Date.now() : 0,
            a = this[s](t, e);
          if (this[f].has(e)) {
            if (a > this[i]) return m(this, this[f].get(e)), !1;
            const s = this[f].get(e).value;
            return this[u] && (this[c] || this[u](e, s.value)), s.now = n, s.maxAge = r, s.value = t, this[o] += a - s.length, s.length = a, this.get(e), b(this), !0;
          }
          const p = new v(e, t, a, n, r);
          return p.length > this[i] ? (this[u] && this[u](e, t), !1) : (this[o] += p.length, this[h].unshift(p), this[f].set(e, this[h].head), b(this), !0);
        }
        has(e) {
          if (!this[f].has(e)) return !1;
          const t = this[f].get(e).value;
          return !y(this, t);
        }
        get(e) {
          return g(this, e, !0);
        }
        peek(e) {
          return g(this, e, !1);
        }
        pop() {
          const e = this[h].tail;
          return e ? (m(this, e), e.value) : null;
        }
        del(e) {
          m(this, this[f].get(e));
        }
        load(e) {
          this.reset();
          const t = Date.now();
          for (let r = e.length - 1; r >= 0; r--) {
            const n = e[r],
              i = n.e || 0;
            if (0 === i) this.set(n.k, n.v);else {
              const e = i - t;
              e > 0 && this.set(n.k, n.v, e);
            }
          }
        }
        prune() {
          this[f].forEach((e, t) => g(this, t, !1));
        }
      };
    }, {
      yallist: 83
    }],
    38: [function (e, t, r) {
      (function (e) {
        (function () {
          const r = t.exports;
          r.types = {
            0: "reserved",
            1: "connect",
            2: "connack",
            3: "publish",
            4: "puback",
            5: "pubrec",
            6: "pubrel",
            7: "pubcomp",
            8: "subscribe",
            9: "suback",
            10: "unsubscribe",
            11: "unsuback",
            12: "pingreq",
            13: "pingresp",
            14: "disconnect",
            15: "auth"
          }, r.codes = {};
          for (const e in r.types) {
            const t = r.types[e];
            r.codes[t] = e;
          }
          r.CMD_SHIFT = 4, r.CMD_MASK = 240, r.DUP_MASK = 8, r.QOS_MASK = 3, r.QOS_SHIFT = 1, r.RETAIN_MASK = 1, r.VARBYTEINT_MASK = 127, r.VARBYTEINT_FIN_MASK = 128, r.VARBYTEINT_MAX = 268435455, r.SESSIONPRESENT_MASK = 1, r.SESSIONPRESENT_HEADER = e.from([r.SESSIONPRESENT_MASK]), r.CONNACK_HEADER = e.from([r.codes.connack << r.CMD_SHIFT]), r.USERNAME_MASK = 128, r.PASSWORD_MASK = 64, r.WILL_RETAIN_MASK = 32, r.WILL_QOS_MASK = 24, r.WILL_QOS_SHIFT = 3, r.WILL_FLAG_MASK = 4, r.CLEAN_SESSION_MASK = 2, r.CONNECT_HEADER = e.from([r.codes.connect << r.CMD_SHIFT]), r.properties = {
            sessionExpiryInterval: 17,
            willDelayInterval: 24,
            receiveMaximum: 33,
            maximumPacketSize: 39,
            topicAliasMaximum: 34,
            requestResponseInformation: 25,
            requestProblemInformation: 23,
            userProperties: 38,
            authenticationMethod: 21,
            authenticationData: 22,
            payloadFormatIndicator: 1,
            messageExpiryInterval: 2,
            contentType: 3,
            responseTopic: 8,
            correlationData: 9,
            maximumQoS: 36,
            retainAvailable: 37,
            assignedClientIdentifier: 18,
            reasonString: 31,
            wildcardSubscriptionAvailable: 40,
            subscriptionIdentifiersAvailable: 41,
            sharedSubscriptionAvailable: 42,
            serverKeepAlive: 19,
            responseInformation: 26,
            serverReference: 28,
            topicAlias: 35,
            subscriptionIdentifier: 11
          }, r.propertiesCodes = {};
          for (const e in r.properties) {
            const t = r.properties[e];
            r.propertiesCodes[t] = e;
          }
          function n(t) {
            return [0, 1, 2].map(n => [0, 1].map(i => [0, 1].map(o => {
              const s = e.alloc(1);
              return s.writeUInt8(r.codes[t] << r.CMD_SHIFT | (i ? r.DUP_MASK : 0) | n << r.QOS_SHIFT | o, 0, !0), s;
            })));
          }
          r.propertiesTypes = {
            sessionExpiryInterval: "int32",
            willDelayInterval: "int32",
            receiveMaximum: "int16",
            maximumPacketSize: "int32",
            topicAliasMaximum: "int16",
            requestResponseInformation: "byte",
            requestProblemInformation: "byte",
            userProperties: "pair",
            authenticationMethod: "string",
            authenticationData: "binary",
            payloadFormatIndicator: "byte",
            messageExpiryInterval: "int32",
            contentType: "string",
            responseTopic: "string",
            correlationData: "binary",
            maximumQoS: "int8",
            retainAvailable: "byte",
            assignedClientIdentifier: "string",
            reasonString: "string",
            wildcardSubscriptionAvailable: "byte",
            subscriptionIdentifiersAvailable: "byte",
            sharedSubscriptionAvailable: "byte",
            serverKeepAlive: "int16",
            responseInformation: "string",
            serverReference: "string",
            topicAlias: "int16",
            subscriptionIdentifier: "var"
          }, r.PUBLISH_HEADER = n("publish"), r.SUBSCRIBE_HEADER = n("subscribe"), r.SUBSCRIBE_OPTIONS_QOS_MASK = 3, r.SUBSCRIBE_OPTIONS_NL_MASK = 1, r.SUBSCRIBE_OPTIONS_NL_SHIFT = 2, r.SUBSCRIBE_OPTIONS_RAP_MASK = 1, r.SUBSCRIBE_OPTIONS_RAP_SHIFT = 3, r.SUBSCRIBE_OPTIONS_RH_MASK = 3, r.SUBSCRIBE_OPTIONS_RH_SHIFT = 4, r.SUBSCRIBE_OPTIONS_RH = [0, 16, 32], r.SUBSCRIBE_OPTIONS_NL = 4, r.SUBSCRIBE_OPTIONS_RAP = 8, r.SUBSCRIBE_OPTIONS_QOS = [0, 1, 2], r.UNSUBSCRIBE_HEADER = n("unsubscribe"), r.ACKS = {
            unsuback: n("unsuback"),
            puback: n("puback"),
            pubcomp: n("pubcomp"),
            pubrel: n("pubrel"),
            pubrec: n("pubrec")
          }, r.SUBACK_HEADER = e.from([r.codes.suback << r.CMD_SHIFT]), r.VERSION3 = e.from([3]), r.VERSION4 = e.from([4]), r.VERSION5 = e.from([5]), r.VERSION131 = e.from([131]), r.VERSION132 = e.from([132]), r.QOS = [0, 1, 2].map(t => e.from([t])), r.EMPTY = {
            pingreq: e.from([r.codes.pingreq << 4, 0]),
            pingresp: e.from([r.codes.pingresp << 4, 0]),
            disconnect: e.from([r.codes.disconnect << 4, 0])
          };
        }).call(this);
      }).call(this, e("buffer").Buffer);
    }, {
      buffer: 17
    }],
    39: [function (e, t, r) {
      (function (r) {
        (function () {
          const n = e("./writeToStream"),
            i = e("events");
          class o extends i {
            constructor() {
              super(), this._array = new Array(20), this._i = 0;
            }
            write(e) {
              return this._array[this._i++] = e, !0;
            }
            concat() {
              let e = 0;
              const t = new Array(this._array.length),
                n = this._array;
              let i,
                o = 0;
              for (i = 0; i < n.length && void 0 !== n[i]; i++) "string" != typeof n[i] ? t[i] = n[i].length : t[i] = r.byteLength(n[i]), e += t[i];
              const s = r.allocUnsafe(e);
              for (i = 0; i < n.length && void 0 !== n[i]; i++) "string" != typeof n[i] ? (n[i].copy(s, o), o += t[i]) : (s.write(n[i], o), o += t[i]);
              return s;
            }
          }
          t.exports = function (e, t) {
            const r = new o();
            return n(e, r, t), r.concat();
          };
        }).call(this);
      }).call(this, e("buffer").Buffer);
    }, {
      "./writeToStream": 44,
      buffer: 17,
      events: 22
    }],
    40: [function (e, t, r) {
      r.parser = e("./parser").parser, r.generate = e("./generate"), r.writeToStream = e("./writeToStream");
    }, {
      "./generate": 39,
      "./parser": 43,
      "./writeToStream": 44
    }],
    41: [function (e, t, r) {
      (function (e) {
        (function () {
          const r = 65536,
            n = {},
            i = e.isBuffer(e.from([1, 2]).subarray(0, 1));
          function o(t) {
            const r = e.allocUnsafe(2);
            return r.writeUInt8(t >> 8, 0), r.writeUInt8(255 & t, 1), r;
          }
          t.exports = {
            cache: n,
            generateCache: function () {
              for (let e = 0; e < r; e++) n[e] = o(e);
            },
            generateNumber: o,
            genBufVariableByteInt: function (t) {
              let r = 0,
                n = 0;
              const o = e.allocUnsafe(4);
              do {
                r = t % 128 | 0, (t = t / 128 | 0) > 0 && (r |= 128), o.writeUInt8(r, n++);
              } while (t > 0 && n < 4);
              return t > 0 && (n = 0), i ? o.subarray(0, n) : o.slice(0, n);
            },
            generate4ByteBuffer: function (t) {
              const r = e.allocUnsafe(4);
              return r.writeUInt32BE(t, 0), r;
            }
          };
        }).call(this);
      }).call(this, e("buffer").Buffer);
    }, {
      buffer: 17
    }],
    42: [function (e, t, r) {
      t.exports = class {
        constructor() {
          this.cmd = null, this.retain = !1, this.qos = 0, this.dup = !1, this.length = -1, this.topic = null, this.payload = null;
        }
      };
    }, {}],
    43: [function (e, t, r) {
      const n = e("bl"),
        i = e("events"),
        o = e("./packet"),
        s = e("./constants"),
        a = e("debug")("mqtt-packet:parser");
      class l extends i {
        constructor() {
          super(), this.parser = this.constructor.parser;
        }
        static parser(e) {
          return this instanceof l ? (this.settings = e || {}, this._states = ["_parseHeader", "_parseLength", "_parsePayload", "_newPacket"], this._resetState(), this) : new l().parser(e);
        }
        _resetState() {
          a("_resetState: resetting packet, error, _list, and _stateCounter"), this.packet = new o(), this.error = null, this._list = n(), this._stateCounter = 0;
        }
        parse(e) {
          for (this.error && this._resetState(), this._list.append(e), a("parse: current state: %s", this._states[this._stateCounter]); (-1 !== this.packet.length || this._list.length > 0) && this[this._states[this._stateCounter]]() && !this.error;) this._stateCounter++, a("parse: state complete. _stateCounter is now: %d", this._stateCounter), a("parse: packet.length: %d, buffer list length: %d", this.packet.length, this._list.length), this._stateCounter >= this._states.length && (this._stateCounter = 0);
          return a("parse: exited while loop. packet: %d, buffer list length: %d", this.packet.length, this._list.length), this._list.length;
        }
        _parseHeader() {
          const e = this._list.readUInt8(0);
          return this.packet.cmd = s.types[e >> s.CMD_SHIFT], this.packet.retain = 0 != (e & s.RETAIN_MASK), this.packet.qos = e >> s.QOS_SHIFT & s.QOS_MASK, this.packet.dup = 0 != (e & s.DUP_MASK), a("_parseHeader: packet: %o", this.packet), this._list.consume(1), !0;
        }
        _parseLength() {
          const e = this._parseVarByteNum(!0);
          return e && (this.packet.length = e.value, this._list.consume(e.bytes)), a("_parseLength %d", e.value), !!e;
        }
        _parsePayload() {
          a("_parsePayload: payload %O", this._list);
          let e = !1;
          if (0 === this.packet.length || this._list.length >= this.packet.length) {
            switch (this._pos = 0, this.packet.cmd) {
              case "connect":
                this._parseConnect();
                break;
              case "connack":
                this._parseConnack();
                break;
              case "publish":
                this._parsePublish();
                break;
              case "puback":
              case "pubrec":
              case "pubrel":
              case "pubcomp":
                this._parseConfirmation();
                break;
              case "subscribe":
                this._parseSubscribe();
                break;
              case "suback":
                this._parseSuback();
                break;
              case "unsubscribe":
                this._parseUnsubscribe();
                break;
              case "unsuback":
                this._parseUnsuback();
                break;
              case "pingreq":
              case "pingresp":
                break;
              case "disconnect":
                this._parseDisconnect();
                break;
              case "auth":
                this._parseAuth();
                break;
              default:
                this._emitError(new Error("Not supported"));
            }
            e = !0;
          }
          return a("_parsePayload complete result: %s", e), e;
        }
        _parseConnect() {
          let e, t, r, n;
          a("_parseConnect");
          const i = {},
            o = this.packet,
            l = this._parseString();
          if (null === l) return this._emitError(new Error("Cannot parse protocolId"));
          if ("MQTT" !== l && "MQIsdp" !== l) return this._emitError(new Error("Invalid protocolId"));
          if (o.protocolId = l, this._pos >= this._list.length) return this._emitError(new Error("Packet too short"));
          if (o.protocolVersion = this._list.readUInt8(this._pos), o.protocolVersion >= 128 && (o.bridgeMode = !0, o.protocolVersion = o.protocolVersion - 128), 3 !== o.protocolVersion && 4 !== o.protocolVersion && 5 !== o.protocolVersion) return this._emitError(new Error("Invalid protocol version"));
          if (this._pos++, this._pos >= this._list.length) return this._emitError(new Error("Packet too short"));
          if (i.username = this._list.readUInt8(this._pos) & s.USERNAME_MASK, i.password = this._list.readUInt8(this._pos) & s.PASSWORD_MASK, i.will = this._list.readUInt8(this._pos) & s.WILL_FLAG_MASK, i.will && (o.will = {}, o.will.retain = 0 != (this._list.readUInt8(this._pos) & s.WILL_RETAIN_MASK), o.will.qos = (this._list.readUInt8(this._pos) & s.WILL_QOS_MASK) >> s.WILL_QOS_SHIFT), o.clean = 0 != (this._list.readUInt8(this._pos) & s.CLEAN_SESSION_MASK), this._pos++, o.keepalive = this._parseNum(), -1 === o.keepalive) return this._emitError(new Error("Packet too short"));
          if (5 === o.protocolVersion) {
            const e = this._parseProperties();
            Object.getOwnPropertyNames(e).length && (o.properties = e);
          }
          const u = this._parseString();
          if (null === u) return this._emitError(new Error("Packet too short"));
          if (o.clientId = u, a("_parseConnect: packet.clientId: %s", o.clientId), i.will) {
            if (5 === o.protocolVersion) {
              const e = this._parseProperties();
              Object.getOwnPropertyNames(e).length && (o.will.properties = e);
            }
            if (null === (e = this._parseString())) return this._emitError(new Error("Cannot parse will topic"));
            if (o.will.topic = e, a("_parseConnect: packet.will.topic: %s", o.will.topic), null === (t = this._parseBuffer())) return this._emitError(new Error("Cannot parse will payload"));
            o.will.payload = t, a("_parseConnect: packet.will.paylaod: %s", o.will.payload);
          }
          if (i.username) {
            if (null === (n = this._parseString())) return this._emitError(new Error("Cannot parse username"));
            o.username = n, a("_parseConnect: packet.username: %s", o.username);
          }
          if (i.password) {
            if (null === (r = this._parseBuffer())) return this._emitError(new Error("Cannot parse password"));
            o.password = r;
          }
          return this.settings = o, a("_parseConnect: complete"), o;
        }
        _parseConnack() {
          a("_parseConnack");
          const e = this.packet;
          if (this._list.length < 1) return null;
          if (e.sessionPresent = !!(this._list.readUInt8(this._pos++) & s.SESSIONPRESENT_MASK), 5 === this.settings.protocolVersion) this._list.length >= 2 ? e.reasonCode = this._list.readUInt8(this._pos++) : e.reasonCode = 0;else {
            if (this._list.length < 2) return null;
            e.returnCode = this._list.readUInt8(this._pos++);
          }
          if (-1 === e.returnCode || -1 === e.reasonCode) return this._emitError(new Error("Cannot parse return code"));
          if (5 === this.settings.protocolVersion) {
            const t = this._parseProperties();
            Object.getOwnPropertyNames(t).length && (e.properties = t);
          }
          a("_parseConnack: complete");
        }
        _parsePublish() {
          a("_parsePublish");
          const e = this.packet;
          if (e.topic = this._parseString(), null === e.topic) return this._emitError(new Error("Cannot parse topic"));
          if (!(e.qos > 0) || this._parseMessageId()) {
            if (5 === this.settings.protocolVersion) {
              const t = this._parseProperties();
              Object.getOwnPropertyNames(t).length && (e.properties = t);
            }
            e.payload = this._list.slice(this._pos, e.length), a("_parsePublish: payload from buffer list: %o", e.payload);
          }
        }
        _parseSubscribe() {
          a("_parseSubscribe");
          const e = this.packet;
          let t, r, n, i, o, l, u;
          if (1 !== e.qos) return this._emitError(new Error("Wrong subscribe header"));
          if (e.subscriptions = [], this._parseMessageId()) {
            if (5 === this.settings.protocolVersion) {
              const t = this._parseProperties();
              Object.getOwnPropertyNames(t).length && (e.properties = t);
            }
            for (; this._pos < e.length;) {
              if (null === (t = this._parseString())) return this._emitError(new Error("Cannot parse topic"));
              if (this._pos >= e.length) return this._emitError(new Error("Malformed Subscribe Payload"));
              n = (r = this._parseByte()) & s.SUBSCRIBE_OPTIONS_QOS_MASK, l = 0 != (r >> s.SUBSCRIBE_OPTIONS_NL_SHIFT & s.SUBSCRIBE_OPTIONS_NL_MASK), o = 0 != (r >> s.SUBSCRIBE_OPTIONS_RAP_SHIFT & s.SUBSCRIBE_OPTIONS_RAP_MASK), i = r >> s.SUBSCRIBE_OPTIONS_RH_SHIFT & s.SUBSCRIBE_OPTIONS_RH_MASK, u = {
                topic: t,
                qos: n
              }, 5 === this.settings.protocolVersion ? (u.nl = l, u.rap = o, u.rh = i) : this.settings.bridgeMode && (u.rh = 0, u.rap = !0, u.nl = !0), a("_parseSubscribe: push subscription `%s` to subscription", u), e.subscriptions.push(u);
            }
          }
        }
        _parseSuback() {
          a("_parseSuback");
          const e = this.packet;
          if (this.packet.granted = [], this._parseMessageId()) {
            if (5 === this.settings.protocolVersion) {
              const t = this._parseProperties();
              Object.getOwnPropertyNames(t).length && (e.properties = t);
            }
            for (; this._pos < this.packet.length;) this.packet.granted.push(this._list.readUInt8(this._pos++));
          }
        }
        _parseUnsubscribe() {
          a("_parseUnsubscribe");
          const e = this.packet;
          if (e.unsubscriptions = [], this._parseMessageId()) {
            if (5 === this.settings.protocolVersion) {
              const t = this._parseProperties();
              Object.getOwnPropertyNames(t).length && (e.properties = t);
            }
            for (; this._pos < e.length;) {
              const t = this._parseString();
              if (null === t) return this._emitError(new Error("Cannot parse topic"));
              a("_parseUnsubscribe: push topic `%s` to unsubscriptions", t), e.unsubscriptions.push(t);
            }
          }
        }
        _parseUnsuback() {
          a("_parseUnsuback");
          const e = this.packet;
          if (!this._parseMessageId()) return this._emitError(new Error("Cannot parse messageId"));
          if (5 === this.settings.protocolVersion) {
            const t = this._parseProperties();
            for (Object.getOwnPropertyNames(t).length && (e.properties = t), e.granted = []; this._pos < this.packet.length;) this.packet.granted.push(this._list.readUInt8(this._pos++));
          }
        }
        _parseConfirmation() {
          a("_parseConfirmation: packet.cmd: `%s`", this.packet.cmd);
          const e = this.packet;
          if (this._parseMessageId(), 5 === this.settings.protocolVersion && (e.length > 2 ? (e.reasonCode = this._parseByte(), a("_parseConfirmation: packet.reasonCode `%d`", e.reasonCode)) : e.reasonCode = 0, e.length > 3)) {
            const t = this._parseProperties();
            Object.getOwnPropertyNames(t).length && (e.properties = t);
          }
          return !0;
        }
        _parseDisconnect() {
          const e = this.packet;
          if (a("_parseDisconnect"), 5 === this.settings.protocolVersion) {
            this._list.length > 0 ? e.reasonCode = this._parseByte() : e.reasonCode = 0;
            const t = this._parseProperties();
            Object.getOwnPropertyNames(t).length && (e.properties = t);
          }
          return a("_parseDisconnect result: true"), !0;
        }
        _parseAuth() {
          a("_parseAuth");
          const e = this.packet;
          if (5 !== this.settings.protocolVersion) return this._emitError(new Error("Not supported auth packet for this version MQTT"));
          e.reasonCode = this._parseByte();
          const t = this._parseProperties();
          return Object.getOwnPropertyNames(t).length && (e.properties = t), a("_parseAuth: result: true"), !0;
        }
        _parseMessageId() {
          const e = this.packet;
          return e.messageId = this._parseNum(), null === e.messageId ? (this._emitError(new Error("Cannot parse messageId")), !1) : (a("_parseMessageId: packet.messageId %d", e.messageId), !0);
        }
        _parseString(e) {
          const t = this._parseNum(),
            r = t + this._pos;
          if (-1 === t || r > this._list.length || r > this.packet.length) return null;
          const n = this._list.toString("utf8", this._pos, r);
          return this._pos += t, a("_parseString: result: %s", n), n;
        }
        _parseStringPair() {
          return a("_parseStringPair"), {
            name: this._parseString(),
            value: this._parseString()
          };
        }
        _parseBuffer() {
          const e = this._parseNum(),
            t = e + this._pos;
          if (-1 === e || t > this._list.length || t > this.packet.length) return null;
          const r = this._list.slice(this._pos, t);
          return this._pos += e, a("_parseBuffer: result: %o", r), r;
        }
        _parseNum() {
          if (this._list.length - this._pos < 2) return -1;
          const e = this._list.readUInt16BE(this._pos);
          return this._pos += 2, a("_parseNum: result: %s", e), e;
        }
        _parse4ByteNum() {
          if (this._list.length - this._pos < 4) return -1;
          const e = this._list.readUInt32BE(this._pos);
          return this._pos += 4, a("_parse4ByteNum: result: %s", e), e;
        }
        _parseVarByteNum(e) {
          a("_parseVarByteNum");
          let t,
            r = 0,
            n = 1,
            i = 0,
            o = !1;
          const l = this._pos ? this._pos : 0;
          for (; r < 4 && l + r < this._list.length;) {
            if (i += n * ((t = this._list.readUInt8(l + r++)) & s.VARBYTEINT_MASK), n *= 128, 0 == (t & s.VARBYTEINT_FIN_MASK)) {
              o = !0;
              break;
            }
            if (this._list.length <= r) break;
          }
          return !o && 4 === r && this._list.length >= r && this._emitError(new Error("Invalid variable byte integer")), l && (this._pos += r), a("_parseVarByteNum: result: %o", o = !!o && (e ? {
            bytes: r,
            value: i
          } : i)), o;
        }
        _parseByte() {
          let e;
          return this._pos < this._list.length && (e = this._list.readUInt8(this._pos), this._pos++), a("_parseByte: result: %o", e), e;
        }
        _parseByType(e) {
          switch (a("_parseByType: type: %s", e), e) {
            case "byte":
              return 0 !== this._parseByte();
            case "int8":
              return this._parseByte();
            case "int16":
              return this._parseNum();
            case "int32":
              return this._parse4ByteNum();
            case "var":
              return this._parseVarByteNum();
            case "string":
              return this._parseString();
            case "pair":
              return this._parseStringPair();
            case "binary":
              return this._parseBuffer();
          }
        }
        _parseProperties() {
          a("_parseProperties");
          const e = this._parseVarByteNum(),
            t = this._pos + e,
            r = {};
          for (; this._pos < t;) {
            const e = this._parseByte();
            if (!e) return this._emitError(new Error("Cannot parse property code type")), !1;
            const t = s.propertiesCodes[e];
            if (!t) return this._emitError(new Error("Unknown property")), !1;
            if ("userProperties" !== t) r[t] ? Array.isArray(r[t]) ? r[t].push(this._parseByType(s.propertiesTypes[t])) : (r[t] = [r[t]], r[t].push(this._parseByType(s.propertiesTypes[t]))) : r[t] = this._parseByType(s.propertiesTypes[t]);else {
              r[t] || (r[t] = Object.create(null));
              const e = this._parseByType(s.propertiesTypes[t]);
              if (r[t][e.name]) {
                if (Array.isArray(r[t][e.name])) r[t][e.name].push(e.value);else {
                  const n = r[t][e.name];
                  r[t][e.name] = [n], r[t][e.name].push(e.value);
                }
              } else r[t][e.name] = e.value;
            }
          }
          return r;
        }
        _newPacket() {
          return a("_newPacket"), this.packet && (this._list.consume(this.packet.length), a("_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d", this.packet.cmd, this.packet.payload, this.packet.length), this.emit("packet", this.packet)), a("_newPacket: new packet"), this.packet = new o(), this._pos = 0, !0;
        }
        _emitError(e) {
          a("_emitError"), this.error = e, this.emit("error", e);
        }
      }
      t.exports = l;
    }, {
      "./constants": 38,
      "./packet": 42,
      bl: 15,
      debug: 18,
      events: 22
    }],
    44: [function (e, t, r) {
      (function (r) {
        (function () {
          const n = e("./constants"),
            i = r.allocUnsafe(0),
            o = r.from([0]),
            s = e("./numbers"),
            a = e("process-nextick-args").nextTick,
            l = e("debug")("mqtt-packet:writeToStream"),
            u = s.cache,
            c = s.generateNumber,
            h = s.generateCache,
            f = s.genBufVariableByteInt,
            p = s.generate4ByteBuffer;
          let d = k,
            g = !0;
          function y(e, t, s) {
            switch (l("generate called"), t.cork && (t.cork(), a(b, t)), g && (g = !1, h()), l("generate: packet.cmd: %s", e.cmd), e.cmd) {
              case "connect":
                return function (e, t, i) {
                  const o = e || {},
                    s = o.protocolId || "MQTT";
                  let a = o.protocolVersion || 4;
                  const l = o.will;
                  let u = o.clean;
                  const c = o.keepalive || 0,
                    h = o.clientId || "",
                    f = o.username,
                    p = o.password,
                    g = o.properties;
                  void 0 === u && (u = !0);
                  let y = 0;
                  if (!s || "string" != typeof s && !r.isBuffer(s)) return t.emit("error", new Error("Invalid protocolId")), !1;
                  y += s.length + 2;
                  if (3 !== a && 4 !== a && 5 !== a) return t.emit("error", new Error("Invalid protocol version")), !1;
                  y += 1;
                  if (("string" == typeof h || r.isBuffer(h)) && (h || a >= 4) && (h || u)) y += r.byteLength(h) + 2;else {
                    if (a < 4) return t.emit("error", new Error("clientId must be supplied before 3.1.1")), !1;
                    if (1 * u == 0) return t.emit("error", new Error("clientId must be given if cleanSession set to 0")), !1;
                  }
                  if ("number" != typeof c || c < 0 || c > 65535 || c % 1 != 0) return t.emit("error", new Error("Invalid keepalive")), !1;
                  y += 2;
                  if (y += 1, 5 === a) {
                    var b = C(t, g);
                    if (!b) return !1;
                    y += b.length;
                  }
                  if (l) {
                    if ("object" != typeof l) return t.emit("error", new Error("Invalid will")), !1;
                    if (!l.topic || "string" != typeof l.topic) return t.emit("error", new Error("Invalid will topic")), !1;
                    if (y += r.byteLength(l.topic) + 2, y += 2, l.payload) {
                      if (!(l.payload.length >= 0)) return t.emit("error", new Error("Invalid will payload")), !1;
                      "string" == typeof l.payload ? y += r.byteLength(l.payload) : y += l.payload.length;
                    }
                    var m = {};
                    if (5 === a) {
                      if (!(m = C(t, l.properties))) return !1;
                      y += m.length;
                    }
                  }
                  let _ = !1;
                  if (null != f) {
                    if (!P(f)) return t.emit("error", new Error("Invalid username")), !1;
                    _ = !0, y += r.byteLength(f) + 2;
                  }
                  if (null != p) {
                    if (!_) return t.emit("error", new Error("Username is required to use password")), !1;
                    if (!P(p)) return t.emit("error", new Error("Invalid password")), !1;
                    y += I(p) + 2;
                  }
                  t.write(n.CONNECT_HEADER), v(t, y), E(t, s), o.bridgeMode && (a += 128);
                  t.write(131 === a ? n.VERSION131 : 132 === a ? n.VERSION132 : 4 === a ? n.VERSION4 : 5 === a ? n.VERSION5 : n.VERSION3);
                  let k = 0;
                  k |= null != f ? n.USERNAME_MASK : 0, k |= null != p ? n.PASSWORD_MASK : 0, k |= l && l.retain ? n.WILL_RETAIN_MASK : 0, k |= l && l.qos ? l.qos << n.WILL_QOS_SHIFT : 0, k |= l ? n.WILL_FLAG_MASK : 0, k |= u ? n.CLEAN_SESSION_MASK : 0, t.write(r.from([k])), d(t, c), 5 === a && b.write();
                  E(t, h), l && (5 === a && m.write(), w(t, l.topic), E(t, l.payload));
                  null != f && E(t, f);
                  null != p && E(t, p);
                  return !0;
                }(e, t);
              case "connack":
                return function (e, t, i) {
                  const s = i ? i.protocolVersion : 4,
                    a = e || {},
                    l = 5 === s ? a.reasonCode : a.returnCode,
                    u = a.properties;
                  let c = 2;
                  if ("number" != typeof l) return t.emit("error", new Error("Invalid return code")), !1;
                  let h = null;
                  if (5 === s) {
                    if (!(h = C(t, u))) return !1;
                    c += h.length;
                  }
                  t.write(n.CONNACK_HEADER), v(t, c), t.write(a.sessionPresent ? n.SESSIONPRESENT_HEADER : o), t.write(r.from([l])), null != h && h.write();
                  return !0;
                }(e, t, s);
              case "publish":
                return function (e, t, o) {
                  l("publish: packet: %o", e);
                  const s = o ? o.protocolVersion : 4,
                    a = e || {},
                    u = a.qos || 0,
                    c = a.retain ? n.RETAIN_MASK : 0,
                    h = a.topic,
                    f = a.payload || i,
                    p = a.messageId,
                    g = a.properties;
                  let y = 0;
                  if ("string" == typeof h) y += r.byteLength(h) + 2;else {
                    if (!r.isBuffer(h)) return t.emit("error", new Error("Invalid topic")), !1;
                    y += h.length + 2;
                  }
                  r.isBuffer(f) ? y += f.length : y += r.byteLength(f);
                  if (u && "number" != typeof p) return t.emit("error", new Error("Invalid messageId")), !1;
                  u && (y += 2);
                  let b = null;
                  if (5 === s) {
                    if (!(b = C(t, g))) return !1;
                    y += b.length;
                  }
                  t.write(n.PUBLISH_HEADER[u][a.dup ? 1 : 0][c ? 1 : 0]), v(t, y), d(t, I(h)), t.write(h), u > 0 && d(t, p);
                  null != b && b.write();
                  return l("publish: payload: %o", f), t.write(f);
                }(e, t, s);
              case "puback":
              case "pubrec":
              case "pubrel":
              case "pubcomp":
                return function (e, t, i) {
                  const o = i ? i.protocolVersion : 4,
                    s = e || {},
                    a = s.cmd || "puback",
                    l = s.messageId,
                    u = s.dup && "pubrel" === a ? n.DUP_MASK : 0;
                  let c = 0;
                  const h = s.reasonCode,
                    f = s.properties;
                  let p = 5 === o ? 3 : 2;
                  "pubrel" === a && (c = 1);
                  if ("number" != typeof l) return t.emit("error", new Error("Invalid messageId")), !1;
                  let g = null;
                  if (5 === o && "object" == typeof f) {
                    if (!(g = T(t, f, i, p))) return !1;
                    p += g.length;
                  }
                  t.write(n.ACKS[a][c][u][0]), v(t, p), d(t, l), 5 === o && t.write(r.from([h]));
                  null !== g && g.write();
                  return !0;
                }(e, t, s);
              case "subscribe":
                return function (e, t, i) {
                  l("subscribe: packet: ");
                  const o = i ? i.protocolVersion : 4,
                    s = e || {},
                    a = s.dup ? n.DUP_MASK : 0,
                    u = s.messageId,
                    c = s.subscriptions,
                    h = s.properties;
                  let f = 0;
                  if ("number" != typeof u) return t.emit("error", new Error("Invalid messageId")), !1;
                  f += 2;
                  let p = null;
                  if (5 === o) {
                    if (!(p = C(t, h))) return !1;
                    f += p.length;
                  }
                  if ("object" != typeof c || !c.length) return t.emit("error", new Error("Invalid subscriptions")), !1;
                  for (let e = 0; e < c.length; e += 1) {
                    const n = c[e].topic,
                      i = c[e].qos;
                    if ("string" != typeof n) return t.emit("error", new Error("Invalid subscriptions - invalid topic")), !1;
                    if ("number" != typeof i) return t.emit("error", new Error("Invalid subscriptions - invalid qos")), !1;
                    if (5 === o) {
                      const r = c[e].nl || !1;
                      if ("boolean" != typeof r) return t.emit("error", new Error("Invalid subscriptions - invalid No Local")), !1;
                      const n = c[e].rap || !1;
                      if ("boolean" != typeof n) return t.emit("error", new Error("Invalid subscriptions - invalid Retain as Published")), !1;
                      const i = c[e].rh || 0;
                      if ("number" != typeof i || i > 2) return t.emit("error", new Error("Invalid subscriptions - invalid Retain Handling")), !1;
                    }
                    f += r.byteLength(n) + 2 + 1;
                  }
                  l("subscribe: writing to stream: %o", n.SUBSCRIBE_HEADER), t.write(n.SUBSCRIBE_HEADER[1][a ? 1 : 0][0]), v(t, f), d(t, u), null !== p && p.write();
                  let g = !0;
                  for (const e of c) {
                    const i = e.topic,
                      s = e.qos,
                      a = +e.nl,
                      l = +e.rap,
                      u = e.rh;
                    let c;
                    w(t, i), c = n.SUBSCRIBE_OPTIONS_QOS[s], 5 === o && (c |= a ? n.SUBSCRIBE_OPTIONS_NL : 0, c |= l ? n.SUBSCRIBE_OPTIONS_RAP : 0, c |= u ? n.SUBSCRIBE_OPTIONS_RH[u] : 0), g = t.write(r.from([c]));
                  }
                  return g;
                }(e, t, s);
              case "suback":
                return function (e, t, i) {
                  const o = i ? i.protocolVersion : 4,
                    s = e || {},
                    a = s.messageId,
                    l = s.granted,
                    u = s.properties;
                  let c = 0;
                  if ("number" != typeof a) return t.emit("error", new Error("Invalid messageId")), !1;
                  c += 2;
                  if ("object" != typeof l || !l.length) return t.emit("error", new Error("Invalid qos vector")), !1;
                  for (let e = 0; e < l.length; e += 1) {
                    if ("number" != typeof l[e]) return t.emit("error", new Error("Invalid qos vector")), !1;
                    c += 1;
                  }
                  let h = null;
                  if (5 === o) {
                    if (!(h = T(t, u, i, c))) return !1;
                    c += h.length;
                  }
                  t.write(n.SUBACK_HEADER), v(t, c), d(t, a), null !== h && h.write();
                  return t.write(r.from(l));
                }(e, t, s);
              case "unsubscribe":
                return function (e, t, i) {
                  const o = i ? i.protocolVersion : 4,
                    s = e || {},
                    a = s.messageId,
                    l = s.dup ? n.DUP_MASK : 0,
                    u = s.unsubscriptions,
                    c = s.properties;
                  let h = 0;
                  if ("number" != typeof a) return t.emit("error", new Error("Invalid messageId")), !1;
                  h += 2;
                  if ("object" != typeof u || !u.length) return t.emit("error", new Error("Invalid unsubscriptions")), !1;
                  for (let e = 0; e < u.length; e += 1) {
                    if ("string" != typeof u[e]) return t.emit("error", new Error("Invalid unsubscriptions")), !1;
                    h += r.byteLength(u[e]) + 2;
                  }
                  let f = null;
                  if (5 === o) {
                    if (!(f = C(t, c))) return !1;
                    h += f.length;
                  }
                  t.write(n.UNSUBSCRIBE_HEADER[1][l ? 1 : 0][0]), v(t, h), d(t, a), null !== f && f.write();
                  let p = !0;
                  for (let e = 0; e < u.length; e++) p = w(t, u[e]);
                  return p;
                }(e, t, s);
              case "unsuback":
                return function (e, t, i) {
                  const o = i ? i.protocolVersion : 4,
                    s = e || {},
                    a = s.messageId,
                    l = s.dup ? n.DUP_MASK : 0,
                    u = s.granted,
                    c = s.properties,
                    h = s.cmd;
                  let f = 2;
                  if ("number" != typeof a) return t.emit("error", new Error("Invalid messageId")), !1;
                  if (5 === o) {
                    if ("object" != typeof u || !u.length) return t.emit("error", new Error("Invalid qos vector")), !1;
                    for (let e = 0; e < u.length; e += 1) {
                      if ("number" != typeof u[e]) return t.emit("error", new Error("Invalid qos vector")), !1;
                      f += 1;
                    }
                  }
                  let p = null;
                  if (5 === o) {
                    if (!(p = T(t, c, i, f))) return !1;
                    f += p.length;
                  }
                  t.write(n.ACKS[h][0][l][0]), v(t, f), d(t, a), null !== p && p.write();
                  5 === o && t.write(r.from(u));
                  return !0;
                }(e, t, s);
              case "pingreq":
              case "pingresp":
                return function (e, t, r) {
                  return t.write(n.EMPTY[e.cmd]);
                }(e, t);
              case "disconnect":
                return function (e, t, i) {
                  const o = i ? i.protocolVersion : 4,
                    s = e || {},
                    a = s.reasonCode,
                    l = s.properties;
                  let u = 5 === o ? 1 : 0,
                    c = null;
                  if (5 === o) {
                    if (!(c = T(t, l, i, u))) return !1;
                    u += c.length;
                  }
                  t.write(r.from([n.codes.disconnect << 4])), v(t, u), 5 === o && t.write(r.from([a]));
                  null !== c && c.write();
                  return !0;
                }(e, t, s);
              case "auth":
                return function (e, t, i) {
                  const o = i ? i.protocolVersion : 4,
                    s = e || {},
                    a = s.reasonCode,
                    l = s.properties;
                  let u = 5 === o ? 1 : 0;
                  5 !== o && t.emit("error", new Error("Invalid mqtt version for auth packet"));
                  const c = T(t, l, i, u);
                  if (!c) return !1;
                  u += c.length, t.write(r.from([n.codes.auth << 4])), v(t, u), t.write(r.from([a])), null !== c && c.write();
                  return !0;
                }(e, t, s);
              default:
                return t.emit("error", new Error("Unknown command")), !1;
            }
          }
          function b(e) {
            e.uncork();
          }
          Object.defineProperty(y, "cacheNumbers", {
            get: () => d === k,
            set(e) {
              e ? (u && 0 !== Object.keys(u).length || (g = !0), d = k) : (g = !1, d = S);
            }
          });
          const m = {};
          function v(e, t) {
            if (t > n.VARBYTEINT_MAX) return e.emit("error", new Error(`Invalid variable byte integer: ${t}`)), !1;
            let r = m[t];
            return r || (r = f(t), t < 16384 && (m[t] = r)), l("writeVarByteInt: writing to stream: %o", r), e.write(r);
          }
          function w(e, t) {
            const n = r.byteLength(t);
            return d(e, n), l("writeString: %s", t), e.write(t, "utf8");
          }
          function _(e, t, r) {
            w(e, t), w(e, r);
          }
          function k(e, t) {
            return l("writeNumberCached: number: %d", t), l("writeNumberCached: %o", u[t]), e.write(u[t]);
          }
          function S(e, t) {
            const r = c(t);
            return l("writeNumberGenerated: %o", r), e.write(r);
          }
          function E(e, t) {
            "string" == typeof t ? w(e, t) : t ? (d(e, t.length), e.write(t)) : d(e, 0);
          }
          function C(e, t) {
            if ("object" != typeof t || null != t.length) return {
              length: 1,
              write() {
                A(e, {}, 0);
              }
            };
            let i = 0;
            function o(t, i) {
              let o = 0;
              switch (n.propertiesTypes[t]) {
                case "byte":
                  if ("boolean" != typeof i) return e.emit("error", new Error(`Invalid ${t}: ${i}`)), !1;
                  o += 2;
                  break;
                case "int8":
                  if ("number" != typeof i || i < 0 || i > 255) return e.emit("error", new Error(`Invalid ${t}: ${i}`)), !1;
                  o += 2;
                  break;
                case "binary":
                  if (i && null === i) return e.emit("error", new Error(`Invalid ${t}: ${i}`)), !1;
                  o += 1 + r.byteLength(i) + 2;
                  break;
                case "int16":
                  if ("number" != typeof i || i < 0 || i > 65535) return e.emit("error", new Error(`Invalid ${t}: ${i}`)), !1;
                  o += 3;
                  break;
                case "int32":
                  if ("number" != typeof i || i < 0 || i > 4294967295) return e.emit("error", new Error(`Invalid ${t}: ${i}`)), !1;
                  o += 5;
                  break;
                case "var":
                  if ("number" != typeof i || i < 0 || i > 268435455) return e.emit("error", new Error(`Invalid ${t}: ${i}`)), !1;
                  o += 1 + r.byteLength(f(i));
                  break;
                case "string":
                  if ("string" != typeof i) return e.emit("error", new Error(`Invalid ${t}: ${i}`)), !1;
                  o += 3 + r.byteLength(i.toString());
                  break;
                case "pair":
                  if ("object" != typeof i) return e.emit("error", new Error(`Invalid ${t}: ${i}`)), !1;
                  o += Object.getOwnPropertyNames(i).reduce((e, t) => {
                    const n = i[t];
                    return Array.isArray(n) ? e += n.reduce((e, n) => e += 3 + r.byteLength(t.toString()) + 2 + r.byteLength(n.toString()), 0) : e += 3 + r.byteLength(t.toString()) + 2 + r.byteLength(i[t].toString()), e;
                  }, 0);
                  break;
                default:
                  return e.emit("error", new Error(`Invalid property ${t}: ${i}`)), !1;
              }
              return o;
            }
            if (t) for (const e in t) {
              let r = 0,
                n = 0;
              const s = t[e];
              if (Array.isArray(s)) for (let t = 0; t < s.length; t++) {
                if (!(n = o(e, s[t]))) return !1;
                r += n;
              } else {
                if (!(n = o(e, s))) return !1;
                r = n;
              }
              if (!r) return !1;
              i += r;
            }
            return {
              length: r.byteLength(f(i)) + i,
              write() {
                A(e, t, i);
              }
            };
          }
          function T(e, t, r, n) {
            const i = ["reasonString", "userProperties"],
              o = r && r.properties && r.properties.maximumPacketSize ? r.properties.maximumPacketSize : 0;
            let s = C(e, t);
            if (o) for (; n + s.length > o;) {
              const r = i.shift();
              if (!r || !t[r]) return !1;
              delete t[r], s = C(e, t);
            }
            return s;
          }
          function x(e, t, i) {
            switch (n.propertiesTypes[t]) {
              case "byte":
                e.write(r.from([n.properties[t]])), e.write(r.from([+i]));
                break;
              case "int8":
                e.write(r.from([n.properties[t]])), e.write(r.from([i]));
                break;
              case "binary":
                e.write(r.from([n.properties[t]])), E(e, i);
                break;
              case "int16":
                e.write(r.from([n.properties[t]])), d(e, i);
                break;
              case "int32":
                e.write(r.from([n.properties[t]])), function (e, t) {
                  const r = p(t);
                  l("write4ByteNumber: %o", r), e.write(r);
                }(e, i);
                break;
              case "var":
                e.write(r.from([n.properties[t]])), v(e, i);
                break;
              case "string":
                e.write(r.from([n.properties[t]])), w(e, i);
                break;
              case "pair":
                Object.getOwnPropertyNames(i).forEach(o => {
                  const s = i[o];
                  Array.isArray(s) ? s.forEach(i => {
                    e.write(r.from([n.properties[t]])), _(e, o.toString(), i.toString());
                  }) : (e.write(r.from([n.properties[t]])), _(e, o.toString(), s.toString()));
                });
                break;
              default:
                return e.emit("error", new Error(`Invalid property ${t} value: ${i}`)), !1;
            }
          }
          function A(e, t, r) {
            v(e, r);
            for (const r in t) if (Object.prototype.hasOwnProperty.call(t, r) && null !== t[r]) {
              const n = t[r];
              if (Array.isArray(n)) for (let t = 0; t < n.length; t++) x(e, r, n[t]);else x(e, r, n);
            }
          }
          function I(e) {
            return e ? e instanceof r ? e.length : r.byteLength(e) : 0;
          }
          function P(e) {
            return "string" == typeof e || e instanceof r;
          }
          t.exports = y;
        }).call(this);
      }).call(this, e("buffer").Buffer);
    }, {
      "./constants": 38,
      "./numbers": 41,
      buffer: 17,
      debug: 18,
      "process-nextick-args": 49
    }],
    45: [function (e, t, r) {
      var n = 1e3,
        i = 60 * n,
        o = 60 * i,
        s = 24 * o,
        a = 7 * s,
        l = 365.25 * s;
      function u(e, t, r, n) {
        var i = t >= 1.5 * r;
        return Math.round(e / r) + " " + n + (i ? "s" : "");
      }
      t.exports = function (e, t) {
        t = t || {};
        var r = typeof e;
        if ("string" === r && e.length > 0) return function (e) {
          if ((e = String(e)).length > 100) return;
          var t = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);
          if (!t) return;
          var r = parseFloat(t[1]);
          switch ((t[2] || "ms").toLowerCase()) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return r * l;
            case "weeks":
            case "week":
            case "w":
              return r * a;
            case "days":
            case "day":
            case "d":
              return r * s;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return r * o;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return r * i;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return r * n;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return r;
            default:
              return;
          }
        }(e);
        if ("number" === r && isFinite(e)) return t.long ? function (e) {
          var t = Math.abs(e);
          if (t >= s) return u(e, t, s, "day");
          if (t >= o) return u(e, t, o, "hour");
          if (t >= i) return u(e, t, i, "minute");
          if (t >= n) return u(e, t, n, "second");
          return e + " ms";
        }(e) : function (e) {
          var t = Math.abs(e);
          if (t >= s) return Math.round(e / s) + "d";
          if (t >= o) return Math.round(e / o) + "h";
          if (t >= i) return Math.round(e / i) + "m";
          if (t >= n) return Math.round(e / n) + "s";
          return e + "ms";
        }(e);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e));
      };
    }, {}],
    46: [function (e, t, r) {
      const n = e("./lib/number-allocator.js");
      t.exports.NumberAllocator = n;
    }, {
      "./lib/number-allocator.js": 47
    }],
    47: [function (e, t, r) {
      "use strict";

      const n = e("js-sdsl").Set,
        i = e("debug")("number-allocator:trace"),
        o = e("debug")("number-allocator:error");
      function s(e, t) {
        this.low = e, this.high = t;
      }
      function a(e, t) {
        if (!(this instanceof a)) return new a(e, t);
        this.min = e, this.max = t, this.ss = new n([], (e, t) => e.compare(t)), i("Create"), this.clear();
      }
      s.prototype.equals = function (e) {
        return this.low === e.low && this.high === e.high;
      }, s.prototype.compare = function (e) {
        return this.low < e.low && this.high < e.low ? -1 : e.low < this.low && e.high < this.low ? 1 : 0;
      }, a.prototype.firstVacant = function () {
        return 0 === this.ss.size() ? null : this.ss.front().low;
      }, a.prototype.alloc = function () {
        if (0 === this.ss.size()) return i("alloc():empty"), null;
        const e = this.ss.front(),
          t = e.low;
        return t + 1 <= e.high ? ++e.low : this.ss.eraseElementByPos(0), i("alloc():" + t), t;
      }, a.prototype.use = function (e) {
        const t = new s(e, e),
          r = this.ss.lowerBound(t);
        if (r) {
          if (r.equals(t)) return this.ss.eraseElementByValue(r), i("use():" + e), !0;
          if (r.low > e) return !1;
          if (r.low === e) return ++r.low, i("use():" + e), !0;
          if (r.high === e) return --r.high, i("use():" + e), !0;
          const n = r.low;
          return r.low = e + 1, this.ss.insert(new s(n, e - 1)), i("use():" + e), !0;
        }
        return i("use():failed"), !1;
      }, a.prototype.free = function (e) {
        if (e < this.min || e > this.max) return void o("free():" + e + " is out of range");
        const t = new s(e, e),
          r = this.ss.lowerBound(t);
        if (r) {
          if (r.low <= e && e <= r.high) return void o("free():" + e + " has already been vacant");
          if (r === this.ss.front()) e + 1 === r.low ? --r.low : this.ss.insert(t);else {
            const n = this.ss.reverseLowerBound(t);
            n.high + 1 === e ? e + 1 === r.low ? (this.ss.eraseElementByValue(n), r.low = n.low) : n.high = e : e + 1 === r.low ? r.low = e : this.ss.insert(t);
          }
        } else {
          if (r === this.ss.front()) return void this.ss.insert(t);
          const n = this.ss.reverseLowerBound(t);
          n.high + 1 === e ? n.high = e : this.ss.insert(t);
        }
        i("free():" + e);
      }, a.prototype.clear = function () {
        i("clear()"), this.ss.clear(), this.ss.insert(new s(this.min, this.max));
      }, a.prototype.intervalCount = function () {
        return this.ss.size();
      }, a.prototype.dump = function () {
        console.log("length:" + this.ss.size());
        for (const e of this.ss) console.log(e);
      }, t.exports = a;
    }, {
      debug: 18,
      "js-sdsl": 36
    }],
    48: [function (e, t, r) {
      var n = e("wrappy");
      function i(e) {
        var t = function () {
          return t.called ? t.value : (t.called = !0, t.value = e.apply(this, arguments));
        };
        return t.called = !1, t;
      }
      function o(e) {
        var t = function () {
            if (t.called) throw new Error(t.onceError);
            return t.called = !0, t.value = e.apply(this, arguments);
          },
          r = e.name || "Function wrapped with `once`";
        return t.onceError = r + " shouldn't be called more than once", t.called = !1, t;
      }
      t.exports = n(i), t.exports.strict = n(o), i.proto = i(function () {
        Object.defineProperty(Function.prototype, "once", {
          value: function () {
            return i(this);
          },
          configurable: !0
        }), Object.defineProperty(Function.prototype, "onceStrict", {
          value: function () {
            return o(this);
          },
          configurable: !0
        });
      });
    }, {
      wrappy: 79
    }],
    49: [function (e, t, r) {
      (function (e) {
        (function () {
          "use strict";

          void 0 === e || !e.version || 0 === e.version.indexOf("v0.") || 0 === e.version.indexOf("v1.") && 0 !== e.version.indexOf("v1.8.") ? t.exports = {
            nextTick: function (t, r, n, i) {
              if ("function" != typeof t) throw new TypeError('"callback" argument must be a function');
              var o,
                s,
                a = arguments.length;
              switch (a) {
                case 0:
                case 1:
                  return e.nextTick(t);
                case 2:
                  return e.nextTick(function () {
                    t.call(null, r);
                  });
                case 3:
                  return e.nextTick(function () {
                    t.call(null, r, n);
                  });
                case 4:
                  return e.nextTick(function () {
                    t.call(null, r, n, i);
                  });
                default:
                  for (o = new Array(a - 1), s = 0; s < o.length;) o[s++] = arguments[s];
                  return e.nextTick(function () {
                    t.apply(null, o);
                  });
              }
            }
          } : t.exports = e;
        }).call(this);
      }).call(this, e("_process"));
    }, {
      _process: 50
    }],
    50: [function (e, t, r) {
      var n,
        i,
        o = t.exports = {};
      function s() {
        throw new Error("setTimeout has not been defined");
      }
      function a() {
        throw new Error("clearTimeout has not been defined");
      }
      function l(e) {
        if (n === setTimeout) return setTimeout(e, 0);
        if ((n === s || !n) && setTimeout) return n = setTimeout, setTimeout(e, 0);
        try {
          return n(e, 0);
        } catch (t) {
          try {
            return n.call(null, e, 0);
          } catch (t) {
            return n.call(this, e, 0);
          }
        }
      }
      !function () {
        try {
          n = "function" == typeof setTimeout ? setTimeout : s;
        } catch (e) {
          n = s;
        }
        try {
          i = "function" == typeof clearTimeout ? clearTimeout : a;
        } catch (e) {
          i = a;
        }
      }();
      var u,
        c = [],
        h = !1,
        f = -1;
      function p() {
        h && u && (h = !1, u.length ? c = u.concat(c) : f = -1, c.length && d());
      }
      function d() {
        if (!h) {
          var e = l(p);
          h = !0;
          for (var t = c.length; t;) {
            for (u = c, c = []; ++f < t;) u && u[f].run();
            f = -1, t = c.length;
          }
          u = null, h = !1, function (e) {
            if (i === clearTimeout) return clearTimeout(e);
            if ((i === a || !i) && clearTimeout) return i = clearTimeout, clearTimeout(e);
            try {
              i(e);
            } catch (t) {
              try {
                return i.call(null, e);
              } catch (t) {
                return i.call(this, e);
              }
            }
          }(e);
        }
      }
      function g(e, t) {
        this.fun = e, this.array = t;
      }
      function y() {}
      o.nextTick = function (e) {
        var t = new Array(arguments.length - 1);
        if (arguments.length > 1) for (var r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
        c.push(new g(e, t)), 1 !== c.length || h || l(d);
      }, g.prototype.run = function () {
        this.fun.apply(null, this.array);
      }, o.title = "browser", o.browser = !0, o.env = {}, o.argv = [], o.version = "", o.versions = {}, o.on = y, o.addListener = y, o.once = y, o.off = y, o.removeListener = y, o.removeAllListeners = y, o.emit = y, o.prependListener = y, o.prependOnceListener = y, o.listeners = function (e) {
        return [];
      }, o.binding = function (e) {
        throw new Error("process.binding is not supported");
      }, o.cwd = function () {
        return "/";
      }, o.chdir = function (e) {
        throw new Error("process.chdir is not supported");
      }, o.umask = function () {
        return 0;
      };
    }, {}],
    51: [function (e, t, r) {
      (function (e) {
        (function () {
          !function (n) {
            var i = "object" == typeof r && r && !r.nodeType && r,
              o = "object" == typeof t && t && !t.nodeType && t,
              s = "object" == typeof e && e;
            s.global !== s && s.window !== s && s.self !== s || (n = s);
            var a,
              l,
              u = 2147483647,
              c = 36,
              h = 1,
              f = 26,
              p = 38,
              d = 700,
              g = 72,
              y = 128,
              b = "-",
              m = /^xn--/,
              v = /[^\x20-\x7E]/,
              w = /[\x2E\u3002\uFF0E\uFF61]/g,
              _ = {
                overflow: "Overflow: input needs wider integers to process",
                "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                "invalid-input": "Invalid input"
              },
              k = c - h,
              S = Math.floor,
              E = String.fromCharCode;
            function C(e) {
              throw new RangeError(_[e]);
            }
            function T(e, t) {
              for (var r = e.length, n = []; r--;) n[r] = t(e[r]);
              return n;
            }
            function x(e, t) {
              var r = e.split("@"),
                n = "";
              return r.length > 1 && (n = r[0] + "@", e = r[1]), n + T((e = e.replace(w, ".")).split("."), t).join(".");
            }
            function A(e) {
              for (var t, r, n = [], i = 0, o = e.length; i < o;) (t = e.charCodeAt(i++)) >= 55296 && t <= 56319 && i < o ? 56320 == (64512 & (r = e.charCodeAt(i++))) ? n.push(((1023 & t) << 10) + (1023 & r) + 65536) : (n.push(t), i--) : n.push(t);
              return n;
            }
            function I(e) {
              return T(e, function (e) {
                var t = "";
                return e > 65535 && (t += E((e -= 65536) >>> 10 & 1023 | 55296), e = 56320 | 1023 & e), t += E(e);
              }).join("");
            }
            function P(e, t) {
              return e + 22 + 75 * (e < 26) - ((0 != t) << 5);
            }
            function O(e, t, r) {
              var n = 0;
              for (e = r ? S(e / d) : e >> 1, e += S(e / t); e > k * f >> 1; n += c) e = S(e / k);
              return S(n + (k + 1) * e / (e + p));
            }
            function B(e) {
              var t,
                r,
                n,
                i,
                o,
                s,
                a,
                l,
                p,
                d,
                m,
                v = [],
                w = e.length,
                _ = 0,
                k = y,
                E = g;
              for ((r = e.lastIndexOf(b)) < 0 && (r = 0), n = 0; n < r; ++n) e.charCodeAt(n) >= 128 && C("not-basic"), v.push(e.charCodeAt(n));
              for (i = r > 0 ? r + 1 : 0; i < w;) {
                for (o = _, s = 1, a = c; i >= w && C("invalid-input"), ((l = (m = e.charCodeAt(i++)) - 48 < 10 ? m - 22 : m - 65 < 26 ? m - 65 : m - 97 < 26 ? m - 97 : c) >= c || l > S((u - _) / s)) && C("overflow"), _ += l * s, !(l < (p = a <= E ? h : a >= E + f ? f : a - E)); a += c) s > S(u / (d = c - p)) && C("overflow"), s *= d;
                E = O(_ - o, t = v.length + 1, 0 == o), S(_ / t) > u - k && C("overflow"), k += S(_ / t), _ %= t, v.splice(_++, 0, k);
              }
              return I(v);
            }
            function R(e) {
              var t,
                r,
                n,
                i,
                o,
                s,
                a,
                l,
                p,
                d,
                m,
                v,
                w,
                _,
                k,
                T = [];
              for (v = (e = A(e)).length, t = y, r = 0, o = g, s = 0; s < v; ++s) (m = e[s]) < 128 && T.push(E(m));
              for (n = i = T.length, i && T.push(b); n < v;) {
                for (a = u, s = 0; s < v; ++s) (m = e[s]) >= t && m < a && (a = m);
                for (a - t > S((u - r) / (w = n + 1)) && C("overflow"), r += (a - t) * w, t = a, s = 0; s < v; ++s) if ((m = e[s]) < t && ++r > u && C("overflow"), m == t) {
                  for (l = r, p = c; !(l < (d = p <= o ? h : p >= o + f ? f : p - o)); p += c) k = l - d, _ = c - d, T.push(E(P(d + k % _, 0))), l = S(k / _);
                  T.push(E(P(l, 0))), o = O(r, w, n == i), r = 0, ++n;
                }
                ++r, ++t;
              }
              return T.join("");
            }
            if (a = {
              version: "1.4.1",
              ucs2: {
                decode: A,
                encode: I
              },
              decode: B,
              encode: R,
              toASCII: function (e) {
                return x(e, function (e) {
                  return v.test(e) ? "xn--" + R(e) : e;
                });
              },
              toUnicode: function (e) {
                return x(e, function (e) {
                  return m.test(e) ? B(e.slice(4).toLowerCase()) : e;
                });
              }
            }, i && o) {
              if (t.exports == i) o.exports = a;else for (l in a) a.hasOwnProperty(l) && (i[l] = a[l]);
            } else n.punycode = a;
          }(this);
        }).call(this);
      }).call(this, "undefined" != typeof __webpack_require__.g ? __webpack_require__.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {}],
    52: [function (e, t, r) {
      "use strict";

      function n(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t);
      }
      t.exports = function (e, t, r, o) {
        t = t || "&", r = r || "=";
        var s = {};
        if ("string" != typeof e || 0 === e.length) return s;
        var a = /\+/g;
        e = e.split(t);
        var l = 1e3;
        o && "number" == typeof o.maxKeys && (l = o.maxKeys);
        var u = e.length;
        l > 0 && u > l && (u = l);
        for (var c = 0; c < u; ++c) {
          var h,
            f,
            p,
            d,
            g = e[c].replace(a, "%20"),
            y = g.indexOf(r);
          y >= 0 ? (h = g.substr(0, y), f = g.substr(y + 1)) : (h = g, f = ""), p = decodeURIComponent(h), d = decodeURIComponent(f), n(s, p) ? i(s[p]) ? s[p].push(d) : s[p] = [s[p], d] : s[p] = d;
        }
        return s;
      };
      var i = Array.isArray || function (e) {
        return "[object Array]" === Object.prototype.toString.call(e);
      };
    }, {}],
    53: [function (e, t, r) {
      "use strict";

      var n = function (e) {
        switch (typeof e) {
          case "string":
            return e;
          case "boolean":
            return e ? "true" : "false";
          case "number":
            return isFinite(e) ? e : "";
          default:
            return "";
        }
      };
      t.exports = function (e, t, r, a) {
        return t = t || "&", r = r || "=", null === e && (e = void 0), "object" == typeof e ? o(s(e), function (s) {
          var a = encodeURIComponent(n(s)) + r;
          return i(e[s]) ? o(e[s], function (e) {
            return a + encodeURIComponent(n(e));
          }).join(t) : a + encodeURIComponent(n(e[s]));
        }).join(t) : a ? encodeURIComponent(n(a)) + r + encodeURIComponent(n(e)) : "";
      };
      var i = Array.isArray || function (e) {
        return "[object Array]" === Object.prototype.toString.call(e);
      };
      function o(e, t) {
        if (e.map) return e.map(t);
        for (var r = [], n = 0; n < e.length; n++) r.push(t(e[n], n));
        return r;
      }
      var s = Object.keys || function (e) {
        var t = [];
        for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.push(r);
        return t;
      };
    }, {}],
    54: [function (e, t, r) {
      "use strict";

      r.decode = r.parse = e("./decode"), r.encode = r.stringify = e("./encode");
    }, {
      "./decode": 52,
      "./encode": 53
    }],
    55: [function (e, t, r) {
      "use strict";

      var n = {};
      function i(e, t, r) {
        r || (r = Error);
        var i = function (e) {
          var r, n;
          function i(r, n, i) {
            return e.call(this, function (e, r, n) {
              return "string" == typeof t ? t : t(e, r, n);
            }(r, n, i)) || this;
          }
          return n = e, (r = i).prototype = Object.create(n.prototype), r.prototype.constructor = r, r.__proto__ = n, i;
        }(r);
        i.prototype.name = r.name, i.prototype.code = e, n[e] = i;
      }
      function o(e, t) {
        if (Array.isArray(e)) {
          var r = e.length;
          return e = e.map(function (e) {
            return String(e);
          }), r > 2 ? "one of ".concat(t, " ").concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1] : 2 === r ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
        }
        return "of ".concat(t, " ").concat(String(e));
      }
      i("ERR_INVALID_OPT_VALUE", function (e, t) {
        return 'The value "' + t + '" is invalid for option "' + e + '"';
      }, TypeError), i("ERR_INVALID_ARG_TYPE", function (e, t, r) {
        var n, i, s, a;
        if ("string" == typeof t && (i = "not ", t.substr(!s || s < 0 ? 0 : +s, i.length) === i) ? (n = "must not be", t = t.replace(/^not /, "")) : n = "must be", function (e, t, r) {
          return (void 0 === r || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
        }(e, " argument")) a = "The ".concat(e, " ").concat(n, " ").concat(o(t, "type"));else {
          var l = function (e, t, r) {
            return "number" != typeof r && (r = 0), !(r + t.length > e.length) && -1 !== e.indexOf(t, r);
          }(e, ".") ? "property" : "argument";
          a = 'The "'.concat(e, '" ').concat(l, " ").concat(n, " ").concat(o(t, "type"));
        }
        return a += ". Received type ".concat(typeof r);
      }, TypeError), i("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), i("ERR_METHOD_NOT_IMPLEMENTED", function (e) {
        return "The " + e + " method is not implemented";
      }), i("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), i("ERR_STREAM_DESTROYED", function (e) {
        return "Cannot call " + e + " after a stream was destroyed";
      }), i("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), i("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), i("ERR_STREAM_WRITE_AFTER_END", "write after end"), i("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), i("ERR_UNKNOWN_ENCODING", function (e) {
        return "Unknown encoding: " + e;
      }, TypeError), i("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), t.exports.codes = n;
    }, {}],
    56: [function (e, t, r) {
      (function (r) {
        (function () {
          "use strict";

          var n = Object.keys || function (e) {
            var t = [];
            for (var r in e) t.push(r);
            return t;
          };
          t.exports = u;
          var i = e("./_stream_readable"),
            o = e("./_stream_writable");
          e("inherits")(u, i);
          for (var s = n(o.prototype), a = 0; a < s.length; a++) {
            var l = s[a];
            u.prototype[l] || (u.prototype[l] = o.prototype[l]);
          }
          function u(e) {
            if (!(this instanceof u)) return new u(e);
            i.call(this, e), o.call(this, e), this.allowHalfOpen = !0, e && (!1 === e.readable && (this.readable = !1), !1 === e.writable && (this.writable = !1), !1 === e.allowHalfOpen && (this.allowHalfOpen = !1, this.once("end", c)));
          }
          function c() {
            this._writableState.ended || r.nextTick(h, this);
          }
          function h(e) {
            e.end();
          }
          Object.defineProperty(u.prototype, "writableHighWaterMark", {
            enumerable: !1,
            get: function () {
              return this._writableState.highWaterMark;
            }
          }), Object.defineProperty(u.prototype, "writableBuffer", {
            enumerable: !1,
            get: function () {
              return this._writableState && this._writableState.getBuffer();
            }
          }), Object.defineProperty(u.prototype, "writableLength", {
            enumerable: !1,
            get: function () {
              return this._writableState.length;
            }
          }), Object.defineProperty(u.prototype, "destroyed", {
            enumerable: !1,
            get: function () {
              return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed;
            },
            set: function (e) {
              void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e, this._writableState.destroyed = e);
            }
          });
        }).call(this);
      }).call(this, e("_process"));
    }, {
      "./_stream_readable": 58,
      "./_stream_writable": 60,
      _process: 50,
      inherits: 24
    }],
    57: [function (e, t, r) {
      "use strict";

      t.exports = i;
      var n = e("./_stream_transform");
      function i(e) {
        if (!(this instanceof i)) return new i(e);
        n.call(this, e);
      }
      e("inherits")(i, n), i.prototype._transform = function (e, t, r) {
        r(null, e);
      };
    }, {
      "./_stream_transform": 59,
      inherits: 24
    }],
    58: [function (e, t, r) {
      (function (r, n) {
        (function () {
          "use strict";

          var i;
          t.exports = C, C.ReadableState = E;
          e("events").EventEmitter;
          var o = function (e, t) {
              return e.listeners(t).length;
            },
            s = e("./internal/streams/stream"),
            a = e("buffer").Buffer,
            l = n.Uint8Array || function () {};
          var u,
            c = e("util");
          u = c && c.debuglog ? c.debuglog("stream") : function () {};
          var h,
            f,
            p,
            d = e("./internal/streams/buffer_list"),
            g = e("./internal/streams/destroy"),
            y = e("./internal/streams/state").getHighWaterMark,
            b = e("../errors").codes,
            m = b.ERR_INVALID_ARG_TYPE,
            v = b.ERR_STREAM_PUSH_AFTER_EOF,
            w = b.ERR_METHOD_NOT_IMPLEMENTED,
            _ = b.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
          e("inherits")(C, s);
          var k = g.errorOrDestroy,
            S = ["error", "close", "destroy", "pause", "resume"];
          function E(t, r, n) {
            i = i || e("./_stream_duplex"), t = t || {}, "boolean" != typeof n && (n = r instanceof i), this.objectMode = !!t.objectMode, n && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = y(this, t, "readableHighWaterMark", n), this.buffer = new d(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = !1 !== t.emitClose, this.autoDestroy = !!t.autoDestroy, this.destroyed = !1, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, t.encoding && (h || (h = e("string_decoder/").StringDecoder), this.decoder = new h(t.encoding), this.encoding = t.encoding);
          }
          function C(t) {
            if (i = i || e("./_stream_duplex"), !(this instanceof C)) return new C(t);
            var r = this instanceof i;
            this._readableState = new E(t, this, r), this.readable = !0, t && ("function" == typeof t.read && (this._read = t.read), "function" == typeof t.destroy && (this._destroy = t.destroy)), s.call(this);
          }
          function T(e, t, r, n, i) {
            u("readableAddChunk", t);
            var o,
              s = e._readableState;
            if (null === t) s.reading = !1, function (e, t) {
              if (u("onEofChunk"), t.ended) return;
              if (t.decoder) {
                var r = t.decoder.end();
                r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
              }
              t.ended = !0, t.sync ? P(e) : (t.needReadable = !1, t.emittedReadable || (t.emittedReadable = !0, O(e)));
            }(e, s);else if (i || (o = function (e, t) {
              var r;
              n = t, a.isBuffer(n) || n instanceof l || "string" == typeof t || void 0 === t || e.objectMode || (r = new m("chunk", ["string", "Buffer", "Uint8Array"], t));
              var n;
              return r;
            }(s, t)), o) k(e, o);else if (s.objectMode || t && t.length > 0) {
              if ("string" == typeof t || s.objectMode || Object.getPrototypeOf(t) === a.prototype || (t = function (e) {
                return a.from(e);
              }(t)), n) s.endEmitted ? k(e, new _()) : x(e, s, t, !0);else if (s.ended) k(e, new v());else {
                if (s.destroyed) return !1;
                s.reading = !1, s.decoder && !r ? (t = s.decoder.write(t), s.objectMode || 0 !== t.length ? x(e, s, t, !1) : B(e, s)) : x(e, s, t, !1);
              }
            } else n || (s.reading = !1, B(e, s));
            return !s.ended && (s.length < s.highWaterMark || 0 === s.length);
          }
          function x(e, t, r, n) {
            t.flowing && 0 === t.length && !t.sync ? (t.awaitDrain = 0, e.emit("data", r)) : (t.length += t.objectMode ? 1 : r.length, n ? t.buffer.unshift(r) : t.buffer.push(r), t.needReadable && P(e)), B(e, t);
          }
          Object.defineProperty(C.prototype, "destroyed", {
            enumerable: !1,
            get: function () {
              return void 0 !== this._readableState && this._readableState.destroyed;
            },
            set: function (e) {
              this._readableState && (this._readableState.destroyed = e);
            }
          }), C.prototype.destroy = g.destroy, C.prototype._undestroy = g.undestroy, C.prototype._destroy = function (e, t) {
            t(e);
          }, C.prototype.push = function (e, t) {
            var r,
              n = this._readableState;
            return n.objectMode ? r = !0 : "string" == typeof e && ((t = t || n.defaultEncoding) !== n.encoding && (e = a.from(e, t), t = ""), r = !0), T(this, e, t, !1, r);
          }, C.prototype.unshift = function (e) {
            return T(this, e, null, !0, !1);
          }, C.prototype.isPaused = function () {
            return !1 === this._readableState.flowing;
          }, C.prototype.setEncoding = function (t) {
            h || (h = e("string_decoder/").StringDecoder);
            var r = new h(t);
            this._readableState.decoder = r, this._readableState.encoding = this._readableState.decoder.encoding;
            for (var n = this._readableState.buffer.head, i = ""; null !== n;) i += r.write(n.data), n = n.next;
            return this._readableState.buffer.clear(), "" !== i && this._readableState.buffer.push(i), this._readableState.length = i.length, this;
          };
          var A = 1073741824;
          function I(e, t) {
            return e <= 0 || 0 === t.length && t.ended ? 0 : t.objectMode ? 1 : e != e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = function (e) {
              return e >= A ? e = A : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
            }(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0));
          }
          function P(e) {
            var t = e._readableState;
            u("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = !1, t.emittedReadable || (u("emitReadable", t.flowing), t.emittedReadable = !0, r.nextTick(O, e));
          }
          function O(e) {
            var t = e._readableState;
            u("emitReadable_", t.destroyed, t.length, t.ended), t.destroyed || !t.length && !t.ended || (e.emit("readable"), t.emittedReadable = !1), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, j(e);
          }
          function B(e, t) {
            t.readingMore || (t.readingMore = !0, r.nextTick(R, e, t));
          }
          function R(e, t) {
            for (; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && 0 === t.length);) {
              var r = t.length;
              if (u("maybeReadMore read 0"), e.read(0), r === t.length) break;
            }
            t.readingMore = !1;
          }
          function M(e) {
            var t = e._readableState;
            t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = !0 : e.listenerCount("data") > 0 && e.resume();
          }
          function N(e) {
            u("readable nexttick read 0"), e.read(0);
          }
          function L(e, t) {
            u("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit("resume"), j(e), t.flowing && !t.reading && e.read(0);
          }
          function j(e) {
            var t = e._readableState;
            for (u("flow", t.flowing); t.flowing && null !== e.read(););
          }
          function U(e, t) {
            return 0 === t.length ? null : (t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (r = t.decoder ? t.buffer.join("") : 1 === t.buffer.length ? t.buffer.first() : t.buffer.concat(t.length), t.buffer.clear()) : r = t.buffer.consume(e, t.decoder), r);
            var r;
          }
          function q(e) {
            var t = e._readableState;
            u("endReadable", t.endEmitted), t.endEmitted || (t.ended = !0, r.nextTick(D, t, e));
          }
          function D(e, t) {
            if (u("endReadableNT", e.endEmitted, e.length), !e.endEmitted && 0 === e.length && (e.endEmitted = !0, t.readable = !1, t.emit("end"), e.autoDestroy)) {
              var r = t._writableState;
              (!r || r.autoDestroy && r.finished) && t.destroy();
            }
          }
          function z(e, t) {
            for (var r = 0, n = e.length; r < n; r++) if (e[r] === t) return r;
            return -1;
          }
          C.prototype.read = function (e) {
            u("read", e), e = parseInt(e, 10);
            var t = this._readableState,
              r = e;
            if (0 !== e && (t.emittedReadable = !1), 0 === e && t.needReadable && ((0 !== t.highWaterMark ? t.length >= t.highWaterMark : t.length > 0) || t.ended)) return u("read: emitReadable", t.length, t.ended), 0 === t.length && t.ended ? q(this) : P(this), null;
            if (0 === (e = I(e, t)) && t.ended) return 0 === t.length && q(this), null;
            var n,
              i = t.needReadable;
            return u("need readable", i), (0 === t.length || t.length - e < t.highWaterMark) && u("length less than watermark", i = !0), t.ended || t.reading ? u("reading or ended", i = !1) : i && (u("do read"), t.reading = !0, t.sync = !0, 0 === t.length && (t.needReadable = !0), this._read(t.highWaterMark), t.sync = !1, t.reading || (e = I(r, t))), null === (n = e > 0 ? U(e, t) : null) ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), 0 === t.length && (t.ended || (t.needReadable = !0), r !== e && t.ended && q(this)), null !== n && this.emit("data", n), n;
          }, C.prototype._read = function (e) {
            k(this, new w("_read()"));
          }, C.prototype.pipe = function (e, t) {
            var n = this,
              i = this._readableState;
            switch (i.pipesCount) {
              case 0:
                i.pipes = e;
                break;
              case 1:
                i.pipes = [i.pipes, e];
                break;
              default:
                i.pipes.push(e);
            }
            i.pipesCount += 1, u("pipe count=%d opts=%j", i.pipesCount, t);
            var s = (!t || !1 !== t.end) && e !== r.stdout && e !== r.stderr ? l : y;
            function a(t, r) {
              u("onunpipe"), t === n && r && !1 === r.hasUnpiped && (r.hasUnpiped = !0, u("cleanup"), e.removeListener("close", d), e.removeListener("finish", g), e.removeListener("drain", c), e.removeListener("error", p), e.removeListener("unpipe", a), n.removeListener("end", l), n.removeListener("end", y), n.removeListener("data", f), h = !0, !i.awaitDrain || e._writableState && !e._writableState.needDrain || c());
            }
            function l() {
              u("onend"), e.end();
            }
            i.endEmitted ? r.nextTick(s) : n.once("end", s), e.on("unpipe", a);
            var c = function (e) {
              return function () {
                var t = e._readableState;
                u("pipeOnDrain", t.awaitDrain), t.awaitDrain && t.awaitDrain--, 0 === t.awaitDrain && o(e, "data") && (t.flowing = !0, j(e));
              };
            }(n);
            e.on("drain", c);
            var h = !1;
            function f(t) {
              u("ondata");
              var r = e.write(t);
              u("dest.write", r), !1 === r && ((1 === i.pipesCount && i.pipes === e || i.pipesCount > 1 && -1 !== z(i.pipes, e)) && !h && (u("false write response, pause", i.awaitDrain), i.awaitDrain++), n.pause());
            }
            function p(t) {
              u("onerror", t), y(), e.removeListener("error", p), 0 === o(e, "error") && k(e, t);
            }
            function d() {
              e.removeListener("finish", g), y();
            }
            function g() {
              u("onfinish"), e.removeListener("close", d), y();
            }
            function y() {
              u("unpipe"), n.unpipe(e);
            }
            return n.on("data", f), function (e, t, r) {
              if ("function" == typeof e.prependListener) return e.prependListener(t, r);
              e._events && e._events[t] ? Array.isArray(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]] : e.on(t, r);
            }(e, "error", p), e.once("close", d), e.once("finish", g), e.emit("pipe", n), i.flowing || (u("pipe resume"), n.resume()), e;
          }, C.prototype.unpipe = function (e) {
            var t = this._readableState,
              r = {
                hasUnpiped: !1
              };
            if (0 === t.pipesCount) return this;
            if (1 === t.pipesCount) return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, r), this);
            if (!e) {
              var n = t.pipes,
                i = t.pipesCount;
              t.pipes = null, t.pipesCount = 0, t.flowing = !1;
              for (var o = 0; o < i; o++) n[o].emit("unpipe", this, {
                hasUnpiped: !1
              });
              return this;
            }
            var s = z(t.pipes, e);
            return -1 === s ? this : (t.pipes.splice(s, 1), t.pipesCount -= 1, 1 === t.pipesCount && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r), this);
          }, C.prototype.on = function (e, t) {
            var n = s.prototype.on.call(this, e, t),
              i = this._readableState;
            return "data" === e ? (i.readableListening = this.listenerCount("readable") > 0, !1 !== i.flowing && this.resume()) : "readable" === e && (i.endEmitted || i.readableListening || (i.readableListening = i.needReadable = !0, i.flowing = !1, i.emittedReadable = !1, u("on readable", i.length, i.reading), i.length ? P(this) : i.reading || r.nextTick(N, this))), n;
          }, C.prototype.addListener = C.prototype.on, C.prototype.removeListener = function (e, t) {
            var n = s.prototype.removeListener.call(this, e, t);
            return "readable" === e && r.nextTick(M, this), n;
          }, C.prototype.removeAllListeners = function (e) {
            var t = s.prototype.removeAllListeners.apply(this, arguments);
            return "readable" !== e && void 0 !== e || r.nextTick(M, this), t;
          }, C.prototype.resume = function () {
            var e = this._readableState;
            return e.flowing || (u("resume"), e.flowing = !e.readableListening, function (e, t) {
              t.resumeScheduled || (t.resumeScheduled = !0, r.nextTick(L, e, t));
            }(this, e)), e.paused = !1, this;
          }, C.prototype.pause = function () {
            return u("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (u("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
          }, C.prototype.wrap = function (e) {
            var t = this,
              r = this._readableState,
              n = !1;
            for (var i in e.on("end", function () {
              if (u("wrapped end"), r.decoder && !r.ended) {
                var e = r.decoder.end();
                e && e.length && t.push(e);
              }
              t.push(null);
            }), e.on("data", function (i) {
              (u("wrapped data"), r.decoder && (i = r.decoder.write(i)), !r.objectMode || null !== i && void 0 !== i) && (r.objectMode || i && i.length) && (t.push(i) || (n = !0, e.pause()));
            }), e) void 0 === this[i] && "function" == typeof e[i] && (this[i] = function (t) {
              return function () {
                return e[t].apply(e, arguments);
              };
            }(i));
            for (var o = 0; o < S.length; o++) e.on(S[o], this.emit.bind(this, S[o]));
            return this._read = function (t) {
              u("wrapped _read", t), n && (n = !1, e.resume());
            }, this;
          }, "function" == typeof Symbol && (C.prototype[Symbol.asyncIterator] = function () {
            return void 0 === f && (f = e("./internal/streams/async_iterator")), f(this);
          }), Object.defineProperty(C.prototype, "readableHighWaterMark", {
            enumerable: !1,
            get: function () {
              return this._readableState.highWaterMark;
            }
          }), Object.defineProperty(C.prototype, "readableBuffer", {
            enumerable: !1,
            get: function () {
              return this._readableState && this._readableState.buffer;
            }
          }), Object.defineProperty(C.prototype, "readableFlowing", {
            enumerable: !1,
            get: function () {
              return this._readableState.flowing;
            },
            set: function (e) {
              this._readableState && (this._readableState.flowing = e);
            }
          }), C._fromList = U, Object.defineProperty(C.prototype, "readableLength", {
            enumerable: !1,
            get: function () {
              return this._readableState.length;
            }
          }), "function" == typeof Symbol && (C.from = function (t, r) {
            return void 0 === p && (p = e("./internal/streams/from")), p(C, t, r);
          });
        }).call(this);
      }).call(this, e("_process"), "undefined" != typeof __webpack_require__.g ? __webpack_require__.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {
      "../errors": 55,
      "./_stream_duplex": 56,
      "./internal/streams/async_iterator": 61,
      "./internal/streams/buffer_list": 62,
      "./internal/streams/destroy": 63,
      "./internal/streams/from": 65,
      "./internal/streams/state": 67,
      "./internal/streams/stream": 68,
      _process: 50,
      buffer: 17,
      events: 22,
      inherits: 24,
      "string_decoder/": 75,
      util: 16
    }],
    59: [function (e, t, r) {
      "use strict";

      t.exports = u;
      var n = e("../errors").codes,
        i = n.ERR_METHOD_NOT_IMPLEMENTED,
        o = n.ERR_MULTIPLE_CALLBACK,
        s = n.ERR_TRANSFORM_ALREADY_TRANSFORMING,
        a = n.ERR_TRANSFORM_WITH_LENGTH_0,
        l = e("./_stream_duplex");
      function u(e) {
        if (!(this instanceof u)) return new u(e);
        l.call(this, e), this._transformState = {
          afterTransform: function (e, t) {
            var r = this._transformState;
            r.transforming = !1;
            var n = r.writecb;
            if (null === n) return this.emit("error", new o());
            r.writechunk = null, r.writecb = null, null != t && this.push(t), n(e);
            var i = this._readableState;
            i.reading = !1, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
          }.bind(this),
          needTransform: !1,
          transforming: !1,
          writecb: null,
          writechunk: null,
          writeencoding: null
        }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && ("function" == typeof e.transform && (this._transform = e.transform), "function" == typeof e.flush && (this._flush = e.flush)), this.on("prefinish", c);
      }
      function c() {
        var e = this;
        "function" != typeof this._flush || this._readableState.destroyed ? h(this, null, null) : this._flush(function (t, r) {
          h(e, t, r);
        });
      }
      function h(e, t, r) {
        if (t) return e.emit("error", t);
        if (null != r && e.push(r), e._writableState.length) throw new a();
        if (e._transformState.transforming) throw new s();
        return e.push(null);
      }
      e("inherits")(u, l), u.prototype.push = function (e, t) {
        return this._transformState.needTransform = !1, l.prototype.push.call(this, e, t);
      }, u.prototype._transform = function (e, t, r) {
        r(new i("_transform()"));
      }, u.prototype._write = function (e, t, r) {
        var n = this._transformState;
        if (n.writecb = r, n.writechunk = e, n.writeencoding = t, !n.transforming) {
          var i = this._readableState;
          (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
        }
      }, u.prototype._read = function (e) {
        var t = this._transformState;
        null === t.writechunk || t.transforming ? t.needTransform = !0 : (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform));
      }, u.prototype._destroy = function (e, t) {
        l.prototype._destroy.call(this, e, function (e) {
          t(e);
        });
      };
    }, {
      "../errors": 55,
      "./_stream_duplex": 56,
      inherits: 24
    }],
    60: [function (e, t, r) {
      (function (r, n) {
        (function () {
          "use strict";

          function i(e) {
            var t = this;
            this.next = null, this.entry = null, this.finish = function () {
              !function (e, t, r) {
                var n = e.entry;
                e.entry = null;
                for (; n;) {
                  var i = n.callback;
                  t.pendingcb--, i(r), n = n.next;
                }
                t.corkedRequestsFree.next = e;
              }(t, e);
            };
          }
          var o;
          t.exports = C, C.WritableState = E;
          var s = {
              deprecate: e("util-deprecate")
            },
            a = e("./internal/streams/stream"),
            l = e("buffer").Buffer,
            u = n.Uint8Array || function () {};
          var c,
            h = e("./internal/streams/destroy"),
            f = e("./internal/streams/state").getHighWaterMark,
            p = e("../errors").codes,
            d = p.ERR_INVALID_ARG_TYPE,
            g = p.ERR_METHOD_NOT_IMPLEMENTED,
            y = p.ERR_MULTIPLE_CALLBACK,
            b = p.ERR_STREAM_CANNOT_PIPE,
            m = p.ERR_STREAM_DESTROYED,
            v = p.ERR_STREAM_NULL_VALUES,
            w = p.ERR_STREAM_WRITE_AFTER_END,
            _ = p.ERR_UNKNOWN_ENCODING,
            k = h.errorOrDestroy;
          function S() {}
          function E(t, n, s) {
            o = o || e("./_stream_duplex"), t = t || {}, "boolean" != typeof s && (s = n instanceof o), this.objectMode = !!t.objectMode, s && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = f(this, t, "writableHighWaterMark", s), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
            var a = !1 === t.decodeStrings;
            this.decodeStrings = !a, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function (e) {
              !function (e, t) {
                var n = e._writableState,
                  i = n.sync,
                  o = n.writecb;
                if ("function" != typeof o) throw new y();
                if (function (e) {
                  e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
                }(n), t) !function (e, t, n, i, o) {
                  --t.pendingcb, n ? (r.nextTick(o, i), r.nextTick(O, e, t), e._writableState.errorEmitted = !0, k(e, i)) : (o(i), e._writableState.errorEmitted = !0, k(e, i), O(e, t));
                }(e, n, i, t, o);else {
                  var s = I(n) || e.destroyed;
                  s || n.corked || n.bufferProcessing || !n.bufferedRequest || A(e, n), i ? r.nextTick(x, e, n, s, o) : x(e, n, s, o);
                }
              }(n, e);
            }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !1 !== t.emitClose, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new i(this);
          }
          function C(t) {
            var r = this instanceof (o = o || e("./_stream_duplex"));
            if (!r && !c.call(C, this)) return new C(t);
            this._writableState = new E(t, this, r), this.writable = !0, t && ("function" == typeof t.write && (this._write = t.write), "function" == typeof t.writev && (this._writev = t.writev), "function" == typeof t.destroy && (this._destroy = t.destroy), "function" == typeof t.final && (this._final = t.final)), a.call(this);
          }
          function T(e, t, r, n, i, o, s) {
            t.writelen = n, t.writecb = s, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new m("write")) : r ? e._writev(i, t.onwrite) : e._write(i, o, t.onwrite), t.sync = !1;
          }
          function x(e, t, r, n) {
            r || function (e, t) {
              0 === t.length && t.needDrain && (t.needDrain = !1, e.emit("drain"));
            }(e, t), t.pendingcb--, n(), O(e, t);
          }
          function A(e, t) {
            t.bufferProcessing = !0;
            var r = t.bufferedRequest;
            if (e._writev && r && r.next) {
              var n = t.bufferedRequestCount,
                o = new Array(n),
                s = t.corkedRequestsFree;
              s.entry = r;
              for (var a = 0, l = !0; r;) o[a] = r, r.isBuf || (l = !1), r = r.next, a += 1;
              o.allBuffers = l, T(e, t, !0, t.length, o, "", s.finish), t.pendingcb++, t.lastBufferedRequest = null, s.next ? (t.corkedRequestsFree = s.next, s.next = null) : t.corkedRequestsFree = new i(t), t.bufferedRequestCount = 0;
            } else {
              for (; r;) {
                var u = r.chunk,
                  c = r.encoding,
                  h = r.callback;
                if (T(e, t, !1, t.objectMode ? 1 : u.length, u, c, h), r = r.next, t.bufferedRequestCount--, t.writing) break;
              }
              null === r && (t.lastBufferedRequest = null);
            }
            t.bufferedRequest = r, t.bufferProcessing = !1;
          }
          function I(e) {
            return e.ending && 0 === e.length && null === e.bufferedRequest && !e.finished && !e.writing;
          }
          function P(e, t) {
            e._final(function (r) {
              t.pendingcb--, r && k(e, r), t.prefinished = !0, e.emit("prefinish"), O(e, t);
            });
          }
          function O(e, t) {
            var n = I(t);
            if (n && (function (e, t) {
              t.prefinished || t.finalCalled || ("function" != typeof e._final || t.destroyed ? (t.prefinished = !0, e.emit("prefinish")) : (t.pendingcb++, t.finalCalled = !0, r.nextTick(P, e, t)));
            }(e, t), 0 === t.pendingcb && (t.finished = !0, e.emit("finish"), t.autoDestroy))) {
              var i = e._readableState;
              (!i || i.autoDestroy && i.endEmitted) && e.destroy();
            }
            return n;
          }
          e("inherits")(C, a), E.prototype.getBuffer = function () {
            for (var e = this.bufferedRequest, t = []; e;) t.push(e), e = e.next;
            return t;
          }, function () {
            try {
              Object.defineProperty(E.prototype, "buffer", {
                get: s.deprecate(function () {
                  return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
              });
            } catch (e) {}
          }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (c = Function.prototype[Symbol.hasInstance], Object.defineProperty(C, Symbol.hasInstance, {
            value: function (e) {
              return !!c.call(this, e) || this === C && e && e._writableState instanceof E;
            }
          })) : c = function (e) {
            return e instanceof this;
          }, C.prototype.pipe = function () {
            k(this, new b());
          }, C.prototype.write = function (e, t, n) {
            var i,
              o = this._writableState,
              s = !1,
              a = !o.objectMode && (i = e, l.isBuffer(i) || i instanceof u);
            return a && !l.isBuffer(e) && (e = function (e) {
              return l.from(e);
            }(e)), "function" == typeof t && (n = t, t = null), a ? t = "buffer" : t || (t = o.defaultEncoding), "function" != typeof n && (n = S), o.ending ? function (e, t) {
              var n = new w();
              k(e, n), r.nextTick(t, n);
            }(this, n) : (a || function (e, t, n, i) {
              var o;
              return null === n ? o = new v() : "string" == typeof n || t.objectMode || (o = new d("chunk", ["string", "Buffer"], n)), !o || (k(e, o), r.nextTick(i, o), !1);
            }(this, o, e, n)) && (o.pendingcb++, s = function (e, t, r, n, i, o) {
              if (!r) {
                var s = function (e, t, r) {
                  e.objectMode || !1 === e.decodeStrings || "string" != typeof t || (t = l.from(t, r));
                  return t;
                }(t, n, i);
                n !== s && (r = !0, i = "buffer", n = s);
              }
              var a = t.objectMode ? 1 : n.length;
              t.length += a;
              var u = t.length < t.highWaterMark;
              u || (t.needDrain = !0);
              if (t.writing || t.corked) {
                var c = t.lastBufferedRequest;
                t.lastBufferedRequest = {
                  chunk: n,
                  encoding: i,
                  isBuf: r,
                  callback: o,
                  next: null
                }, c ? c.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
              } else T(e, t, !1, a, n, i, o);
              return u;
            }(this, o, a, e, t, n)), s;
          }, C.prototype.cork = function () {
            this._writableState.corked++;
          }, C.prototype.uncork = function () {
            var e = this._writableState;
            e.corked && (e.corked--, e.writing || e.corked || e.bufferProcessing || !e.bufferedRequest || A(this, e));
          }, C.prototype.setDefaultEncoding = function (e) {
            if ("string" == typeof e && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1)) throw new _(e);
            return this._writableState.defaultEncoding = e, this;
          }, Object.defineProperty(C.prototype, "writableBuffer", {
            enumerable: !1,
            get: function () {
              return this._writableState && this._writableState.getBuffer();
            }
          }), Object.defineProperty(C.prototype, "writableHighWaterMark", {
            enumerable: !1,
            get: function () {
              return this._writableState.highWaterMark;
            }
          }), C.prototype._write = function (e, t, r) {
            r(new g("_write()"));
          }, C.prototype._writev = null, C.prototype.end = function (e, t, n) {
            var i = this._writableState;
            return "function" == typeof e ? (n = e, e = null, t = null) : "function" == typeof t && (n = t, t = null), null !== e && void 0 !== e && this.write(e, t), i.corked && (i.corked = 1, this.uncork()), i.ending || function (e, t, n) {
              t.ending = !0, O(e, t), n && (t.finished ? r.nextTick(n) : e.once("finish", n));
              t.ended = !0, e.writable = !1;
            }(this, i, n), this;
          }, Object.defineProperty(C.prototype, "writableLength", {
            enumerable: !1,
            get: function () {
              return this._writableState.length;
            }
          }), Object.defineProperty(C.prototype, "destroyed", {
            enumerable: !1,
            get: function () {
              return void 0 !== this._writableState && this._writableState.destroyed;
            },
            set: function (e) {
              this._writableState && (this._writableState.destroyed = e);
            }
          }), C.prototype.destroy = h.destroy, C.prototype._undestroy = h.undestroy, C.prototype._destroy = function (e, t) {
            t(e);
          };
        }).call(this);
      }).call(this, e("_process"), "undefined" != typeof __webpack_require__.g ? __webpack_require__.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {
      "../errors": 55,
      "./_stream_duplex": 56,
      "./internal/streams/destroy": 63,
      "./internal/streams/state": 67,
      "./internal/streams/stream": 68,
      _process: 50,
      buffer: 17,
      inherits: 24,
      "util-deprecate": 78
    }],
    61: [function (e, t, r) {
      (function (r) {
        (function () {
          "use strict";

          var n;
          function i(e, t, r) {
            return t in e ? Object.defineProperty(e, t, {
              value: r,
              enumerable: !0,
              configurable: !0,
              writable: !0
            }) : e[t] = r, e;
          }
          var o = e("./end-of-stream"),
            s = Symbol("lastResolve"),
            a = Symbol("lastReject"),
            l = Symbol("error"),
            u = Symbol("ended"),
            c = Symbol("lastPromise"),
            h = Symbol("handlePromise"),
            f = Symbol("stream");
          function p(e, t) {
            return {
              value: e,
              done: t
            };
          }
          function d(e) {
            var t = e[s];
            if (null !== t) {
              var r = e[f].read();
              null !== r && (e[c] = null, e[s] = null, e[a] = null, t(p(r, !1)));
            }
          }
          var g = Object.getPrototypeOf(function () {}),
            y = Object.setPrototypeOf((i(n = {
              get stream() {
                return this[f];
              },
              next: function () {
                var e = this,
                  t = this[l];
                if (null !== t) return Promise.reject(t);
                if (this[u]) return Promise.resolve(p(void 0, !0));
                if (this[f].destroyed) return new Promise(function (t, n) {
                  r.nextTick(function () {
                    e[l] ? n(e[l]) : t(p(void 0, !0));
                  });
                });
                var n,
                  i = this[c];
                if (i) n = new Promise(function (e, t) {
                  return function (r, n) {
                    e.then(function () {
                      t[u] ? r(p(void 0, !0)) : t[h](r, n);
                    }, n);
                  };
                }(i, this));else {
                  var o = this[f].read();
                  if (null !== o) return Promise.resolve(p(o, !1));
                  n = new Promise(this[h]);
                }
                return this[c] = n, n;
              }
            }, Symbol.asyncIterator, function () {
              return this;
            }), i(n, "return", function () {
              var e = this;
              return new Promise(function (t, r) {
                e[f].destroy(null, function (e) {
                  e ? r(e) : t(p(void 0, !0));
                });
              });
            }), n), g);
          t.exports = function (e) {
            var t,
              n = Object.create(y, (i(t = {}, f, {
                value: e,
                writable: !0
              }), i(t, s, {
                value: null,
                writable: !0
              }), i(t, a, {
                value: null,
                writable: !0
              }), i(t, l, {
                value: null,
                writable: !0
              }), i(t, u, {
                value: e._readableState.endEmitted,
                writable: !0
              }), i(t, h, {
                value: function (e, t) {
                  var r = n[f].read();
                  r ? (n[c] = null, n[s] = null, n[a] = null, e(p(r, !1))) : (n[s] = e, n[a] = t);
                },
                writable: !0
              }), t));
            return n[c] = null, o(e, function (e) {
              if (e && "ERR_STREAM_PREMATURE_CLOSE" !== e.code) {
                var t = n[a];
                return null !== t && (n[c] = null, n[s] = null, n[a] = null, t(e)), void (n[l] = e);
              }
              var r = n[s];
              null !== r && (n[c] = null, n[s] = null, n[a] = null, r(p(void 0, !0))), n[u] = !0;
            }), e.on("readable", function (e) {
              r.nextTick(d, e);
            }.bind(null, n)), n;
          };
        }).call(this);
      }).call(this, e("_process"));
    }, {
      "./end-of-stream": 64,
      _process: 50
    }],
    62: [function (e, t, r) {
      "use strict";

      function n(e, t) {
        var r = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var n = Object.getOwnPropertySymbols(e);
          t && (n = n.filter(function (t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable;
          })), r.push.apply(r, n);
        }
        return r;
      }
      function i(e, t, r) {
        return t in e ? Object.defineProperty(e, t, {
          value: r,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }) : e[t] = r, e;
      }
      function o(e, t) {
        for (var r = 0; r < t.length; r++) {
          var n = t[r];
          n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
        }
      }
      var s = e("buffer").Buffer,
        a = e("util").inspect,
        l = a && a.custom || "inspect";
      t.exports = function () {
        function e() {
          !function (e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
          }(this, e), this.head = null, this.tail = null, this.length = 0;
        }
        var t, r, u;
        return t = e, (r = [{
          key: "push",
          value: function (e) {
            var t = {
              data: e,
              next: null
            };
            this.length > 0 ? this.tail.next = t : this.head = t, this.tail = t, ++this.length;
          }
        }, {
          key: "unshift",
          value: function (e) {
            var t = {
              data: e,
              next: this.head
            };
            0 === this.length && (this.tail = t), this.head = t, ++this.length;
          }
        }, {
          key: "shift",
          value: function () {
            if (0 !== this.length) {
              var e = this.head.data;
              return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e;
            }
          }
        }, {
          key: "clear",
          value: function () {
            this.head = this.tail = null, this.length = 0;
          }
        }, {
          key: "join",
          value: function (e) {
            if (0 === this.length) return "";
            for (var t = this.head, r = "" + t.data; t = t.next;) r += e + t.data;
            return r;
          }
        }, {
          key: "concat",
          value: function (e) {
            if (0 === this.length) return s.alloc(0);
            for (var t, r, n, i = s.allocUnsafe(e >>> 0), o = this.head, a = 0; o;) t = o.data, r = i, n = a, s.prototype.copy.call(t, r, n), a += o.data.length, o = o.next;
            return i;
          }
        }, {
          key: "consume",
          value: function (e, t) {
            var r;
            return e < this.head.data.length ? (r = this.head.data.slice(0, e), this.head.data = this.head.data.slice(e)) : r = e === this.head.data.length ? this.shift() : t ? this._getString(e) : this._getBuffer(e), r;
          }
        }, {
          key: "first",
          value: function () {
            return this.head.data;
          }
        }, {
          key: "_getString",
          value: function (e) {
            var t = this.head,
              r = 1,
              n = t.data;
            for (e -= n.length; t = t.next;) {
              var i = t.data,
                o = e > i.length ? i.length : e;
              if (o === i.length ? n += i : n += i.slice(0, e), 0 === (e -= o)) {
                o === i.length ? (++r, t.next ? this.head = t.next : this.head = this.tail = null) : (this.head = t, t.data = i.slice(o));
                break;
              }
              ++r;
            }
            return this.length -= r, n;
          }
        }, {
          key: "_getBuffer",
          value: function (e) {
            var t = s.allocUnsafe(e),
              r = this.head,
              n = 1;
            for (r.data.copy(t), e -= r.data.length; r = r.next;) {
              var i = r.data,
                o = e > i.length ? i.length : e;
              if (i.copy(t, t.length - e, 0, o), 0 === (e -= o)) {
                o === i.length ? (++n, r.next ? this.head = r.next : this.head = this.tail = null) : (this.head = r, r.data = i.slice(o));
                break;
              }
              ++n;
            }
            return this.length -= n, t;
          }
        }, {
          key: l,
          value: function (e, t) {
            return a(this, function (e) {
              for (var t = 1; t < arguments.length; t++) {
                var r = null != arguments[t] ? arguments[t] : {};
                t % 2 ? n(Object(r), !0).forEach(function (t) {
                  i(e, t, r[t]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : n(Object(r)).forEach(function (t) {
                  Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
                });
              }
              return e;
            }({}, t, {
              depth: 0,
              customInspect: !1
            }));
          }
        }]) && o(t.prototype, r), u && o(t, u), e;
      }();
    }, {
      buffer: 17,
      util: 16
    }],
    63: [function (e, t, r) {
      (function (e) {
        (function () {
          "use strict";

          function r(e, t) {
            i(e, t), n(e);
          }
          function n(e) {
            e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
          }
          function i(e, t) {
            e.emit("error", t);
          }
          t.exports = {
            destroy: function (t, o) {
              var s = this,
                a = this._readableState && this._readableState.destroyed,
                l = this._writableState && this._writableState.destroyed;
              return a || l ? (o ? o(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, e.nextTick(i, this, t)) : e.nextTick(i, this, t)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(t || null, function (t) {
                !o && t ? s._writableState ? s._writableState.errorEmitted ? e.nextTick(n, s) : (s._writableState.errorEmitted = !0, e.nextTick(r, s, t)) : e.nextTick(r, s, t) : o ? (e.nextTick(n, s), o(t)) : e.nextTick(n, s);
              }), this);
            },
            undestroy: function () {
              this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
            },
            errorOrDestroy: function (e, t) {
              var r = e._readableState,
                n = e._writableState;
              r && r.autoDestroy || n && n.autoDestroy ? e.destroy(t) : e.emit("error", t);
            }
          };
        }).call(this);
      }).call(this, e("_process"));
    }, {
      _process: 50
    }],
    64: [function (e, t, r) {
      "use strict";

      var n = e("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
      function i() {}
      t.exports = function e(t, r, o) {
        if ("function" == typeof r) return e(t, null, r);
        r || (r = {}), o = function (e) {
          var t = !1;
          return function () {
            if (!t) {
              t = !0;
              for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++) n[i] = arguments[i];
              e.apply(this, n);
            }
          };
        }(o || i);
        var s = r.readable || !1 !== r.readable && t.readable,
          a = r.writable || !1 !== r.writable && t.writable,
          l = function () {
            t.writable || c();
          },
          u = t._writableState && t._writableState.finished,
          c = function () {
            a = !1, u = !0, s || o.call(t);
          },
          h = t._readableState && t._readableState.endEmitted,
          f = function () {
            s = !1, h = !0, a || o.call(t);
          },
          p = function (e) {
            o.call(t, e);
          },
          d = function () {
            var e;
            return s && !h ? (t._readableState && t._readableState.ended || (e = new n()), o.call(t, e)) : a && !u ? (t._writableState && t._writableState.ended || (e = new n()), o.call(t, e)) : void 0;
          },
          g = function () {
            t.req.on("finish", c);
          };
        return function (e) {
          return e.setHeader && "function" == typeof e.abort;
        }(t) ? (t.on("complete", c), t.on("abort", d), t.req ? g() : t.on("request", g)) : a && !t._writableState && (t.on("end", l), t.on("close", l)), t.on("end", f), t.on("finish", c), !1 !== r.error && t.on("error", p), t.on("close", d), function () {
          t.removeListener("complete", c), t.removeListener("abort", d), t.removeListener("request", g), t.req && t.req.removeListener("finish", c), t.removeListener("end", l), t.removeListener("close", l), t.removeListener("finish", c), t.removeListener("end", f), t.removeListener("error", p), t.removeListener("close", d);
        };
      };
    }, {
      "../../../errors": 55
    }],
    65: [function (e, t, r) {
      t.exports = function () {
        throw new Error("Readable.from is not available in the browser");
      };
    }, {}],
    66: [function (e, t, r) {
      "use strict";

      var n;
      var i = e("../../../errors").codes,
        o = i.ERR_MISSING_ARGS,
        s = i.ERR_STREAM_DESTROYED;
      function a(e) {
        if (e) throw e;
      }
      function l(e) {
        e();
      }
      function u(e, t) {
        return e.pipe(t);
      }
      t.exports = function () {
        for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++) r[i] = arguments[i];
        var c,
          h = function (e) {
            return e.length ? "function" != typeof e[e.length - 1] ? a : e.pop() : a;
          }(r);
        if (Array.isArray(r[0]) && (r = r[0]), r.length < 2) throw new o("streams");
        var f = r.map(function (t, i) {
          var o = i < r.length - 1;
          return function (t, r, i, o) {
            o = function (e) {
              var t = !1;
              return function () {
                t || (t = !0, e.apply(void 0, arguments));
              };
            }(o);
            var a = !1;
            t.on("close", function () {
              a = !0;
            }), void 0 === n && (n = e("./end-of-stream")), n(t, {
              readable: r,
              writable: i
            }, function (e) {
              if (e) return o(e);
              a = !0, o();
            });
            var l = !1;
            return function (e) {
              if (!a && !l) return l = !0, function (e) {
                return e.setHeader && "function" == typeof e.abort;
              }(t) ? t.abort() : "function" == typeof t.destroy ? t.destroy() : void o(e || new s("pipe"));
            };
          }(t, o, i > 0, function (e) {
            c || (c = e), e && f.forEach(l), o || (f.forEach(l), h(c));
          });
        });
        return r.reduce(u);
      };
    }, {
      "../../../errors": 55,
      "./end-of-stream": 64
    }],
    67: [function (e, t, r) {
      "use strict";

      var n = e("../../../errors").codes.ERR_INVALID_OPT_VALUE;
      t.exports = {
        getHighWaterMark: function (e, t, r, i) {
          var o = function (e, t, r) {
            return null != e.highWaterMark ? e.highWaterMark : t ? e[r] : null;
          }(t, i, r);
          if (null != o) {
            if (!isFinite(o) || Math.floor(o) !== o || o < 0) throw new n(i ? r : "highWaterMark", o);
            return Math.floor(o);
          }
          return e.objectMode ? 16 : 16384;
        }
      };
    }, {
      "../../../errors": 55
    }],
    68: [function (e, t, r) {
      t.exports = e("events").EventEmitter;
    }, {
      events: 22
    }],
    69: [function (e, t, r) {
      (r = t.exports = e("./lib/_stream_readable.js")).Stream = r, r.Readable = r, r.Writable = e("./lib/_stream_writable.js"), r.Duplex = e("./lib/_stream_duplex.js"), r.Transform = e("./lib/_stream_transform.js"), r.PassThrough = e("./lib/_stream_passthrough.js"), r.finished = e("./lib/internal/streams/end-of-stream.js"), r.pipeline = e("./lib/internal/streams/pipeline.js");
    }, {
      "./lib/_stream_duplex.js": 56,
      "./lib/_stream_passthrough.js": 57,
      "./lib/_stream_readable.js": 58,
      "./lib/_stream_transform.js": 59,
      "./lib/_stream_writable.js": 60,
      "./lib/internal/streams/end-of-stream.js": 64,
      "./lib/internal/streams/pipeline.js": 66
    }],
    70: [function (e, t, r) {
      "use strict";

      t.exports = function () {
        if ("function" != typeof arguments[0]) throw new Error("callback needed");
        if ("number" != typeof arguments[1]) throw new Error("interval needed");
        var e;
        if (arguments.length > 0) {
          e = new Array(arguments.length - 2);
          for (var t = 0; t < e.length; t++) e[t] = arguments[t + 2];
        }
        return new function (e, t, r) {
          var n = this;
          this._callback = e, this._args = r, this._interval = setInterval(e, t, this._args), this.reschedule = function (e) {
            e || (e = n._interval), n._interval && clearInterval(n._interval), n._interval = setInterval(n._callback, e, n._args);
          }, this.clear = function () {
            n._interval && (clearInterval(n._interval), n._interval = void 0);
          }, this.destroy = function () {
            n._interval && clearInterval(n._interval), n._callback = void 0, n._interval = void 0, n._args = void 0;
          };
        }(arguments[0], arguments[1], e);
      };
    }, {}],
    71: [function (e, t, r) {
      "use strict";

      t.exports = e("./index.js")();
    }, {
      "./index.js": 72
    }],
    72: [function (e, t, r) {
      (function (e) {
        (function () {
          "use strict";

          function r(t) {
            return t instanceof e ? e.from(t) : new t.constructor(t.buffer.slice(), t.byteOffset, t.length);
          }
          t.exports = function (e) {
            return (e = e || {}).circles ? function (e) {
              var t = [],
                n = [];
              return e.proto ? function e(o) {
                if ("object" != typeof o || null === o) return o;
                if (o instanceof Date) return new Date(o);
                if (Array.isArray(o)) return i(o, e);
                if (o instanceof Map) return new Map(i(Array.from(o), e));
                if (o instanceof Set) return new Set(i(Array.from(o), e));
                var s = {};
                for (var a in t.push(o), n.push(s), o) {
                  var l = o[a];
                  if ("object" != typeof l || null === l) s[a] = l;else if (l instanceof Date) s[a] = new Date(l);else if (l instanceof Map) s[a] = new Map(i(Array.from(l), e));else if (l instanceof Set) s[a] = new Set(i(Array.from(l), e));else if (ArrayBuffer.isView(l)) s[a] = r(l);else {
                    var u = t.indexOf(l);
                    s[a] = -1 !== u ? n[u] : e(l);
                  }
                }
                return t.pop(), n.pop(), s;
              } : function e(o) {
                if ("object" != typeof o || null === o) return o;
                if (o instanceof Date) return new Date(o);
                if (Array.isArray(o)) return i(o, e);
                if (o instanceof Map) return new Map(i(Array.from(o), e));
                if (o instanceof Set) return new Set(i(Array.from(o), e));
                var s = {};
                for (var a in t.push(o), n.push(s), o) if (!1 !== Object.hasOwnProperty.call(o, a)) {
                  var l = o[a];
                  if ("object" != typeof l || null === l) s[a] = l;else if (l instanceof Date) s[a] = new Date(l);else if (l instanceof Map) s[a] = new Map(i(Array.from(l), e));else if (l instanceof Set) s[a] = new Set(i(Array.from(l), e));else if (ArrayBuffer.isView(l)) s[a] = r(l);else {
                    var u = t.indexOf(l);
                    s[a] = -1 !== u ? n[u] : e(l);
                  }
                }
                return t.pop(), n.pop(), s;
              };
              function i(e, i) {
                for (var o = Object.keys(e), s = new Array(o.length), a = 0; a < o.length; a++) {
                  var l = o[a],
                    u = e[l];
                  if ("object" != typeof u || null === u) s[l] = u;else if (u instanceof Date) s[l] = new Date(u);else if (ArrayBuffer.isView(u)) s[l] = r(u);else {
                    var c = t.indexOf(u);
                    s[l] = -1 !== c ? n[c] : i(u);
                  }
                }
                return s;
              }
            }(e) : e.proto ? function e(n) {
              if ("object" != typeof n || null === n) return n;
              if (n instanceof Date) return new Date(n);
              if (Array.isArray(n)) return t(n, e);
              if (n instanceof Map) return new Map(t(Array.from(n), e));
              if (n instanceof Set) return new Set(t(Array.from(n), e));
              var i = {};
              for (var o in n) {
                var s = n[o];
                "object" != typeof s || null === s ? i[o] = s : s instanceof Date ? i[o] = new Date(s) : s instanceof Map ? i[o] = new Map(t(Array.from(s), e)) : s instanceof Set ? i[o] = new Set(t(Array.from(s), e)) : ArrayBuffer.isView(s) ? i[o] = r(s) : i[o] = e(s);
              }
              return i;
            } : function e(n) {
              if ("object" != typeof n || null === n) return n;
              if (n instanceof Date) return new Date(n);
              if (Array.isArray(n)) return t(n, e);
              if (n instanceof Map) return new Map(t(Array.from(n), e));
              if (n instanceof Set) return new Set(t(Array.from(n), e));
              var i = {};
              for (var o in n) if (!1 !== Object.hasOwnProperty.call(n, o)) {
                var s = n[o];
                "object" != typeof s || null === s ? i[o] = s : s instanceof Date ? i[o] = new Date(s) : s instanceof Map ? i[o] = new Map(t(Array.from(s), e)) : s instanceof Set ? i[o] = new Set(t(Array.from(s), e)) : ArrayBuffer.isView(s) ? i[o] = r(s) : i[o] = e(s);
              }
              return i;
            };
            function t(e, t) {
              for (var n = Object.keys(e), i = new Array(n.length), o = 0; o < n.length; o++) {
                var s = n[o],
                  a = e[s];
                "object" != typeof a || null === a ? i[s] = a : a instanceof Date ? i[s] = new Date(a) : ArrayBuffer.isView(a) ? i[s] = r(a) : i[s] = t(a);
              }
              return i;
            }
          };
        }).call(this);
      }).call(this, e("buffer").Buffer);
    }, {
      buffer: 17
    }],
    73: [function (e, t, r) {
      var n = e("buffer"),
        i = n.Buffer;
      function o(e, t) {
        for (var r in e) t[r] = e[r];
      }
      function s(e, t, r) {
        return i(e, t, r);
      }
      i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? t.exports = n : (o(n, r), r.Buffer = s), s.prototype = Object.create(i.prototype), o(i, s), s.from = function (e, t, r) {
        if ("number" == typeof e) throw new TypeError("Argument must not be a number");
        return i(e, t, r);
      }, s.alloc = function (e, t, r) {
        if ("number" != typeof e) throw new TypeError("Argument must be a number");
        var n = i(e);
        return void 0 !== t ? "string" == typeof r ? n.fill(t, r) : n.fill(t) : n.fill(0), n;
      }, s.allocUnsafe = function (e) {
        if ("number" != typeof e) throw new TypeError("Argument must be a number");
        return i(e);
      }, s.allocUnsafeSlow = function (e) {
        if ("number" != typeof e) throw new TypeError("Argument must be a number");
        return n.SlowBuffer(e);
      };
    }, {
      buffer: 17
    }],
    74: [function (e, t, r) {
      t.exports = function (e) {
        var t = e._readableState;
        return t ? t.objectMode || "number" == typeof e._duplexState ? e.read() : e.read((r = t, r.buffer.length ? r.buffer.head ? r.buffer.head.data.length : r.buffer[0].length : r.length)) : null;
        var r;
      };
    }, {}],
    75: [function (e, t, r) {
      "use strict";

      var n = e("safe-buffer").Buffer,
        i = n.isEncoding || function (e) {
          switch ((e = "" + e) && e.toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
              return !0;
            default:
              return !1;
          }
        };
      function o(e) {
        var t;
        switch (this.encoding = function (e) {
          var t = function (e) {
            if (!e) return "utf8";
            for (var t;;) switch (e) {
              case "utf8":
              case "utf-8":
                return "utf8";
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return "utf16le";
              case "latin1":
              case "binary":
                return "latin1";
              case "base64":
              case "ascii":
              case "hex":
                return e;
              default:
                if (t) return;
                e = ("" + e).toLowerCase(), t = !0;
            }
          }(e);
          if ("string" != typeof t && (n.isEncoding === i || !i(e))) throw new Error("Unknown encoding: " + e);
          return t || e;
        }(e), this.encoding) {
          case "utf16le":
            this.text = l, this.end = u, t = 4;
            break;
          case "utf8":
            this.fillLast = a, t = 4;
            break;
          case "base64":
            this.text = c, this.end = h, t = 3;
            break;
          default:
            return this.write = f, void (this.end = p);
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = n.allocUnsafe(t);
      }
      function s(e) {
        return e <= 127 ? 0 : e >> 5 == 6 ? 2 : e >> 4 == 14 ? 3 : e >> 3 == 30 ? 4 : e >> 6 == 2 ? -1 : -2;
      }
      function a(e) {
        var t = this.lastTotal - this.lastNeed,
          r = function (e, t, r) {
            if (128 != (192 & t[0])) return e.lastNeed = 0, "�";
            if (e.lastNeed > 1 && t.length > 1) {
              if (128 != (192 & t[1])) return e.lastNeed = 1, "�";
              if (e.lastNeed > 2 && t.length > 2 && 128 != (192 & t[2])) return e.lastNeed = 2, "�";
            }
          }(this, e);
        return void 0 !== r ? r : this.lastNeed <= e.length ? (e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (e.copy(this.lastChar, t, 0, e.length), void (this.lastNeed -= e.length));
      }
      function l(e, t) {
        if ((e.length - t) % 2 == 0) {
          var r = e.toString("utf16le", t);
          if (r) {
            var n = r.charCodeAt(r.length - 1);
            if (n >= 55296 && n <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], r.slice(0, -1);
          }
          return r;
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1);
      }
      function u(e) {
        var t = e && e.length ? this.write(e) : "";
        if (this.lastNeed) {
          var r = this.lastTotal - this.lastNeed;
          return t + this.lastChar.toString("utf16le", 0, r);
        }
        return t;
      }
      function c(e, t) {
        var r = (e.length - t) % 3;
        return 0 === r ? e.toString("base64", t) : (this.lastNeed = 3 - r, this.lastTotal = 3, 1 === r ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - r));
      }
      function h(e) {
        var t = e && e.length ? this.write(e) : "";
        return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t;
      }
      function f(e) {
        return e.toString(this.encoding);
      }
      function p(e) {
        return e && e.length ? this.write(e) : "";
      }
      r.StringDecoder = o, o.prototype.write = function (e) {
        if (0 === e.length) return "";
        var t, r;
        if (this.lastNeed) {
          if (void 0 === (t = this.fillLast(e))) return "";
          r = this.lastNeed, this.lastNeed = 0;
        } else r = 0;
        return r < e.length ? t ? t + this.text(e, r) : this.text(e, r) : t || "";
      }, o.prototype.end = function (e) {
        var t = e && e.length ? this.write(e) : "";
        return this.lastNeed ? t + "�" : t;
      }, o.prototype.text = function (e, t) {
        var r = function (e, t, r) {
          var n = t.length - 1;
          if (n < r) return 0;
          var i = s(t[n]);
          if (i >= 0) return i > 0 && (e.lastNeed = i - 1), i;
          if (--n < r || -2 === i) return 0;
          if ((i = s(t[n])) >= 0) return i > 0 && (e.lastNeed = i - 2), i;
          if (--n < r || -2 === i) return 0;
          if ((i = s(t[n])) >= 0) return i > 0 && (2 === i ? i = 0 : e.lastNeed = i - 3), i;
          return 0;
        }(this, e, t);
        if (!this.lastNeed) return e.toString("utf8", t);
        this.lastTotal = r;
        var n = e.length - (r - this.lastNeed);
        return e.copy(this.lastChar, 0, n), e.toString("utf8", t, n);
      }, o.prototype.fillLast = function (e) {
        if (this.lastNeed <= e.length) return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length;
      };
    }, {
      "safe-buffer": 73
    }],
    76: [function (e, t, r) {
      "use strict";

      var n = e("punycode"),
        i = e("./util");
      function o() {
        this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
      }
      r.parse = v, r.resolve = function (e, t) {
        return v(e, !1, !0).resolve(t);
      }, r.resolveObject = function (e, t) {
        return e ? v(e, !1, !0).resolveObject(t) : t;
      }, r.format = function (e) {
        i.isString(e) && (e = v(e));
        return e instanceof o ? e.format() : o.prototype.format.call(e);
      }, r.Url = o;
      var s = /^([a-z0-9.+-]+:)/i,
        a = /:[0-9]*$/,
        l = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
        u = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "\t"]),
        c = ["'"].concat(u),
        h = ["%", "/", "?", ";", "#"].concat(c),
        f = ["/", "?", "#"],
        p = /^[+a-z0-9A-Z_-]{0,63}$/,
        d = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
        g = {
          javascript: !0,
          "javascript:": !0
        },
        y = {
          javascript: !0,
          "javascript:": !0
        },
        b = {
          http: !0,
          https: !0,
          ftp: !0,
          gopher: !0,
          file: !0,
          "http:": !0,
          "https:": !0,
          "ftp:": !0,
          "gopher:": !0,
          "file:": !0
        },
        m = e("querystring");
      function v(e, t, r) {
        if (e && i.isObject(e) && e instanceof o) return e;
        var n = new o();
        return n.parse(e, t, r), n;
      }
      o.prototype.parse = function (e, t, r) {
        if (!i.isString(e)) throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
        var o = e.indexOf("?"),
          a = -1 !== o && o < e.indexOf("#") ? "?" : "#",
          u = e.split(a);
        u[0] = u[0].replace(/\\/g, "/");
        var v = e = u.join(a);
        if (v = v.trim(), !r && 1 === e.split("#").length) {
          var w = l.exec(v);
          if (w) return this.path = v, this.href = v, this.pathname = w[1], w[2] ? (this.search = w[2], this.query = t ? m.parse(this.search.substr(1)) : this.search.substr(1)) : t && (this.search = "", this.query = {}), this;
        }
        var _ = s.exec(v);
        if (_) {
          var k = (_ = _[0]).toLowerCase();
          this.protocol = k, v = v.substr(_.length);
        }
        if (r || _ || v.match(/^\/\/[^@\/]+@[^@\/]+/)) {
          var S = "//" === v.substr(0, 2);
          !S || _ && y[_] || (v = v.substr(2), this.slashes = !0);
        }
        if (!y[_] && (S || _ && !b[_])) {
          for (var E, C, T = -1, x = 0; x < f.length; x++) {
            -1 !== (A = v.indexOf(f[x])) && (-1 === T || A < T) && (T = A);
          }
          -1 !== (C = -1 === T ? v.lastIndexOf("@") : v.lastIndexOf("@", T)) && (E = v.slice(0, C), v = v.slice(C + 1), this.auth = decodeURIComponent(E)), T = -1;
          for (x = 0; x < h.length; x++) {
            var A;
            -1 !== (A = v.indexOf(h[x])) && (-1 === T || A < T) && (T = A);
          }
          -1 === T && (T = v.length), this.host = v.slice(0, T), v = v.slice(T), this.parseHost(), this.hostname = this.hostname || "";
          var I = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
          if (!I) for (var P = this.hostname.split(/\./), O = (x = 0, P.length); x < O; x++) {
            var B = P[x];
            if (B && !B.match(p)) {
              for (var R = "", M = 0, N = B.length; M < N; M++) B.charCodeAt(M) > 127 ? R += "x" : R += B[M];
              if (!R.match(p)) {
                var L = P.slice(0, x),
                  j = P.slice(x + 1),
                  U = B.match(d);
                U && (L.push(U[1]), j.unshift(U[2])), j.length && (v = "/" + j.join(".") + v), this.hostname = L.join(".");
                break;
              }
            }
          }
          this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), I || (this.hostname = n.toASCII(this.hostname));
          var q = this.port ? ":" + this.port : "",
            D = this.hostname || "";
          this.host = D + q, this.href += this.host, I && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== v[0] && (v = "/" + v));
        }
        if (!g[k]) for (x = 0, O = c.length; x < O; x++) {
          var z = c[x];
          if (-1 !== v.indexOf(z)) {
            var F = encodeURIComponent(z);
            F === z && (F = escape(z)), v = v.split(z).join(F);
          }
        }
        var V = v.indexOf("#");
        -1 !== V && (this.hash = v.substr(V), v = v.slice(0, V));
        var H = v.indexOf("?");
        if (-1 !== H ? (this.search = v.substr(H), this.query = v.substr(H + 1), t && (this.query = m.parse(this.query)), v = v.slice(0, H)) : t && (this.search = "", this.query = {}), v && (this.pathname = v), b[k] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
          q = this.pathname || "";
          var W = this.search || "";
          this.path = q + W;
        }
        return this.href = this.format(), this;
      }, o.prototype.format = function () {
        var e = this.auth || "";
        e && (e = (e = encodeURIComponent(e)).replace(/%3A/i, ":"), e += "@");
        var t = this.protocol || "",
          r = this.pathname || "",
          n = this.hash || "",
          o = !1,
          s = "";
        this.host ? o = e + this.host : this.hostname && (o = e + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (o += ":" + this.port)), this.query && i.isObject(this.query) && Object.keys(this.query).length && (s = m.stringify(this.query));
        var a = this.search || s && "?" + s || "";
        return t && ":" !== t.substr(-1) && (t += ":"), this.slashes || (!t || b[t]) && !1 !== o ? (o = "//" + (o || ""), r && "/" !== r.charAt(0) && (r = "/" + r)) : o || (o = ""), n && "#" !== n.charAt(0) && (n = "#" + n), a && "?" !== a.charAt(0) && (a = "?" + a), t + o + (r = r.replace(/[?#]/g, function (e) {
          return encodeURIComponent(e);
        })) + (a = a.replace("#", "%23")) + n;
      }, o.prototype.resolve = function (e) {
        return this.resolveObject(v(e, !1, !0)).format();
      }, o.prototype.resolveObject = function (e) {
        if (i.isString(e)) {
          var t = new o();
          t.parse(e, !1, !0), e = t;
        }
        for (var r = new o(), n = Object.keys(this), s = 0; s < n.length; s++) {
          var a = n[s];
          r[a] = this[a];
        }
        if (r.hash = e.hash, "" === e.href) return r.href = r.format(), r;
        if (e.slashes && !e.protocol) {
          for (var l = Object.keys(e), u = 0; u < l.length; u++) {
            var c = l[u];
            "protocol" !== c && (r[c] = e[c]);
          }
          return b[r.protocol] && r.hostname && !r.pathname && (r.path = r.pathname = "/"), r.href = r.format(), r;
        }
        if (e.protocol && e.protocol !== r.protocol) {
          if (!b[e.protocol]) {
            for (var h = Object.keys(e), f = 0; f < h.length; f++) {
              var p = h[f];
              r[p] = e[p];
            }
            return r.href = r.format(), r;
          }
          if (r.protocol = e.protocol, e.host || y[e.protocol]) r.pathname = e.pathname;else {
            for (var d = (e.pathname || "").split("/"); d.length && !(e.host = d.shift()););
            e.host || (e.host = ""), e.hostname || (e.hostname = ""), "" !== d[0] && d.unshift(""), d.length < 2 && d.unshift(""), r.pathname = d.join("/");
          }
          if (r.search = e.search, r.query = e.query, r.host = e.host || "", r.auth = e.auth, r.hostname = e.hostname || e.host, r.port = e.port, r.pathname || r.search) {
            var g = r.pathname || "",
              m = r.search || "";
            r.path = g + m;
          }
          return r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
        }
        var v = r.pathname && "/" === r.pathname.charAt(0),
          w = e.host || e.pathname && "/" === e.pathname.charAt(0),
          _ = w || v || r.host && e.pathname,
          k = _,
          S = r.pathname && r.pathname.split("/") || [],
          E = (d = e.pathname && e.pathname.split("/") || [], r.protocol && !b[r.protocol]);
        if (E && (r.hostname = "", r.port = null, r.host && ("" === S[0] ? S[0] = r.host : S.unshift(r.host)), r.host = "", e.protocol && (e.hostname = null, e.port = null, e.host && ("" === d[0] ? d[0] = e.host : d.unshift(e.host)), e.host = null), _ = _ && ("" === d[0] || "" === S[0])), w) r.host = e.host || "" === e.host ? e.host : r.host, r.hostname = e.hostname || "" === e.hostname ? e.hostname : r.hostname, r.search = e.search, r.query = e.query, S = d;else if (d.length) S || (S = []), S.pop(), S = S.concat(d), r.search = e.search, r.query = e.query;else if (!i.isNullOrUndefined(e.search)) {
          if (E) r.hostname = r.host = S.shift(), (I = !!(r.host && r.host.indexOf("@") > 0) && r.host.split("@")) && (r.auth = I.shift(), r.host = r.hostname = I.shift());
          return r.search = e.search, r.query = e.query, i.isNull(r.pathname) && i.isNull(r.search) || (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.href = r.format(), r;
        }
        if (!S.length) return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, r.href = r.format(), r;
        for (var C = S.slice(-1)[0], T = (r.host || e.host || S.length > 1) && ("." === C || ".." === C) || "" === C, x = 0, A = S.length; A >= 0; A--) "." === (C = S[A]) ? S.splice(A, 1) : ".." === C ? (S.splice(A, 1), x++) : x && (S.splice(A, 1), x--);
        if (!_ && !k) for (; x--; x) S.unshift("..");
        !_ || "" === S[0] || S[0] && "/" === S[0].charAt(0) || S.unshift(""), T && "/" !== S.join("/").substr(-1) && S.push("");
        var I,
          P = "" === S[0] || S[0] && "/" === S[0].charAt(0);
        E && (r.hostname = r.host = P ? "" : S.length ? S.shift() : "", (I = !!(r.host && r.host.indexOf("@") > 0) && r.host.split("@")) && (r.auth = I.shift(), r.host = r.hostname = I.shift()));
        return (_ = _ || r.host && S.length) && !P && S.unshift(""), S.length ? r.pathname = S.join("/") : (r.pathname = null, r.path = null), i.isNull(r.pathname) && i.isNull(r.search) || (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.auth = e.auth || r.auth, r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
      }, o.prototype.parseHost = function () {
        var e = this.host,
          t = a.exec(e);
        t && (":" !== (t = t[0]) && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (this.hostname = e);
      };
    }, {
      "./util": 77,
      punycode: 51,
      querystring: 54
    }],
    77: [function (e, t, r) {
      "use strict";

      t.exports = {
        isString: function (e) {
          return "string" == typeof e;
        },
        isObject: function (e) {
          return "object" == typeof e && null !== e;
        },
        isNull: function (e) {
          return null === e;
        },
        isNullOrUndefined: function (e) {
          return null == e;
        }
      };
    }, {}],
    78: [function (e, t, r) {
      (function (e) {
        (function () {
          function r(t) {
            try {
              if (!e.localStorage) return !1;
            } catch (e) {
              return !1;
            }
            var r = e.localStorage[t];
            return null != r && "true" === String(r).toLowerCase();
          }
          t.exports = function (e, t) {
            if (r("noDeprecation")) return e;
            var n = !1;
            return function () {
              if (!n) {
                if (r("throwDeprecation")) throw new Error(t);
                r("traceDeprecation") ? console.trace(t) : console.warn(t), n = !0;
              }
              return e.apply(this, arguments);
            };
          };
        }).call(this);
      }).call(this, "undefined" != typeof __webpack_require__.g ? __webpack_require__.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {}],
    79: [function (e, t, r) {
      t.exports = function e(t, r) {
        if (t && r) return e(t)(r);
        if ("function" != typeof t) throw new TypeError("need wrapper function");
        Object.keys(t).forEach(function (e) {
          n[e] = t[e];
        });
        return n;
        function n() {
          for (var e = new Array(arguments.length), r = 0; r < e.length; r++) e[r] = arguments[r];
          var n = t.apply(this, e),
            i = e[e.length - 1];
          return "function" == typeof n && n !== i && Object.keys(i).forEach(function (e) {
            n[e] = i[e];
          }), n;
        }
      };
    }, {}],
    80: [function (e, t, r) {
      "use strict";

      t.exports = function () {
        throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object");
      };
    }, {}],
    81: [function (e, t, r) {
      t.exports = function () {
        for (var e = {}, t = 0; t < arguments.length; t++) {
          var r = arguments[t];
          for (var i in r) n.call(r, i) && (e[i] = r[i]);
        }
        return e;
      };
      var n = Object.prototype.hasOwnProperty;
    }, {}],
    82: [function (e, t, r) {
      "use strict";

      t.exports = function (e) {
        e.prototype[Symbol.iterator] = function* () {
          for (let e = this.head; e; e = e.next) yield e.value;
        };
      };
    }, {}],
    83: [function (e, t, r) {
      "use strict";

      function n(e) {
        var t = this;
        if (t instanceof n || (t = new n()), t.tail = null, t.head = null, t.length = 0, e && "function" == typeof e.forEach) e.forEach(function (e) {
          t.push(e);
        });else if (arguments.length > 0) for (var r = 0, i = arguments.length; r < i; r++) t.push(arguments[r]);
        return t;
      }
      function i(e, t, r) {
        var n = t === e.head ? new a(r, null, t, e) : new a(r, t, t.next, e);
        return null === n.next && (e.tail = n), null === n.prev && (e.head = n), e.length++, n;
      }
      function o(e, t) {
        e.tail = new a(t, e.tail, null, e), e.head || (e.head = e.tail), e.length++;
      }
      function s(e, t) {
        e.head = new a(t, null, e.head, e), e.tail || (e.tail = e.head), e.length++;
      }
      function a(e, t, r, n) {
        if (!(this instanceof a)) return new a(e, t, r, n);
        this.list = n, this.value = e, t ? (t.next = this, this.prev = t) : this.prev = null, r ? (r.prev = this, this.next = r) : this.next = null;
      }
      t.exports = n, n.Node = a, n.create = n, n.prototype.removeNode = function (e) {
        if (e.list !== this) throw new Error("removing node which does not belong to this list");
        var t = e.next,
          r = e.prev;
        return t && (t.prev = r), r && (r.next = t), e === this.head && (this.head = t), e === this.tail && (this.tail = r), e.list.length--, e.next = null, e.prev = null, e.list = null, t;
      }, n.prototype.unshiftNode = function (e) {
        if (e !== this.head) {
          e.list && e.list.removeNode(e);
          var t = this.head;
          e.list = this, e.next = t, t && (t.prev = e), this.head = e, this.tail || (this.tail = e), this.length++;
        }
      }, n.prototype.pushNode = function (e) {
        if (e !== this.tail) {
          e.list && e.list.removeNode(e);
          var t = this.tail;
          e.list = this, e.prev = t, t && (t.next = e), this.tail = e, this.head || (this.head = e), this.length++;
        }
      }, n.prototype.push = function () {
        for (var e = 0, t = arguments.length; e < t; e++) o(this, arguments[e]);
        return this.length;
      }, n.prototype.unshift = function () {
        for (var e = 0, t = arguments.length; e < t; e++) s(this, arguments[e]);
        return this.length;
      }, n.prototype.pop = function () {
        if (this.tail) {
          var e = this.tail.value;
          return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e;
        }
      }, n.prototype.shift = function () {
        if (this.head) {
          var e = this.head.value;
          return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e;
        }
      }, n.prototype.forEach = function (e, t) {
        t = t || this;
        for (var r = this.head, n = 0; null !== r; n++) e.call(t, r.value, n, this), r = r.next;
      }, n.prototype.forEachReverse = function (e, t) {
        t = t || this;
        for (var r = this.tail, n = this.length - 1; null !== r; n--) e.call(t, r.value, n, this), r = r.prev;
      }, n.prototype.get = function (e) {
        for (var t = 0, r = this.head; null !== r && t < e; t++) r = r.next;
        if (t === e && null !== r) return r.value;
      }, n.prototype.getReverse = function (e) {
        for (var t = 0, r = this.tail; null !== r && t < e; t++) r = r.prev;
        if (t === e && null !== r) return r.value;
      }, n.prototype.map = function (e, t) {
        t = t || this;
        for (var r = new n(), i = this.head; null !== i;) r.push(e.call(t, i.value, this)), i = i.next;
        return r;
      }, n.prototype.mapReverse = function (e, t) {
        t = t || this;
        for (var r = new n(), i = this.tail; null !== i;) r.push(e.call(t, i.value, this)), i = i.prev;
        return r;
      }, n.prototype.reduce = function (e, t) {
        var r,
          n = this.head;
        if (arguments.length > 1) r = t;else {
          if (!this.head) throw new TypeError("Reduce of empty list with no initial value");
          n = this.head.next, r = this.head.value;
        }
        for (var i = 0; null !== n; i++) r = e(r, n.value, i), n = n.next;
        return r;
      }, n.prototype.reduceReverse = function (e, t) {
        var r,
          n = this.tail;
        if (arguments.length > 1) r = t;else {
          if (!this.tail) throw new TypeError("Reduce of empty list with no initial value");
          n = this.tail.prev, r = this.tail.value;
        }
        for (var i = this.length - 1; null !== n; i--) r = e(r, n.value, i), n = n.prev;
        return r;
      }, n.prototype.toArray = function () {
        for (var e = new Array(this.length), t = 0, r = this.head; null !== r; t++) e[t] = r.value, r = r.next;
        return e;
      }, n.prototype.toArrayReverse = function () {
        for (var e = new Array(this.length), t = 0, r = this.tail; null !== r; t++) e[t] = r.value, r = r.prev;
        return e;
      }, n.prototype.slice = function (e, t) {
        (t = t || this.length) < 0 && (t += this.length), (e = e || 0) < 0 && (e += this.length);
        var r = new n();
        if (t < e || t < 0) return r;
        e < 0 && (e = 0), t > this.length && (t = this.length);
        for (var i = 0, o = this.head; null !== o && i < e; i++) o = o.next;
        for (; null !== o && i < t; i++, o = o.next) r.push(o.value);
        return r;
      }, n.prototype.sliceReverse = function (e, t) {
        (t = t || this.length) < 0 && (t += this.length), (e = e || 0) < 0 && (e += this.length);
        var r = new n();
        if (t < e || t < 0) return r;
        e < 0 && (e = 0), t > this.length && (t = this.length);
        for (var i = this.length, o = this.tail; null !== o && i > t; i--) o = o.prev;
        for (; null !== o && i > e; i--, o = o.prev) r.push(o.value);
        return r;
      }, n.prototype.splice = function (e, t, ...r) {
        e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
        for (var n = 0, o = this.head; null !== o && n < e; n++) o = o.next;
        var s = [];
        for (n = 0; o && n < t; n++) s.push(o.value), o = this.removeNode(o);
        null === o && (o = this.tail), o !== this.head && o !== this.tail && (o = o.prev);
        for (n = 0; n < r.length; n++) o = i(this, o, r[n]);
        return s;
      }, n.prototype.reverse = function () {
        for (var e = this.head, t = this.tail, r = e; null !== r; r = r.prev) {
          var n = r.prev;
          r.prev = r.next, r.next = n;
        }
        return this.head = t, this.tail = e, this;
      };
      try {
        e("./iterator.js")(n);
      } catch (e) {}
    }, {
      "./iterator.js": 82
    }]
  }, {}, [12])(12);
});

/***/ }),

/***/ 4414:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
var __webpack_unused_export__;


__webpack_require__(4114);
__webpack_unused_export__ = ({
  value: true
});
exports.A = void 0;
var _utils = __webpack_require__(2297);
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
var SpeakTTS = /*#__PURE__*/
function () {
  function SpeakTTS() {
    _classCallCheck(this, SpeakTTS);
    this.browserSupport = 'speechSynthesis' in window && 'SpeechSynthesisUtterance' in window;
    this.synthesisVoice = null;
  }
  _createClass(SpeakTTS, [{
    key: "init",
    value: function init() {
      var _this = this;
      var conf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return new Promise(function (resolve, reject) {
        if (!_this.browserSupport) {
          reject('Your browser does not support Speech Synthesis');
        }
        var listeners = (0, _utils.isNil)(conf.listeners) ? {} : conf.listeners;
        var splitSentences = (0, _utils.isNil)(conf.splitSentences) ? true : conf.splitSentences;
        var lang = (0, _utils.isNil)(conf.lang) ? undefined : conf.lang;
        var volume = (0, _utils.isNil)(conf.volume) ? 1 : conf.volume;
        var rate = (0, _utils.isNil)(conf.rate) ? 1 : conf.rate;
        var pitch = (0, _utils.isNil)(conf.pitch) ? 1 : conf.pitch;
        var voice = (0, _utils.isNil)(conf.voice) ? undefined : conf.voice; // Attach event listeners

        Object.keys(listeners).forEach(function (listener) {
          var fn = listeners[listener];
          var newListener = function newListener(data) {
            fn && fn(data);
          };
          if (listener !== 'onvoiceschanged') {
            speechSynthesis[listener] = newListener;
          }
        });
        _this._loadVoices().then(function (voices) {
          // Handle callback onvoiceschanged by hand
          listeners['onvoiceschanged'] && listeners['onvoiceschanged'](voices); // Initialize values if necessary

          !(0, _utils.isNil)(lang) && _this.setLanguage(lang);
          !(0, _utils.isNil)(voice) && _this.setVoice(voice);
          !(0, _utils.isNil)(volume) && _this.setVolume(volume);
          !(0, _utils.isNil)(rate) && _this.setRate(rate);
          !(0, _utils.isNil)(pitch) && _this.setPitch(pitch);
          !(0, _utils.isNil)(splitSentences) && _this.setSplitSentences(splitSentences);
          resolve({
            voices: voices,
            lang: _this.lang,
            voice: _this.voice,
            volume: _this.volume,
            rate: _this.rate,
            pitch: _this.pitch,
            splitSentences: _this.splitSentences,
            browserSupport: _this.browserSupport
          });
        }).catch(function (e) {
          reject(e);
        });
      });
    }
  }, {
    key: "_fetchVoices",
    value: function _fetchVoices() {
      return new Promise(function (resolve, reject) {
        setTimeout(function () {
          var voices = speechSynthesis.getVoices();
          if ((0, _utils.size)(voices) > 0) {
            return resolve(voices);
          } else {
            return reject("Could not fetch voices");
          }
        }, 100);
      });
    }
  }, {
    key: "_loadVoices",
    value: function _loadVoices() {
      var _this2 = this;
      var remainingAttempts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
      return this._fetchVoices().catch(function (error) {
        if (remainingAttempts === 0) throw error;
        return _this2._loadVoices(remainingAttempts - 1);
      });
    }
  }, {
    key: "hasBrowserSupport",
    value: function hasBrowserSupport() {
      return this.browserSupport;
    }
  }, {
    key: "setVoice",
    value: function setVoice(voice) {
      var synthesisVoice;
      var voices = speechSynthesis.getVoices(); // set voice by name

      if ((0, _utils.isString)(voice)) {
        synthesisVoice = voices.find(function (v) {
          return v.name === voice;
        });
      } // Set the voice in conf if found

      if ((0, _utils.isObject)(voice)) {
        synthesisVoice = voice;
      }
      if (synthesisVoice) {
        this.synthesisVoice = synthesisVoice;
      } else {
        throw 'Error setting voice. The voice you passed is not valid or the voices have not been loaded yet.';
      }
    }
  }, {
    key: "setLanguage",
    value: function setLanguage(lang) {
      lang = lang.replace('_', '-'); // some Android versions seem to ignore BCP 47 and use an underscore character in language tag

      if ((0, _utils.validateLocale)(lang)) {
        this.lang = lang;
      } else {
        throw 'Error setting language. Please verify your locale is BCP47 format (http://schneegans.de/lv/?tags=es-FR&format=text)';
      }
    }
  }, {
    key: "setVolume",
    value: function setVolume(volume) {
      volume = parseFloat(volume);
      if (!(0, _utils.isNan)(volume) && volume >= 0 && volume <= 1) {
        this.volume = volume;
      } else {
        throw 'Error setting volume. Please verify your volume value is a number between 0 and 1.';
      }
    }
  }, {
    key: "setRate",
    value: function setRate(rate) {
      rate = parseFloat(rate);
      if (!(0, _utils.isNan)(rate) && rate >= 0 && rate <= 10) {
        this.rate = rate;
      } else {
        throw 'Error setting rate. Please verify your volume value is a number between 0 and 10.';
      }
    }
  }, {
    key: "setPitch",
    value: function setPitch(pitch) {
      pitch = parseFloat(pitch);
      if (!(0, _utils.isNan)(pitch) && pitch >= 0 && pitch <= 2) {
        this.pitch = pitch;
      } else {
        throw 'Error setting pitch. Please verify your pitch value is a number between 0 and 2.';
      }
    }
  }, {
    key: "setSplitSentences",
    value: function setSplitSentences(splitSentences) {
      this.splitSentences = splitSentences;
    }
  }, {
    key: "speak",
    value: function speak(data) {
      var _this3 = this;
      return new Promise(function (resolve, reject) {
        var text = data.text,
          _data$listeners = data.listeners,
          listeners = _data$listeners === void 0 ? {} : _data$listeners,
          _data$queue = data.queue,
          queue = _data$queue === void 0 ? true : _data$queue;
        var msg = (0, _utils.trim)(text);
        if ((0, _utils.isNil)(msg)) resolve(); // Stop current speech

        !queue && _this3.cancel(); // Split into sentences (for better result and bug with some versions of chrome)

        var utterances = [];
        var sentences = _this3.splitSentences ? (0, _utils.splitSentences)(msg) : [msg];
        sentences.forEach(function (sentence, index) {
          var isLast = index === (0, _utils.size)(sentences) - 1;
          var utterance = new SpeechSynthesisUtterance();
          if (_this3.synthesisVoice) utterance.voice = _this3.synthesisVoice;
          if (_this3.lang) utterance.lang = _this3.lang;
          if (_this3.volume) utterance.volume = _this3.volume; // 0 to 1

          if (_this3.rate) utterance.rate = _this3.rate; // 0.1 to 10

          if (_this3.pitch) utterance.pitch = _this3.pitch; //0 to 2

          utterance.text = sentence; // Attach event listeners

          Object.keys(listeners).forEach(function (listener) {
            var fn = listeners[listener];
            var newListener = function newListener(data) {
              fn && fn(data);
              if (listener === 'onerror') {
                reject({
                  utterances: utterances,
                  lastUtterance: utterance,
                  error: data
                });
              }
              if (listener === 'onend') {
                if (isLast) resolve({
                  utterances: utterances,
                  lastUtterance: utterance
                });
              }
            };
            utterance[listener] = newListener;
          });
          utterances.push(utterance);
          speechSynthesis.speak(utterance);
        });
      });
    }
  }, {
    key: "pending",
    value: function pending() {
      return speechSynthesis.pending;
    }
  }, {
    key: "paused",
    value: function paused() {
      return speechSynthesis.paused;
    }
  }, {
    key: "speaking",
    value: function speaking() {
      return speechSynthesis.speaking;
    }
  }, {
    key: "pause",
    value: function pause() {
      speechSynthesis.pause();
    }
  }, {
    key: "resume",
    value: function resume() {
      speechSynthesis.resume();
    }
  }, {
    key: "cancel",
    value: function cancel() {
      speechSynthesis.cancel();
    }
  }]);
  return SpeakTTS;
}();
var _default = SpeakTTS;
exports.A = _default;

/***/ }),

/***/ 2297:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.trim = exports.isObject = exports.isNil = exports.isNan = exports.size = exports.isString = exports.validateLocale = exports.splitSentences = void 0;
var splitSentences = function splitSentences() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return text.replace(/\.+/g, '.|').replace(/\?/g, '?|').replace(/\!/g, '!|').split("|").map(function (sentence) {
    return trim(sentence);
  }).filter(Boolean);
};
exports.splitSentences = splitSentences;
var bcp47LocalePattern = /^(?:(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))$|^((?:[a-z]{2,3}(?:(?:-[a-z]{3}){1,3})?)|[a-z]{4}|[a-z]{5,8})(?:-([a-z]{4}))?(?:-([a-z]{2}|\d{3}))?((?:-(?:[\da-z]{5,8}|\d[\da-z]{3}))*)?((?:-[\da-wy-z](?:-[\da-z]{2,8})+)*)?(-x(?:-[\da-z]{1,8})+)?$|^(x(?:-[\da-z]{1,8})+)$/i; // eslint-disable-line max-len

/**
 * Validate a locale string to test if it is bcp47 compliant
 * @param {String} locale The tag locale to parse
 * @return {Boolean} True if tag is bcp47 compliant false otherwise
 */

var validateLocale = function validateLocale(locale) {
  return typeof locale !== 'string' ? false : bcp47LocalePattern.test(locale);
};
exports.validateLocale = validateLocale;
var isString = function isString(value) {
  return typeof value === 'string' || value instanceof String;
};
exports.isString = isString;
var size = function size(value) {
  return value && Array.isArray(value) && value.length ? value.length : 0;
};
exports.size = size;
var isNan = function isNan(value) {
  return typeof value === "number" && isNaN(value);
};
exports.isNan = isNan;
var isNil = function isNil(value) {
  return value === null || value === undefined;
};
exports.isNil = isNil;
var isObject = function isObject(value) {
  return Object.prototype.toString.call(value) === '[object Object]';
};
exports.isObject = isObject;
var trim = function trim(value) {
  return isString(value) ? value.trim() : '';
};
exports.trim = trim;

/***/ }),

/***/ 9306:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var isCallable = __webpack_require__(4901);
var tryToString = __webpack_require__(6823);

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw new $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ 3506:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var isPossiblePrototype = __webpack_require__(3925);

var $String = String;
var $TypeError = TypeError;

module.exports = function (argument) {
  if (isPossiblePrototype(argument)) return argument;
  throw new $TypeError("Can't set " + $String(argument) + ' as a prototype');
};


/***/ }),

/***/ 7080:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var has = (__webpack_require__(4402).has);

// Perform ? RequireInternalSlot(M, [[SetData]])
module.exports = function (it) {
  has(it);
  return it;
};


/***/ }),

/***/ 679:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var isPrototypeOf = __webpack_require__(1625);

var $TypeError = TypeError;

module.exports = function (it, Prototype) {
  if (isPrototypeOf(Prototype, it)) return it;
  throw new $TypeError('Incorrect invocation');
};


/***/ }),

/***/ 8551:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var isObject = __webpack_require__(34);

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw new $TypeError($String(argument) + ' is not an object');
};


/***/ }),

/***/ 7811:
/***/ (function(module) {

"use strict";

// eslint-disable-next-line es/no-typed-arrays -- safe
module.exports = typeof ArrayBuffer != 'undefined' && typeof DataView != 'undefined';


/***/ }),

/***/ 7394:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var globalThis = __webpack_require__(4576);
var uncurryThisAccessor = __webpack_require__(6706);
var classof = __webpack_require__(2195);

var ArrayBuffer = globalThis.ArrayBuffer;
var TypeError = globalThis.TypeError;

// Includes
// - Perform ? RequireInternalSlot(O, [[ArrayBufferData]]).
// - If IsSharedArrayBuffer(O) is true, throw a TypeError exception.
module.exports = ArrayBuffer && uncurryThisAccessor(ArrayBuffer.prototype, 'byteLength', 'get') || function (O) {
  if (classof(O) !== 'ArrayBuffer') throw new TypeError('ArrayBuffer expected');
  return O.byteLength;
};


/***/ }),

/***/ 3238:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var globalThis = __webpack_require__(4576);
var uncurryThis = __webpack_require__(7476);
var arrayBufferByteLength = __webpack_require__(7394);

var ArrayBuffer = globalThis.ArrayBuffer;
var ArrayBufferPrototype = ArrayBuffer && ArrayBuffer.prototype;
var slice = ArrayBufferPrototype && uncurryThis(ArrayBufferPrototype.slice);

module.exports = function (O) {
  if (arrayBufferByteLength(O) !== 0) return false;
  if (!slice) return false;
  try {
    slice(O, 0, 0);
    return false;
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 5169:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var isDetached = __webpack_require__(3238);

var $TypeError = TypeError;

module.exports = function (it) {
  if (isDetached(it)) throw new $TypeError('ArrayBuffer is detached');
  return it;
};


/***/ }),

/***/ 5636:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var globalThis = __webpack_require__(4576);
var uncurryThis = __webpack_require__(9504);
var uncurryThisAccessor = __webpack_require__(6706);
var toIndex = __webpack_require__(7696);
var notDetached = __webpack_require__(5169);
var arrayBufferByteLength = __webpack_require__(7394);
var detachTransferable = __webpack_require__(4483);
var PROPER_STRUCTURED_CLONE_TRANSFER = __webpack_require__(1548);

var structuredClone = globalThis.structuredClone;
var ArrayBuffer = globalThis.ArrayBuffer;
var DataView = globalThis.DataView;
var min = Math.min;
var ArrayBufferPrototype = ArrayBuffer.prototype;
var DataViewPrototype = DataView.prototype;
var slice = uncurryThis(ArrayBufferPrototype.slice);
var isResizable = uncurryThisAccessor(ArrayBufferPrototype, 'resizable', 'get');
var maxByteLength = uncurryThisAccessor(ArrayBufferPrototype, 'maxByteLength', 'get');
var getInt8 = uncurryThis(DataViewPrototype.getInt8);
var setInt8 = uncurryThis(DataViewPrototype.setInt8);

module.exports = (PROPER_STRUCTURED_CLONE_TRANSFER || detachTransferable) && function (arrayBuffer, newLength, preserveResizability) {
  var byteLength = arrayBufferByteLength(arrayBuffer);
  var newByteLength = newLength === undefined ? byteLength : toIndex(newLength);
  var fixedLength = !isResizable || !isResizable(arrayBuffer);
  var newBuffer;
  notDetached(arrayBuffer);
  if (PROPER_STRUCTURED_CLONE_TRANSFER) {
    arrayBuffer = structuredClone(arrayBuffer, { transfer: [arrayBuffer] });
    if (byteLength === newByteLength && (preserveResizability || fixedLength)) return arrayBuffer;
  }
  if (byteLength >= newByteLength && (!preserveResizability || fixedLength)) {
    newBuffer = slice(arrayBuffer, 0, newByteLength);
  } else {
    var options = preserveResizability && !fixedLength && maxByteLength ? { maxByteLength: maxByteLength(arrayBuffer) } : undefined;
    newBuffer = new ArrayBuffer(newByteLength, options);
    var a = new DataView(arrayBuffer);
    var b = new DataView(newBuffer);
    var copyLength = min(newByteLength, byteLength);
    for (var i = 0; i < copyLength; i++) setInt8(b, i, getInt8(a, i));
  }
  if (!PROPER_STRUCTURED_CLONE_TRANSFER) detachTransferable(arrayBuffer);
  return newBuffer;
};


/***/ }),

/***/ 4644:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var NATIVE_ARRAY_BUFFER = __webpack_require__(7811);
var DESCRIPTORS = __webpack_require__(3724);
var globalThis = __webpack_require__(4576);
var isCallable = __webpack_require__(4901);
var isObject = __webpack_require__(34);
var hasOwn = __webpack_require__(9297);
var classof = __webpack_require__(6955);
var tryToString = __webpack_require__(6823);
var createNonEnumerableProperty = __webpack_require__(6699);
var defineBuiltIn = __webpack_require__(6840);
var defineBuiltInAccessor = __webpack_require__(2106);
var isPrototypeOf = __webpack_require__(1625);
var getPrototypeOf = __webpack_require__(2787);
var setPrototypeOf = __webpack_require__(2967);
var wellKnownSymbol = __webpack_require__(8227);
var uid = __webpack_require__(3392);
var InternalStateModule = __webpack_require__(1181);

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var Int8Array = globalThis.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var Uint8ClampedArray = globalThis.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
var TypedArray = Int8Array && getPrototypeOf(Int8Array);
var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype = Object.prototype;
var TypeError = globalThis.TypeError;

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
var TYPED_ARRAY_CONSTRUCTOR = 'TypedArrayConstructor';
// Fixing native typed arrays in Opera Presto crashes the browser, see #595
var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(globalThis.opera) !== 'Opera';
var TYPED_ARRAY_TAG_REQUIRED = false;
var NAME, Constructor, Prototype;

var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};

var BigIntArrayConstructorsList = {
  BigInt64Array: 8,
  BigUint64Array: 8
};

var isView = function isView(it) {
  if (!isObject(it)) return false;
  var klass = classof(it);
  return klass === 'DataView'
    || hasOwn(TypedArrayConstructorsList, klass)
    || hasOwn(BigIntArrayConstructorsList, klass);
};

var getTypedArrayConstructor = function (it) {
  var proto = getPrototypeOf(it);
  if (!isObject(proto)) return;
  var state = getInternalState(proto);
  return (state && hasOwn(state, TYPED_ARRAY_CONSTRUCTOR)) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);
};

var isTypedArray = function (it) {
  if (!isObject(it)) return false;
  var klass = classof(it);
  return hasOwn(TypedArrayConstructorsList, klass)
    || hasOwn(BigIntArrayConstructorsList, klass);
};

var aTypedArray = function (it) {
  if (isTypedArray(it)) return it;
  throw new TypeError('Target is not a typed array');
};

var aTypedArrayConstructor = function (C) {
  if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C))) return C;
  throw new TypeError(tryToString(C) + ' is not a typed array constructor');
};

var exportTypedArrayMethod = function (KEY, property, forced, options) {
  if (!DESCRIPTORS) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = globalThis[ARRAY];
    if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY)) try {
      delete TypedArrayConstructor.prototype[KEY];
    } catch (error) {
      // old WebKit bug - some methods are non-configurable
      try {
        TypedArrayConstructor.prototype[KEY] = property;
      } catch (error2) { /* empty */ }
    }
  }
  if (!TypedArrayPrototype[KEY] || forced) {
    defineBuiltIn(TypedArrayPrototype, KEY, forced ? property
      : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);
  }
};

var exportTypedArrayStaticMethod = function (KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!DESCRIPTORS) return;
  if (setPrototypeOf) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = globalThis[ARRAY];
      if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY)) try {
        delete TypedArrayConstructor[KEY];
      } catch (error) { /* empty */ }
    }
    if (!TypedArray[KEY] || forced) {
      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
      try {
        return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
      } catch (error) { /* empty */ }
    } else return;
  }
  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = globalThis[ARRAY];
    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      defineBuiltIn(TypedArrayConstructor, KEY, property);
    }
  }
};

for (NAME in TypedArrayConstructorsList) {
  Constructor = globalThis[NAME];
  Prototype = Constructor && Constructor.prototype;
  if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
  else NATIVE_ARRAY_BUFFER_VIEWS = false;
}

for (NAME in BigIntArrayConstructorsList) {
  Constructor = globalThis[NAME];
  Prototype = Constructor && Constructor.prototype;
  if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
}

// WebKit bug - typed arrays constructors prototype is Object.prototype
if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
  // eslint-disable-next-line no-shadow -- safe
  TypedArray = function TypedArray() {
    throw new TypeError('Incorrect invocation');
  };
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (globalThis[NAME]) setPrototypeOf(globalThis[NAME], TypedArray);
  }
}

if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
  TypedArrayPrototype = TypedArray.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (globalThis[NAME]) setPrototypeOf(globalThis[NAME].prototype, TypedArrayPrototype);
  }
}

// WebKit bug - one more object in Uint8ClampedArray prototype chain
if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
  setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
}

if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
  TYPED_ARRAY_TAG_REQUIRED = true;
  defineBuiltInAccessor(TypedArrayPrototype, TO_STRING_TAG, {
    configurable: true,
    get: function () {
      return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
    }
  });
  for (NAME in TypedArrayConstructorsList) if (globalThis[NAME]) {
    createNonEnumerableProperty(globalThis[NAME], TYPED_ARRAY_TAG, NAME);
  }
}

module.exports = {
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
  aTypedArray: aTypedArray,
  aTypedArrayConstructor: aTypedArrayConstructor,
  exportTypedArrayMethod: exportTypedArrayMethod,
  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
  getTypedArrayConstructor: getTypedArrayConstructor,
  isView: isView,
  isTypedArray: isTypedArray,
  TypedArray: TypedArray,
  TypedArrayPrototype: TypedArrayPrototype
};


/***/ }),

/***/ 5370:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var lengthOfArrayLike = __webpack_require__(6198);

module.exports = function (Constructor, list, $length) {
  var index = 0;
  var length = arguments.length > 2 ? $length : lengthOfArrayLike(list);
  var result = new Constructor(length);
  while (length > index) result[index] = list[index++];
  return result;
};


/***/ }),

/***/ 9617:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var toIndexedObject = __webpack_require__(5397);
var toAbsoluteIndex = __webpack_require__(5610);
var lengthOfArrayLike = __webpack_require__(6198);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    if (length === 0) return !IS_INCLUDES && -1;
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el !== el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value !== value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 4527:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__(3724);
var isArray = __webpack_require__(4376);

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Safari < 13 does not throw an error in this case
var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function () {
  // makes no sense without proper strict mode support
  if (this !== undefined) return true;
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty([], 'length', { writable: false }).length = 1;
  } catch (error) {
    return error instanceof TypeError;
  }
}();

module.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function (O, length) {
  if (isArray(O) && !getOwnPropertyDescriptor(O, 'length').writable) {
    throw new $TypeError('Cannot set read only .length');
  } return O.length = length;
} : function (O, length) {
  return O.length = length;
};


/***/ }),

/***/ 7628:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var lengthOfArrayLike = __webpack_require__(6198);

// https://tc39.es/proposal-change-array-by-copy/#sec-array.prototype.toReversed
// https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.toReversed
module.exports = function (O, C) {
  var len = lengthOfArrayLike(O);
  var A = new C(len);
  var k = 0;
  for (; k < len; k++) A[k] = O[len - k - 1];
  return A;
};


/***/ }),

/***/ 9928:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var lengthOfArrayLike = __webpack_require__(6198);
var toIntegerOrInfinity = __webpack_require__(1291);

var $RangeError = RangeError;

// https://tc39.es/proposal-change-array-by-copy/#sec-array.prototype.with
// https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.with
module.exports = function (O, C, index, value) {
  var len = lengthOfArrayLike(O);
  var relativeIndex = toIntegerOrInfinity(index);
  var actualIndex = relativeIndex < 0 ? len + relativeIndex : relativeIndex;
  if (actualIndex >= len || actualIndex < 0) throw new $RangeError('Incorrect index');
  var A = new C(len);
  var k = 0;
  for (; k < len; k++) A[k] = k === actualIndex ? value : O[k];
  return A;
};


/***/ }),

/***/ 2195:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var uncurryThis = __webpack_require__(9504);

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ 6955:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(2140);
var isCallable = __webpack_require__(4901);
var classofRaw = __webpack_require__(2195);
var wellKnownSymbol = __webpack_require__(8227);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) === 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) === 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ 7740:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var hasOwn = __webpack_require__(9297);
var ownKeys = __webpack_require__(5031);
var getOwnPropertyDescriptorModule = __webpack_require__(7347);
var definePropertyModule = __webpack_require__(4913);

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};


/***/ }),

/***/ 2211:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(9039);

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ 6699:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__(3724);
var definePropertyModule = __webpack_require__(4913);
var createPropertyDescriptor = __webpack_require__(6980);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 6980:
/***/ (function(module) {

"use strict";

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 2106:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var makeBuiltIn = __webpack_require__(283);
var defineProperty = __webpack_require__(4913);

module.exports = function (target, name, descriptor) {
  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
  return defineProperty.f(target, name, descriptor);
};


/***/ }),

/***/ 6840:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var isCallable = __webpack_require__(4901);
var definePropertyModule = __webpack_require__(4913);
var makeBuiltIn = __webpack_require__(283);
var defineGlobalProperty = __webpack_require__(9433);

module.exports = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) { /* empty */ }
    if (simple) O[key] = value;
    else definePropertyModule.f(O, key, {
      value: value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  } return O;
};


/***/ }),

/***/ 9433:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var globalThis = __webpack_require__(4576);

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(globalThis, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    globalThis[key] = value;
  } return value;
};


/***/ }),

/***/ 3724:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(9039);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;
});


/***/ }),

/***/ 4483:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var globalThis = __webpack_require__(4576);
var getBuiltInNodeModule = __webpack_require__(9429);
var PROPER_STRUCTURED_CLONE_TRANSFER = __webpack_require__(1548);

var structuredClone = globalThis.structuredClone;
var $ArrayBuffer = globalThis.ArrayBuffer;
var $MessageChannel = globalThis.MessageChannel;
var detach = false;
var WorkerThreads, channel, buffer, $detach;

if (PROPER_STRUCTURED_CLONE_TRANSFER) {
  detach = function (transferable) {
    structuredClone(transferable, { transfer: [transferable] });
  };
} else if ($ArrayBuffer) try {
  if (!$MessageChannel) {
    WorkerThreads = getBuiltInNodeModule('worker_threads');
    if (WorkerThreads) $MessageChannel = WorkerThreads.MessageChannel;
  }

  if ($MessageChannel) {
    channel = new $MessageChannel();
    buffer = new $ArrayBuffer(2);

    $detach = function (transferable) {
      channel.port1.postMessage(null, [transferable]);
    };

    if (buffer.byteLength === 2) {
      $detach(buffer);
      if (buffer.byteLength === 0) detach = $detach;
    }
  }
} catch (error) { /* empty */ }

module.exports = detach;


/***/ }),

/***/ 4055:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var globalThis = __webpack_require__(4576);
var isObject = __webpack_require__(34);

var document = globalThis.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 6837:
/***/ (function(module) {

"use strict";

var $TypeError = TypeError;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

module.exports = function (it) {
  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
  return it;
};


/***/ }),

/***/ 5002:
/***/ (function(module) {

"use strict";

module.exports = {
  IndexSizeError: { s: 'INDEX_SIZE_ERR', c: 1, m: 1 },
  DOMStringSizeError: { s: 'DOMSTRING_SIZE_ERR', c: 2, m: 0 },
  HierarchyRequestError: { s: 'HIERARCHY_REQUEST_ERR', c: 3, m: 1 },
  WrongDocumentError: { s: 'WRONG_DOCUMENT_ERR', c: 4, m: 1 },
  InvalidCharacterError: { s: 'INVALID_CHARACTER_ERR', c: 5, m: 1 },
  NoDataAllowedError: { s: 'NO_DATA_ALLOWED_ERR', c: 6, m: 0 },
  NoModificationAllowedError: { s: 'NO_MODIFICATION_ALLOWED_ERR', c: 7, m: 1 },
  NotFoundError: { s: 'NOT_FOUND_ERR', c: 8, m: 1 },
  NotSupportedError: { s: 'NOT_SUPPORTED_ERR', c: 9, m: 1 },
  InUseAttributeError: { s: 'INUSE_ATTRIBUTE_ERR', c: 10, m: 1 },
  InvalidStateError: { s: 'INVALID_STATE_ERR', c: 11, m: 1 },
  SyntaxError: { s: 'SYNTAX_ERR', c: 12, m: 1 },
  InvalidModificationError: { s: 'INVALID_MODIFICATION_ERR', c: 13, m: 1 },
  NamespaceError: { s: 'NAMESPACE_ERR', c: 14, m: 1 },
  InvalidAccessError: { s: 'INVALID_ACCESS_ERR', c: 15, m: 1 },
  ValidationError: { s: 'VALIDATION_ERR', c: 16, m: 0 },
  TypeMismatchError: { s: 'TYPE_MISMATCH_ERR', c: 17, m: 1 },
  SecurityError: { s: 'SECURITY_ERR', c: 18, m: 1 },
  NetworkError: { s: 'NETWORK_ERR', c: 19, m: 1 },
  AbortError: { s: 'ABORT_ERR', c: 20, m: 1 },
  URLMismatchError: { s: 'URL_MISMATCH_ERR', c: 21, m: 1 },
  QuotaExceededError: { s: 'QUOTA_EXCEEDED_ERR', c: 22, m: 1 },
  TimeoutError: { s: 'TIMEOUT_ERR', c: 23, m: 1 },
  InvalidNodeTypeError: { s: 'INVALID_NODE_TYPE_ERR', c: 24, m: 1 },
  DataCloneError: { s: 'DATA_CLONE_ERR', c: 25, m: 1 }
};


/***/ }),

/***/ 8727:
/***/ (function(module) {

"use strict";

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ 8574:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var ENVIRONMENT = __webpack_require__(4215);

module.exports = ENVIRONMENT === 'NODE';


/***/ }),

/***/ 2839:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var globalThis = __webpack_require__(4576);

var navigator = globalThis.navigator;
var userAgent = navigator && navigator.userAgent;

module.exports = userAgent ? String(userAgent) : '';


/***/ }),

/***/ 9519:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var globalThis = __webpack_require__(4576);
var userAgent = __webpack_require__(2839);

var process = globalThis.process;
var Deno = globalThis.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ 4215:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

/* global Bun, Deno -- detection */
var globalThis = __webpack_require__(4576);
var userAgent = __webpack_require__(2839);
var classof = __webpack_require__(2195);

var userAgentStartsWith = function (string) {
  return userAgent.slice(0, string.length) === string;
};

module.exports = (function () {
  if (userAgentStartsWith('Bun/')) return 'BUN';
  if (userAgentStartsWith('Cloudflare-Workers')) return 'CLOUDFLARE';
  if (userAgentStartsWith('Deno/')) return 'DENO';
  if (userAgentStartsWith('Node.js/')) return 'NODE';
  if (globalThis.Bun && typeof Bun.version == 'string') return 'BUN';
  if (globalThis.Deno && typeof Deno.version == 'object') return 'DENO';
  if (classof(globalThis.process) === 'process') return 'NODE';
  if (globalThis.window && globalThis.document) return 'BROWSER';
  return 'REST';
})();


/***/ }),

/***/ 6193:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var uncurryThis = __webpack_require__(9504);

var $Error = Error;
var replace = uncurryThis(''.replace);

var TEST = (function (arg) { return String(new $Error(arg).stack); })('zxcasd');
// eslint-disable-next-line redos/no-vulnerable -- safe
var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);

module.exports = function (stack, dropEntries) {
  if (IS_V8_OR_CHAKRA_STACK && typeof stack == 'string' && !$Error.prepareStackTrace) {
    while (dropEntries--) stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, '');
  } return stack;
};


/***/ }),

/***/ 6518:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var globalThis = __webpack_require__(4576);
var getOwnPropertyDescriptor = (__webpack_require__(7347).f);
var createNonEnumerableProperty = __webpack_require__(6699);
var defineBuiltIn = __webpack_require__(6840);
var defineGlobalProperty = __webpack_require__(9433);
var copyConstructorProperties = __webpack_require__(7740);
var isForced = __webpack_require__(2796);

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = globalThis;
  } else if (STATIC) {
    target = globalThis[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = globalThis[TARGET] && globalThis[TARGET].prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    defineBuiltIn(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ 9039:
/***/ (function(module) {

"use strict";

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 616:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(9039);

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ 9565:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var NATIVE_BIND = __webpack_require__(616);

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ 350:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__(3724);
var hasOwn = __webpack_require__(9297);

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ 6706:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var uncurryThis = __webpack_require__(9504);
var aCallable = __webpack_require__(9306);

module.exports = function (object, key, method) {
  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
  } catch (error) { /* empty */ }
};


/***/ }),

/***/ 7476:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var classofRaw = __webpack_require__(2195);
var uncurryThis = __webpack_require__(9504);

module.exports = function (fn) {
  // Nashorn bug:
  //   https://github.com/zloirock/core-js/issues/1128
  //   https://github.com/zloirock/core-js/issues/1130
  if (classofRaw(fn) === 'Function') return uncurryThis(fn);
};


/***/ }),

/***/ 9504:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var NATIVE_BIND = __webpack_require__(616);

var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);

module.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
  return function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ 9429:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var globalThis = __webpack_require__(4576);
var IS_NODE = __webpack_require__(8574);

module.exports = function (name) {
  if (IS_NODE) {
    try {
      return globalThis.process.getBuiltinModule(name);
    } catch (error) { /* empty */ }
    try {
      // eslint-disable-next-line no-new-func -- safe
      return Function('return require("' + name + '")')();
    } catch (error) { /* empty */ }
  }
};


/***/ }),

/***/ 7751:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var globalThis = __webpack_require__(4576);
var isCallable = __webpack_require__(4901);

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(globalThis[namespace]) : globalThis[namespace] && globalThis[namespace][method];
};


/***/ }),

/***/ 1767:
/***/ (function(module) {

"use strict";

// `GetIteratorDirect(obj)` abstract operation
// https://tc39.es/proposal-iterator-helpers/#sec-getiteratordirect
module.exports = function (obj) {
  return {
    iterator: obj,
    next: obj.next,
    done: false
  };
};


/***/ }),

/***/ 5966:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var aCallable = __webpack_require__(9306);
var isNullOrUndefined = __webpack_require__(4117);

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? undefined : aCallable(func);
};


/***/ }),

/***/ 3789:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var aCallable = __webpack_require__(9306);
var anObject = __webpack_require__(8551);
var call = __webpack_require__(9565);
var toIntegerOrInfinity = __webpack_require__(1291);
var getIteratorDirect = __webpack_require__(1767);

var INVALID_SIZE = 'Invalid size';
var $RangeError = RangeError;
var $TypeError = TypeError;
var max = Math.max;

var SetRecord = function (set, intSize) {
  this.set = set;
  this.size = max(intSize, 0);
  this.has = aCallable(set.has);
  this.keys = aCallable(set.keys);
};

SetRecord.prototype = {
  getIterator: function () {
    return getIteratorDirect(anObject(call(this.keys, this.set)));
  },
  includes: function (it) {
    return call(this.has, this.set, it);
  }
};

// `GetSetRecord` abstract operation
// https://tc39.es/proposal-set-methods/#sec-getsetrecord
module.exports = function (obj) {
  anObject(obj);
  var numSize = +obj.size;
  // NOTE: If size is undefined, then numSize will be NaN
  // eslint-disable-next-line no-self-compare -- NaN check
  if (numSize !== numSize) throw new $TypeError(INVALID_SIZE);
  var intSize = toIntegerOrInfinity(numSize);
  if (intSize < 0) throw new $RangeError(INVALID_SIZE);
  return new SetRecord(obj, intSize);
};


/***/ }),

/***/ 4576:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var check = function (it) {
  return it && it.Math === Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  check(typeof this == 'object' && this) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ 9297:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var uncurryThis = __webpack_require__(9504);
var toObject = __webpack_require__(8981);

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ 421:
/***/ (function(module) {

"use strict";

module.exports = {};


/***/ }),

/***/ 5917:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__(3724);
var fails = __webpack_require__(9039);
var createElement = __webpack_require__(4055);

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a !== 7;
});


/***/ }),

/***/ 7055:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var uncurryThis = __webpack_require__(9504);
var fails = __webpack_require__(9039);
var classof = __webpack_require__(2195);

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) === 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),

/***/ 3167:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var isCallable = __webpack_require__(4901);
var isObject = __webpack_require__(34);
var setPrototypeOf = __webpack_require__(2967);

// makes subclassing work correct for wrapped built-ins
module.exports = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf &&
    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    isCallable(NewTarget = dummy.constructor) &&
    NewTarget !== Wrapper &&
    isObject(NewTargetPrototype = NewTarget.prototype) &&
    NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};


/***/ }),

/***/ 3706:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var uncurryThis = __webpack_require__(9504);
var isCallable = __webpack_require__(4901);
var store = __webpack_require__(7629);

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ 1181:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var NATIVE_WEAK_MAP = __webpack_require__(8622);
var globalThis = __webpack_require__(4576);
var isObject = __webpack_require__(34);
var createNonEnumerableProperty = __webpack_require__(6699);
var hasOwn = __webpack_require__(9297);
var shared = __webpack_require__(7629);
var sharedKey = __webpack_require__(6119);
var hiddenKeys = __webpack_require__(421);

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = globalThis.TypeError;
var WeakMap = globalThis.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw new TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  /* eslint-disable no-self-assign -- prototype methods protection */
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  /* eslint-enable no-self-assign -- prototype methods protection */
  set = function (it, metadata) {
    if (store.has(it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get = function (it) {
    return store.get(it) || {};
  };
  has = function (it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ 4376:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var classof = __webpack_require__(2195);

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) === 'Array';
};


/***/ }),

/***/ 1108:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var classof = __webpack_require__(6955);

module.exports = function (it) {
  var klass = classof(it);
  return klass === 'BigInt64Array' || klass === 'BigUint64Array';
};


/***/ }),

/***/ 4901:
/***/ (function(module) {

"use strict";

// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
var documentAll = typeof document == 'object' && document.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
module.exports = typeof documentAll == 'undefined' && documentAll !== undefined ? function (argument) {
  return typeof argument == 'function' || argument === documentAll;
} : function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ 2796:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(9039);
var isCallable = __webpack_require__(4901);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value === POLYFILL ? true
    : value === NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 4117:
/***/ (function(module) {

"use strict";

// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function (it) {
  return it === null || it === undefined;
};


/***/ }),

/***/ 34:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var isCallable = __webpack_require__(4901);

module.exports = function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ 3925:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var isObject = __webpack_require__(34);

module.exports = function (argument) {
  return isObject(argument) || argument === null;
};


/***/ }),

/***/ 6395:
/***/ (function(module) {

"use strict";

module.exports = false;


/***/ }),

/***/ 757:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var getBuiltIn = __webpack_require__(7751);
var isCallable = __webpack_require__(4901);
var isPrototypeOf = __webpack_require__(1625);
var USE_SYMBOL_AS_UID = __webpack_require__(7040);

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),

/***/ 507:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var call = __webpack_require__(9565);

module.exports = function (record, fn, ITERATOR_INSTEAD_OF_RECORD) {
  var iterator = ITERATOR_INSTEAD_OF_RECORD ? record : record.iterator;
  var next = record.next;
  var step, result;
  while (!(step = call(next, iterator)).done) {
    result = fn(step.value);
    if (result !== undefined) return result;
  }
};


/***/ }),

/***/ 9539:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var call = __webpack_require__(9565);
var anObject = __webpack_require__(8551);
var getMethod = __webpack_require__(5966);

module.exports = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject(iterator);
  try {
    innerResult = getMethod(iterator, 'return');
    if (!innerResult) {
      if (kind === 'throw') throw value;
      return value;
    }
    innerResult = call(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === 'throw') throw value;
  if (innerError) throw innerResult;
  anObject(innerResult);
  return value;
};


/***/ }),

/***/ 6198:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var toLength = __webpack_require__(8014);

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ 283:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var uncurryThis = __webpack_require__(9504);
var fails = __webpack_require__(9039);
var isCallable = __webpack_require__(4901);
var hasOwn = __webpack_require__(9297);
var DESCRIPTORS = __webpack_require__(3724);
var CONFIGURABLE_FUNCTION_NAME = (__webpack_require__(350).CONFIGURABLE);
var inspectSource = __webpack_require__(3706);
var InternalStateModule = __webpack_require__(1181);

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var $String = String;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;
var stringSlice = uncurryThis(''.slice);
var replace = uncurryThis(''.replace);
var join = uncurryThis([].join);

var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn = module.exports = function (value, name, options) {
  if (stringSlice($String(name), 0, 7) === 'Symbol(') {
    name = '[' + replace($String(name), /^Symbol\(([^)]*)\).*$/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
    defineProperty(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) { /* empty */ }
  var state = enforceInternalState(value);
  if (!hasOwn(state, 'source')) {
    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');
  } return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn(function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
}, 'toString');


/***/ }),

/***/ 741:
/***/ (function(module) {

"use strict";

var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),

/***/ 2603:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var toString = __webpack_require__(655);

module.exports = function (argument, $default) {
  return argument === undefined ? arguments.length < 2 ? '' : $default : toString(argument);
};


/***/ }),

/***/ 4913:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__(3724);
var IE8_DOM_DEFINE = __webpack_require__(5917);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(8686);
var anObject = __webpack_require__(8551);
var toPropertyKey = __webpack_require__(6969);

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw new $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 7347:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__(3724);
var call = __webpack_require__(9565);
var propertyIsEnumerableModule = __webpack_require__(8773);
var createPropertyDescriptor = __webpack_require__(6980);
var toIndexedObject = __webpack_require__(5397);
var toPropertyKey = __webpack_require__(6969);
var hasOwn = __webpack_require__(9297);
var IE8_DOM_DEFINE = __webpack_require__(5917);

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ 8480:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var internalObjectKeys = __webpack_require__(1828);
var enumBugKeys = __webpack_require__(8727);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ 3717:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 2787:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var hasOwn = __webpack_require__(9297);
var isCallable = __webpack_require__(4901);
var toObject = __webpack_require__(8981);
var sharedKey = __webpack_require__(6119);
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(2211);

var IE_PROTO = sharedKey('IE_PROTO');
var $Object = Object;
var ObjectPrototype = $Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es/no-object-getprototypeof -- safe
module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
  var object = toObject(O);
  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable(constructor) && object instanceof constructor) {
    return constructor.prototype;
  } return object instanceof $Object ? ObjectPrototype : null;
};


/***/ }),

/***/ 1625:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var uncurryThis = __webpack_require__(9504);

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ 1828:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var uncurryThis = __webpack_require__(9504);
var hasOwn = __webpack_require__(9297);
var toIndexedObject = __webpack_require__(5397);
var indexOf = (__webpack_require__(9617).indexOf);
var hiddenKeys = __webpack_require__(421);

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ 8773:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ 2967:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

/* eslint-disable no-proto -- safe */
var uncurryThisAccessor = __webpack_require__(6706);
var isObject = __webpack_require__(34);
var requireObjectCoercible = __webpack_require__(7750);
var aPossiblePrototype = __webpack_require__(3506);

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    requireObjectCoercible(O);
    aPossiblePrototype(proto);
    if (!isObject(O)) return O;
    if (CORRECT_SETTER) setter(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ 4270:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var call = __webpack_require__(9565);
var isCallable = __webpack_require__(4901);
var isObject = __webpack_require__(34);

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw new $TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 5031:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var getBuiltIn = __webpack_require__(7751);
var uncurryThis = __webpack_require__(9504);
var getOwnPropertyNamesModule = __webpack_require__(8480);
var getOwnPropertySymbolsModule = __webpack_require__(3717);
var anObject = __webpack_require__(8551);

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ 7750:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var isNullOrUndefined = __webpack_require__(4117);

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 9286:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var SetHelpers = __webpack_require__(4402);
var iterate = __webpack_require__(8469);

var Set = SetHelpers.Set;
var add = SetHelpers.add;

module.exports = function (set) {
  var result = new Set();
  iterate(set, function (it) {
    add(result, it);
  });
  return result;
};


/***/ }),

/***/ 3440:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var aSet = __webpack_require__(7080);
var SetHelpers = __webpack_require__(4402);
var clone = __webpack_require__(9286);
var size = __webpack_require__(5170);
var getSetRecord = __webpack_require__(3789);
var iterateSet = __webpack_require__(8469);
var iterateSimple = __webpack_require__(507);

var has = SetHelpers.has;
var remove = SetHelpers.remove;

// `Set.prototype.difference` method
// https://github.com/tc39/proposal-set-methods
module.exports = function difference(other) {
  var O = aSet(this);
  var otherRec = getSetRecord(other);
  var result = clone(O);
  if (size(O) <= otherRec.size) iterateSet(O, function (e) {
    if (otherRec.includes(e)) remove(result, e);
  });
  else iterateSimple(otherRec.getIterator(), function (e) {
    if (has(O, e)) remove(result, e);
  });
  return result;
};


/***/ }),

/***/ 4402:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var uncurryThis = __webpack_require__(9504);

// eslint-disable-next-line es/no-set -- safe
var SetPrototype = Set.prototype;

module.exports = {
  // eslint-disable-next-line es/no-set -- safe
  Set: Set,
  add: uncurryThis(SetPrototype.add),
  has: uncurryThis(SetPrototype.has),
  remove: uncurryThis(SetPrototype['delete']),
  proto: SetPrototype
};


/***/ }),

/***/ 8750:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var aSet = __webpack_require__(7080);
var SetHelpers = __webpack_require__(4402);
var size = __webpack_require__(5170);
var getSetRecord = __webpack_require__(3789);
var iterateSet = __webpack_require__(8469);
var iterateSimple = __webpack_require__(507);

var Set = SetHelpers.Set;
var add = SetHelpers.add;
var has = SetHelpers.has;

// `Set.prototype.intersection` method
// https://github.com/tc39/proposal-set-methods
module.exports = function intersection(other) {
  var O = aSet(this);
  var otherRec = getSetRecord(other);
  var result = new Set();

  if (size(O) > otherRec.size) {
    iterateSimple(otherRec.getIterator(), function (e) {
      if (has(O, e)) add(result, e);
    });
  } else {
    iterateSet(O, function (e) {
      if (otherRec.includes(e)) add(result, e);
    });
  }

  return result;
};


/***/ }),

/***/ 4449:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var aSet = __webpack_require__(7080);
var has = (__webpack_require__(4402).has);
var size = __webpack_require__(5170);
var getSetRecord = __webpack_require__(3789);
var iterateSet = __webpack_require__(8469);
var iterateSimple = __webpack_require__(507);
var iteratorClose = __webpack_require__(9539);

// `Set.prototype.isDisjointFrom` method
// https://tc39.github.io/proposal-set-methods/#Set.prototype.isDisjointFrom
module.exports = function isDisjointFrom(other) {
  var O = aSet(this);
  var otherRec = getSetRecord(other);
  if (size(O) <= otherRec.size) return iterateSet(O, function (e) {
    if (otherRec.includes(e)) return false;
  }, true) !== false;
  var iterator = otherRec.getIterator();
  return iterateSimple(iterator, function (e) {
    if (has(O, e)) return iteratorClose(iterator, 'normal', false);
  }) !== false;
};


/***/ }),

/***/ 3838:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var aSet = __webpack_require__(7080);
var size = __webpack_require__(5170);
var iterate = __webpack_require__(8469);
var getSetRecord = __webpack_require__(3789);

// `Set.prototype.isSubsetOf` method
// https://tc39.github.io/proposal-set-methods/#Set.prototype.isSubsetOf
module.exports = function isSubsetOf(other) {
  var O = aSet(this);
  var otherRec = getSetRecord(other);
  if (size(O) > otherRec.size) return false;
  return iterate(O, function (e) {
    if (!otherRec.includes(e)) return false;
  }, true) !== false;
};


/***/ }),

/***/ 8527:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var aSet = __webpack_require__(7080);
var has = (__webpack_require__(4402).has);
var size = __webpack_require__(5170);
var getSetRecord = __webpack_require__(3789);
var iterateSimple = __webpack_require__(507);
var iteratorClose = __webpack_require__(9539);

// `Set.prototype.isSupersetOf` method
// https://tc39.github.io/proposal-set-methods/#Set.prototype.isSupersetOf
module.exports = function isSupersetOf(other) {
  var O = aSet(this);
  var otherRec = getSetRecord(other);
  if (size(O) < otherRec.size) return false;
  var iterator = otherRec.getIterator();
  return iterateSimple(iterator, function (e) {
    if (!has(O, e)) return iteratorClose(iterator, 'normal', false);
  }) !== false;
};


/***/ }),

/***/ 8469:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var uncurryThis = __webpack_require__(9504);
var iterateSimple = __webpack_require__(507);
var SetHelpers = __webpack_require__(4402);

var Set = SetHelpers.Set;
var SetPrototype = SetHelpers.proto;
var forEach = uncurryThis(SetPrototype.forEach);
var keys = uncurryThis(SetPrototype.keys);
var next = keys(new Set()).next;

module.exports = function (set, fn, interruptible) {
  return interruptible ? iterateSimple({ iterator: keys(set), next: next }, fn) : forEach(set, fn);
};


/***/ }),

/***/ 4916:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var getBuiltIn = __webpack_require__(7751);

var createSetLike = function (size) {
  return {
    size: size,
    has: function () {
      return false;
    },
    keys: function () {
      return {
        next: function () {
          return { done: true };
        }
      };
    }
  };
};

module.exports = function (name) {
  var Set = getBuiltIn('Set');
  try {
    new Set()[name](createSetLike(0));
    try {
      // late spec change, early WebKit ~ Safari 17.0 beta implementation does not pass it
      // https://github.com/tc39/proposal-set-methods/pull/88
      new Set()[name](createSetLike(-1));
      return false;
    } catch (error2) {
      return true;
    }
  } catch (error) {
    return false;
  }
};


/***/ }),

/***/ 5170:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var uncurryThisAccessor = __webpack_require__(6706);
var SetHelpers = __webpack_require__(4402);

module.exports = uncurryThisAccessor(SetHelpers.proto, 'size', 'get') || function (set) {
  return set.size;
};


/***/ }),

/***/ 3650:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var aSet = __webpack_require__(7080);
var SetHelpers = __webpack_require__(4402);
var clone = __webpack_require__(9286);
var getSetRecord = __webpack_require__(3789);
var iterateSimple = __webpack_require__(507);

var add = SetHelpers.add;
var has = SetHelpers.has;
var remove = SetHelpers.remove;

// `Set.prototype.symmetricDifference` method
// https://github.com/tc39/proposal-set-methods
module.exports = function symmetricDifference(other) {
  var O = aSet(this);
  var keysIter = getSetRecord(other).getIterator();
  var result = clone(O);
  iterateSimple(keysIter, function (e) {
    if (has(O, e)) remove(result, e);
    else add(result, e);
  });
  return result;
};


/***/ }),

/***/ 4204:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var aSet = __webpack_require__(7080);
var add = (__webpack_require__(4402).add);
var clone = __webpack_require__(9286);
var getSetRecord = __webpack_require__(3789);
var iterateSimple = __webpack_require__(507);

// `Set.prototype.union` method
// https://github.com/tc39/proposal-set-methods
module.exports = function union(other) {
  var O = aSet(this);
  var keysIter = getSetRecord(other).getIterator();
  var result = clone(O);
  iterateSimple(keysIter, function (it) {
    add(result, it);
  });
  return result;
};


/***/ }),

/***/ 6119:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var shared = __webpack_require__(5745);
var uid = __webpack_require__(3392);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ 7629:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var IS_PURE = __webpack_require__(6395);
var globalThis = __webpack_require__(4576);
var defineGlobalProperty = __webpack_require__(9433);

var SHARED = '__core-js_shared__';
var store = module.exports = globalThis[SHARED] || defineGlobalProperty(SHARED, {});

(store.versions || (store.versions = [])).push({
  version: '3.38.1',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2014-2024 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.38.1/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ 5745:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var store = __webpack_require__(7629);

module.exports = function (key, value) {
  return store[key] || (store[key] = value || {});
};


/***/ }),

/***/ 1548:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var globalThis = __webpack_require__(4576);
var fails = __webpack_require__(9039);
var V8 = __webpack_require__(9519);
var ENVIRONMENT = __webpack_require__(4215);

var structuredClone = globalThis.structuredClone;

module.exports = !!structuredClone && !fails(function () {
  // prevent V8 ArrayBufferDetaching protector cell invalidation and performance degradation
  // https://github.com/zloirock/core-js/issues/679
  if ((ENVIRONMENT === 'DENO' && V8 > 92) || (ENVIRONMENT === 'NODE' && V8 > 94) || (ENVIRONMENT === 'BROWSER' && V8 > 97)) return false;
  var buffer = new ArrayBuffer(8);
  var clone = structuredClone(buffer, { transfer: [buffer] });
  return buffer.byteLength !== 0 || clone.byteLength !== 8;
});


/***/ }),

/***/ 4495:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(9519);
var fails = __webpack_require__(9039);
var globalThis = __webpack_require__(4576);

var $String = globalThis.String;

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol('symbol detection');
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
  // of course, fail.
  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ 5610:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var toIntegerOrInfinity = __webpack_require__(1291);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 5854:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var toPrimitive = __webpack_require__(2777);

var $TypeError = TypeError;

// `ToBigInt` abstract operation
// https://tc39.es/ecma262/#sec-tobigint
module.exports = function (argument) {
  var prim = toPrimitive(argument, 'number');
  if (typeof prim == 'number') throw new $TypeError("Can't convert number to bigint");
  // eslint-disable-next-line es/no-bigint -- safe
  return BigInt(prim);
};


/***/ }),

/***/ 7696:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var toIntegerOrInfinity = __webpack_require__(1291);
var toLength = __webpack_require__(8014);

var $RangeError = RangeError;

// `ToIndex` abstract operation
// https://tc39.es/ecma262/#sec-toindex
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toIntegerOrInfinity(it);
  var length = toLength(number);
  if (number !== length) throw new $RangeError('Wrong length or index');
  return length;
};


/***/ }),

/***/ 5397:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(7055);
var requireObjectCoercible = __webpack_require__(7750);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 1291:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var trunc = __webpack_require__(741);

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),

/***/ 8014:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var toIntegerOrInfinity = __webpack_require__(1291);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  var len = toIntegerOrInfinity(argument);
  return len > 0 ? min(len, 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 8981:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var requireObjectCoercible = __webpack_require__(7750);

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 2777:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var call = __webpack_require__(9565);
var isObject = __webpack_require__(34);
var isSymbol = __webpack_require__(757);
var getMethod = __webpack_require__(5966);
var ordinaryToPrimitive = __webpack_require__(4270);
var wellKnownSymbol = __webpack_require__(8227);

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw new $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ 6969:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var toPrimitive = __webpack_require__(2777);
var isSymbol = __webpack_require__(757);

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ 2140:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var wellKnownSymbol = __webpack_require__(8227);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ 655:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var classof = __webpack_require__(6955);

var $String = String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw new TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};


/***/ }),

/***/ 6823:
/***/ (function(module) {

"use strict";

var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ 3392:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var uncurryThis = __webpack_require__(9504);

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ 7040:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(4495);

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 8686:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__(3724);
var fails = __webpack_require__(9039);

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype !== 42;
});


/***/ }),

/***/ 2812:
/***/ (function(module) {

"use strict";

var $TypeError = TypeError;

module.exports = function (passed, required) {
  if (passed < required) throw new $TypeError('Not enough arguments');
  return passed;
};


/***/ }),

/***/ 8622:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var globalThis = __webpack_require__(4576);
var isCallable = __webpack_require__(4901);

var WeakMap = globalThis.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));


/***/ }),

/***/ 8227:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var globalThis = __webpack_require__(4576);
var shared = __webpack_require__(5745);
var hasOwn = __webpack_require__(9297);
var uid = __webpack_require__(3392);
var NATIVE_SYMBOL = __webpack_require__(4495);
var USE_SYMBOL_AS_UID = __webpack_require__(7040);

var Symbol = globalThis.Symbol;
var WellKnownSymbolsStore = shared('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
      ? Symbol[name]
      : createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 6573:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__(3724);
var defineBuiltInAccessor = __webpack_require__(2106);
var isDetached = __webpack_require__(3238);

var ArrayBufferPrototype = ArrayBuffer.prototype;

if (DESCRIPTORS && !('detached' in ArrayBufferPrototype)) {
  defineBuiltInAccessor(ArrayBufferPrototype, 'detached', {
    configurable: true,
    get: function detached() {
      return isDetached(this);
    }
  });
}


/***/ }),

/***/ 7936:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(6518);
var $transfer = __webpack_require__(5636);

// `ArrayBuffer.prototype.transferToFixedLength` method
// https://tc39.es/proposal-arraybuffer-transfer/#sec-arraybuffer.prototype.transfertofixedlength
if ($transfer) $({ target: 'ArrayBuffer', proto: true }, {
  transferToFixedLength: function transferToFixedLength() {
    return $transfer(this, arguments.length ? arguments[0] : undefined, false);
  }
});


/***/ }),

/***/ 8100:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(6518);
var $transfer = __webpack_require__(5636);

// `ArrayBuffer.prototype.transfer` method
// https://tc39.es/proposal-arraybuffer-transfer/#sec-arraybuffer.prototype.transfer
if ($transfer) $({ target: 'ArrayBuffer', proto: true }, {
  transfer: function transfer() {
    return $transfer(this, arguments.length ? arguments[0] : undefined, true);
  }
});


/***/ }),

/***/ 4114:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(6518);
var toObject = __webpack_require__(8981);
var lengthOfArrayLike = __webpack_require__(6198);
var setArrayLength = __webpack_require__(4527);
var doesNotExceedSafeInteger = __webpack_require__(6837);
var fails = __webpack_require__(9039);

var INCORRECT_TO_LENGTH = fails(function () {
  return [].push.call({ length: 0x100000000 }, 1) !== 4294967297;
});

// V8 <= 121 and Safari <= 15.4; FF < 23 throws InternalError
// https://bugs.chromium.org/p/v8/issues/detail?id=12681
var properErrorOnNonWritableLength = function () {
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty([], 'length', { writable: false }).push();
  } catch (error) {
    return error instanceof TypeError;
  }
};

var FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();

// `Array.prototype.push` method
// https://tc39.es/ecma262/#sec-array.prototype.push
$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  push: function push(item) {
    var O = toObject(this);
    var len = lengthOfArrayLike(O);
    var argCount = arguments.length;
    doesNotExceedSafeInteger(len + argCount);
    for (var i = 0; i < argCount; i++) {
      O[len] = arguments[i];
      len++;
    }
    setArrayLength(O, len);
    return len;
  }
});


/***/ }),

/***/ 7642:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(6518);
var difference = __webpack_require__(3440);
var setMethodAcceptSetLike = __webpack_require__(4916);

// `Set.prototype.difference` method
// https://github.com/tc39/proposal-set-methods
$({ target: 'Set', proto: true, real: true, forced: !setMethodAcceptSetLike('difference') }, {
  difference: difference
});


/***/ }),

/***/ 8004:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(6518);
var fails = __webpack_require__(9039);
var intersection = __webpack_require__(8750);
var setMethodAcceptSetLike = __webpack_require__(4916);

var INCORRECT = !setMethodAcceptSetLike('intersection') || fails(function () {
  // eslint-disable-next-line es/no-array-from, es/no-set -- testing
  return String(Array.from(new Set([1, 2, 3]).intersection(new Set([3, 2])))) !== '3,2';
});

// `Set.prototype.intersection` method
// https://github.com/tc39/proposal-set-methods
$({ target: 'Set', proto: true, real: true, forced: INCORRECT }, {
  intersection: intersection
});


/***/ }),

/***/ 3853:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(6518);
var isDisjointFrom = __webpack_require__(4449);
var setMethodAcceptSetLike = __webpack_require__(4916);

// `Set.prototype.isDisjointFrom` method
// https://github.com/tc39/proposal-set-methods
$({ target: 'Set', proto: true, real: true, forced: !setMethodAcceptSetLike('isDisjointFrom') }, {
  isDisjointFrom: isDisjointFrom
});


/***/ }),

/***/ 5876:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(6518);
var isSubsetOf = __webpack_require__(3838);
var setMethodAcceptSetLike = __webpack_require__(4916);

// `Set.prototype.isSubsetOf` method
// https://github.com/tc39/proposal-set-methods
$({ target: 'Set', proto: true, real: true, forced: !setMethodAcceptSetLike('isSubsetOf') }, {
  isSubsetOf: isSubsetOf
});


/***/ }),

/***/ 2475:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(6518);
var isSupersetOf = __webpack_require__(8527);
var setMethodAcceptSetLike = __webpack_require__(4916);

// `Set.prototype.isSupersetOf` method
// https://github.com/tc39/proposal-set-methods
$({ target: 'Set', proto: true, real: true, forced: !setMethodAcceptSetLike('isSupersetOf') }, {
  isSupersetOf: isSupersetOf
});


/***/ }),

/***/ 5024:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(6518);
var symmetricDifference = __webpack_require__(3650);
var setMethodAcceptSetLike = __webpack_require__(4916);

// `Set.prototype.symmetricDifference` method
// https://github.com/tc39/proposal-set-methods
$({ target: 'Set', proto: true, real: true, forced: !setMethodAcceptSetLike('symmetricDifference') }, {
  symmetricDifference: symmetricDifference
});


/***/ }),

/***/ 1698:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(6518);
var union = __webpack_require__(4204);
var setMethodAcceptSetLike = __webpack_require__(4916);

// `Set.prototype.union` method
// https://github.com/tc39/proposal-set-methods
$({ target: 'Set', proto: true, real: true, forced: !setMethodAcceptSetLike('union') }, {
  union: union
});


/***/ }),

/***/ 7467:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var arrayToReversed = __webpack_require__(7628);
var ArrayBufferViewCore = __webpack_require__(4644);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;

// `%TypedArray%.prototype.toReversed` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.toreversed
exportTypedArrayMethod('toReversed', function toReversed() {
  return arrayToReversed(aTypedArray(this), getTypedArrayConstructor(this));
});


/***/ }),

/***/ 4732:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(4644);
var uncurryThis = __webpack_require__(9504);
var aCallable = __webpack_require__(9306);
var arrayFromConstructorAndList = __webpack_require__(5370);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var sort = uncurryThis(ArrayBufferViewCore.TypedArrayPrototype.sort);

// `%TypedArray%.prototype.toSorted` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tosorted
exportTypedArrayMethod('toSorted', function toSorted(compareFn) {
  if (compareFn !== undefined) aCallable(compareFn);
  var O = aTypedArray(this);
  var A = arrayFromConstructorAndList(getTypedArrayConstructor(O), O);
  return sort(A, compareFn);
});


/***/ }),

/***/ 9577:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var arrayWith = __webpack_require__(9928);
var ArrayBufferViewCore = __webpack_require__(4644);
var isBigIntArray = __webpack_require__(1108);
var toIntegerOrInfinity = __webpack_require__(1291);
var toBigInt = __webpack_require__(5854);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

var PROPER_ORDER = !!function () {
  try {
    // eslint-disable-next-line no-throw-literal, es/no-typed-arrays, es/no-array-prototype-with -- required for testing
    new Int8Array(1)['with'](2, { valueOf: function () { throw 8; } });
  } catch (error) {
    // some early implementations, like WebKit, does not follow the final semantic
    // https://github.com/tc39/proposal-change-array-by-copy/pull/86
    return error === 8;
  }
}();

// `%TypedArray%.prototype.with` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.with
exportTypedArrayMethod('with', { 'with': function (index, value) {
  var O = aTypedArray(this);
  var relativeIndex = toIntegerOrInfinity(index);
  var actualValue = isBigIntArray(O) ? toBigInt(value) : +value;
  return arrayWith(O, getTypedArrayConstructor(O), relativeIndex, actualValue);
} }['with'], !PROPER_ORDER);


/***/ }),

/***/ 4979:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(6518);
var globalThis = __webpack_require__(4576);
var getBuiltIn = __webpack_require__(7751);
var createPropertyDescriptor = __webpack_require__(6980);
var defineProperty = (__webpack_require__(4913).f);
var hasOwn = __webpack_require__(9297);
var anInstance = __webpack_require__(679);
var inheritIfRequired = __webpack_require__(3167);
var normalizeStringArgument = __webpack_require__(2603);
var DOMExceptionConstants = __webpack_require__(5002);
var clearErrorStack = __webpack_require__(6193);
var DESCRIPTORS = __webpack_require__(3724);
var IS_PURE = __webpack_require__(6395);

var DOM_EXCEPTION = 'DOMException';
var Error = getBuiltIn('Error');
var NativeDOMException = getBuiltIn(DOM_EXCEPTION);

var $DOMException = function DOMException() {
  anInstance(this, DOMExceptionPrototype);
  var argumentsLength = arguments.length;
  var message = normalizeStringArgument(argumentsLength < 1 ? undefined : arguments[0]);
  var name = normalizeStringArgument(argumentsLength < 2 ? undefined : arguments[1], 'Error');
  var that = new NativeDOMException(message, name);
  var error = new Error(message);
  error.name = DOM_EXCEPTION;
  defineProperty(that, 'stack', createPropertyDescriptor(1, clearErrorStack(error.stack, 1)));
  inheritIfRequired(that, this, $DOMException);
  return that;
};

var DOMExceptionPrototype = $DOMException.prototype = NativeDOMException.prototype;

var ERROR_HAS_STACK = 'stack' in new Error(DOM_EXCEPTION);
var DOM_EXCEPTION_HAS_STACK = 'stack' in new NativeDOMException(1, 2);

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var descriptor = NativeDOMException && DESCRIPTORS && Object.getOwnPropertyDescriptor(globalThis, DOM_EXCEPTION);

// Bun ~ 0.1.1 DOMException have incorrect descriptor and we can't redefine it
// https://github.com/Jarred-Sumner/bun/issues/399
var BUGGY_DESCRIPTOR = !!descriptor && !(descriptor.writable && descriptor.configurable);

var FORCED_CONSTRUCTOR = ERROR_HAS_STACK && !BUGGY_DESCRIPTOR && !DOM_EXCEPTION_HAS_STACK;

// `DOMException` constructor patch for `.stack` where it's required
// https://webidl.spec.whatwg.org/#es-DOMException-specialness
$({ global: true, constructor: true, forced: IS_PURE || FORCED_CONSTRUCTOR }, { // TODO: fix export logic
  DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException
});

var PolyfilledDOMException = getBuiltIn(DOM_EXCEPTION);
var PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;

if (PolyfilledDOMExceptionPrototype.constructor !== PolyfilledDOMException) {
  if (!IS_PURE) {
    defineProperty(PolyfilledDOMExceptionPrototype, 'constructor', createPropertyDescriptor(1, PolyfilledDOMException));
  }

  for (var key in DOMExceptionConstants) if (hasOwn(DOMExceptionConstants, key)) {
    var constant = DOMExceptionConstants[key];
    var constantName = constant.s;
    if (!hasOwn(PolyfilledDOMException, constantName)) {
      defineProperty(PolyfilledDOMException, constantName, createPropertyDescriptor(6, constant.c));
    }
  }
}


/***/ }),

/***/ 4603:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var defineBuiltIn = __webpack_require__(6840);
var uncurryThis = __webpack_require__(9504);
var toString = __webpack_require__(655);
var validateArgumentsLength = __webpack_require__(2812);

var $URLSearchParams = URLSearchParams;
var URLSearchParamsPrototype = $URLSearchParams.prototype;
var append = uncurryThis(URLSearchParamsPrototype.append);
var $delete = uncurryThis(URLSearchParamsPrototype['delete']);
var forEach = uncurryThis(URLSearchParamsPrototype.forEach);
var push = uncurryThis([].push);
var params = new $URLSearchParams('a=1&a=2&b=3');

params['delete']('a', 1);
// `undefined` case is a Chromium 117 bug
// https://bugs.chromium.org/p/v8/issues/detail?id=14222
params['delete']('b', undefined);

if (params + '' !== 'a=2') {
  defineBuiltIn(URLSearchParamsPrototype, 'delete', function (name /* , value */) {
    var length = arguments.length;
    var $value = length < 2 ? undefined : arguments[1];
    if (length && $value === undefined) return $delete(this, name);
    var entries = [];
    forEach(this, function (v, k) { // also validates `this`
      push(entries, { key: k, value: v });
    });
    validateArgumentsLength(length, 1);
    var key = toString(name);
    var value = toString($value);
    var index = 0;
    var dindex = 0;
    var found = false;
    var entriesLength = entries.length;
    var entry;
    while (index < entriesLength) {
      entry = entries[index++];
      if (found || entry.key === key) {
        found = true;
        $delete(this, entry.key);
      } else dindex++;
    }
    while (dindex < entriesLength) {
      entry = entries[dindex++];
      if (!(entry.key === key && entry.value === value)) append(this, entry.key, entry.value);
    }
  }, { enumerable: true, unsafe: true });
}


/***/ }),

/***/ 7566:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var defineBuiltIn = __webpack_require__(6840);
var uncurryThis = __webpack_require__(9504);
var toString = __webpack_require__(655);
var validateArgumentsLength = __webpack_require__(2812);

var $URLSearchParams = URLSearchParams;
var URLSearchParamsPrototype = $URLSearchParams.prototype;
var getAll = uncurryThis(URLSearchParamsPrototype.getAll);
var $has = uncurryThis(URLSearchParamsPrototype.has);
var params = new $URLSearchParams('a=1');

// `undefined` case is a Chromium 117 bug
// https://bugs.chromium.org/p/v8/issues/detail?id=14222
if (params.has('a', 2) || !params.has('a', undefined)) {
  defineBuiltIn(URLSearchParamsPrototype, 'has', function has(name /* , value */) {
    var length = arguments.length;
    var $value = length < 2 ? undefined : arguments[1];
    if (length && $value === undefined) return $has(this, name);
    var values = getAll(this, name); // also validates `this`
    validateArgumentsLength(length, 1);
    var value = toString($value);
    var index = 0;
    while (index < values.length) {
      if (values[index++] === value) return true;
    } return false;
  }, { enumerable: true, unsafe: true });
}


/***/ }),

/***/ 8721:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__(3724);
var uncurryThis = __webpack_require__(9504);
var defineBuiltInAccessor = __webpack_require__(2106);

var URLSearchParamsPrototype = URLSearchParams.prototype;
var forEach = uncurryThis(URLSearchParamsPrototype.forEach);

// `URLSearchParams.prototype.size` getter
// https://github.com/whatwg/url/pull/734
if (DESCRIPTORS && !('size' in URLSearchParamsPrototype)) {
  defineBuiltInAccessor(URLSearchParamsPrototype, 'size', {
    get: function size() {
      var count = 0;
      forEach(this, function () { count++; });
      return count;
    },
    configurable: true,
    enumerable: true
  });
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		__webpack_require__.p = "";
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": function() { return /* binding */ entry_lib; }
});

;// ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
/* eslint-disable no-var */
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  var currentScript = window.document.currentScript
  if (false) { var getCurrentScript; }

  var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)
  if (src) {
    __webpack_require__.p = src[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */ var setPublicPath = (null);

;// ./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/package/Preview/Index.vue?vue&type=template&id=36606a4d&scoped=true
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}
var staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"c-preview"},[_c('div',{attrs:{"id":"cobweb"}})])}]


;// ./src/package/Preview/Index.vue?vue&type=template&id=36606a4d&scoped=true

;// ./node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}

;// ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js

function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

;// ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js


function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}

;// ./node_modules/@babel/runtime/helpers/esm/defineProperty.js

function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.push.js
var es_array_push = __webpack_require__(4114);
// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url-search-params.delete.js
var web_url_search_params_delete = __webpack_require__(4603);
// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url-search-params.has.js
var web_url_search_params_has = __webpack_require__(7566);
// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url-search-params.size.js
var web_url_search_params_size = __webpack_require__(8721);
;// ./node_modules/@kyvi/cobweb/src/diagrams/rectangle.js
function rectangle(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  let wr = pen.calculative.borderRadius || 0,
    hr = wr;
  const {
    x,
    y,
    width,
    height,
    ex,
    ey
  } = pen.calculative.worldRect;
  if (wr < 1) {
    wr = width * wr;
    hr = height * hr;
  }
  let r = wr < hr ? wr : hr;
  if (width < 2 * r) {
    r = width / 2;
  }
  if (height < 2 * r) {
    r = height / 2;
  }
  path.moveTo(x + r, y);
  path.arcTo(ex, y, ex, ey, r);
  path.arcTo(ex, ey, x, ey, r);
  path.arcTo(x, ey, x, y, r);
  path.arcTo(x, y, ex, y, r);
  path.closePath();
  if (path instanceof Path2D) {
    return path;
  }
}
const square = rectangle;
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.set.difference.v2.js
var es_set_difference_v2 = __webpack_require__(7642);
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.set.intersection.v2.js
var es_set_intersection_v2 = __webpack_require__(8004);
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.set.is-disjoint-from.v2.js
var es_set_is_disjoint_from_v2 = __webpack_require__(3853);
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.set.is-subset-of.v2.js
var es_set_is_subset_of_v2 = __webpack_require__(5876);
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.set.is-superset-of.v2.js
var es_set_is_superset_of_v2 = __webpack_require__(2475);
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.set.symmetric-difference.v2.js
var es_set_symmetric_difference_v2 = __webpack_require__(5024);
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.set.union.v2.js
var es_set_union_v2 = __webpack_require__(1698);
;// ./node_modules/@kyvi/cobweb/src/pen/model.js







var PenType;
(function (PenType) {
  PenType[PenType["Node"] = 0] = "Node";
  PenType[PenType["Line"] = 1] = "Line";
})(PenType || (PenType = {}));
var LockState;
(function (LockState) {
  LockState[LockState["None"] = 0] = "None";
  LockState[LockState["DisableEdit"] = 1] = "DisableEdit";
  LockState[LockState["DisableMove"] = 2] = "DisableMove";
  LockState[LockState["DisableScale"] = 3] = "DisableScale";
  LockState[LockState["DisableMoveScale"] = 4] = "DisableMoveScale";
  // DisableActive,
  LockState[LockState["Disable"] = 10] = "Disable";
})(LockState || (LockState = {}));
var AnchorMode;
(function (AnchorMode) {
  AnchorMode[AnchorMode["Default"] = 0] = "Default";
  AnchorMode[AnchorMode["In"] = 1] = "In";
  AnchorMode[AnchorMode["Out"] = 2] = "Out";
})(AnchorMode || (AnchorMode = {}));
var Gradient;
(function (Gradient) {
  Gradient[Gradient["None"] = 0] = "None";
  Gradient[Gradient["Linear"] = 1] = "Linear";
  Gradient[Gradient["Radial"] = 2] = "Radial";
})(Gradient || (Gradient = {}));
//所在画布层 值和画布zIndex对应
var CanvasLayer;
(function (CanvasLayer) {
  CanvasLayer[CanvasLayer["CanvasTemplate"] = 1] = "CanvasTemplate";
  CanvasLayer[CanvasLayer["CanvasImageBottom"] = 2] = "CanvasImageBottom";
  CanvasLayer[CanvasLayer["CanvasMain"] = 3] = "CanvasMain";
  CanvasLayer[CanvasLayer["CanvasImage"] = 4] = "CanvasImage"; //顶部图片层
})(CanvasLayer || (CanvasLayer = {}));
// export enum Flip {
//   None, // 正常
//   Horizontal, // 水平翻转
//   Vertical, // 垂直翻转
//   Both, // 全翻转
// }
// 修改哪些属性需要重现计算 textRect
const needCalcTextRectProps = ['text', 'textWidth', 'textHeight', 'textLeft', 'textTop', 'fontFamily', 'fontSize', 'lineHeight', 'fontStyle', 'fontWeight', 'textAlign', 'textBaseline', 'whiteSpace', 'ellipsis', 'keepDecimal'];
const needSetPenProps = ['x', 'y', 'width', 'height', 'flipX', 'flipY'];
const needPatchFlagsPenRectProps = ['paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', 'flipX', 'flipY', 'visible', 'showChild'];
const needCalcIconRectProps = ['iconLeft', 'iconTop', 'iconRotate'];
var LineAnimateType;
(function (LineAnimateType) {
  LineAnimateType[LineAnimateType["Normal"] = 0] = "Normal";
  LineAnimateType[LineAnimateType["Beads"] = 1] = "Beads";
  LineAnimateType[LineAnimateType["Dot"] = 2] = "Dot";
  LineAnimateType[LineAnimateType["Arrow"] = 3] = "Arrow";
  LineAnimateType[LineAnimateType["WaterDrop"] = 4] = "WaterDrop";
})(LineAnimateType || (LineAnimateType = {}));
/**
 * dom 类型的 图形
 */
const isDomShapes = ['gif', 'iframe', 'video', 'echarts', 'highcharts', 'lightningCharts'];
/**
 *  交互图元
 */
const isInteraction = ['radio', 'checkbox', 'button', 'inputDom', 'slider', 'echarts'];
// 格式刷同步的属性
const formatAttrs = new Set(['borderRadius',
// 'rotate',
'paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom', 'progress', 'progressColor', 'verticalProgress', 'reverseProgress',
// 'flip',
'flipX', 'flipY', 'input', 'lineDash', 'lineCap', 'lineJoin', 'strokeType', 'lineGradientFromColor', 'lineGradientToColor', 'lineGradientAngle', 'color', 'hoverColor', 'activeColor', 'lineWidth', 'bkType', 'gradientFromColor', 'gradientToColor', 'gradientAngle', 'gradientRadius', 'hoverBackground', 'activeBackground', 'globalAlpha', 'anchorColor', 'anchorRadius', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textHasShadow', 'fontFamily', 'fontSize', 'textColor', 'hoverTextColor', 'activeTextColor', 'textBackground', 'fontStyle', 'fontWeight', 'textAlign', 'textBaseline', 'lineHeight', 'whiteSpace', 'textWidth', 'textHeight', 'textLeft', 'textTop', 'ellipsis', 'hiddenText', 'keepDecimal', 'borderWidth', 'borderColor', 'animateLineWidth', 'lineAnimateType', 'frames', 'animateColor', 'animateType', 'animateReverse', 'background', 'gradientColors', 'lineGradientColors', 'animateLineWidth', 'gradientSmooth', 'lineSmooth', 'animations']);
/**
 * 清空 pen 的 生命周期
 */
function clearLifeCycle(pen) {
  pen.onAdd = undefined;
  pen.onValue = undefined;
  pen.onBeforeValue = undefined;
  pen.onDestroy = undefined;
  pen.onMove = undefined;
  pen.onResize = undefined;
  pen.onRotate = undefined;
  pen.onClick = undefined;
  pen.onMouseEnter = undefined;
  pen.onMouseLeave = undefined;
  pen.onMouseDown = undefined;
  pen.onMouseMove = undefined;
  pen.onMouseUp = undefined;
  pen.onShowInput = undefined;
  pen.onInput = undefined;
  pen.onChangeId = undefined;
  pen.onBinds = undefined;
  pen.onStartVideo = undefined;
  pen.onPauseVideo = undefined;
  pen.onStopVideo = undefined;
  pen.onRenderPenRaw = undefined;
  pen.onKeyDown = undefined;
  pen.onContextmenu = undefined;
  pen.onScale = undefined;
  pen.onWheel = undefined;
  pen.onConnectLine = undefined;
}
;// ./node_modules/@kyvi/cobweb/src/data.js
var HoverType;
(function (HoverType) {
  HoverType[HoverType["None"] = 0] = "None";
  HoverType[HoverType["LineAnchor"] = 1] = "LineAnchor";
  HoverType[HoverType["NodeAnchor"] = 2] = "NodeAnchor";
  HoverType[HoverType["Line"] = 3] = "Line";
  HoverType[HoverType["Node"] = 4] = "Node";
  HoverType[HoverType["Resize"] = 5] = "Resize";
  HoverType[HoverType["Rotate"] = 6] = "Rotate";
  HoverType[HoverType["LineAnchorPrev"] = 7] = "LineAnchorPrev";
  HoverType[HoverType["LineAnchorNext"] = 8] = "LineAnchorNext";
})(HoverType || (HoverType = {}));
var HotkeyType;
(function (HotkeyType) {
  HotkeyType[HotkeyType["None"] = 0] = "None";
  HotkeyType[HotkeyType["Translate"] = 1] = "Translate";
  HotkeyType[HotkeyType["Select"] = 2] = "Select";
  HotkeyType[HotkeyType["Resize"] = 3] = "Resize";
  HotkeyType[HotkeyType["AddAnchor"] = 4] = "AddAnchor";
})(HotkeyType || (HotkeyType = {}));
var MouseRight;
(function (MouseRight) {
  MouseRight[MouseRight["None"] = 0] = "None";
  MouseRight[MouseRight["Down"] = 1] = "Down";
  MouseRight[MouseRight["Translate"] = 2] = "Translate";
})(MouseRight || (MouseRight = {}));
var Direction;
(function (Direction) {
  Direction[Direction["None"] = -1] = "None";
  Direction[Direction["Up"] = 0] = "Up";
  Direction[Direction["Right"] = 1] = "Right";
  Direction[Direction["Bottom"] = 2] = "Bottom";
  Direction[Direction["Left"] = 3] = "Left";
})(Direction || (Direction = {}));
const defaultCursors = ['nw-resize', 'ne-resize', 'se-resize', 'sw-resize'];
const rotatedCursors = ['n-resize', 'e-resize', 's-resize', 'w-resize'];
const defaultDrawLineFns = ['curve', 'polyline', 'line'];
const inheritanceProps = ['dash', 'lineWidth', 'lineCap', 'lineJoin', 'strokeType', 'color', 'lineGradientFromColor', 'lineGradientToColor', 'lineGradientAngle', 'globalAlpha', 'bkType', 'background', 'gradientFromColor', 'gradientToColor', 'gradientAngle', 'gradientRadius', 'fontFamily', 'fontSize', 'textColor', 'hoverTextColor', 'activeTextColor', 'textBackground', 'fontStyle', 'fontWeight', 'textAlign', 'textBaseline', 'lineHeight', 'whiteSpace', 'textLeft', 'textTop', 'flipX', 'flipY', 'lineDash', 'visible', 'iconColor'];
;// ./node_modules/@kyvi/cobweb/src/point/point.js


var PrevNextType;
(function (PrevNextType) {
  PrevNextType[PrevNextType["Mirror"] = 0] = "Mirror";
  PrevNextType[PrevNextType["Bilateral"] = 1] = "Bilateral";
  PrevNextType[PrevNextType["Free"] = 2] = "Free";
})(PrevNextType || (PrevNextType = {}));
var TwoWay;
(function (TwoWay) {
  TwoWay[TwoWay["Default"] = 0] = "Default";
  TwoWay[TwoWay["In"] = 1] = "In";
  TwoWay[TwoWay["Out"] = 2] = "Out";
  TwoWay[TwoWay["DisableConnected"] = 3] = "DisableConnected";
  TwoWay[TwoWay["DisableConnectTo"] = 4] = "DisableConnectTo";
  TwoWay[TwoWay["Disable"] = 10] = "Disable";
})(TwoWay || (TwoWay = {}));
var PointType;
(function (PointType) {
  PointType[PointType["Default"] = 0] = "Default";
  PointType[PointType["Line"] = 1] = "Line";
})(PointType || (PointType = {}));
function rotatePoint(pt, angle, center) {
  if (!angle || angle % 360 === 0) {
    return;
  }
  const a = angle * Math.PI / 180;
  const x = (pt.x - center.x) * Math.cos(a) - (pt.y - center.y) * Math.sin(a) + center.x;
  const y = (pt.x - center.x) * Math.sin(a) + (pt.y - center.y) * Math.cos(a) + center.y;
  pt.x = x;
  pt.y = y;
  pt.prev && rotatePoint(pt.prev, angle, center);
  pt.next && rotatePoint(pt.next, angle, center);
}
function hitPoint(pt, target, radius = 5, pen) {
  if (target.type === PointType.Line) {
    let _rotate = pen.rotate;
    if (pen.flipX) {
      _rotate *= -1;
    }
    if (pen.flipY) {
      _rotate *= -1;
    }
    let rotate = target.rotate + _rotate;
    if (pen.flipX) {
      rotate *= -1;
    }
    if (pen.flipY) {
      rotate *= -1;
    }
    return pointInRect(pt, {
      x: target.x - target.length * pen.calculative.canvas.store.data.scale / 2,
      y: target.y - radius,
      width: target.length * pen.calculative.canvas.store.data.scale,
      height: radius * 2,
      rotate: rotate
    });
  } else {
    return pt.x > target.x - radius && pt.x < target.x + radius && pt.y > target.y - radius && pt.y < target.y + radius;
  }
}
function scalePoint(pt, scale, center) {
  pt.x = center.x - (center.x - pt.x) * scale;
  pt.y = center.y - (center.y - pt.y) * scale;
}
function calcRotate(pt, center) {
  if (pt.x === center.x) {
    return pt.y <= center.y ? 0 : 180;
  }
  if (pt.y === center.y) {
    return pt.x < center.x ? 270 : 90;
  }
  const x = pt.x - center.x;
  const y = pt.y - center.y;
  let angle = Math.atan(Math.abs(x / y)) / (2 * Math.PI) * 360;
  if (x > 0 && y > 0) {
    angle = 180 - angle;
  } else if (x < 0 && y > 0) {
    angle += 180;
  } else if (x < 0 && y < 0) {
    angle = 360 - angle;
  }
  return angle;
}
function distance(pt1, pt2) {
  const x = pt1.x - pt2.x;
  const y = pt1.y - pt2.y;
  return Math.sqrt(x * x + y * y);
}
function facePoint(pt, targetPt) {
  let d = Direction.None;
  if (!targetPt) {
    return d;
  }
  const disX = pt.x - targetPt.x;
  const disY = pt.y - targetPt.y;
  if (Math.abs(disX) > Math.abs(disY)) {
    if (disX > 0) {
      d = Direction.Right;
    } else {
      d = Direction.Left;
    }
  } else {
    if (disY > 0) {
      d = Direction.Bottom;
    } else {
      d = Direction.Up;
    }
  }
  return d;
}
function translatePoint(pt, x, y) {
  if (!pt) {
    return;
  }
  pt.x += x;
  pt.y += y;
  if (pt.next) {
    pt.next.x += x;
    pt.next.y += y;
  }
  if (pt.prev) {
    pt.prev.x += x;
    pt.prev.y += y;
  }
}
/**
 * 是否是同一个点
 * @param pt1 点1
 * @param pt2 点2
 * @returns true 相同
 */
function samePoint(pt1, pt2) {
  return pt1.anchorId === pt2.anchorId && pt1.connectTo === pt2.connectTo;
}
function getDistance(form, to, store) {
  let dis = Math.sqrt((form.x - to.x) * (form.x - to.x) + (form.y - to.y) * (form.y - to.y)) / store.data.scale;
  if (to.rotate === 0) {
    if (form.x < to.x) {
      if (!store.pens[to.penId].flipX) {
        dis *= -1;
      }
    } else {
      if (store.pens[to.penId].flipX) {
        dis *= -1;
      }
    }
  } else {
    if (form.y < to.y) {
      if (!store.pens[to.penId].flipY) {
        dis *= -1;
      }
    } else {
      if (store.pens[to.penId].flipY) {
        dis *= -1;
      }
    }
  }
  form.distance = dis;
}
;// ./node_modules/@kyvi/cobweb/src/point/index.js

;// ./node_modules/@kyvi/cobweb/package.json
var package_namespaceObject = {"rE":"1.0.1"};
;// ./node_modules/@kyvi/cobweb/src/store/global.js

const globalStore = {
  version: package_namespaceObject.rE,
  path2dDraws: {},
  canvasDraws: {},
  anchors: {},
  htmlElements: {}
};
function register(path2dFns) {
  Object.assign(globalStore.path2dDraws, path2dFns);
}
function registerCanvasDraw(drawFns) {
  Object.assign(globalStore.canvasDraws, drawFns);
}
function registerAnchors(anchorsFns) {
  Object.assign(globalStore.anchors, anchorsFns);
}
;// ./node_modules/mitt/dist/mitt.es.js

/* harmony default export */ function mitt_es(n) {
  return {
    all: n = n || new Map(),
    on: function (t, e) {
      var i = n.get(t);
      i && i.push(e) || n.set(t, [e]);
    },
    off: function (t, e) {
      var i = n.get(t);
      i && i.splice(i.indexOf(e) >>> 0, 1);
    },
    emit: function (t, e) {
      (n.get(t) || []).slice().map(function (n) {
        n(e);
      }), (n.get("*") || []).slice().map(function (n) {
        n(t, e);
      });
    }
  };
}
;// ./node_modules/@kyvi/cobweb/src/options.js
var KeydownType;
(function (KeydownType) {
  KeydownType[KeydownType["None"] = -1] = "None";
  KeydownType[KeydownType["Document"] = 0] = "Document";
  KeydownType[KeydownType["Canvas"] = 1] = "Canvas";
})(KeydownType || (KeydownType = {}));
const defaultOptions = {
  fontFamily: '"Hiragino Sans GB", "Microsoft YaHei", "Helvetica Neue", Helvetica, Arial',
  fontSize: 12,
  lineHeight: 1.5,
  textAlign: 'center',
  textBaseline: 'middle',
  color: '#222222',
  activeColor: '#278df8',
  hoverColor: 'rgba(39,141,248,0.50)',
  anchorColor: '#278DF8',
  hoverAnchorColor: '#FF4101',
  anchorRadius: 4,
  anchorBackground: '#fff',
  dockColor: 'rgba(39,141,248,0.50)',
  dockPenColor: '#1890FF',
  dragColor: '#1890ff',
  rotateCursor: 'rotate.cur',
  rightCursor: 'right.cur',
  downCursor: 'down.cur',
  hoverCursor: 'pointer',
  minScale: 0.1,
  maxScale: 10,
  keydown: KeydownType.Document,
  gridSize: 20,
  gridColor: '#e2e2e2',
  ruleColor: '#888888',
  drawingLineName: 'curve',
  interval: 30,
  animateInterval: 30,
  autoPolyline: true,
  autoAnchor: true,
  autoAlignGrid: false,
  animateColor: '#30EEDC',
  ruleLineColor: '#FF4101',
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowBlur: 64,
  shadowColor: "#00000014",
  globalAlpha: 1,
  defaultAnchors: [{
    x: 0.5,
    y: 0
  }, {
    x: 1,
    y: 0.5
  }, {
    x: 0.5,
    y: 1
  }, {
    x: 0,
    y: 0.5
  }],
  measureTextWidth: true,
  moveConnectedLine: true,
  mouseRightActive: true,
  disableClipboard: false,
  drawingLineLength: 0,
  disableTouchPadScale: false,
  cdn: '',
  polylineSpace: 10,
  domShapes: [],
  containerShapes: ['tablePlus'],
  textFlip: true,
  textRotate: true,
  unavailableKeys: [],
  diagramOptions: {},
  svgPathStroke: true
};
;// ./node_modules/@kyvi/cobweb/src/theme.js
const defaultTheme = {
  dark: {
    color: '#bdc7db',
    background: '#1e2430',
    parentBackground: '#080b0f',
    ruleColor: '#222E47',
    ruleOptions: {
      background: '#121924',
      textColor: '#6E7B91'
    }
  },
  light: {
    color: '#222222',
    background: '#FFFFFF',
    parentBackground: '#F0F1F2',
    ruleColor: '#C8D0E1',
    ruleOptions: {
      background: '#F7F8FA',
      textColor: '#C8D0E1'
    }
  }
};
;// ./node_modules/@kyvi/cobweb/src/store/store.js












var EditType;
(function (EditType) {
  EditType[EditType["Add"] = 0] = "Add";
  EditType[EditType["Update"] = 1] = "Update";
  EditType[EditType["Delete"] = 2] = "Delete";
  EditType[EditType["Replace"] = 3] = "Replace";
})(EditType || (EditType = {}));
const createStore = () => {
  return {
    data: {
      x: 0,
      y: 0,
      scale: 1,
      pens: [],
      origin: {
        x: 0,
        y: 0
      },
      center: {
        x: 0,
        y: 0
      },
      paths: {},
      theme: 'light'
    },
    histories: [],
    pens: {},
    path2dMap: new WeakMap(),
    animateMap: new WeakMap(),
    active: [],
    animates: new Set(),
    options: {
      ...defaultOptions
    },
    theme: {
      ...defaultTheme
    },
    emitter: mitt_es(),
    bindDatas: {},
    bind: {},
    pensNetwork: {},
    cacheDatas: [],
    messageEvents: {},
    templatePens: {},
    globalTriggers: {}
  };
};
// Return a data store, if not exists will create a store.
const useStore = (id = 'default') => {
  if (!globalStore[id]) {
    globalStore[id] = createStore();
    globalStore[id].id = id;
  }
  return globalStore[id];
};
const clearStore = (store, template) => {
  const isSame = store.data.template === template;
  if (isSame) {
    //模版一样
    for (const pen of store.data.pens) {
      // if (pen.template) {
      if (pen.canvasLayer === CanvasLayer.CanvasTemplate) {
        store.templatePens[pen.id] = pen;
      }
    }
  }
  store.lastScale = store.data.scale;
  store.data = {
    x: 0,
    y: 0,
    scale: 1,
    pens: [],
    origin: {
      x: 0,
      y: 0
    },
    center: {
      x: 0,
      y: 0
    },
    paths: {},
    template: isSame ? template : null
  };
  store.sameTemplate = isSame;
  store.pens = {};
  store.histories = [];
  store.historyIndex = null;
  store.path2dMap = new WeakMap();
  store.animateMap = new WeakMap();
  store.bindDatas = {};
  store.bind = {};
  store.pensNetwork = {};
  store.active = [];
  store.hover = undefined;
  store.lastHover = undefined;
  store.animates.clear();
};
;// ./node_modules/@kyvi/cobweb/src/store/index.js


;// ./node_modules/@kyvi/cobweb/src/pen/text.js



function calcTextRect(pen) {
  const {
    paddingTop,
    paddingBottom,
    paddingLeft,
    paddingRight,
    worldRect,
    canvas
  } = pen.calculative;
  let {
    textLeft,
    textTop,
    textWidth,
    textHeight
  } = pen.calculative;
  let x = paddingLeft;
  let y = paddingTop;
  // if (textLeft && Math.abs(textLeft) < 1) {
  //   textLeft *= worldRect.width;
  // }
  // if (textTop && Math.abs(textTop) < 1) {
  //   textTop *= worldRect.height;
  // }
  const width = worldRect.width - paddingLeft - paddingRight;
  const height = worldRect.height - paddingTop - paddingBottom;
  if (textWidth && textWidth < 1) {
    textWidth *= worldRect.width;
  }
  if (textHeight && textHeight < 1) {
    textHeight *= worldRect.height;
  }
  if (textWidth < pen.calculative.fontSize) {
    textWidth = pen.calculative.fontSize;
  }
  // 默认居左，居上
  x += (textLeft || 0) + worldRect.x;
  y += (textTop || 0) + worldRect.y;
  const textAlign = pen.textAlign || canvas.store.options.textAlign;
  const textBaseline = pen.textBaseline || canvas.store.options.textBaseline;
  switch (textAlign) {
    case 'center':
      x += (width - (textWidth || width)) / 2;
      break;
    case 'right':
      x += width - (textWidth || width);
      break;
  }
  switch (textBaseline) {
    case 'middle':
      y += (height - (textHeight || height)) / 2;
      break;
    case 'bottom':
      y += height - (textHeight || height);
      break;
  }
  const rect = {
    x,
    y,
    width: textWidth || width,
    height: textHeight || height
  };
  rect_calcRightBottom(rect);
  pen.calculative.worldTextRect = rect;
  text_calcTextLines(pen);
  pen.calculative.textDrawRect = undefined;
}
function calcTextDrawRect(ctx, pen) {
  // By default, the text is center aligned.
  const lineHeight = pen.calculative.fontSize * pen.calculative.lineHeight;
  const h = pen.calculative.textLines.length * lineHeight;
  const textWidth = calcTextAdaptionWidth(ctx, pen); // 多行文本最大宽度
  const rect = pen.calculative.worldTextRect;
  let x = rect.x + (rect.width - textWidth) / 2;
  let y = rect.y + (rect.height - h) / 2;
  const options = pen.calculative.canvas.store.options;
  const textAlign = pen.textAlign || options.textAlign;
  switch (textAlign) {
    case 'left':
      x = rect.x;
      break;
    case 'right':
      x = rect.x + rect.width - textWidth;
      break;
  }
  const textBaseline = pen.textBaseline || options.textBaseline;
  switch (textBaseline) {
    case 'top':
      y = rect.y;
      break;
    case 'bottom':
      y = rect.ey - h;
      break;
  }
  pen.calculative.textDrawRect = {
    x,
    y,
    width: textWidth,
    height: h
  };
  rect_calcRightBottom(pen.calculative.textDrawRect);
}
function text_calcTextLines(pen, text = pen.calculative.text) {
  if (text == undefined) {
    pen.calculative.textLines = [];
    return;
  }
  text = text.toString();
  let lines = [];
  const oneRowHeight = pen.calculative.fontSize * pen.calculative.lineHeight;
  const textHeight = pen.calculative.worldTextRect.height;
  const calcRows = Math.floor(textHeight / oneRowHeight);
  // 最小值为 1
  const maxRows = calcRows > 1 ? calcRows : 1;
  switch (pen.whiteSpace) {
    case 'nowrap':
      if (pen.ellipsis !== false) {
        const allLines = wrapLines(text.split(''), pen);
        if (allLines[0]) {
          lines.push(allLines[0]);
          if (allLines.length > 1) {
            // 存在第二行，说明宽度超出
            setEllipsisOnLastLine(lines);
          }
        }
      } else {
        lines.push(text);
      }
      break;
    case 'pre-line':
      lines = text.split(/[\n]/g);
      if (pen.ellipsis !== false && lines.length > maxRows) {
        lines = lines.slice(0, maxRows);
        setEllipsisOnLastLine(lines);
      }
      break;
    case 'break-all':
    default:
      const paragraphs = text.split(/[\n]/g);
      let currentRow = 0;
      outer: for (const paragraph of paragraphs) {
        const words = pen.whiteSpace === 'break-all' ? paragraph.split('') : getWords(paragraph);
        let items = wrapLines(words, pen);
        // 空行换行的情况
        if (items.length === 0) items = [''];
        if (pen.ellipsis != false) {
          for (const l of items) {
            currentRow++;
            if (currentRow > maxRows) {
              setEllipsisOnLastLine(lines);
              break outer;
            } else {
              lines.push(l);
            }
          }
        } else {
          lines.push(...items);
        }
      }
      break;
  }
  const keepDecimal = pen.calculative.keepDecimal;
  if (keepDecimal != undefined) {
    lines.forEach((text, i) => {
      const textNum = Number(text);
      if (!isNaN(textNum)) {
        lines[i] = textNum.toFixed(keepDecimal);
      }
    });
  }
  pen.calculative.textLines = lines;
  return lines;
}
function getWords(txt = '') {
  const words = [];
  let word = '';
  for (let i = 0; i < txt.length; ++i) {
    const ch = txt.charCodeAt(i);
    if (ch < 33 || ch > 126) {
      if (word) {
        words.push(word);
        word = '';
      }
      words.push(txt[i]);
    } else {
      word += txt[i];
    }
  }
  if (word) {
    words.push(word);
  }
  return words;
}
function wrapLines(words, pen) {
  const canvas = pen.calculative.canvas;
  const ctx = canvas.offscreen.getContext('2d');
  const {
    fontStyle,
    fontWeight,
    fontSize,
    fontFamily,
    lineHeight
  } = pen.calculative;
  ctx.save();
  const lines = [];
  let currentLine = words[0] || '';
  for (let i = 1; i < words.length; ++i) {
    const word = words[i] || '';
    const text = currentLine + word;
    let currentWidth = 0;
    if (canvas.store.options.measureTextWidth) {
      ctx.font = getFont({
        fontStyle,
        fontWeight,
        fontFamily: fontFamily || canvas.store.options.fontFamily,
        fontSize,
        lineHeight
      });
      currentWidth = ctx.measureText(text).width;
    } else {
      // 近似计算
      const chinese = text.match(/[^\x00-\xff]/g) || '';
      const chineseWidth = chinese.length * fontSize; // 中文占用的宽度
      const spaces = text.match(/\s/g) || '';
      const spaceWidth = spaces.length * fontSize * 0.3; // 空格占用的宽度
      const otherWidth = (text.length - chinese.length - spaces.length) * fontSize * 0.6; // 其他字符占用的宽度
      currentWidth = chineseWidth + spaceWidth + otherWidth;
    }
    const textWidth = pen.calculative.worldTextRect.width;
    if (currentWidth <= textWidth + 0.1) {
      currentLine += word;
    } else {
      currentLine.length && lines.push(currentLine);
      currentLine = word;
    }
  }
  currentLine.length && lines.push(currentLine);
  ctx.restore();
  return lines;
}
function calcTextAdaptionWidth(ctx, pen) {
  let maxWidth = 0;
  pen.calculative.textLineWidths = [];
  pen.calculative.textLines.forEach(text => {
    const width = ctx.measureText(text).width;
    pen.calculative.textLineWidths.push(width);
    maxWidth < width && (maxWidth = width);
  });
  return maxWidth;
}
/**
 * 副作用函数，会修改传入的参数
 * 把最后一行的最后变成 ...
 * TODO: 中文的三个字符宽度比 . 大，显示起来像是删多了
 * @param lines
 */
function setEllipsisOnLastLine(lines) {
  lines[lines.length - 1] = lines[lines.length - 1].slice(0, -3) + '...';
}
function calcTextAutoWidth(pen) {
  let arr = pen.text.split('\n');
  const canvas = pen.calculative.canvas;
  const ctx = canvas.offscreen.getContext('2d');
  const {
    fontStyle,
    fontWeight,
    fontSize,
    fontFamily,
    lineHeight
  } = pen.calculative;
  let textWidth = 0; // pen.calculative.worldTextRect.width;
  let currentWidth = 0; // textWidth;
  ctx.save();
  for (let i = 0; i < arr.length; i++) {
    if (canvas.store.options.measureTextWidth) {
      ctx.font = getFont({
        fontStyle,
        fontWeight,
        fontFamily: fontFamily || canvas.store.options.fontFamily,
        fontSize,
        lineHeight
      });
      currentWidth = ctx.measureText(arr[i]).width; //* scale;
    } else {
      // 近似计算
      const chinese = arr[i].match(/[^\x00-\xff]/g) || '';
      const chineseWidth = chinese.length * fontSize; // 中文占用的宽度
      const spaces = arr[i].match(/\s/g) || '';
      const spaceWidth = spaces.length * fontSize * 0.3; // 空格占用的宽度
      const otherWidth = (arr[i].length - chinese.length - spaces.length) * fontSize * 0.6; // 其他字符占用的宽度
      currentWidth = chineseWidth + spaceWidth + otherWidth;
    }
    if (currentWidth > textWidth) {
      textWidth = currentWidth; //* scale;
    }
  }
  ctx.restore();
  let textHeight = arr.length * fontSize * lineHeight;
  if (pen.textAlign === 'left') {
    // pen.x = pen.x;
  } else if (pen.textAlign === 'right') {
    pen.x = pen.x - (textWidth - pen.width);
  } else {
    pen.x = pen.x - (textWidth - pen.width) / 2;
  }
  if (pen.textBaseline === 'top') {} else if (pen.textBaseline === 'bottom') {
    pen.y = pen.y - (textHeight - pen.height);
  } else {
    pen.y = pen.y - (textHeight - pen.height) / 2;
  }
  // if (textHeight > pen.height) {
  pen.height = textHeight + 2;
  // }
  pen.width = textWidth + 2; //误差
  pen.calculative.canvas.updatePenRect(pen);
  pen.calculative.canvas.calcActiveRect();
}
;// ./node_modules/@kyvi/cobweb/src/utils/clone.js

/**
 * 拷贝一个对象
 * @param o - object to clone
 * @param keepCalc 是否保留计算属性， false, 不保留， true, 保留（但 calculative.canvas 属性仍不保存）
 * @returns 拷贝后的对象
 */
function deepClone(o, keepCalc = false) {
  if (Array.isArray(o)) {
    const arr = [];
    o.forEach(item => {
      arr.push(deepClone(item, keepCalc));
    });
    return arr;
  } else if (typeof o === 'object') {
    if (o === null) {
      return null;
    } else if (o.constructor === RegExp) {
      return o;
    }
    const _o = {};
    for (const key in o) {
      if (['canvas', 'lastFrame'].includes(key) || o[key] instanceof HTMLImageElement || o[key] instanceof HTMLMediaElement) {
        continue;
      } else if (key === 'calculative' && !keepCalc) {
        continue;
      } else if (key === 'singleton') {
        if (keepCalc) {
          _o[key] = {};
        } else {
          _o[key] = o[key];
        }
        continue;
      }
      _o[key] = deepClone(o[key], keepCalc);
    }
    return _o;
  }
  return o;
}
function deepSetValue(o, keyWords, value) {
  if (Array.isArray(o)) {
    const arr = [];
    o.forEach(item => {
      arr.push(deepSetValue(item, keyWords, value));
    });
    return arr;
  } else if (typeof o === 'object') {
    if (o === null) {
      return null;
    }
    // const _o = {} as any;
    for (const key in o) {
      if (keyWords.includes(key)) {
        if (Array.isArray(o[key])) {
          o[key].forEach((i, index) => {
            if (!Number.isNaN(Number(i))) {
              o[key][index] = Number(i * value);
            }
          });
        } else {
          if (Number.isNaN(Number(o[key]))) {
            continue;
          }
          o[key] = Number(o[key]) * value;
        }
      } else {
        o[key] = deepSetValue(o[key], keyWords, value);
      }
    }
    return o;
  }
  return o;
}
;// ./node_modules/@kyvi/cobweb/src/pen/arrow.js


const arrows = {};
function renderFromArrow(ctx, pen, store) {
  if (!arrows[pen.fromArrow]) {
    return;
  }
  const from = getFromAnchor(pen);
  const {
    x,
    y
  } = from;
  const pt = {
    x,
    y
  };
  pt.step = (pen.fromArrowSize || 10) * store.data.scale;
  if (from.next) {
    pt.rotate = calcRotate(from.next, from) + 90;
  } else {
    const p = pen.calculative.worldAnchors[1];
    if (!p) {
      return;
    }
    if (p.prev) {
      pt.rotate = calcRotate(p.prev, from) + 90;
    } else {
      pt.rotate = calcRotate(p, from) + 90;
    }
  }
  ctx.save();
  ctx.beginPath();
  ctx.setLineDash([]);
  const fromArrowColor = pen.fromArrowColor || pen.calculative.color;
  fromArrowColor && (ctx.strokeStyle = fromArrowColor);
  arrows[pen.fromArrow](ctx, pen, store, pt);
  ctx.restore();
}
function renderToArrow(ctx, pen, store) {
  if (!arrows[pen.toArrow] || pen.calculative.worldAnchors.length < 2) {
    return;
  }
  ctx.save();
  const to = getToAnchor(pen);
  const {
    x,
    y
  } = to;
  const pt = {
    x,
    y
  };
  pt.step = (pen.toArrowSize || 10) * store.data.scale;
  if (to.prev) {
    pt.rotate = calcRotate(to.prev, to) + 90;
  } else {
    const p = pen.calculative.worldAnchors[pen.calculative.worldAnchors.length - 2];
    if (p.next) {
      pt.rotate = calcRotate(p.next, to) + 90;
    } else {
      pt.rotate = calcRotate(p, to) + 90;
    }
  }
  ctx.beginPath();
  ctx.setLineDash([]);
  const toArrowColor = pen.toArrowColor || pen.calculative.color;
  toArrowColor && (ctx.strokeStyle = toArrowColor);
  arrows[pen.toArrow](ctx, pen, store, pt);
  ctx.restore();
}
arrows.triangleSolid = (ctx, pen, store, point) => {
  ctx.save();
  ctx.translate(point.x, point.y);
  ctx.rotate(point.rotate * Math.PI / 180);
  ctx.translate(-point.x, -point.y);
  const fromX = point.x - point.step;
  ctx.moveTo(fromX, point.y - point.step / 4);
  ctx.lineTo(point.x, point.y);
  ctx.lineTo(fromX, point.y + point.step / 4);
  ctx.closePath();
  ctx.stroke();
  ctx.fillStyle = ctx.strokeStyle;
  ctx.fill();
  ctx.restore();
};
arrows.triangle = (ctx, pen, store, point) => {
  ctx.save();
  if (ctx.lineWidth < 2) {
    ctx.lineWidth = 2;
  }
  ctx.translate(point.x, point.y);
  ctx.rotate(point.rotate * Math.PI / 180);
  ctx.translate(-point.x, -point.y);
  const fromX = point.x - point.step;
  ctx.moveTo(fromX, point.y - point.step / 4);
  ctx.lineTo(point.x, point.y);
  ctx.lineTo(fromX, point.y + point.step / 4);
  ctx.closePath();
  ctx.stroke();
  ctx.fillStyle = store.data.background || '#ffffff';
  ctx.fill();
  ctx.restore();
};
arrows.circleSolid = (ctx, pen, store, point) => {
  ctx.save();
  ctx.translate(point.x, point.y);
  ctx.rotate(point.rotate * Math.PI / 180);
  ctx.translate(-point.x, -point.y);
  const r = point.step / 2;
  ctx.arc(point.x - r, point.y, r, 0, 2 * Math.PI);
  ctx.stroke();
  ctx.fillStyle = ctx.strokeStyle;
  ctx.fill();
  ctx.restore();
};
arrows.circle = (ctx, pen, store, point) => {
  ctx.save();
  ctx.translate(point.x, point.y);
  ctx.rotate(point.rotate * Math.PI / 180);
  ctx.translate(-point.x, -point.y);
  const r = point.step / 2;
  ctx.arc(point.x - r, point.y, r, 0, 2 * Math.PI);
  ctx.stroke();
  ctx.fillStyle = store.data.background || '#ffffff';
  ctx.fill();
  ctx.restore();
};
arrows.diamondSolid = (ctx, pen, store, point) => {
  ctx.save();
  ctx.translate(point.x, point.y);
  ctx.rotate(point.rotate * Math.PI / 180);
  ctx.translate(-point.x, -point.y);
  const fromX = point.x - point.step;
  const r = point.step / 2;
  ctx.moveTo(fromX, point.y);
  ctx.lineTo(fromX + r, point.y - r / 2);
  ctx.lineTo(point.x, point.y);
  ctx.lineTo(fromX + r, point.y + r / 2);
  ctx.closePath();
  ctx.stroke();
  ctx.fillStyle = ctx.strokeStyle;
  ctx.fill();
  ctx.restore();
};
arrows.diamond = (ctx, pen, store, point) => {
  ctx.save();
  ctx.translate(point.x, point.y);
  ctx.rotate(point.rotate * Math.PI / 180);
  ctx.translate(-point.x, -point.y);
  const fromX = point.x - point.step;
  const r = point.step / 2;
  ctx.moveTo(fromX, point.y);
  ctx.lineTo(fromX + r, point.y - r / 2);
  ctx.lineTo(point.x, point.y);
  ctx.lineTo(fromX + r, point.y + r / 2);
  ctx.closePath();
  ctx.stroke();
  ctx.fillStyle = store.data.background || '#ffffff';
  ctx.fill();
  ctx.restore();
};
arrows.line = (ctx, pen, store, point) => {
  ctx.save();
  ctx.translate(point.x, point.y);
  ctx.rotate(point.rotate * Math.PI / 180);
  ctx.translate(-point.x, -point.y);
  const fromX = point.x - point.step;
  ctx.moveTo(fromX, point.y - point.step / 3);
  ctx.lineTo(point.x, point.y);
  ctx.lineTo(fromX, point.y + point.step / 3);
  ctx.stroke();
  ctx.restore();
};
arrows.lineUp = (ctx, pen, store, point) => {
  ctx.save();
  ctx.translate(point.x, point.y);
  ctx.rotate(point.rotate * Math.PI / 180);
  ctx.translate(-point.x, -point.y);
  const fromX = point.x - point.step;
  ctx.moveTo(fromX, point.y - point.step / 3);
  ctx.lineTo(point.x, point.y);
  ctx.stroke();
  ctx.restore();
};
arrows.lineDown = (ctx, pen, store, point) => {
  ctx.save();
  ctx.translate(point.x, point.y);
  ctx.rotate(point.rotate * Math.PI / 180);
  ctx.translate(-point.x, -point.y);
  const fromX = point.x - point.step;
  ctx.moveTo(fromX, point.y + point.step / 3);
  ctx.lineTo(point.x, point.y);
  ctx.stroke();
  ctx.restore();
};
;// ./node_modules/@kyvi/cobweb/src/utils/color.js
// pSBC - Shade Blend Convert - Version 4.0 - 02/18/2019
// https://github.com/PimpTrizkit/PJs/edit/master/pSBC.js
function pSBCr(d) {
  const i = parseInt,
    m = Math.round;
  let n = d.length,
    x = {};
  if (n > 9) {
    const [r, g, b, a] = d = d.split(',');
    n = d.length;
    if (n < 3 || n > 4) return null;
    x.r = i(r[3] == 'a' ? r.slice(5) : r.slice(4)), x.g = i(g), x.b = i(b), x.a = a ? parseFloat(a) : -1;
  } else {
    if (n == 8 || n == 6 || n < 4) return null;
    if (n < 6) d = '#' + d[1] + d[1] + d[2] + d[2] + d[3] + d[3] + (n > 4 ? d[4] + d[4] : '');
    d = i(d.slice(1), 16);
    if (n == 9 || n == 5) x.r = d >> 24 & 255, x.g = d >> 16 & 255, x.b = d >> 8 & 255, x.a = m((d & 255) / 0.255) / 1000;else x.r = d >> 16, x.g = d >> 8 & 255, x.b = d & 255, x.a = -1;
  }
  return x;
}
/*
example：
pSBC ( 0.42, color1 ); // rgb(20,60,200) + [42% Lighter] => rgb(166,171,225)
pSBC ( -0.4, color5 ); // #F3A + [40% Darker] => #c62884

pSBC ( -0.5, color2, color8, true ); // rgba(20,60,200,0.67423) + rgba(200,60,20,0.98631) + [50% Blend] => rgba(110,60,110,0.83)
pSBC ( 0.7, color2, color7, true ); // rgba(20,60,200,0.67423) + rgb(200,60,20) + [70% Blend] => rgba(146,60,74,0.67423)

more:
https://github-wiki-see.page/m/PimpTrizkit/PJs/wiki/12.-Shade%2C-Blend-and-Convert-a-Web-Color-%28pSBC.js%29
*/
function pSBC(p, c0, c1, l) {
  let r,
    g,
    b,
    P,
    f,
    t,
    h,
    m = Math.round,
    a = typeof c1 == 'string';
  if (typeof p != 'number' || p < -1 || p > 1 || typeof c0 != 'string' || c0[0] != 'r' && c0[0] != '#' || c1 && !a) return null;
  h = c0.length > 9, h = a ? c1.length > 9 ? true : c1 == 'c' ? !h : false : h, f = pSBCr(c0), P = p < 0, t = c1 && c1 != 'c' ? pSBCr(c1) : P ? {
    r: 0,
    g: 0,
    b: 0,
    a: -1
  } : {
    r: 255,
    g: 255,
    b: 255,
    a: -1
  }, p = P ? p * -1 : p, P = 1 - p;
  if (!f || !t) return null;
  if (l) r = m(P * f.r + p * t.r), g = m(P * f.g + p * t.g), b = m(P * f.b + p * t.b);else r = m((P * f.r ** 2 + p * t.r ** 2) ** 0.5), g = m((P * f.g ** 2 + p * t.g ** 2) ** 0.5), b = m((P * f.b ** 2 + p * t.b ** 2) ** 0.5);
  a = f.a, t = t.a, f = a >= 0 || t >= 0, a = f ? a < 0 ? t : t < 0 ? a : a * P + t * p : 0;
  if (h) return 'rgb' + (f ? 'a(' : '(') + r + ',' + g + ',' + b + (f ? ',' + m(a * 1000) / 1000 : '') + ')';else return '#' + (4294967296 + r * 16777216 + g * 65536 + b * 256 + (f ? m(a * 255) : 0)).toString(16).slice(1, f ? undefined : -2);
}
globalThis.pSBC = pSBC;
function rgba(c, p) {
  const f = pSBCr(c) || {
    r: 0,
    g: 0,
    b: 0
  };
  if (f.a < 0) {
    return `rgba(${f.r},${f.g},${f.b},${p})`;
  }
  return `rgba(${f.r},${f.g},${f.b},${p + f.a})`;
}
;// ./node_modules/@kyvi/cobweb/src/utils/math.js
function abs(num, percent) {
  if (+percent) {
    return +percent;
  }
  if (!percent || percent[percent.length - 1] !== '%') {
    return 0;
  }
  percent = percent.substr(0, percent.length - 1);
  return num * +percent / 100;
}
/**
 * 实际值是否在范围中, 数学上的开闭
 * @param realValue 实际值
 * @param collection 集合规范，与数学上相同，如[0, 100]，前闭后闭；如[0, 100)，前闭后开；
 * @returns undefined 说明参数不规范 ，true 说明在范围内，false 说明不在范围内
 */
function valueInRange(realValue, collection) {
  if (isNaN(realValue)) {
    console.warn(`realValue not number`);
    return;
  }
  if (typeof collection !== 'string') {
    console.warn('collection must be string');
    return;
  }
  const [start, end] = [collection[0], collection[collection.length - 1]];
  if (!['[', '('].includes(start)) {
    console.warn('collection must start with "[" or "("');
    return;
  }
  if (![']', ')'].includes(end)) {
    console.warn('collection must end with "]" or ")"');
    return;
  }
  const nums = collection.substring(1, collection.length - 1).split(',');
  if (nums.length !== 2) {
    console.warn('collection must have 2 numbers');
    return;
  }
  const [startNum, endNum] = [+nums[0], +nums[1]];
  if (startNum >= endNum) {
    console.warn('startNum must less than endNum');
    return;
  }
  // 大于 startNum 左肯定成立
  const left = realValue > startNum || start === '[' && realValue === startNum ? true : false;
  if (!left) {
    return false;
  }
  // 执行到这，左边已经是true了，判断右边
  const right = realValue < endNum || end === ']' && realValue === endNum ? true : false;
  return right;
}
/**
 * 实际值是否在数组中，即是否属于
 * 例如: [1,2,3] 只有 1 2 3 是属于 collection 的
 * .. 范围值 30..50 等于 闭区间的 [30,50] ，即范围值
 * [1,20,30..50,65] 只有 1 20 30..50 65 是属于 collection 的
 * @param realValue 实际值
 * @param collection 集合
 * @returns undefined 说明参数不规范 ，true 说明在范围内，false 说明不在范围内
 */
function valueInArray(realValue, collection) {
  // if (isNaN(realValue)) {
  //   console.warn(`realValue not number`);
  //   return;
  // }
  //允许字符串的情况
  if (typeof collection !== 'string') {
    console.warn('collection must be string');
    return;
  }
  const [start, end] = [collection[0], collection[collection.length - 1]];
  if (start !== '[' || end !== ']') {
    console.warn('collection must start with "[" and end with "]"');
    return;
  }
  const numStrs = collection.substring(1, collection.length - 1).split(',');
  for (const numStr of numStrs) {
    if (numStr.includes('..')) {
      // 范围值
      const [start, end] = numStr.split('..');
      const [startNum, endNum] = [+start, +end];
      if (startNum >= endNum) {
        console.warn('startNum must less than endNum');
        return;
      }
      if (realValue >= startNum && realValue <= endNum) {
        return true;
      }
    } else {
      // 单个值
      // let num:any = +numStr;
      // if(Number.isNaN(num)){
      //   num = numStr;
      //   const [start, end] = [num[0], num[num.length - 1]];
      //   if (!((start !== '"' && end !== '"')||(start !== "'" && end !== "'"))) {
      //     console.warn('Not a valid string');
      //     return;
      //   }else{
      //     num = num.substring(1, num.length - 1)
      //   }
      // }
      if (realValue == numStr) {
        return true;
      }
    }
  }
  return false;
}
;// ./node_modules/@kyvi/cobweb/src/utils/uuid.js
function s4() {
  return ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);
}
function s8() {
  return ((1 + Math.random()) * 0x100000000 | 0).toString(16).substring(1);
}
function s12() {
  return s4() + s8();
}
function s16() {
  return s8() + s8();
}
;// ./node_modules/@kyvi/cobweb/src/utils/padding.js
/**
 * turn padding into [top, right, bottom, left]
 * @param  {Number|Array} padding input padding
 * @return {array} output
 */
const formatPadding = padding => {
  let top = 0;
  let left = 0;
  let right = 0;
  let bottom = 0;
  if (typeof padding === 'number') {
    top = left = right = bottom = padding;
  } else if (typeof padding === 'string') {
    const intPadding = parseInt(padding, 10);
    top = left = right = bottom = intPadding;
  } else if (Array.isArray(padding)) {
    top = padding[0];
    right = !isNil(padding[1]) ? padding[1] : padding[0];
    bottom = !isNil(padding[2]) ? padding[2] : padding[0];
    left = !isNil(padding[3]) ? padding[3] : right;
  }
  return [top, right, bottom, left];
};
/**
 * Checks if `value` is `null` or `undefined`.
 *
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
 * @example
 *
 * isNil(null)
 * // => true
 *
 * isNil(void 0)
 * // => true
 *
 * isNil(NaN)
 * // => false
 */
function isNil(value) {
  return value == null;
}
;// ./node_modules/@kyvi/cobweb/src/utils/file.js
async function fileToBase64(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = e => {
      resolve(e.target.result);
    };
    reader.onerror = e => {
      reject(e);
    };
    reader.readAsDataURL(file);
  });
}
async function uploadFile(file, url, params, headers) {
  const formData = new FormData();
  // 后端接受的 formData 文件属性名一定为 file
  formData.append('file', file);
  if (params) {
    for (const key in params) {
      if (params.hasOwnProperty(key)) {
        formData.append(key, params[key]);
      }
    }
  }
  const res = await fetch(url, {
    method: 'POST',
    headers,
    body: formData
  });
  // 后端返回的一级属性中，必须包含一个名为url的属性
  return (await res.json()).url;
}
function loadCss(url, success, error) {
  var link = document.createElement('link');
  link.href = url;
  link.rel = 'stylesheet';
  success && (link.onload = success);
  error && (link.onerror = error);
  document.head.appendChild(link);
}
;// ./node_modules/@kyvi/cobweb/src/utils/url.js



function queryURLParams(value) {
  let url = value || window.location.search.split('?')[1];
  const urlSearchParams = new URLSearchParams(url);
  const params = Object.fromEntries(urlSearchParams.entries());
  return params;
}
const url_getRootDomain = () => {
  let domain = '';
  const domainItems = location.hostname.split('.');
  if (domainItems.length < 3 || domainItems.length === 4 && +domainItems[0] > 0 && +domainItems[1] > 0 && +domainItems[2] > 0 && +domainItems[3] > 0) {
    domain = location.hostname;
  } else if (location.hostname.endsWith('.com.cn') || location.hostname.endsWith('.org.cn')) {
    domain = domainItems.slice(-3).join('.');
  } else {
    domain = domainItems.slice(-2).join('.');
  }
  return domain;
};
;// ./node_modules/@kyvi/cobweb/src/utils/object.js
// const obj = {a:{b:[0,1,2]}}
// getter(obj, 'a.b.1')
function getter(object, path) {
  if (path == undefined) {
    return object;
  }
  const arr = path.split('.');
  while (arr.length && (object = object[arr.shift()]));
  return object;
}
// setter(obj, 'a.b.1', 111)
function setter(object, path, value) {
  if (path == undefined) {
    return;
  }
  path.split('.').reduce((o, p, i) => o[p] = path.split('.').length === ++i ? value : o[p] || {}, object);
}
;// ./node_modules/@kyvi/cobweb/src/utils/time.js
function formatTime(format) {
  const weeks = ['天', '一', '二', '三', '四', '五', '六'];
  const now = new Date();
  const year = now.getFullYear();
  const month = now.getMonth() + 1;
  const day = now.getDate();
  const week = now.getDay();
  const hours = now.getHours();
  const minutes = now.getMinutes();
  const seconds = now.getSeconds();
  const fn = new Function('year', 'month', 'day', 'week', 'hours', 'minutes', 'seconds', format ? `return ${format}` : 'return `${year}:${month}:${day} ${hours}:${minutes}:${seconds} 星期${week}`');
  const time = fn(year, month, day, weeks[week], hours, minutes, seconds);
  return time;
}
;// ./node_modules/@kyvi/cobweb/src/utils/index.js









;// ./node_modules/@kyvi/cobweb/src/pen/render.js












/**
 * ancestor 是否是 pen 的祖先
 * @param pen 当前画笔
 * @param ancestor 祖先画笔
 */
function isAncestor(pen, ancestor) {
  if (!pen || !ancestor) {
    return false;
  }
  let parent = getParent(pen);
  while (parent) {
    if (parent.id === ancestor.id) {
      return true;
    }
    parent = getParent(parent);
  }
  return false;
}
function getParent(pen, root) {
  if (!pen || !pen.parentId || !pen.calculative) {
    return undefined;
  }
  const store = pen.calculative.canvas.store;
  const parent = store.pens[pen.parentId];
  if (!root) {
    return parent;
  }
  return getParent(parent, root) || parent;
}
function getAllChildren(pen, store) {
  if (!pen || !pen.children) {
    return [];
  }
  const children = [];
  pen.children.forEach(id => {
    const child = store.pens[id];
    if (child) {
      children.push(child);
      children.push(...getAllChildren(child, store));
    }
  });
  return children;
}
function getAllFollowers(pen, store) {
  if (!pen || !pen.followers) {
    return [];
  }
  const followers = [];
  pen.followers.forEach(id => {
    const follower = store.pens[id];
    if (follower && !follower.parentId) {
      followers.push(follower);
      followers.push(...getAllFollowers(follower, store));
    }
  });
  return followers;
}
function drawBkLinearGradient(ctx, pen) {
  const {
    worldRect,
    gradientFromColor,
    gradientToColor,
    gradientAngle
  } = pen.calculative;
  return linearGradient(ctx, worldRect, gradientFromColor, gradientToColor, gradientAngle);
}
/**
 * 避免副作用，把创建好后的径向渐变对象返回出来
 * @param ctx 画布绘制对象
 * @param pen 当前画笔
 * @returns 径向渐变
 */
function drawBkRadialGradient(ctx, pen) {
  const {
    worldRect,
    gradientFromColor,
    gradientToColor,
    gradientRadius
  } = pen.calculative;
  if (!gradientFromColor || !gradientToColor) {
    return;
  }
  const {
    width,
    height,
    center
  } = worldRect;
  const {
    x: centerX,
    y: centerY
  } = center;
  let r = width;
  if (r < height) {
    r = height;
  }
  r *= 0.5;
  const grd = ctx.createRadialGradient(centerX, centerY, r * (gradientRadius || 0), centerX, centerY, r);
  grd.addColorStop(0, gradientFromColor);
  grd.addColorStop(1, gradientToColor);
  return grd;
}
function getLinearGradientPoints(x1, y1, x2, y2, r) {
  let slantAngle = 0;
  slantAngle = Math.PI / 2 - Math.atan2(y2 - y1, x2 - x1);
  const originX = (x1 + x2) / 2;
  const originY = (y1 + y2) / 2;
  const perpX1 = originX + r * Math.sin(90 * Math.PI / 180 - slantAngle);
  const perpY1 = originY + r * -Math.cos(90 * Math.PI / 180 - slantAngle);
  const perpX2 = originX + r * Math.sin(270 * Math.PI / 180 - slantAngle);
  const perpY2 = originY + r * -Math.cos(270 * Math.PI / 180 - slantAngle);
  return [perpX1, perpY1, perpX2, perpY2];
}
function getBkRadialGradient(ctx, pen) {
  const {
    worldRect,
    gradientColors,
    gradientRadius
  } = pen.calculative;
  if (!gradientColors) {
    return;
  }
  const {
    width,
    height,
    center
  } = worldRect;
  const {
    x: centerX,
    y: centerY
  } = center;
  let r = width;
  if (r < height) {
    r = height;
  }
  r *= 0.5;
  const {
    colors
  } = formatGradient(gradientColors);
  const grd = ctx.createRadialGradient(centerX, centerY, r * (gradientRadius || 0), centerX, centerY, r);
  colors.forEach(stop => {
    grd.addColorStop(stop.i, stop.color);
  });
  return grd;
}
function getBkGradient(ctx, pen) {
  const {
    x,
    y,
    ex,
    width,
    height,
    center
  } = pen.calculative.worldRect;
  let points = [{
    x: ex,
    y: y + height / 2
  }, {
    x: x,
    y: y + height / 2
  }];
  const {
    angle,
    colors
  } = formatGradient(pen.calculative.gradientColors);
  let r = getGradientR(angle, width, height);
  points.forEach(point => {
    rotatePoint(point, angle, center);
  });
  return getLinearGradient(ctx, points, colors, r);
}
function getTextRadialGradient(ctx, pen) {
  const {
    worldRect,
    textGradientColors
  } = pen.calculative;
  if (!textGradientColors) {
    return;
  }
  const {
    width,
    height,
    center
  } = worldRect;
  const {
    x: centerX,
    y: centerY
  } = center;
  let r = width;
  if (r < height) {
    r = height;
  }
  r *= 0.5;
  const {
    colors
  } = formatGradient(textGradientColors);
  const grd = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, r);
  colors.forEach(stop => {
    grd.addColorStop(stop.i, stop.color);
  });
  return grd;
}
function getTextGradient(ctx, pen) {
  const {
    x,
    y,
    ex,
    width,
    height,
    center
  } = pen.calculative.worldRect;
  let points = [{
    x: ex,
    y: y + height / 2
  }, {
    x: x,
    y: y + height / 2
  }];
  const {
    angle,
    colors
  } = formatGradient(pen.calculative.textGradientColors);
  let r = getGradientR(angle, width, height);
  points.forEach(point => {
    rotatePoint(point, angle, center);
  });
  return getLinearGradient(ctx, points, colors, r);
}
function getGradientR(angle, width, height) {
  const dividAngle = Math.atan(height / width) / Math.PI * 180;
  let calculateAngle = (angle - 90) % 360;
  let r = 0;
  if (calculateAngle > dividAngle && calculateAngle < 180 - dividAngle || calculateAngle > 180 + dividAngle && calculateAngle < 360 - dividAngle || calculateAngle < 0) {
    //根据高计算
    if (calculateAngle > 270) {
      calculateAngle = 360 - calculateAngle;
    } else if (calculateAngle > 180) {
      calculateAngle = calculateAngle - 180;
    } else if (calculateAngle > 90) {
      calculateAngle = 180 - calculateAngle;
    }
    r = Math.abs(height / Math.sin(calculateAngle / 180 * Math.PI) / 2);
  } else {
    //根据宽计算
    if (calculateAngle > 270) {
      calculateAngle = 360 - calculateAngle;
    } else if (calculateAngle > 180) {
      calculateAngle = calculateAngle - 180;
    } else if (calculateAngle > 90) {
      calculateAngle = 180 - calculateAngle;
    }
    r = Math.abs(width / Math.cos(calculateAngle / 180 * Math.PI) / 2);
  }
  return r;
}
function formatGradient(color) {
  if (typeof color == 'string' && color.startsWith('linear-gradient')) {
    let arr = color.slice(16, -2).split('deg,');
    if (arr.length > 1) {
      let _arr = arr[1].split('%,');
      const colors = [];
      _arr.forEach(stap => {
        if (/rgba?/.test(stap)) {
          let _arr = stap.split(') ');
          colors.push({
            color: rgbaToHex(_arr[0] + ')'),
            i: parseFloat(_arr[1]) / 100
          });
        } else {
          let _arr = stap.split(' ');
          if (_arr.length > 2) {
            colors.push({
              color: _arr[1],
              i: parseFloat(_arr[2]) / 100
            });
          } else {
            colors.push({
              color: _arr[0],
              i: parseFloat(_arr[1]) / 100
            });
          }
        }
      });
      return {
        angle: parseFloat(arr[0]),
        colors
      };
    } else {
      return {
        angle: parseFloat(arr[0]),
        colors: []
      };
    }
  } else {
    return {
      angle: 0,
      colors: []
    };
  }
}
function rgbaToHex(value) {
  if (/rgba?/.test(value)) {
    let array = value.split(',');
    //不符合rgb或rgb规则直接return
    if (array.length < 3) return '';
    value = '#';
    for (let i = 0, color; color = array[i++];) {
      if (i < 4) {
        //前三位转换成16进制
        color = parseInt(color.replace(/[^\d]/gi, ''), 10).toString(16);
        value += color.length == 1 ? '0' + color : color;
      } else {
        //rgba的透明度转换成16进制
        color = color.replace(')', '');
        let colorA = parseInt(color * 255 + '');
        let colorAHex = colorA.toString(16);
        colorAHex = colorAHex.length === 2 ? colorAHex : '0' + colorAHex;
        value += colorAHex;
      }
    }
    value = value.toUpperCase();
  }
  return value;
}
function getLineGradient(ctx, pen) {
  const {
    x,
    y,
    ex,
    width,
    height,
    center
  } = pen.calculative.worldRect;
  let points = [{
    x: ex,
    y: y + height / 2
  }, {
    x: x,
    y: y + height / 2
  }];
  const {
    angle,
    colors
  } = formatGradient(pen.calculative.lineGradientColors);
  let r = getGradientR(angle, width, height);
  points.forEach(point => {
    rotatePoint(point, angle, center);
  });
  return getLinearGradient(ctx, points, colors, r);
}
function getLinearGradient(ctx, points, colors, radius) {
  let arr = getLinearGradientPoints(points[0].x, points[0].y, points[1].x, points[1].y, radius);
  let gradient = ctx.createLinearGradient(arr[0], arr[1], arr[2], arr[3]);
  colors.forEach(stop => {
    gradient.addColorStop(stop.i, stop.color);
  });
  return gradient;
}
function drawLinearGradientLine(ctx, pen, points) {
  let colors = [];
  if (pen.calculative.gradientColorStop) {
    colors = pen.calculative.gradientColorStop;
  } else {
    colors = formatGradient(pen.calculative.lineGradientColors).colors;
    pen.calculative.gradientColorStop = colors;
  }
  ctx.strokeStyle = getLinearGradient(ctx, points, colors, pen.calculative.lineWidth / 2);
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  ctx.lineTo(points[1].x, points[1].y);
  ctx.stroke();
}
function ctxDrawLinearGradientPath(ctx, pen) {
  const anchors = pen.calculative.worldAnchors;
  let smoothLenth = pen.calculative.lineWidth * (pen.calculative.gradientSmooth || pen.calculative.lineSmooth || 0);
  for (let i = 0; i < anchors.length - 1; i++) {
    if ((pen.lineName === 'curve' || pen.lineName === 'mind') && anchors[i].curvePoints) {
      if (i > 0) {
        let lastCurvePoints = anchors[i - 1].curvePoints;
        if (lastCurvePoints) {
          //上一个存在锚点
          smoothTransition(ctx, pen, smoothLenth, lastCurvePoints[lastCurvePoints.length - 1], anchors[i], anchors[i].curvePoints[0]);
        } else {
          smoothTransition(ctx, pen, smoothLenth, anchors[i - 1], anchors[i], anchors[i].curvePoints[0]);
        }
        //获取当前相对于0的位置
        let next = getSmoothAdjacent(smoothLenth, anchors[i], anchors[i].curvePoints[0]);
        drawLinearGradientLine(ctx, pen, [next, anchors[i].curvePoints[1]]);
      } else {
        drawLinearGradientLine(ctx, pen, [anchors[i], anchors[i].curvePoints[0]]);
        drawLinearGradientLine(ctx, pen, [anchors[i].curvePoints[0], anchors[i].curvePoints[1]]);
      }
      let len = anchors[i].curvePoints.length - 1;
      for (let j = 1; j < len; j++) {
        drawLinearGradientLine(ctx, pen, [anchors[i].curvePoints[j], anchors[i].curvePoints[j + 1]]);
      }
      let last = getSmoothAdjacent(smoothLenth, anchors[i + 1], anchors[i].curvePoints[len]);
      drawLinearGradientLine(ctx, pen, [anchors[i].curvePoints[len], last]);
    } else {
      let _next = anchors[i];
      let _last = anchors[i + 1];
      if (i > 0 && i < anchors.length - 1) {
        //有突兀的地方
        let lastCurvePoints = anchors[i - 1].curvePoints;
        if (lastCurvePoints) {
          smoothTransition(ctx, pen, smoothLenth, lastCurvePoints[lastCurvePoints.length - 1], anchors[i], anchors[i + 1]);
        } else {
          smoothTransition(ctx, pen, smoothLenth, anchors[i - 1], anchors[i], anchors[i + 1]);
        }
      }
      if (i > 0 && i < anchors.length - 1) {
        _next = getSmoothAdjacent(smoothLenth, anchors[i], anchors[i + 1]);
      }
      if (i < anchors.length - 2) {
        _last = getSmoothAdjacent(smoothLenth, anchors[i + 1], anchors[i]);
      }
      let flag = false;
      if (i === 0) {
        if (pen.fromLineCap && pen.fromLineCap !== 'butt') {
          ctx.save();
          flag = true;
          ctx.lineCap = pen.fromLineCap;
        }
      }
      if (i !== 0 && i === anchors.length - 2) {
        if (pen.toLineCap && pen.toLineCap !== 'butt') {
          ctx.save();
          flag = true;
          ctx.lineCap = pen.toLineCap;
        }
      }
      drawLinearGradientLine(ctx, pen, [_next, _last]);
      if (flag) {
        ctx.restore();
      }
      if (anchors.length === 2 && i === 0) {
        ctx.save();
        flag = true;
        ctx.lineCap = pen.toLineCap;
        let _y = 0.1;
        let _x = 0.1;
        if (_next.x - _last.x === 0) {
          _x = 0;
        } else {
          _y = (_next.y - _last.y) / (_next.x - _last.x) * 0.1;
        }
        drawLinearGradientLine(ctx, pen, [{
          x: _last.x - _x,
          y: _last.y - _y
        }, _last]);
        ctx.restore();
      }
    }
  }
}
function getSmoothAdjacent(smoothLenth, p1, p2) {
  let nexLength = Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));
  if (nexLength === 0) {
    return {
      x: p1.x,
      y: p1.y
    };
  }
  if (smoothLenth < nexLength) {
    return {
      x: p1.x + (p2.x - p1.x) * smoothLenth / nexLength,
      y: p1.y + (p2.y - p1.y) * smoothLenth / nexLength
    };
  } else {
    return {
      x: p1.x + (p2.x - p1.x) / nexLength / 2,
      y: p1.y + (p2.y - p1.y) / nexLength / 2
    };
  }
}
function smoothTransition(ctx, pen, smoothLenth, p1, p2, p3) {
  let last = getSmoothAdjacent(smoothLenth, p2, p1);
  let next = getSmoothAdjacent(smoothLenth, p2, p3);
  let contrlPoint = {
    x: p2.x,
    y: p2.y
  };
  let points = getBezierPoints(pen.calculative.canvas.store.data.smoothNum || 20, last, contrlPoint, next);
  for (let k = 0; k < points.length - 1; k++) {
    drawLinearGradientLine(ctx, pen, [{
      x: points[k].x,
      y: points[k].y
    }, {
      x: points[k + 1].x,
      y: points[k + 1].y
    }]);
  }
}
function smoothAnimateTransition(ctx, smoothLenth, p2, p3) {
  let next = getSmoothAdjacent(smoothLenth, p2, p3);
  let contrlPoint = {
    x: p2.x,
    y: p2.y
  };
  ctx.quadraticCurveTo(contrlPoint.x, contrlPoint.y, next.x, next.y);
}
function getGradientAnimatePath(pen) {
  const anchors = pen.calculative.worldAnchors;
  let smoothLenth = pen.calculative.lineWidth * (pen.calculative.gradientSmooth || pen.calculative.lineSmooth || 0);
  //只创建一次
  const _path = new Path2D();
  for (let i = 0; i < anchors.length - 1; i++) {
    let _next = anchors[i];
    let _last = anchors[i + 1];
    if (i == 0) {
      _path.moveTo(anchors[i].x, anchors[i].y);
    }
    if (i > 0 && i < anchors.length - 1) {
      //有突兀的地方
      let lastCurvePoints = anchors[i - 1].curvePoints;
      // const path = new Path2D();
      if (lastCurvePoints) {
        smoothAnimateTransition(_path, smoothLenth, anchors[i], anchors[i + 1]);
      } else {
        smoothAnimateTransition(_path, smoothLenth, anchors[i], anchors[i + 1]);
      }
    }
    if (i > 0 && i < anchors.length - 1) {
      _next = getSmoothAdjacent(smoothLenth, anchors[i], anchors[i + 1]);
    }
    if (i < anchors.length - 2) {
      _last = getSmoothAdjacent(smoothLenth, anchors[i + 1], anchors[i]);
    }
    _path.lineTo(_last.x, _last.y);
  }
  return _path;
}
function getAngle(p1, p2, p3) {
  let a = {
      x: 0,
      y: 0
    },
    b = {
      x: 0,
      y: 0
    };
  a.x = p1.x - p2.x;
  a.y = p1.y - p2.y;
  b.x = p3.x - p2.x;
  b.y = p3.y - p2.y;
  return Math.acos((a.x * b.x + a.y * b.y) / (Math.sqrt(a.x * a.x + a.y * a.y) * Math.sqrt(b.x * b.x + b.y * b.y))) / Math.PI * 180;
}
function getBezierPoints(num = 100, p1, p2, p3, p4) {
  let func = null;
  const points = [];
  if (!p3 && !p4) {
    func = oneBezier;
  } else if (p3 && !p4) {
    func = twoBezier;
  } else if (p3 && p4) {
    func = threeBezier;
  }
  for (let i = 0; i < num; i++) {
    points.push(func(i / num, p1, p2, p3, p4));
  }
  if (p4) {
    points.push(p4);
  } else if (p3) {
    points.push(p3);
  }
  return points;
}
/**
 * @desc 一阶贝塞尔
 * @param  t 当前百分比
 * @param  p1 起点坐标
 * @param  p2 终点坐标
 */
function oneBezier(t, p1, p2) {
  const {
    x: x1,
    y: y1
  } = p1;
  const {
    x: x2,
    y: y2
  } = p2;
  let x = x1 + (x2 - x1) * t;
  let y = y1 + (y2 - y1) * t;
  return {
    x,
    y
  };
}
/**
 * @desc 二阶贝塞尔
 * @param  t 当前百分比
 * @param  p1 起点坐标
 * @param  p2 终点坐标
 * @param  cp 控制点
 */
function twoBezier(t, p1, cp, p2) {
  const {
    x: x1,
    y: y1
  } = p1;
  const {
    x: cx,
    y: cy
  } = cp;
  const {
    x: x2,
    y: y2
  } = p2;
  let x = (1 - t) * (1 - t) * x1 + 2 * t * (1 - t) * cx + t * t * x2;
  let y = (1 - t) * (1 - t) * y1 + 2 * t * (1 - t) * cy + t * t * y2;
  return {
    x,
    y
  };
}
/**
 * @desc 三阶贝塞尔
 * @param  t 当前百分比
 * @param  p1 起点坐标
 * @param  p2 终点坐标
 * @param  cp1 控制点1
 * @param  cp2 控制点2
 */
function threeBezier(t, p1, cp1, cp2, p2) {
  const {
    x: x1,
    y: y1
  } = p1;
  const {
    x: x2,
    y: y2
  } = p2;
  const {
    x: cx1,
    y: cy1
  } = cp1;
  const {
    x: cx2,
    y: cy2
  } = cp2;
  let x = x1 * (1 - t) * (1 - t) * (1 - t) + 3 * cx1 * t * (1 - t) * (1 - t) + 3 * cx2 * t * t * (1 - t) + x2 * t * t * t;
  let y = y1 * (1 - t) * (1 - t) * (1 - t) + 3 * cy1 * t * (1 - t) * (1 - t) + 3 * cy2 * t * t * (1 - t) + y2 * t * t * t;
  return {
    x,
    y
  };
}
function strokeLinearGradient(ctx, pen) {
  const {
    worldRect,
    lineGradientFromColor,
    lineGradientToColor,
    lineGradientAngle
  } = pen.calculative;
  return linearGradient(ctx, worldRect, lineGradientFromColor, lineGradientToColor, lineGradientAngle);
}
/**
 * 避免副作用，把创建好后的线性渐变对象返回出来
 * @param ctx 画布绘制对象
 * @param worldRect 世界坐标
 * @returns 线性渐变
 */
function linearGradient(ctx, worldRect, fromColor, toColor, angle) {
  if (!fromColor || !toColor) {
    return;
  }
  const {
    x,
    y,
    center,
    ex,
    ey
  } = worldRect;
  const from = {
    x,
    y: center.y
  };
  const to = {
    x: ex,
    y: center.y
  };
  if (angle % 90 === 0 && angle % 180) {
    from.x = center.x;
    to.x = center.x;
    if (angle % 270) {
      from.y = y;
      to.y = ey;
    } else {
      from.y = ey;
      to.y = y;
    }
  } else if (angle) {
    rotatePoint(from, angle, worldRect.center);
    rotatePoint(to, angle, worldRect.center);
  }
  // contributor: https://github.com/sunnyguohua/meta2d
  const grd = ctx.createLinearGradient(from.x, from.y, to.x, to.y);
  grd.addColorStop(0, fromColor);
  grd.addColorStop(1, toColor);
  return grd;
}
/**
 * 根据图片的宽高， imageRatio iconAlign 来获取图片的实际位置
 * @param pen 画笔
 */
function getImagePosition(pen) {
  const {
    worldIconRect: rect,
    iconWidth,
    iconHeight,
    imgNaturalWidth,
    imgNaturalHeight
  } = pen.calculative;
  let {
    x,
    y,
    width: w,
    height: h
  } = rect;
  if (iconWidth) {
    w = iconWidth;
  }
  if (iconHeight) {
    h = iconHeight;
  }
  if (imgNaturalWidth && imgNaturalHeight && pen.imageRatio) {
    const scaleW = rect.width / imgNaturalWidth;
    const scaleH = rect.height / imgNaturalHeight;
    const scaleMin = Math.min(scaleW, scaleH);
    const wDivideH = imgNaturalWidth / imgNaturalHeight;
    if (iconWidth) {
      h = iconWidth / wDivideH;
    } else if (iconHeight) {
      w = iconHeight * wDivideH;
    } else {
      w = scaleMin * imgNaturalWidth;
      h = scaleMin * imgNaturalHeight;
    }
  }
  x += (rect.width - w) / 2;
  y += (rect.height - h) / 2;
  switch (pen.iconAlign) {
    case 'top':
      y = rect.y;
      break;
    case 'bottom':
      y = rect.ey - h;
      break;
    case 'left':
      x = rect.x;
      break;
    case 'right':
      x = rect.ex - w;
      break;
    case 'left-top':
      x = rect.x;
      y = rect.y;
      break;
    case 'right-top':
      x = rect.ex - w;
      y = rect.y;
      break;
    case 'left-bottom':
      x = rect.x;
      y = rect.ey - h;
      break;
    case 'right-bottom':
      x = rect.ex - w;
      y = rect.ey - h;
      break;
  }
  return {
    x,
    y,
    width: w,
    height: h
  };
}
function drawImage(ctx, pen) {
  const {
    x,
    y,
    width,
    height
  } = getImagePosition(pen);
  const {
    worldIconRect,
    iconRotate,
    img
  } = pen.calculative;
  if (iconRotate) {
    const {
      x: centerX,
      y: centerY
    } = worldIconRect.center;
    ctx.translate(centerX, centerY);
    ctx.rotate(iconRotate * Math.PI / 180);
    ctx.translate(-centerX, -centerY);
  }
  if (pen.imageRadius) {
    ctx.save();
    let wr = pen.calculative.imageRadius || 0,
      hr = wr;
    const {
      x: _x,
      y: _y,
      width: w,
      height: h,
      ex,
      ey
    } = pen.calculative.worldRect;
    if (wr < 1) {
      wr = w * wr;
      hr = h * hr;
    }
    let r = wr < hr ? wr : hr;
    if (w < 2 * r) {
      r = w / 2;
    }
    if (h < 2 * r) {
      r = h / 2;
    }
    ctx.beginPath();
    ctx.moveTo(_x + r, _y);
    ctx.arcTo(ex, _y, ex, ey, r);
    ctx.arcTo(ex, ey, _x, ey, r);
    ctx.arcTo(_x, ey, _x, _y, r);
    ctx.arcTo(_x, _y, ex, _y, r);
    ctx.clip();
    ctx.drawImage(img, x, y, width, height);
    ctx.restore();
  } else {
    ctx.drawImage(img, x, y, width, height);
  }
}
/**
 * 获取文字颜色， textColor 优先其次 color
 */
function getTextColor(pen, store) {
  const {
    textColor,
    color
  } = pen.calculative;
  const {
    data,
    options
  } = store;
  return textColor || color || data.textColor || data.color || options.textColor || options.color;
}
function drawText(ctx, pen) {
  const {
    fontStyle,
    fontWeight,
    fontSize,
    fontFamily,
    lineHeight,
    text,
    hiddenText,
    canvas,
    textHasShadow,
    textBackground,
    textType
  } = pen.calculative;
  if (text == undefined || hiddenText) {
    return;
  }
  const store = canvas.store;
  ctx.save();
  if (!textHasShadow) {
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
  }
  let fill = undefined;
  if (pen.calculative.disabled) {
    fill = pen.disabledTextColor || pen.disabledColor || pSBC(0.4, getTextColor(pen, store));
  } else if (pen.calculative.hover) {
    fill = pen.hoverTextColor || pen.hoverColor || store.options.hoverColor;
  } else if (pen.calculative.active) {
    fill = pen.activeTextColor || pen.activeColor || store.options.activeColor;
  }
  let gradient = undefined;
  if (textType === Gradient.Linear) {
    gradient = getTextGradient(ctx, pen);
  } else if (textType === Gradient.Radial) {
    gradient = getTextRadialGradient(ctx, pen);
  }
  ctx.fillStyle = fill || gradient || getTextColor(pen, store);
  ctx.font = getFont({
    fontStyle,
    fontWeight,
    fontFamily: fontFamily || store.options.fontFamily,
    fontSize,
    lineHeight
  });
  !pen.calculative.textDrawRect && calcTextDrawRect(ctx, pen);
  const {
    x: drawRectX,
    y: drawRectY,
    width,
    height
  } = pen.calculative.textDrawRect;
  if (textBackground) {
    ctx.save();
    ctx.fillStyle = textBackground;
    ctx.fillRect(drawRectX, drawRectY, width, height);
    ctx.restore();
  }
  const y = 0.55;
  const textAlign = pen.textAlign || store.options.textAlign;
  const oneRowHeight = fontSize * lineHeight;
  pen.calculative.textLines.forEach((text, i) => {
    const textLineWidth = pen.calculative.textLineWidths[i];
    let x = 0;
    if (textAlign === 'center') {
      x = (width - textLineWidth) / 2;
    } else if (textAlign === 'right') {
      x = width - textLineWidth;
    }
    // 下划线
    ctx.fillText(text, drawRectX + x, drawRectY + (i + y) * oneRowHeight);
    const {
      textDecorationColor,
      textDecorationDash,
      textDecoration
    } = pen;
    if (textDecoration) {
      drawUnderLine(ctx, {
        x: drawRectX + x,
        y: drawRectY + (i + y) * oneRowHeight,
        width: textLineWidth
      }, {
        textDecorationColor,
        textDecorationDash,
        fontSize
      });
    }
    // 删除线
    const {
      textStrickoutColor,
      textStrickoutDash,
      textStrickout
    } = pen;
    if (textStrickout) {
      drawStrickout(ctx, {
        x: drawRectX + x,
        y: drawRectY + (i + y) * oneRowHeight,
        width: textLineWidth
      }, {
        textStrickoutColor,
        textStrickoutDash,
        fontSize
      });
    }
  });
  ctx.restore();
}
function drawUnderLine(ctx, location, config) {
  const {
    textDecorationColor,
    textDecorationDash,
    fontSize
  } = config;
  let {
    x,
    y,
    width
  } = location;
  switch (ctx.textBaseline) {
    case 'top':
      y += fontSize;
      break;
    case 'middle':
      y += fontSize / 2;
      break;
  }
  ctx.save();
  ctx.beginPath();
  ctx.strokeStyle = textDecorationColor ? textDecorationColor : ctx.fillStyle;
  ctx.lineWidth = 1;
  ctx.moveTo(x, y);
  ctx.setLineDash(textDecorationDash || []);
  ctx.lineTo(x + width, y);
  ctx.stroke();
  ctx.restore();
}
function drawStrickout(ctx, location, config) {
  const {
    textStrickoutColor,
    textStrickoutDash,
    fontSize
  } = config;
  let {
    x,
    y,
    width
  } = location;
  switch (ctx.textBaseline) {
    case 'top':
      y += fontSize / 2;
      break;
    case 'bottom':
      y -= fontSize / 2;
      break;
  }
  ctx.save();
  ctx.beginPath();
  ctx.strokeStyle = textStrickoutColor ? textStrickoutColor : ctx.fillStyle;
  ctx.lineWidth = 1;
  ctx.moveTo(x, y);
  ctx.setLineDash(textStrickoutDash || []);
  ctx.lineTo(x + width, y);
  ctx.stroke();
  ctx.restore();
}
function drawFillText(ctx, pen, text) {
  if (text == undefined) {
    return;
  }
  const {
    fontStyle,
    fontWeight,
    fontSize,
    fontFamily,
    lineHeight,
    canvas
  } = pen.calculative;
  const store = canvas.store;
  ctx.save();
  let fill = undefined;
  if (pen.calculative.hover) {
    fill = pen.hoverTextColor || pen.hoverColor || store.options.hoverColor;
  } else if (pen.calculative.active) {
    fill = pen.activeTextColor || pen.activeColor || store.options.activeColor;
  }
  ctx.fillStyle = fill || getTextColor(pen, store);
  ctx.font = getFont({
    fontStyle,
    fontWeight,
    fontFamily: fontFamily || store.options.fontFamily,
    fontSize,
    lineHeight
  });
  const w = ctx.measureText(text).width;
  let t;
  let prev;
  for (const anchor of pen.calculative.worldAnchors) {
    if (!prev) {
      prev = anchor;
      continue;
    }
    const dis = distance(prev, anchor);
    const n = Math.floor(dis / w);
    t = '';
    for (let i = 0; i < n; i++) {
      t += text;
    }
    const angle = calcRotate(prev, anchor) - 270;
    ctx.save();
    if (angle % 360 !== 0) {
      const {
        x,
        y
      } = prev;
      ctx.translate(x, y);
      let rotate = angle * Math.PI / 180;
      ctx.rotate(rotate);
      ctx.translate(-x, -y);
    }
    ctx.fillText(t, prev.x, prev.y + lineHeight / 2);
    ctx.restore();
    prev = anchor;
  }
  ctx.restore();
}
function drawIcon(ctx, pen) {
  const store = pen.calculative.canvas.store;
  ctx.save();
  ctx.shadowColor = '';
  ctx.shadowBlur = 0;
  ctx.shadowOffsetX = 0;
  ctx.shadowOffsetY = 0;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  const iconRect = pen.calculative.worldIconRect;
  let x = iconRect.x + iconRect.width / 2;
  let y = iconRect.y + iconRect.height / 2;
  switch (pen.iconAlign) {
    case 'top':
      y = iconRect.y;
      ctx.textBaseline = 'top';
      break;
    case 'bottom':
      y = iconRect.ey;
      ctx.textBaseline = 'bottom';
      break;
    case 'left':
      x = iconRect.x;
      ctx.textAlign = 'left';
      break;
    case 'right':
      x = iconRect.ex;
      ctx.textAlign = 'right';
      break;
    case 'left-top':
      x = iconRect.x;
      y = iconRect.y;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      break;
    case 'right-top':
      x = iconRect.ex;
      y = iconRect.y;
      ctx.textAlign = 'right';
      ctx.textBaseline = 'top';
      break;
    case 'left-bottom':
      x = iconRect.x;
      y = iconRect.ey;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'bottom';
      break;
    case 'right-bottom':
      x = iconRect.ex;
      y = iconRect.ey;
      ctx.textAlign = 'right';
      ctx.textBaseline = 'bottom';
      break;
  }
  const fontWeight = pen.calculative.iconWeight;
  let fontSize = undefined;
  const fontFamily = pen.calculative.iconFamily;
  if (pen.calculative.iconSize > 0) {
    fontSize = pen.calculative.iconSize;
  } else if (iconRect.width > iconRect.height) {
    fontSize = iconRect.height;
  } else {
    fontSize = iconRect.width;
  }
  ctx.font = getFont({
    fontSize,
    fontWeight,
    fontFamily
  });
  ctx.fillStyle = pen.calculative.iconColor || getTextColor(pen, store);
  if (pen.calculative.iconRotate) {
    ctx.translate(iconRect.center.x, iconRect.center.y);
    ctx.rotate(pen.calculative.iconRotate * Math.PI / 180);
    ctx.translate(-iconRect.center.x, -iconRect.center.y);
  }
  ctx.beginPath();
  ctx.fillText(pen.calculative.icon, x, y);
  ctx.restore();
}
/**
 * canvas2svg 中对 font 的解析规则比 canvas 中简单，能识别的类型很少
 * @returns ctx.font
 */
function getFont({
  fontStyle = 'normal',
  textDecoration = 'normal',
  fontWeight = 'normal',
  fontSize = 12,
  fontFamily = 'Arial',
  lineHeight = 1 // TODO: lineHeight 默认值待测试
} = {}) {
  return `${fontStyle} ${textDecoration} ${fontWeight} ${fontSize}px/${lineHeight} ${fontFamily}`;
}
// TODO: 0.5 偏移量在 图片中可能存在问题
function ctxFlip(ctx, pen) {
  // worldRect 可能为 undefined
  const {
    x,
    ex,
    y,
    ey
  } = pen.calculative.worldRect || {};
  if (pen.calculative.flipX) {
    ctx.translate(x + ex + 0.5, 0.5);
    ctx.scale(-1, 1);
  }
  if (pen.calculative.flipY) {
    ctx.translate(0.5, y + ey + 0.5);
    ctx.scale(1, -1);
  }
}
function ctxRotate(ctx, pen, noFlip = false) {
  const {
    x,
    y
  } = pen.calculative.worldRect.pivot || pen.calculative.worldRect.center;
  ctx.translate(x, y);
  let rotate = pen.calculative.rotate * Math.PI / 180;
  // 目前只有水平和垂直翻转，都需要 * -1
  if (!noFlip) {
    if (pen.calculative.flipX) {
      rotate *= -1;
    }
    if (pen.calculative.flipY) {
      rotate *= -1;
    }
  }
  ctx.rotate(rotate);
  ctx.translate(-x, -y);
}
function renderPen(ctx, pen, download) {
  ctx.save();
  ctx.translate(0.5, 0.5);
  ctx.beginPath();
  const store = pen.calculative.canvas.store;
  const textFlip = pen.textFlip || store.options.textFlip;
  const textRotate = pen.textRotate || store.options.textRotate;
  if (!textFlip || !textRotate) {
    ctx.save();
  }
  ctxFlip(ctx, pen);
  if (pen.calculative.rotate && pen.name !== 'line') {
    ctxRotate(ctx, pen);
  }
  if (pen.calculative.lineWidth > 1 || download) {
    ctx.lineWidth = pen.calculative.lineWidth;
  }
  inspectRect(ctx, store, pen); // 审查 rect
  let fill;
  // 该变量控制在 hover active 状态下的节点是否设置填充颜色
  // let setBack = true;
  let lineGradientFlag = false;
  let _stroke = undefined;
  if (pen.calculative.disabled) {
    _stroke = pen.disabledColor || store.options.disabledColor || pSBC(0.4, pen.calculative.color || getGlobalColor(store));
    fill = pen.disabledBackground || store.options.disabledBackground || pSBC(0.4, pen.calculative.background || store.data.penBackground);
  } else if (pen.mouseDownValid && pen.calculative.mouseDown) {
    _stroke = pen.mouseDownColor || pSBC(-0.4, pen.calculative.color || getGlobalColor(store));
    fill = pen.mouseDownBackground || pSBC(-0.4, pen.calculative.background || store.data.penBackground);
  } else if (pen.calculative.hover) {
    _stroke = pen.hoverColor || store.options.hoverColor;
    fill = pen.hoverBackground || store.options.hoverBackground;
    //  ctx.fillStyle = fill;
    //  fill && (setBack = false);
  } else if (pen.calculative.active) {
    _stroke = pen.activeColor || store.options.activeColor;
    fill = pen.activeBackground || store.options.activeBackground;
    // ctx.fillStyle = fill;
    // fill && (setBack = false);
  } else if (pen.calculative.isDock) {
    if (pen.type === PenType.Line) {
      _stroke = store.options.dockPenColor;
    } else {
      fill = rgba(store.options.dockPenColor, 0.2);
      //  ctx.fillStyle = fill;
      //  fill && (setBack = false);
    }
  }
  // else {
  const strokeImg = pen.calculative.strokeImg;
  if (pen.calculative.strokeImage && strokeImg) {
    ctx.strokeStyle = _stroke || ctx.createPattern(strokeImg, 'repeat');
    // fill = true;
  } else {
    let stroke;
    // TODO: 线只有线性渐变
    if (pen.calculative.strokeType) {
      if (pen.calculative.lineGradientColors) {
        if (pen.name === 'line') {
          lineGradientFlag = true;
        } else {
          if (pen.calculative.lineGradient) {
            stroke = pen.calculative.lineGradient;
          } else {
            stroke = getLineGradient(ctx, pen);
            pen.calculative.lineGradient = stroke;
          }
        }
      } else {
        stroke = strokeLinearGradient(ctx, pen);
      }
    } else {
      stroke = pen.calculative.color || getGlobalColor(store);
    }
    ctx.strokeStyle = _stroke || stroke;
  }
  // }
  //if (setBack) {
  const backgroundImg = pen.calculative.backgroundImg;
  if (pen.calculative.backgroundImage && backgroundImg) {
    ctx.fillStyle = fill || ctx.createPattern(backgroundImg, 'repeat');
    fill = true;
  } else {
    let back;
    if (pen.calculative.bkType === Gradient.Linear) {
      if (pen.calculative.gradientColors) {
        // if (!pen.type) {
        //连线不考虑渐进背景
        if (pen.calculative.gradient) {
          //位置变化/放大缩小操作不会触发重新计算
          back = pen.calculative.gradient;
        } else {
          back = getBkGradient(ctx, pen);
          pen.calculative.gradient = back;
        }
        // }
      } else {
        back = drawBkLinearGradient(ctx, pen);
      }
    } else if (pen.calculative.bkType === Gradient.Radial) {
      if (pen.calculative.gradientColors) {
        if (pen.calculative.radialGradient) {
          back = pen.calculative.radialGradient;
        } else {
          back = getBkRadialGradient(ctx, pen);
          pen.calculative.radialGradient = back;
        }
      } else {
        back = drawBkRadialGradient(ctx, pen);
      }
    } else {
      back = pen.calculative.background || store.data.penBackground;
    }
    ctx.fillStyle = fill || back;
    fill = !!back;
  }
  // }
  setLineCap(ctx, pen);
  setLineJoin(ctx, pen);
  setGlobalAlpha(ctx, pen);
  if (pen.calculative.lineDash) {
    ctx.setLineDash(pen.calculative.lineDash.map(item => item * pen.calculative.canvas.store.data.scale));
  }
  if (pen.calculative.lineDashOffset) {
    ctx.lineDashOffset = pen.calculative.lineDashOffset;
  }
  if (pen.calculative.shadowColor) {
    ctx.shadowColor = pen.calculative.shadowColor;
    ctx.shadowOffsetX = pen.calculative.shadowOffsetX;
    ctx.shadowOffsetY = pen.calculative.shadowOffsetY;
    ctx.shadowBlur = pen.calculative.shadowBlur;
  }
  if (lineGradientFlag) {
    ctxDrawLinearGradientPath(ctx, pen);
    ctxDrawLinePath(true, ctx, pen, store);
  } else {
    ctxDrawPath(true, ctx, pen, store, fill);
    ctxDrawCanvas(ctx, pen);
  }
  if (!(pen.image && pen.calculative.img) && pen.calculative.icon) {
    drawIcon(ctx, pen);
  }
  if (!textFlip || !textRotate) {
    ctx.restore();
  }
  if (textFlip && !textRotate) {
    ctxFlip(ctx, pen);
  }
  if (!textFlip && textRotate) {
    if (pen.calculative.rotate && pen.name !== 'line') {
      ctxRotate(ctx, pen, true);
    }
  }
  drawText(ctx, pen);
  if (pen.type === PenType.Line && pen.fillTexts) {
    for (const text of pen.fillTexts) {
      drawFillText(ctx, pen, text);
    }
  }
  ctx.restore();
}
/**
 * 更改 ctx 的 lineCap 属性
 */
function setLineCap(ctx, pen) {
  const lineCap = pen.lineCap || (pen.type ? 'round' : 'square');
  if (lineCap) {
    ctx.lineCap = lineCap;
  } else if (pen.type) {
    ctx.lineCap = 'round';
  }
}
/**
 * 更改 ctx 的 lineJoin 属性
 */
function setLineJoin(ctx, pen) {
  const lineJoin = pen.lineJoin;
  if (lineJoin) {
    ctx.lineJoin = lineJoin;
  } else if (pen.type) {
    ctx.lineJoin = 'round';
  }
}
/**
 * 通常用在下载 svg
 * canvas2svg 与 canvas ctx 设置 strokeStyle 表现不同
 * 若设置值为 undefined ，canvas2svg 为空， canvas ctx 为上一个值
 */
function renderPenRaw(ctx, pen, rect, download) {
  ctx.save();
  if (rect) {
    ctx.translate(-rect.x, -rect.y);
  }
  // for canvas2svg
  ctx.setAttrs?.(pen);
  // end
  let lineGradientFlag = false;
  const store = pen.calculative.canvas.store;
  const textFlip = pen.textFlip || store.options.textFlip;
  const textRotate = pen.textRotate || store.options.textRotate;
  ctx.beginPath();
  if (!textFlip || !textRotate) {
    ctx.save();
  }
  if (pen.calculative.flipX) {
    if (rect) {
      ctx.translate(pen.calculative.worldRect.x + pen.calculative.worldRect.ex, 0);
    } else {
      ctx.translate(pen.calculative.worldRect.x + pen.calculative.worldRect.ex, 0);
    }
    ctx.scale(-1, 1);
  }
  if (pen.calculative.flipY) {
    if (rect) {
      ctx.translate(0, pen.calculative.worldRect.y + pen.calculative.worldRect.ey);
    } else {
      ctx.translate(0, pen.calculative.worldRect.y + pen.calculative.worldRect.ey);
    }
    ctx.scale(1, -1);
  }
  if (pen.calculative.rotate && pen.name !== 'line') {
    ctxRotate(ctx, pen);
  }
  if (pen.calculative.lineWidth > 1 || download) {
    ctx.lineWidth = pen.calculative.lineWidth;
  }
  let fill;
  if (pen.calculative.hover) {
    ctx.strokeStyle = pen.hoverColor || store.options.hoverColor;
    ctx.fillStyle = pen.hoverBackground || store.options.hoverBackground;
    fill = pen.hoverBackground || store.options.hoverBackground;
  } else if (pen.calculative.active) {
    ctx.strokeStyle = pen.activeColor || store.options.activeColor;
    ctx.fillStyle = pen.activeBackground || store.options.activeBackground;
    fill = pen.activeBackground || store.options.activeBackground;
  } else {
    if (pen.strokeImage) {
      if (pen.calculative.strokeImg) {
        ctx.strokeStyle = ctx.createPattern(pen.calculative.strokeImg, 'repeat');
        fill = true;
      }
    } else {
      let stroke;
      if (pen.calculative.strokeType && pen.calculative.lineGradientColors && pen.name === 'line') {
        lineGradientFlag = true;
      } else {
        stroke = pen.calculative.color || getGlobalColor(store);
      }
      ctx.strokeStyle = stroke;
    }
    if (pen.backgroundImage) {
      if (pen.calculative.backgroundImg) {
        ctx.fillStyle = ctx.createPattern(pen.calculative.backgroundImg, 'repeat');
        fill = true;
      }
    } else {
      ctx.fillStyle = pen.background;
      fill = !!pen.background;
    }
  }
  setLineCap(ctx, pen);
  setLineJoin(ctx, pen);
  setGlobalAlpha(ctx, pen);
  if (pen.calculative.lineDash) {
    ctx.setLineDash(pen.calculative.lineDash);
  }
  if (pen.calculative.lineDashOffset) {
    ctx.lineDashOffset = pen.calculative.lineDashOffset;
  }
  if (pen.calculative.shadowColor) {
    ctx.shadowColor = pen.calculative.shadowColor;
    ctx.shadowOffsetX = pen.calculative.shadowOffsetX;
    ctx.shadowOffsetY = pen.calculative.shadowOffsetY;
    ctx.shadowBlur = pen.calculative.shadowBlur;
  }
  if (lineGradientFlag) {
    ctxDrawLinearGradientPath(ctx, pen);
    ctxDrawLinePath(true, ctx, pen, store);
  } else {
    ctxDrawPath(false, ctx, pen, store, fill);
    ctxDrawCanvas(ctx, pen);
  }
  // renderPenRaw 用在 downloadPng svg , echarts 等图形需要
  if (pen.calculative.img) {
    ctx.save();
    ctx.shadowColor = '';
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    drawImage(ctx, pen);
    ctx.restore();
  } else if (pen.calculative.icon) {
    drawIcon(ctx, pen);
  }
  if (!textFlip || !textRotate) {
    ctx.restore();
  }
  if (textFlip && !textRotate) {
    if (pen.calculative.flipX) {
      if (rect) {
        ctx.translate(pen.calculative.worldRect.x + pen.calculative.worldRect.ex, 0);
      } else {
        ctx.translate(pen.calculative.worldRect.x + pen.calculative.worldRect.ex, 0);
      }
      ctx.scale(-1, 1);
    }
    if (pen.calculative.flipY) {
      if (rect) {
        ctx.translate(0, pen.calculative.worldRect.y + pen.calculative.worldRect.ey);
      } else {
        ctx.translate(0, pen.calculative.worldRect.y + pen.calculative.worldRect.ey);
      }
      ctx.scale(1, -1);
    }
  }
  if (!textFlip && textRotate) {
    if (pen.calculative.rotate && pen.name !== 'line') {
      ctxRotate(ctx, pen, true);
    }
  }
  drawText(ctx, pen);
  if (pen.type === PenType.Line && pen.fillTexts) {
    for (const text of pen.fillTexts) {
      drawFillText(ctx, pen, text);
    }
  }
  ctx.restore();
}
/**
 * 根据 path2D 绘制 path
 * @param canUsePath 是否可使用 Path2D, downloadSvg 不可使用 path2D
 */
function ctxDrawPath(canUsePath = true, ctx, pen, store, fill) {
  const path = canUsePath ? store.path2dMap.get(pen) : globalStore.path2dDraws[pen.name];
  let path_from = null;
  let path_to = null;
  if (pen.type === PenType.Line) {
    //线段的起始和结束线帽 分别配置
    if (pen.fromLineCap && pen.fromLineCap !== 'butt') {
      ctx.lineCap = 'butt';
      path_from = new Path2D();
      path_from.moveTo(pen.calculative.worldAnchors[0].x, pen.calculative.worldAnchors[0].y);
      path_from.lineTo(pen.calculative.worldAnchors[0].x, pen.calculative.worldAnchors[0].y);
    }
    if (pen.toLineCap && pen.toLineCap !== 'butt') {
      ctx.lineCap = 'butt';
      path_to = new Path2D();
      path_to.moveTo(pen.calculative.worldAnchors[pen.calculative.worldAnchors.length - 1].x, pen.calculative.worldAnchors[pen.calculative.worldAnchors.length - 1].y);
      path_to.lineTo(pen.calculative.worldAnchors[pen.calculative.worldAnchors.length - 1].x, pen.calculative.worldAnchors[pen.calculative.worldAnchors.length - 1].y);
    }
  }
  if (path) {
    if (pen.type === PenType.Line && pen.borderWidth) {
      ctx.save();
      ctx.beginPath();
      const lineWidth = pen.calculative.lineWidth + pen.calculative.borderWidth;
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = pen.borderColor;
      if (path_from) {
        ctx.save();
        ctx.lineCap = pen.fromLineCap;
        ctx.stroke(path_from);
        ctx.restore();
      }
      if (path instanceof Path2D) {
        fill && ctx.fill(path);
        lineWidth && ctx.stroke(path);
      } else {
        path(pen, ctx);
        fill && ctx.fill();
        lineWidth && ctx.stroke();
      }
      if (path_to) {
        ctx.save();
        ctx.lineCap = pen.toLineCap;
        ctx.stroke(path_to);
        ctx.restore();
      }
      ctx.restore();
    }
    if (path instanceof Path2D) {
      if (pen.type) {
        if (pen.close) {
          fill && ctx.fill(path);
        }
      } else {
        //svgPath
        fill && ctx.fill(path);
      }
    } else {
      ctx.save();
      path(pen, ctx);
      fill && ctx.fill();
      ctx.restore();
    }
    const progress = pen.calculative.progress;
    if (progress != null) {
      // 从左往右 x, y, x + width * progress, y
      // 从右往左 ex, y, x + width * (1-progress), y
      // 从下往上 x, y, x, y + height * progress
      // 从上往下 x, ey, x, y + height * (1 - progress)
      ctx.save();
      const {
        ex,
        x,
        y,
        width,
        height,
        ey
      } = pen.calculative.worldRect;
      let grd = null;
      if (!pen.verticalProgress) {
        grd = !pen.reverseProgress ? ctx.createLinearGradient(x, y, x + width * progress, y) : ctx.createLinearGradient(ex, y, x + width * (1 - progress), y);
      } else {
        grd = !pen.reverseProgress ? ctx.createLinearGradient(x, ey, x, y + height * (1 - progress)) : ctx.createLinearGradient(x, y, x, y + height * progress);
      }
      if (pen.calculative.progressGradientColors) {
        const {
          colors
        } = formatGradient(pen.calculative.progressGradientColors);
        colors.forEach(stop => {
          grd.addColorStop(stop.i, stop.color);
        });
      } else {
        const color = pen.calculative.progressColor || pen.calculative.color || store.options.activeColor;
        grd.addColorStop(0, color);
        grd.addColorStop(1, color);
      }
      grd.addColorStop(1, 'transparent');
      ctx.fillStyle = grd;
      if (path instanceof Path2D) {
        ctx.fill(path);
      } else {
        path(pen, ctx);
        ctx.fill();
      }
      ctx.restore();
    }
    if (pen.calculative.lineWidth) {
      if (path instanceof Path2D) {
        if (store.options.svgPathStroke || pen.name !== 'svgPath') {
          if (path_from) {
            ctx.save();
            ctx.lineCap = pen.fromLineCap;
            ctx.stroke(path_from);
            ctx.restore();
          }
          ctx.stroke(path);
          if (path_to) {
            ctx.save();
            ctx.lineCap = pen.toLineCap;
            ctx.stroke(path_to);
            ctx.restore();
          }
        }
      } else {
        path(pen, ctx);
        ctx.stroke();
      }
    }
    if (pen.type) {
      if (pen.calculative.animatePos) {
        ctx.save();
        setCtxLineAnimate(ctx, pen, store);
        if (pen.lineAnimateType === LineAnimateType.Arrow || pen.lineAnimateType === LineAnimateType.WaterDrop) {
          //箭头动画
          let _path = drawArrow(pen, ctx);
          if (_path instanceof Path2D) {
            ctx.stroke(_path);
            ctx.fill(_path);
          } else {
            ctx.stroke();
            ctx.fill();
          }
        } else {
          if (path instanceof Path2D) {
            if (path_from && !pen.lineAnimateType) {
              ctx.save();
              ctx.lineCap = pen.fromLineCap;
              ctx.stroke(path_from);
              ctx.restore();
            }
            ctx.lineCap = pen.lineCap;
            ctx.stroke(path);
          } else {
            path(pen, ctx);
            ctx.stroke();
          }
        }
        ctx.restore();
      }
      pen.fromArrow && renderFromArrow(ctx, pen, store);
      pen.toArrow && renderToArrow(ctx, pen, store);
      if (pen.calculative.active && !pen.calculative.pencil && !store.options.disableAnchor && !store.data.locked) {
        renderLineAnchors(ctx, pen);
      }
    }
  }
}
/**
 * 连线配置线条渐进后，动画效果、起始点、终点的绘制
 */
function ctxDrawLinePath(canUsePath = true, ctx, pen, store) {
  const path = canUsePath ? store.path2dMap.get(pen) : globalStore.path2dDraws[pen.name];
  if (path) {
    if (pen.type) {
      if (pen.calculative.animatePos) {
        ctx.save();
        setCtxLineAnimate(ctx, pen, store);
        ctx.beginPath();
        if (path instanceof Path2D) {
          if (pen.lineName === 'polyline' || pen.lineName === 'line') {
            if (pen.lineAnimateType === LineAnimateType.Arrow || pen.lineAnimateType === LineAnimateType.WaterDrop) {
              //箭头动画
              const _path = drawArrow(pen);
              ctx.stroke(_path);
              ctx.fill(_path);
            } else {
              if (pen.calculative.gradientSmooth || pen.calculative.lineSmooth) {
                if (!pen.calculative.gradientAnimatePath) {
                  pen.calculative.gradientAnimatePath = getGradientAnimatePath(pen);
                }
                if (pen.calculative.gradientAnimatePath instanceof Path2D) {
                  ctx.stroke(pen.calculative.gradientAnimatePath);
                }
              } else {
                ctx.stroke(path);
              }
            }
          } else {
            ctx.stroke(path);
          }
        } else {
          path(pen, ctx);
          ctx.stroke();
        }
        ctx.restore();
      }
      pen.fromArrow && renderFromArrow(ctx, pen, store);
      pen.toArrow && renderToArrow(ctx, pen, store);
      //TODO 锚点处渐进色的过渡
      if (pen.calculative.active && !pen.calculative.pencil && !store.options.disableAnchor && !store.data.locked) {
        renderLineAnchors(ctx, pen);
      }
    }
  }
}
/**
 * 设置线条动画，ctx 的 strokeStyle lineDash 等属性更改
 */
function setCtxLineAnimate(ctx, pen, store) {
  ctx.strokeStyle = pen.animateColor || store.options.animateColor;
  if (pen.animateShadow) {
    ctx.shadowBlur = pen.animateShadowBlur || pen.animateLineWidth || 6;
    ctx.shadowColor = pen.animateShadowColor || pen.animateColor || store.options.animateColor;
  }
  pen.calculative.animateLineWidth && (ctx.lineWidth = pen.calculative.animateLineWidth * store.data.scale);
  let len = 0;
  switch (pen.lineAnimateType) {
    case LineAnimateType.Beads:
      if (pen.animateReverse) {
        ctx.lineDashOffset = pen.calculative.animatePos;
      } else {
        ctx.lineDashOffset = pen.length - pen.calculative.animatePos;
      }
      len = pen.calculative.lineWidth || 5;
      if (len < 5) {
        len = 5;
      }
      const dash = pen.animateLineDash && pen.animateLineDash.map(item => item * len / 5);
      ctx.setLineDash(dash || [len, len * 2]);
      break;
    case LineAnimateType.Dot:
      if (pen.animateReverse) {
        ctx.lineDashOffset = pen.calculative.animatePos;
      } else {
        ctx.lineDashOffset = pen.length - pen.calculative.animatePos;
      }
      len = pen.calculative.animateDotSize || pen.calculative.lineWidth * 2 || 6;
      if (len < 6) {
        len = 6;
      }
      if (len > 40) {
        len = 40;
      }
      ctx.lineWidth = (pen.calculative.animateLineWidth || len) * store.data.scale;
      ctx.setLineDash([0.1, pen.length]);
      break;
    case LineAnimateType.Arrow:
      ctx.fillStyle = pen.animateColor || store.options.animateColor;
      ctx.lineWidth = 1;
      break;
    case LineAnimateType.WaterDrop:
      ctx.fillStyle = pen.animateColor || store.options.animateColor;
      ctx.lineWidth = 1;
      break;
    default:
      if (pen.animateReverse) {
        ctx.lineDashOffset = Number.EPSILON; //防止在执行动画时会绘制多余的远点
        ctx.setLineDash([0, pen.length - pen.calculative.animatePos + 1, pen.calculative.animatePos]);
      } else {
        ctx.setLineDash([pen.calculative.animatePos, pen.length + 0.01 - pen.calculative.animatePos //避免在缩放时，精度问题绘制多余圆点
        ]);
      }
      break;
  }
}
/**
 * 全局 color
 */
function getGlobalColor(store) {
  const {
    data,
    options
  } = store;
  return data.color || options.color;
}
function renderLineAnchors(ctx, pen) {
  const store = pen.calculative.canvas.store;
  ctx.save();
  ctx.lineWidth = 1;
  ctx.fillStyle = pen.activeColor || store.options.activeColor;
  pen.calculative.worldAnchors.forEach(pt => {
    !pt.hidden && !pt.isTemp && renderAnchor(ctx, pt, pen);
  });
  ctx.restore();
}
function renderAnchor(ctx, pt, pen) {
  if (!pt) {
    return;
  }
  const active = pen.calculative.canvas.store.activeAnchor === pen.calculative.activeAnchor && pen.calculative.activeAnchor === pt;
  let r = 3;
  if (pen.calculative.lineWidth > 3) {
    r = pen.calculative.lineWidth;
  }
  if (pen.anchorRadius) {
    r = pen.anchorRadius;
  }
  if (pt.radius) {
    r = pt.radius;
  }
  if (active) {
    if (pt.prev) {
      ctx.save();
      ctx.strokeStyle = '#4dffff';
      ctx.beginPath();
      ctx.moveTo(pt.prev.x, pt.prev.y);
      ctx.lineTo(pt.x, pt.y);
      ctx.stroke();
      ctx.restore();
      ctx.save();
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(pt.prev.x, pt.prev.y, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }
    if (pt.next) {
      ctx.save();
      ctx.strokeStyle = '#4dffff';
      ctx.beginPath();
      ctx.moveTo(pt.x, pt.y);
      ctx.lineTo(pt.next.x, pt.next.y);
      ctx.stroke();
      ctx.restore();
      ctx.save();
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(pt.next.x, pt.next.y, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
    }
    ctx.beginPath();
    ctx.arc(pt.x, pt.y, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
  } else {
    ctx.save();
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(pt.x, pt.y, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }
}
function calcWorldRects(pen) {
  const store = pen.calculative.canvas.store;
  let rect = {
    x: pen.x,
    y: pen.y
  };
  if (!pen.parentId || pen.parentId && !store.pens[pen.parentId]) {
    pen.parentId = undefined;
    rect.width = pen.width;
    rect.height = pen.height;
    rect.rotate = pen.rotate;
    rect_calcRightBottom(rect);
    calcCenter(rect);
    if (pen.pivot) {
      calcPivot(rect, pen.pivot);
    }
  } else {
    const parent = store.pens[pen.parentId];
    let parentRect = parent.calculative.worldRect;
    if (!parentRect) {
      parentRect = calcWorldRects(parent);
    }
    rect.x = parentRect.x + parentRect.width * pen.x;
    rect.y = parentRect.y + parentRect.height * pen.y;
    rect.width = parentRect.width * pen.width;
    rect.height = parentRect.height * pen.height;
    if (parent.flipX) {
      rect.x = parentRect.width - (rect.x - parentRect.x + rect.width) + parentRect.x;
    }
    if (parent.flipY) {
      rect.y = parentRect.height - (rect.y - parentRect.y + rect.height) + parentRect.y;
    }
    rect_calcRightBottom(rect);
    rect.rotate = parentRect.rotate + pen.rotate;
    calcCenter(rect);
    if (pen.pivot) {
      calcPivot(rect, pen.pivot);
    }
  }
  pen.calculative.worldRect = rect;
  // 这里的 rect 均是绝对值
  calcPadding(pen, rect);
  return rect;
}
function calcPadding(pen, rect) {
  !pen.paddingTop && (pen.calculative.paddingTop = 0);
  !pen.paddingBottom && (pen.calculative.paddingBottom = 0);
  !pen.paddingLeft && (pen.calculative.paddingLeft = 0);
  !pen.paddingRight && (pen.calculative.paddingRight = 0);
  Math.abs(pen.calculative.paddingTop) < 1 && (pen.calculative.paddingTop *= rect.height);
  Math.abs(pen.calculative.paddingBottom) < 1 && (pen.calculative.paddingBottom *= rect.height);
  Math.abs(pen.calculative.paddingLeft) < 1 && (pen.calculative.paddingLeft *= rect.width);
  Math.abs(pen.calculative.paddingRight) < 1 && (pen.calculative.paddingRight *= rect.width);
}
function calcPenRect(pen) {
  const worldRect = deepClone(pen.calculative.worldRect);
  delete worldRect.pivot;
  if (!pen.parentId) {
    Object.assign(pen, worldRect);
    return;
  }
  const store = pen.calculative.canvas.store;
  const parentRect = store.pens[pen.parentId].calculative.worldRect;
  Object.assign(pen, calcRelativeRect(worldRect, parentRect));
}
function calcWorldAnchors(pen) {
  const store = pen.calculative.canvas.store;
  let anchors = [];
  if (pen.anchors) {
    let _anchors = deepClone(pen.anchors);
    if (pen.flipX) {
      _anchors.forEach(anchor => {
        anchor.x = 0.5 - (anchor.x - 0.5);
      });
    }
    if (pen.flipY) {
      _anchors.forEach(anchor => {
        anchor.y = 0.5 - (anchor.y - 0.5);
      });
    }
    _anchors.forEach(anchor => {
      anchors.push(calcWorldPointOfPen(pen, anchor));
    });
  }
  // Default anchors of node
  if (!anchors.length && !pen.type && !pen.calculative.canvas.parent.isCombine(pen)) {
    const {
      x,
      y,
      width,
      height
    } = pen.calculative.worldRect;
    anchors = store.options.defaultAnchors.map((anchor, index) => {
      return {
        id: `${index}`,
        penId: pen.id,
        x: x + width * anchor.x,
        y: y + height * anchor.y
      };
    });
  }
  if (pen.calculative.rotate) {
    anchors.forEach(anchor => {
      rotatePoint(anchor, pen.calculative.rotate, pen.calculative.worldRect.pivot || pen.calculative.worldRect.center);
    });
  }
  if (!pen.type || pen.anchors) {
    pen.calculative.worldAnchors = anchors;
  }
  if (pen.calculative.activeAnchor && anchors.length) {
    pen.calculative.activeAnchor = anchors.find(a => {
      a.id === pen.calculative.activeAnchor.id;
    });
  }
  pen.calculative.gradientAnimatePath = undefined;
}
function calcChildrenInitRect(pen) {
  // 重新计算子节点初始化坐标
  if (pen.children?.length) {
    let parentRect = pen.calculative.worldRect;
    pen.children.forEach(id => {
      const child = pen.calculative.canvas.store.pens[id];
      if (child.calculative.initRect && child.calculative.initRelativeRect) {
        child.calculative.initRect.x = parentRect.x + parentRect.width * child.calculative.initRelativeRect.x;
        child.calculative.initRect.y = parentRect.y + parentRect.height * child.calculative.initRelativeRect.y;
        child.calculative.initRect.ex = child.calculative.initRect.x + parentRect.width * child.calculative.initRelativeRect.width;
        child.calculative.initRect.ey = child.calculative.initRect.y + parentRect.height + child.calculative.initRelativeRect.height;
        calcCenter(child.calculative.initRect);
      }
      calcChildrenInitRect(child);
    });
  }
}
function calcWorldPointOfPen(pen, pt) {
  const p = {
    ...pt
  };
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  p.x = x + width * pt.x;
  p.y = y + height * pt.y;
  if (pt.prev) {
    p.prev = {
      penId: pen.id,
      connectTo: pt.prev.connectTo,
      x: x + width * pt.prev.x,
      y: y + height * pt.prev.y
    };
  }
  if (pt.next) {
    p.next = {
      penId: pen.id,
      connectTo: pt.next.connectTo,
      x: x + width * pt.next.x,
      y: y + height * pt.next.y
    };
  }
  return p;
}
function calcIconRect(pens, pen) {
  const {
    paddingTop,
    paddingBottom,
    paddingLeft,
    paddingRight
  } = pen.calculative;
  let x = paddingLeft;
  let y = paddingTop;
  let width = pen.calculative.worldRect.width - paddingLeft - paddingRight;
  let height = pen.calculative.worldRect.height - paddingTop - paddingBottom;
  let iconLeft = pen.calculative.iconLeft;
  let iconTop = pen.calculative.iconTop;
  if (iconLeft && Math.abs(iconLeft) < 1) {
    iconLeft = pen.calculative.worldRect.width * iconLeft;
  }
  if (iconTop && Math.abs(iconTop) < 1) {
    iconTop = pen.calculative.worldRect.height * iconTop;
  }
  x += iconLeft || 0;
  y += iconTop || 0;
  width -= iconLeft || 0;
  height -= iconTop || 0;
  let rotate = pen.calculative.iconRotate || 0;
  if (pen.parentId) {
    const parentPen = pens[pen.parentId].calculative;
    if (parentPen) {
      rotate += parentPen.rotate;
      rotate %= 360;
    }
  }
  x = pen.calculative.worldRect.x + x;
  y = pen.calculative.worldRect.y + y;
  pen.calculative.worldIconRect = {
    x,
    y,
    width,
    height,
    rotate
  };
  rect_calcRightBottom(pen.calculative.worldIconRect);
  calcCenter(pen.calculative.worldIconRect);
}
function scalePen(pen, scale, center) {
  scaleRect(pen.calculative.worldRect, scale, center, pen.pivot);
  if (pen.calculative.initRect) {
    scaleRect(pen.calculative.initRect, scale, center, pen.pivot);
  }
  scaleChildrenInitRect(pen, scale, center);
  if (pen.calculative.x) {
    scalePoint(pen.calculative, scale, center);
  }
  if (pen.type) {
    calcWorldAnchors(pen);
  }
}
function scaleChildrenInitRect(pen, scale, center) {
  if (!pen) {
    return;
  }
  if (pen.children?.length) {
    pen.children.forEach(id => {
      const child = pen.calculative.canvas.store.pens[id];
      if (child) {
        if (child.calculative.initRect) {
          scaleRect(child.calculative.initRect, scale, center);
        }
        scaleChildrenInitRect(child, scale, center);
      }
    });
  }
}
function pushPenAnchor(pen, pt) {
  if (!pen.anchors) {
    pen.anchors = [];
  }
  if (!pen.calculative.worldAnchors) {
    pen.calculative.worldAnchors = [];
  }
  const worldAnchor = {
    id: pt.id,
    penId: pen.id,
    x: pt.x,
    y: pt.y
  };
  pen.calculative.worldAnchors.push(worldAnchor);
  if (pen.calculative.worldRect) {
    if (pen.rotate % 360) {
      rotatePoint(pt, -pen.rotate, pen.calculative.worldRect.center);
    }
    const anchor = {
      id: pt.id,
      penId: pen.id,
      x: (pt.x - pen.calculative.worldRect.x) / pen.calculative.worldRect.width,
      y: (pt.y - pen.calculative.worldRect.y) / pen.calculative.worldRect.height
    };
    pen.anchors.push(anchor);
  }
  return worldAnchor;
}
function addLineAnchor(pen, pt, index) {
  if (!pen.anchors) {
    pen.anchors = [];
  }
  if (!pen.calculative.worldAnchors) {
    pen.calculative.worldAnchors = [];
  }
  const worldAnchor = getSplitAnchor(pen, pt, index);
  pen.calculative.worldAnchors.splice(index + 1, 0, worldAnchor);
  pen.anchors.splice(index + 1, 0, calcRelativePoint(worldAnchor, pen.calculative.worldRect));
  pen.calculative.activeAnchor = worldAnchor;
  return worldAnchor;
}
function removePenAnchor(pen, anchor) {
  if (!pen || !pen.calculative.worldAnchors) {
    return;
  }
  let i = pen.calculative.worldAnchors.findIndex(a => a.id === anchor.id);
  if (i > -1) {
    pen.calculative.worldAnchors.splice(i, 1);
  }
  i = pen.anchors.findIndex(a => a.id === anchor.id);
  if (i > -1) {
    pen.anchors.splice(i, 1);
  }
}
function facePen(pt, pen) {
  if (!pen || !pen.calculative || !pen.calculative.worldRect.center) {
    return Direction.None;
  }
  if (pt.anchorId) {
    let anchor = pen.anchors.filter(_anchor => _anchor.id === pt.anchorId);
    if (anchor.length) {
      if (anchor[0].direction > -1) {
        return anchor[0].direction;
      }
    }
  }
  return facePoint(pt, pen.calculative.worldRect.center);
}
function nearestAnchor(pen, pt) {
  let dis = Infinity;
  let anchor;
  pen.calculative.worldAnchors.forEach(a => {
    const d = distance(pt, a);
    if (dis > d) {
      dis = d;
      anchor = a;
    }
  });
  return anchor;
}
function translateLine(pen, x, y) {
  pen.x += x;
  pen.y += y;
  if (pen.anchors) {
    pen.anchors.forEach(a => {
      translatePoint(a, x, y);
    });
  }
  if (pen.calculative.worldAnchors) {
    pen.calculative.worldAnchors.forEach(a => {
      translatePoint(a, x, y);
    });
  }
}
function deleteTempAnchor(pen) {
  if (pen && pen.calculative && pen.calculative.worldAnchors.length) {
    let to = getToAnchor(pen);
    // 第一次画线
    if (!pen.anchors || !pen.anchors.length) {
      while (pen.calculative.worldAnchors.length && to !== pen.calculative.activeAnchor) {
        pen.calculative.worldAnchors.pop();
        to = getToAnchor(pen);
      }
    }
    // 拖拽终点
    else if (to === pen.calculative.activeAnchor) {
      pen.calculative.worldAnchors = [pen.calculative.worldAnchors[0]];
    }
    // 拖拽起点
    else if (pen.calculative.worldAnchors[0] === pen.calculative.activeAnchor) {
      pen.calculative.worldAnchors = [pen.calculative.worldAnchors[pen.calculative.worldAnchors.length - 1]];
    }
  }
}
/**
 * 添加line到pen的connectedLines中，并关联相关属性
 * 不添加连线到画布中，请确保画布中已经有该连线。
 * */
function connectLine(pen, anchor, line, lineAnchor) {
  if (!pen || !anchor || !line || !lineAnchor || anchor.twoWay === TwoWay.DisableConnected || anchor.twoWay === TwoWay.Disable || lineAnchor.twoWay === TwoWay.DisableConnectTo || lineAnchor.twoWay === TwoWay.Disable) {
    return;
  }
  if (anchor.twoWay === TwoWay.In) {
    if (line.calculative.worldAnchors.length === 1) {
      return;
    }
    const to = getToAnchor(line);
    if (lineAnchor.id !== to.id) {
      return;
    }
  }
  if (anchor.twoWay === TwoWay.Out) {
    const from = getFromAnchor(line);
    if (lineAnchor.id !== from.id) {
      return;
    }
  }
  if (lineAnchor.connectTo === pen.id && lineAnchor.anchorId === anchor.id) {
    return;
  }
  if (lineAnchor.connectTo) {
    const p = pen.calculative.canvas.store.pens[lineAnchor.connectTo];
    disconnectLine(p, getAnchor(p, lineAnchor.anchorId), line, lineAnchor);
  }
  if (!pen.connectedLines) {
    pen.connectedLines = [];
  }
  const i = pen.connectedLines.findIndex(item => item.lineId === line.id && item.lineAnchor === lineAnchor.id && item.anchor === anchor.id);
  if (i < 0) {
    pen.connectedLines.push({
      lineId: line.id,
      lineAnchor: lineAnchor.id,
      anchor: anchor.id
    });
  }
  lineAnchor.connectTo = pen.id;
  lineAnchor.anchorId = anchor.id;
  // 如果两条连线，则相互关联
  if (pen.type) {
    connectLine(line, lineAnchor, pen, anchor);
  }
  pen.calculative.canvas.store.emitter.emit('connectLine', {
    line,
    lineAnchor,
    pen,
    anchor
  });
  // 新增连线生命周期
  let fromPen = line.calculative.worldAnchors?.length >= 2 ? line.calculative.worldAnchors?.[0].connectTo : undefined;
  let fromAnchor = line.calculative.worldAnchors?.length >= 2 ? line.calculative.canvas.store.pens[line.calculative.worldAnchors?.[0].connectTo]?.anchors.find(i => i.id === line.calculative.worldAnchors?.[0].anchorId) : undefined; // num
  pen.onConnectLine?.(pen, {
    line,
    lineAnchor,
    pen,
    anchor,
    fromPen,
    fromAnchor
  });
  return true;
}
/**
 * 从 pen.connectedLines 中删除 lineId 和 lineAnchor
 */
function disconnectLine(pen, anchor, line, lineAnchor) {
  if (!pen || !anchor || !line || !lineAnchor) {
    return;
  }
  if (!pen.connectedLines || !pen.connectedLines.length) {
    return;
  }
  if (!line.lastConnected) {
    line.lastConnected = {};
  }
  if (!line.lastConnected[pen.id]) {
    line.lastConnected[pen.id] = deepClone(pen.connectedLines);
  }
  pen.connectedLines.forEach((item, index, arr) => {
    if ((item.lineId === line.id || item.lineId === line.id) && item.lineAnchor === lineAnchor.id && item.anchor === anchor.id) {
      arr.splice(index, 1);
    }
  });
  lineAnchor.connectTo = undefined;
  lineAnchor.anchorId = undefined;
  // 如果两条连线相互关联，则都取消关联
  if (pen.type && anchor.connectTo === line.id && anchor.anchorId === lineAnchor.id) {
    disconnectLine(line, lineAnchor, pen, anchor);
  }
  pen.calculative.canvas.store.emitter.emit('disconnectLine', {
    line,
    lineAnchor,
    pen,
    anchor
  });
  return true;
}
function getAnchor(pen, anchorId) {
  if (!pen || !anchorId) {
    return;
  }
  return pen.calculative.worldAnchors?.find(item => item.id === anchorId);
}
function getFromAnchor(pen) {
  if (!pen || !pen.calculative.worldAnchors) {
    return;
  }
  return pen.calculative.worldAnchors[0];
}
function getToAnchor(pen) {
  if (!pen || !pen.calculative.worldAnchors) {
    return;
  }
  return pen.calculative.worldAnchors[pen.calculative.worldAnchors.length - 1];
}
function setNodeAnimate(pen, now) {
  if (pen.calculative.start === 0 || !pen.frames || !pen.frames.length) {
    pen.calculative.start = undefined;
    return 0;
  }
  if (!pen.calculative.duration) {
    pen.calculative.duration = 0;
    for (const f of pen.frames) {
      pen.calculative.duration += f.duration;
      for (const k in f) {
        if (k !== 'duration' && !pen[k]) {
          if (k === 'scale') {
            pen[k] = 1;
          }
        }
      }
    }
  }
  if (!pen.animateCycle) {
    pen.animateCycle = Infinity;
  }
  if (!pen.calculative.start) {
    pen.calculative.start = now;
    pen.calculative.frameIndex = 0;
    pen.calculative.frameStart = pen.calculative.start;
    pen.calculative.frameDuration = pen.frames[0].duration;
    pen.calculative.frameEnd = pen.calculative.frameStart + pen.calculative.frameDuration;
    pen.calculative.cycleIndex = 1;
    pen.calculative.x = pen.calculative.worldRect.x;
    pen.calculative.y = pen.calculative.worldRect.y;
    pen.calculative.initRect = deepClone(pen.calculative.worldRect);
    if (pen.parentId) {
      pen.calculative.initRelativeRect = {
        x: pen.x,
        y: pen.y,
        width: pen.width,
        height: pen.height
      };
    }
    if (pen.children?.length) {
      const store = pen.calculative.canvas.store;
      pen.calculative.childrenVisible = {};
      pen.children.forEach(id => {
        pen.calculative.childrenVisible[id] = store.pens[id].visible;
      });
    }
    pen.calculative.initRect.rotate = pen.calculative.rotate || 0;
    initPrevFrame(pen);
  } else {
    let frameIndex = 0;
    const cycleIndex = Math.ceil((now - pen.calculative.start) / pen.calculative.duration);
    // 播放结束
    if (cycleIndex > pen.animateCycle) {
      pen.currentAnimation = undefined;
      pen.calculative.start = undefined;
      setNodeAnimateProcess(pen, 1);
      return 0;
    }
    const pos = (now - pen.calculative.start) % pen.calculative.duration;
    let d = 0;
    for (const frame of pen.frames) {
      d += frame.duration;
      if (pos > d) {
        ++frameIndex;
      } else {
        break;
      }
    }
    // 帧超出
    if (!pen.frames[frameIndex]) {
      return true;
    }
    pen.calculative.frameDuration = pen.frames[frameIndex].duration;
    pen.calculative.frameStart = pen.calculative.start + pen.calculative.duration * (cycleIndex - 1);
    pen.calculative.frameEnd = pen.calculative.frameStart + pen.calculative.frameDuration;
    // 换帧
    const frameChanged = frameIndex !== pen.calculative.frameIndex;
    // 新循环播放
    const cycleChanged = cycleIndex > pen.calculative.cycleIndex;
    frameChanged && (pen.calculative.frameIndex = frameIndex);
    cycleChanged && (pen.calculative.cycleIndex = cycleIndex);
    if (frameChanged || cycleChanged) {
      // 以初始位置为参考点。因为网页在后台时，不执行动画帧，网页恢复显示时，位置不确定
      pen.calculative.x = pen.calculative.initRect.x;
      pen.calculative.y = pen.calculative.initRect.y;
      if (pen.children?.length && !pen.parentId) {
        pen.calculative.canvas.rotatePen(pen, (pen.calculative.initRect.rotate || 0) - (pen.calculative.rotate || 0), pen.calculative.initRect);
      } else {
        pen.calculative.rotate = pen.calculative.initRect.rotate || 0;
      }
      if (frameIndex > 0) {
        pen.prevFrame = {};
        const prevFrame = pen.frames[frameIndex - 1];
        for (const k in prevFrame) {
          pen.prevFrame[k] = prevFrame[k];
        }
        Object.assign(pen.prevFrame, {
          rotate: prevFrame.rotate || 0,
          x: prevFrame.x || 0,
          y: prevFrame.y || 0,
          scale: prevFrame.scale || 1
        });
      } else {
        initPrevFrame(pen);
      }
    }
  }
  const process = (now - pen.calculative.frameStart) / pen.calculative.frameDuration % 1;
  setNodeAnimateProcess(pen, process);
  return true;
}
// 把前一个动画帧初始化为播放前状态
function initPrevFrame(pen) {
  pen.prevFrame = {};
  for (const k in pen) {
    if (typeof pen[k] !== 'object' || k === 'lineDash') {
      pen.prevFrame[k] = pen[k];
    }
  }
  pen.prevFrame.rotate = 0;
  pen.prevFrame.x = 0;
  pen.prevFrame.y = 0;
  pen.prevFrame.scale = 1;
}
// 根据process进度值（纯小数），计算节点动画属性
function setNodeAnimateProcess(pen, process) {
  if (process < 0) {
    return;
  }
  if (process > 1) {
    process = 1;
  }
  const frame = pen.frames[pen.calculative.frameIndex];
  for (const k in frame) {
    if (k === 'duration') {
      continue;
    } else if (k === 'scale') {
      pen.calculative.worldRect = deepClone(pen.calculative.initRect);
      scaleRect(pen.calculative.worldRect, pen.prevFrame.scale, pen.calculative.worldRect.center);
      const newScale = pen.prevFrame.scale + (frame[k] - pen.prevFrame.scale) * process;
      scaleRect(pen.calculative.worldRect, newScale / pen.prevFrame.scale, pen.calculative.worldRect.center);
      pen.calculative.patchFlags = true;
    } else if (k === 'x') {
      const lastVal = getFrameValue(pen, k, pen.calculative.frameIndex);
      pen.calculative.worldRect.x = pen.calculative.initRect.x + lastVal;
      pen.calculative.worldRect.ex = pen.calculative.initRect.ex + lastVal;
      translateRect(pen.calculative.worldRect, frame[k] * process * pen.calculative.canvas.store.data.scale, 0);
      pen.calculative.patchFlags = true;
    } else if (k === 'y') {
      const lastVal = getFrameValue(pen, k, pen.calculative.frameIndex);
      pen.calculative.worldRect.y = pen.calculative.initRect.y + lastVal;
      pen.calculative.worldRect.ey = pen.calculative.initRect.ey + lastVal;
      translateRect(pen.calculative.worldRect, 0, frame[k] * process * pen.calculative.canvas.store.data.scale);
      pen.calculative.patchFlags = true;
    } else if (k === 'rotate') {
      if (pen.prevFrame[k] >= 360) {
        pen.prevFrame[k] %= 360;
      }
      const lastVal = getFrameValue(pen, k, pen.calculative.frameIndex);
      const offsetRotate = (pen.calculative.initRect.rotate + lastVal + frame[k] * process) % 360 - (pen.calculative.rotate || 0);
      if (pen.children?.length) {
        pen.calculative.canvas.rotatePen(pen, offsetRotate, pen.calculative.initRect);
      } else {
        pen.calculative.rotate = (pen.calculative.initRect.rotate + lastVal + frame[k] * process) % 360;
      }
      pen.calculative.patchFlags = true;
    } else if (k === 'image') {
      pen.image = frame['image'];
      pen.calculative.image = undefined;
      pen.calculative.canvas.loadImage(pen);
      // if (pen.isBottom) {
      //   pen.calculative.canvas.canvasImageBottom.init();
      // } else {
      //   pen.calculative.canvas.canvasImage.init();
      // }
      if (pen.canvasLayer === CanvasLayer.CanvasImageBottom) {
        pen.calculative.canvas.canvasImageBottom.init();
      } else if (pen.canvasLayer === CanvasLayer.CanvasImage) {
        pen.calculative.canvas.canvasImage.init();
      }
    } else if (isLinear(frame[k], k, pen)) {
      if (pen.prevFrame[k] == null) {
        if (k === 'globalAlpha') {
          pen.prevFrame[k] = 1;
        } else {
          pen.prevFrame[k] = 0;
        }
      }
      const current = pen.prevFrame[k] + (frame[k] - pen.prevFrame[k]) * process;
      pen.calculative[k] = Math.round(current * 100) / 100;
    } else {
      if (k === 'visible') {
        if (pen.calculative.image) {
          // if (pen.isBottom) {
          //   pen.calculative.canvas.canvasImageBottom.init();
          // } else {
          //   pen.calculative.canvas.canvasImage.init();
          // }
          if (pen.canvasLayer === CanvasLayer.CanvasImageBottom) {
            pen.calculative.canvas.canvasImageBottom.init();
          } else if (pen.canvasLayer === CanvasLayer.CanvasImage) {
            pen.calculative.canvas.canvasImage.init();
          }
        } else if (pen.children?.length) {
          const childs = getAllChildren(pen, pen.calculative.canvas.store);
          pen.calculative.canvas.initImageCanvas(childs);
        }
      }
      pen.calculative[k] = frame[k];
      const v = {};
      v[k] = frame[k];
      setChildValue(pen, v);
    }
    if (k === 'text') {
      text_calcTextLines(pen);
    }
  }
}
/**
 * 值类型为 number , pen.linear 为 false 时，且 key 不属于 noLinear 时，返回 true
 * @param value 值
 * @param key 键值
 * @param pen 画笔
 * @returns
 */
function isLinear(value, key, pen) {
  // 不线性变化的属性
  const noLinear = ['strokeType', 'bkType', 'showChild'];
  return typeof value === 'number' && pen.linear !== false && !noLinear.includes(key);
}
function setLineAnimate(pen, now) {
  if (pen.calculative.start === 0) {
    pen.calculative.start = undefined;
    return 0;
  }
  if (!pen.animateCycle) {
    pen.animateCycle = Infinity;
  }
  if (!pen.animateSpan) {
    pen.animateSpan = 1;
  }
  pen.calculative.animatePos += pen.animateSpan * (pen.calculative.canvas.store.data.scale || 1);
  if (!pen.calculative.start) {
    pen.calculative.start = Date.now();
    pen.calculative.animatePos = pen.animateSpan * (pen.calculative.canvas.store.data.scale || 1);
    pen.calculative.cycleIndex = 1;
  } else if (pen.calculative.animatePos > pen.length) {
    // 播放到尾了
    ++pen.calculative.cycleIndex;
    // 播放结束
    if (pen.calculative.cycleIndex > pen.animateCycle) {
      pen.currentAnimation = undefined;
      pen.calculative.start = undefined;
      return 0;
    }
    pen.calculative.animatePos = pen.animateSpan;
  }
  return true;
}
function setChildrenActive(pen, active = true) {
  if (!pen.children || pen.childActive === false) {
    return;
  }
  const store = pen.calculative.canvas.store;
  pen.children.forEach(id => {
    const child = store.pens[id];
    if (child) {
      child.calculative.active = active;
      setChildrenActive(child, active);
    }
  });
}
function setHover(pen, hover = true) {
  if (!pen) {
    return;
  }
  const store = pen.calculative.canvas.store;
  pen.calculative.hover = hover;
  if (pen.childHover === false) {
    return;
  }
  if (pen.children) {
    pen.children.forEach(id => {
      // 子节点没有自己的独立hover，继承父节点hover
      if (store.pens[id]?.hoverColor == undefined && store.pens[id]?.hoverBackground == undefined) {
        setHover(store.pens[id], hover);
      }
    });
  }
}
function render_setElemPosition(pen, elem) {
  if (!elem) {
    return;
  }
  const store = pen.calculative.canvas.store;
  const worldRect = pen.calculative.worldRect;
  elem.style.opacity = pen.globalAlpha + '';
  elem.style.position = 'absolute';
  elem.style.outline = 'none';
  elem.style.left = worldRect.x + store.data.x + 'px';
  elem.style.top = worldRect.y + store.data.y + 'px';
  elem.style.width = worldRect.width + 'px';
  elem.style.height = worldRect.height + 'px';
  elem.style.display = pen.calculative.inView != false ? pen.calculative.cssDisplay || 'inline' : 'none'; // 是否隐藏元素
  !pen.calculative.rotate && (pen.calculative.rotate = 0);
  elem.style.transform = `rotate(${pen.calculative.rotate}deg)`;
  if (!pen.calculative.rotate) {
    if (pen.calculative.flipX) {
      elem.style.transform = `rotateY(180deg)`;
    }
    if (pen.calculative.flipY) {
      elem.style.transform = `rotateX(180deg)`;
    }
    if (pen.calculative.flipX && pen.calculative.flipY) {
      elem.style.transform = `rotateZ(180deg)`;
    }
  }
  elem.style.zIndex = pen.calculative.zIndex !== undefined ? pen.calculative.zIndex + '' : '5';
  if (pen.calculative.zIndex > pen.calculative.canvas.maxZindex) {
    pen.calculative.canvas.maxZindex = pen.calculative.zIndex;
  }
  if (pen.locked === LockState.DisableEdit || pen.locked === LockState.DisableMove || store.data.locked) {
    // gif 组合后，作为子节点可通过 lockedOnCombine 来决定自身的 locked 状态
    elem.style.userSelect = 'initial';
    elem.style.pointerEvents = 'initial';
    if (pen.name === 'gif') {
      elem.style.userSelect = 'none';
      elem.style.pointerEvents = 'none';
    }
  } else {
    // pen.locked LockState.Disable 不响应鼠标
    elem.style.userSelect = 'none';
    elem.style.pointerEvents = 'none';
  }
}
function setElemImg(pen, elem) {
  if (!elem) {
    return;
  }
  //https://github.com/niklasvh/html2canvas
  globalThis.html2canvas && globalThis.html2canvas(elem).then(function (canvas) {
    // document.body.appendChild(canvas);
    const img = new Image();
    img.src = canvas.toDataURL('image/png', 0.1);
    if (img.src.length > 10) {
      pen.calculative.img = img;
    }
  });
}
/**
 * 每个画笔 locked
 * @param pens 画笔
 * @returns
 */
function getPensLock(pens) {
  return pens.every(pen => pen.locked);
}
/**
 * 画笔们的 disabledRotate = true
 * 即 全部禁止旋转 返回 true
 * @param pens 画笔
 * @returns
 */
function getPensDisableRotate(pens) {
  return pens.every(pen => pen.disableRotate);
}
function rotatePen(pen, angle, rect) {
  if (pen.type) {
    pen.calculative.worldAnchors.forEach(anchor => {
      rotatePoint(anchor, angle, rect.center);
    });
    initLineRect(pen);
    calcPenRect(pen);
  } else {
    if (pen.calculative.rotate) {
      pen.calculative.rotate += angle;
    } else {
      pen.calculative.rotate = angle;
    }
    rotatePoint(pen.calculative.worldRect.center, angle, rect.center);
    if (pen.parentId) {
      pen.calculative.worldRect.x = pen.calculative.worldRect.center.x - pen.calculative.worldRect.width / 2;
      pen.calculative.worldRect.y = pen.calculative.worldRect.center.y - pen.calculative.worldRect.height / 2;
      pen.x = (pen.calculative.worldRect.x - rect.x) / rect.width;
      pen.y = (pen.calculative.worldRect.y - rect.y) / rect.height;
    }
  }
  pen.children?.forEach(id => {
    const child = pen.calculative.canvas.store.pens[id];
    rotatePen(child, angle, rect);
  });
}
function initLineRect(pen) {
  if (!pen.calculative.worldAnchors?.length) {
    return;
  }
  if (!isFinite(pen.x) || !isFinite(pen.x)) {
    return;
  }
  if (pen.x == null || pen.y == null) {
    return;
  }
  const rect = getLineRect(pen);
  if (!pen.parentId) {
    Object.assign(pen, rect);
  }
  const {
    fontSize,
    lineHeight
  } = pen.calculative.canvas.store.options;
  if (!pen.fontSize) {
    pen.fontSize = fontSize >= 0 ? fontSize : 12;
    pen.calculative.fontSize = pen.fontSize * pen.calculative.canvas.store.data.scale;
  } else if (pen.fontSize < 0) {
    pen.fontSize = 0;
    pen.calculative.fontSize = 0;
  }
  if (!pen.lineHeight) {
    pen.lineHeight = lineHeight;
    pen.calculative.lineHeight = pen.lineHeight;
  }
  calcCenter(rect);
  pen.calculative.worldRect = rect;
  calcPadding(pen, rect);
  calcTextRect(pen);
  if (pen.calculative.worldAnchors) {
    pen.anchors = pen.calculative.worldAnchors.map(pt => {
      return calcRelativePoint(pt, pen.calculative.worldRect);
    });
  }
}
/**
 * 画笔们的 disableSize = true
 * 即 全部不允许改变大小 返回 true
 * @param pens 画笔
 * @returns
 */
function getPensDisableResize(pens) {
  return pens.every(pen => pen.disableSize || pen.pivot); //旋转中心点图元不允许改变大小
}
function getFrameValue(pen, prop, frameIndex) {
  if (!pen.frames || !prop) {
    return 0;
  }
  let v = 0;
  for (let i = 0; i < frameIndex; i++) {
    if (pen.frames[i]) {
      v += pen.frames[i][prop] || 0;
    }
  }
  return v;
}
/**
 * 判断该画笔 是否是组合为状态中 展示的画笔
 */
function isShowChild(pen, store) {
  let selfPen = pen;
  while (selfPen && selfPen.parentId) {
    const oldPen = selfPen;
    selfPen = store.pens[selfPen.parentId];
    const showChildIndex = selfPen?.calculative?.showChild;
    if (showChildIndex != undefined) {
      const showChildId = selfPen.children[showChildIndex];
      if (showChildId !== oldPen.id) {
        // toPng 不展示它
        return false;
      }
    }
  }
  return true;
}
/**
 * 计算画笔的 inView
 * @param pen 画笔
 * @param calcChild 是否计算子画笔
 */
function calcInView(pen, calcChild = false) {
  const {
    store,
    canvasRect
  } = pen.calculative.canvas;
  if (calcChild) {
    pen.children?.forEach(id => {
      const child = store.pens[id];
      child && calcInView(child, true);
    });
  }
  pen.calculative.inView = true;
  if (!isShowChild(pen, store) || pen.visible == false || pen.calculative.visible == false) {
    pen.calculative.inView = false;
  } else {
    const {
      x,
      y,
      width,
      height,
      rotate
    } = pen.calculative.worldRect;
    const penRect = {
      x: x + store.data.x,
      y: y + store.data.y,
      width,
      height,
      rotate
    };
    rect_calcRightBottom(penRect);
    if (!rectInRect(penRect, canvasRect)) {
      pen.calculative.inView = false;
    }
  }
  // TODO: 语义化上，用 onValue 更合适，但 onValue 会触发 echarts 图形的重绘，没有必要
  // 更改 view 后，修改 dom 节点的显示隐藏
  // pen.onMove?.(pen);
  pen.calculative.singleton?.div && render_setElemPosition(pen, pen.calculative.singleton.div);
}
/**
 * 绘制 rect ，上线后可查看 rect 位置
 */
function inspectRect(ctx, store, pen) {
  if (store.fillWorldTextRect) {
    ctx.save();
    ctx.fillStyle = '#c3deb7';
    const {
      x,
      y,
      width,
      height
    } = pen.calculative.worldTextRect;
    ctx.fillRect(x, y, width, height);
    ctx.restore();
  }
}
function setGlobalAlpha(ctx, pen) {
  const globalAlpha = pen.calculative.globalAlpha;
  if (typeof globalAlpha === 'number' && globalAlpha < 1 && !isNaN(globalAlpha)) {
    ctx.globalAlpha = globalAlpha;
  }
}
/**
 * ctx 绘制图纸，并非 Path2D
 * @param ctx 画布上下文
 * @param pen 画笔
 */
function ctxDrawCanvas(ctx, pen) {
  const canvasDraw = drawFuncGenerator(ctx, pen) || globalStore.canvasDraws[pen.name];
  if (canvasDraw) {
    // TODO: 后续考虑优化 save / restore
    ctx.save();
    // TODO: 原有 return 终止后续操作，必要性不大
    canvasDraw(ctx, pen);
    ctx.restore();
  }
}
function drawFuncGenerator(ctx, pen) {
  // 进行数据的预处理
  const drawCommand = pen.drawCommand;
  if (!drawCommand || pen.name === 'line') return;
  // 单位转换 将其他单位转换为px
  // 执行自定义绘画函数
  return (ctx, pen) => {
    // TODO  绘制命令的转换 （能否兼容多种指令？？）
    drawCommand.forEach(command => {
      try {
        command.steps = command.steps.flat(Infinity);
        command.steps.reduce((calculate, step) => {
          const cs = commandTransfer(step, pen, calculate.x, calculate.y);
          // 应当保证顺序的正确
          try {
            if (cs.c) {
              if (cs.c.startsWith('_')) {
                const prop = cs.c.split('_')[1];
                if (typeof cs.v.value === "number") cs.v.value *= pen.calculative.canvas.store.data.scale;
                // debugger;
                (cs.p || ctx)[prop] = cs.v.value;
                return {
                  x: calculate.x,
                  y: calculate.y
                };
              }
              let l = [];
              for (const csKey in cs.v) {
                l.push(cs.v[csKey]);
              }
              // ctx.beginPath();
              (cs.p || ctx)[cs.c](...l);
              // ctx.moveTo(cs.startX || cs.v.x,cs.startY || cs.v.y);
              // command.prop.NoFill === '0'?ctx.fill():'';
              return {
                x: cs.startX || cs.v.x,
                y: cs.startY || cs.v.y
              };
            }
            return {
              x: calculate.x,
              y: calculate.y
            };
          } catch (e) {
            // pass
            console.log(e, 'error', cs);
          }
        }, {});
      } catch (e) {}
    });
    ctx.stroke();
  };
}
function commandTransfer(command, pen, startX, startY) {
  // TODO 是否支持扩展更多的命令？用于兼容未来的其他解析格式？
  //1. 进行简单的命令解析
  // VISIO
  const map = {
    'visio': dealWithVisio,
    'dxf': dealWithDXF
  };
  // CAD
  return map[pen.parseType](command, pen, startX, startY);
}
function dealWithDXF(command, pen, startX, startY) {
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  const {
    originWidth,
    originHeight
  } = pen.dxfOrigin;
  switch (command.c) {
    case "beginPath":
      return {
        c: 'beginPath',
        v: {}
      };
    case "closePath":
      return {
        c: 'closePath',
        v: {}
      };
    case "moveTo":
      return {
        c: 'moveTo',
        v: {
          x: command.v.x * (width / originWidth) + x,
          y: command.v.y * (height / originHeight) + y
        }
      };
    case "lineTo":
      return {
        c: 'lineTo',
        v: {
          x: command.v.x * (width / originWidth) + x,
          y: command.v.y * (height / originHeight) + y
        }
      };
    case "arc":
      return {
        c: 'ellipse',
        v: {
          x: command.v.x * (width / originWidth) + x,
          y: command.v.y * (height / originHeight) + y,
          rx: command.v.xr * (width / originWidth),
          ry: command.v.yr * (height / originHeight),
          rotation: command.v.rotation || 0,
          startAngle: command.v.startAngle,
          endAngle: command.v.endAngle,
          a: command.v.aclockwise ?? true
        }
      };
    case "ellipse":
      return {
        c: 'ellipse',
        v: {
          x: command.v.x * (width / originWidth) + x,
          y: command.v.y * (height / originHeight) + y,
          rx: command.v.xr * (width / originWidth),
          ry: command.v.yr * (height / originHeight),
          rotation: command.v.rotation || 0,
          startAngle: command.v.startAngle,
          endAngle: command.v.endAngle,
          a: command.v.aclockwise ?? true
        }
      };
    case "_font":
      return {
        c: '_font',
        v: {
          value: command.v.fontSize * pen.calculative.canvas.store.data.scale + 'px ' + (command.v.fontFamily || pen.calculative.canvas.store.options.fontFamily)
        }
      };
    case "_fillStyle":
      return {
        c: '_fillStyle',
        v: {
          value: pen.color || command.v.value
        }
      };
    default:
      const c = {
        c: command.c,
        v: {
          ...command.v
        }
      };
      if (c.v.x !== undefined) c.v.x = command.v.x * (width / originWidth) + x;
      if (c.v.y !== undefined) c.v.y = command.v.y * (height / originHeight) + y;
      return c;
  }
}
function dealWithVisio(command, pen, startX, startY) {
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  const {
    width: originWidth,
    height: originHeight
  } = pen.origin;
  switch (command.c) {
    case 'MoveTo':
      return {
        c: 'moveTo',
        v: {
          x: +command.v.X * 100 * (width / originWidth) + x,
          y: +command.v.Y * 100 * (height / originHeight) + y
        }
      };
    case 'RelMoveTo':
      return {
        c: 'moveTo',
        v: {
          x: +command.v.X * originWidth * (width / originWidth) + x,
          y: +command.v.Y * originHeight * (height / originHeight) + y
        }
      };
    case 'LineTo':
      return {
        c: 'lineTo',
        v: {
          x: +command.v.X * 100 * (width / originWidth) + x,
          y: +command.v.Y * 100 * (height / originHeight) + y
        }
      };
    case 'RelLineTo':
      return {
        c: 'lineTo',
        v: {
          x: +command.v.X * originWidth * (width / originWidth) + x,
          y: +command.v.Y * originHeight * (height / originHeight) + y
        }
      };
    case 'Ellipse':
      let centerX1 = command.v.X;
      let centerY1 = command.v.Y;
      let longAxis = Math.abs(command.v.A - command.v.C);
      let shortAxis = Math.abs(command.v.B - command.v.D);
      return {
        c: 'ellipse',
        v: {
          x: centerX1 * 100 * (width / originWidth) + x,
          y: centerY1 * 100 * (height / originHeight) + y,
          radiuX: longAxis * 100 * (width / originWidth),
          radiuY: shortAxis * 100 * (height / originHeight),
          rotation: 0,
          startAngle: 0,
          endAngle: Math.PI * 2,
          anticlockwise: true
        }
      };
    case 'EllipticalArcTo':
      const endX = command.v.X * 100 * (width / originWidth) + x; // 弧上结束顶点的 x 坐标
      const endY = command.v.Y * 100 * (height / originHeight) + y; // 弧上结束顶点的 y 坐标
      const ctrlX = command.v.A * 100 * (width / originWidth) + x; // 控制点的 x 坐标
      const ctrlY = command.v.B * 100 * (height / originHeight) + y; // 控制点的 y 坐标
      const angleDeg = command.v.C; // 主轴相对于 x 轴的角度 (度)
      const axisRatio = command.v.D * (width / height) * (originHeight / originWidth); // 长轴和短轴的比率
      //
      const params = calculateEllipseParameters(startX, startY, endX, endY, ctrlX, ctrlY, axisRatio);
      // 开始绘制路径
      !command.orign && (command.orign = {});
      !command.orign.startA && (command.orign.startA = calculateAngleInRadians(params.x0, params.y0, startX, startY));
      !command.orign.endA && (command.orign.endA = calculateAngleInRadians(params.x0, params.y0, endX, endY));
      return {
        c: 'ellipse',
        v: {
          centerX: params.x0,
          centerY: params.y0,
          radiuX: params.a,
          radiuY: params.b,
          // rotation:radiansToDegrees(angleDeg),
          rotation: 0,
          startAngle: command.orign.startA,
          endAngle: command.orign.endA,
          // startAngle: 0,
          // endAngle: Math.PI * 2,
          // anticlockwise: startA > 0 && startA>endA
          anticlockwise: +angleDeg < 0
          // anticlockwise: Math.abs(endA - startA) < Math.PI
        },
        startX: endX,
        startY: endY
      };
    case 'ArcTo':
      let endX2 = command.v.X * 100 * width / originWidth + x;
      let endY2 = command.v.Y * 100 * height / originHeight + y;
      let h = command.v.A * 100 * (width / height) * (originHeight / originWidth);
      // 计算弦的中点
      let xm = (startX + endX2) / 2;
      let ym = (startY + endY2) / 2;
      // 计算弦的长度
      let d = Math.sqrt((endX2 - startX) ** 2 + (endY2 - startY) ** 2);
      // 计算圆弧的半径
      let R = d ** 2 / (8 * h) + h / 2;
      // 计算单位垂直向量
      let ux = -(endY2 - startY) / d;
      let uy = (endX2 - startX) / d;
      // 计算两个可能的圆心
      let xc1 = xm + ux * R;
      let yc1 = ym + uy * R;
      let xc2 = xm - ux * R;
      let yc2 = ym - uy * R;
      // 选择一个圆心
      let xc = xc1;
      let yc = yc1;
      // 计算起点和终点到圆心的角度
      let startAngle = Math.atan2(startY - yc, startX - xc);
      let endAngle = Math.atan2(endY2 - yc, endX2 - xc);
      return {
        c: 'arc',
        v: {
          x: xc,
          y: yc,
          radius: R,
          startAngle: startAngle,
          endAngle: endAngle,
          aclockwise: true
        }
      };
    // case "RelCubBezTo":
    //   return {
    //     c:"bezierCurveTo",
    //     v:{
    //
    //     }
    //   };
    default:
      // console.log(command.c);
      return {};
  }
}
function setChildValue(pen, data) {
  for (const k in data) {
    if (inheritanceProps.includes(k)) {
      if (k == 'fontSize' && data[k] < 0) {
        data[k] = 0;
      }
      pen[k] = data[k];
      if (['fontSize', 'lineWidth'].includes(k)) {
        pen.calculative[k] = data[k] * pen.calculative.canvas.store.data.scale;
        calcTextRect(pen);
      } else {
        pen.calculative[k] = data[k];
      }
    }
  }
  if (pen.calculative.canvas.parent.isCombine(pen)
  //&& pen.showChild === undefined
  ) {
    const children = pen.children;
    children?.forEach(childId => {
      let _data = deepClone(data);
      if (pen.calculative.childrenVisible) {
        if (pen.calculative.childrenVisible[childId] === false) {
          delete _data.visible;
        }
      }
      const child = pen.calculative.canvas.store.pens[childId];
      child && setChildValue(child, _data);
    });
  }
}
function calculateEllipseParameters(x1, y1, x2, y2, x3, y3, D) {
  // Calculate x₀ using equation ⑥
  let numeratorX0 = (x1 - x2) * (x1 + x2) * (y2 - y3) - (x2 - x3) * (x2 + x3) * (y1 - y2) + D * D * (y1 - y2) * (y2 - y3) * (y1 - y3);
  let denominatorX0 = 2 * ((x1 - x2) * (y2 - y3) - (x2 - x3) * (y1 - y2));
  let x0 = numeratorX0 / denominatorX0;
  // Calculate y₀ using equation ⑦
  let numeratorY0 = (x1 - x2) * (x2 - x3) * (x1 - x3) + D * D * ((x2 - x3) * (y1 - y2) * (y1 + y2) - (x1 - x2) * (y2 - y3) * (y2 + y3));
  let denominatorY0 = 2 * D * D * ((x2 - x3) * (y1 - y2) - (x1 - x2) * (y2 - y3));
  let y0 = numeratorY0 / denominatorY0;
  // Calculate 'a' using equation ⑧, substituting x₀ and y₀
  let a = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(D * (y1 - y0), 2));
  // Calculate 'b' using equation ⑨
  let b = a / D;
  return {
    x0,
    y0,
    a,
    b
  };
}
function calculateAngleInRadians(x1, y1, x2, y2) {
  // 计算两个点的差值
  let dx = x2 - x1;
  let dy = y2 - y1;
  // 使用 atan2 计算角度，结果为弧度
  let angleRadians = Math.atan2(dy, dx);
  // 如果角度为负值，加上2π
  if (angleRadians < 0) {
    angleRadians += 2 * Math.PI;
  }
  return angleRadians;
}
;// ./node_modules/@kyvi/cobweb/src/pen/math.js



function calcAnchorDock(store, e, curAnchor) {
  let xDock;
  let yDock;
  let x = Infinity;
  let y = Infinity;
  const size = 8;
  for (const pen of store.data.pens) {
    if (pen.calculative.inView === false) {
      continue;
    }
    // 得到图形的全部点
    const points = getPointsByPen(pen);
    points.forEach(pt => {
      if (pt === e || pt === curAnchor) {
        return;
      }
      let distance = (pen.calculative.worldRect.center.x - e.x) * (pen.calculative.worldRect.center.x - e.x) + (pen.calculative.worldRect.center.y - e.y) * (pen.calculative.worldRect.center.y - e.y);
      const disX = Math.abs(pt.x - e.x);
      if (disX > 0 && disX < size && distance < x) {
        xDock = {
          x: Math.round(pt.x) + 0.5,
          y: Math.round(pt.y) + 0.5,
          prev: {
            x: Math.round(e.x) + 0.5,
            y: Math.round(e.y) + 0.5
          },
          step: pt.x - e.x
        };
        x = distance;
      }
      const disY = Math.abs(pt.y - e.y);
      if (disY > 0 && disY < size && distance < y) {
        yDock = {
          x: Math.round(pt.x) + 0.5,
          y: Math.round(pt.y) + 0.5,
          prev: {
            x: Math.round(e.x) + 0.5,
            y: Math.round(e.y) + 0.5
          },
          step: pt.y - e.y
        };
        y = distance;
      }
    });
  }
  return {
    xDock,
    yDock
  };
}
function calcMoveDock(store, rect, pens, offset) {
  // 找到 points ，深拷贝一下，不影响原值
  let activePoints = [];
  if (pens.length === 1) {
    activePoints = deepClone(getPointsByPen(pens[0]));
    activePoints.forEach(point => {
      point.x += offset.x;
      point.y += offset.y;
    });
  } else {
    calcCenter(rect);
    activePoints = [rect.center, ...rectToPoints(rect)];
  }
  return calcDockByPoints(store, activePoints, rect, true);
}
/**
 * 得到画笔的全部点
 * 线 即全部的 worldAnchors
 * 图形 即全部的 worldAnchors ，加上边缘四个点以及中心点
 * @param pen 画笔
 */
function getPointsByPen(pen) {
  if (!pen.type) {
    const outerPoints = rectToPoints(pen.calculative.worldRect);
    calcCenter(pen.calculative.worldRect);
    return [...pen.calculative.worldAnchors, ...outerPoints, pen.calculative.worldRect.center];
  } else if (pen.type === PenType.Line) {
    return pen.calculative.worldAnchors;
  }
}
function calcResizeDock(store, rect, pens, resizeIndex) {
  const activePoints = rectToPoints(rect);
  return calcDockByPoints(store, activePoints, rect);
}
/**
 * 通过当前 活动层 的所有点 计算 dock
 * @param activePoints 活动层 的所有点
 * @param rect 当前区域
 * @param calcActive 是否与 活动层画笔 的点进行计算
 */
function calcDockByPoints(store, activePoints, rect, calcActive = false) {
  let xDock;
  let yDock;
  let minCloseX = Infinity;
  let minCloseY = Infinity;
  // 临近范围
  const closeSize = 10;
  const paddingRect = expandRect(rect, closeSize);
  store.data.pens.forEach(pen => {
    const {
      inView,
      worldRect,
      active
    } = pen.calculative;
    if (inView === false || !calcActive && active ||
    // 如果不计算活动层，则过滤掉活动层
    rectInFourAngRect(paddingRect, worldRect) ||
    // 水平和垂直方向 无重合
    pen.type && store.active.some(active => isConnectLine(store, active, pen))) {
      return;
    }
    // 得到图形的全部点
    const points = getPointsByPen(pen);
    if (!points) {
      return;
    }
    // 比对 points 中的点，必须找出最近的点，不可提前跳出
    for (const point of points) {
      for (const activePoint of activePoints) {
        const stepX = point.x - activePoint.x;
        const stepY = point.y - activePoint.y;
        const absStepX = Math.abs(stepX);
        const absStepY = Math.abs(stepY);
        if (!rect.center) {
          rect.center = {
            x: rect.x + rect.width / 2,
            y: rect.y + rect.height / 2
          };
        }
        if (absStepX < closeSize && absStepX < minCloseX) {
          xDock = {
            x: Math.round(point.x) + 0.5,
            y: Math.round(point.y) + 0.5,
            step: stepX,
            prev: {
              x: Math.round(activePoint.x) + 0.5,
              y: Math.round(activePoint.y) + 0.5
            },
            penId: pen.id,
            anchorId: activePoint.id,
            dockAnchorId: point.id
          };
          minCloseX = absStepX;
        }
        if (absStepY < closeSize && absStepY < minCloseY) {
          yDock = {
            x: Math.round(point.x) + 0.5,
            y: Math.round(point.y) + 0.5,
            step: stepY,
            prev: {
              x: Math.round(activePoint.x) + 0.5,
              y: Math.round(activePoint.y) + 0.5
            },
            penId: pen.id,
            anchorId: activePoint.id,
            dockAnchorId: point.id
          };
          minCloseY = absStepY;
        }
      }
    }
  });
  return {
    xDock,
    yDock
  };
}
/**
 * 判断 line 是否是 active 的连接线（并且计算子节点）
 * @param store
 * @param active 本次计算的画笔
 * @param line 连线
 * @returns
 */
function isConnectLine(store, active, line) {
  if (!line.type) {
    return false;
  }
  if (Array.isArray(active?.connectedLines)) {
    for (const cline of active?.connectedLines) {
      if (cline.lineId === line.id) {
        return true;
      }
    }
  }
  // 考虑子节点
  if (Array.isArray(active?.children)) {
    for (const id of active.children) {
      const child = store.pens[id];
      if (isConnectLine(store, child, line)) {
        return true;
      }
    }
  }
  return false;
}
/**
 * 是否近似于 num
 * @param num
 */
function isEqual(source, target) {
  // @ts-ignore
  return source.toFixed(12) == target;
}
;// ./node_modules/@kyvi/cobweb/src/pen/utils.js

function randomId(pen) {
  pen.id = s8();
  if (Array.isArray(pen.anchors)) {
    for (const pt of pen.anchors) {
      pen.type && (pt.id = s8());
      pt.penId = pen.id;
      if (pt.prev) {
        pen.type && (pt.prev.id = s8());
        pt.prev.penId = pen.id;
      }
      if (pt.next) {
        pen.type && (pt.next.id = s8());
        pt.next.penId = pen.id;
      }
    }
  }
}
;// ./node_modules/@kyvi/cobweb/src/pen/plugin.js







// 该文件为penPlugin的相关文件
/**
 * @description 闭包 重写 pen的生命周期，为了追加回调函数
 * @return 生命周期操作函数，可在原生命周期回调函数基础上进行执行多个函数，可通过传参，设置函数的增加和删除，类似addEventListener 和 removeEventListener
 * @bug 漏洞：后面的生命周期无法将前面的生命周期需要的参数正确传递
 */
function rewritePenLifeCycle() {
  let funcMap = null;
  let funcPenMap = new Map();
  return (pen, lifeCycle, func, del = false) => {
    if (funcPenMap.has(pen) && funcPenMap.get(pen)) {
      funcMap = funcPenMap.get(pen);
    } else {
      funcPenMap.set(pen, funcMap = new Map());
    }
    if (typeof func !== "function") return () => {
      console.warn('[rewritePenLifeCycle] warn: not a function ');
    };
    let funcListSet = new Set();
    let originFuncMap = new Map(); // 原始事件回调Map
    if (funcMap.has(lifeCycle) && funcMap.get(lifeCycle)) {
      funcListSet = funcMap.get(lifeCycle);
    } else {
      originFuncMap.set(lifeCycle, pen[lifeCycle]);
      funcMap.set(lifeCycle, funcListSet);
    }
    if (del) {
      funcListSet.delete(func);
    } else {
      funcListSet.add(func);
    }
    let originLifeCycle = originFuncMap.get(lifeCycle); // 原始事件;
    let rewriteFunc = (...args) => {
      originLifeCycle?.(...args);
      funcListSet.forEach(i => {
        // @ts-ignore
        i(...args);
      });
    };
    pen[lifeCycle] = rewriteFunc;
  };
}
let setLifeCycleFunc = rewritePenLifeCycle();
/**
 * @description 校验插件*/
function validationPlugin(plugin) {
  // 校验penPlugin
  if (!plugin.name && !plugin.install) {
    console.error('installPenPlugin Error: Validation Failed');
    return false;
  }
  return true;
}
;// ./node_modules/@kyvi/cobweb/src/pen/index.js






;// ./node_modules/@kyvi/cobweb/src/rect/rect.js




function pointInRect(pt, rect) {
  if (!rect) {
    return;
  }
  if (rect.ex == null) {
    rect_calcRightBottom(rect);
  }
  if (!rect.rotate ||
  // rect.width < 20 ||
  // rect.height < 20 ||
  rect.rotate % 360 === 0) {
    return pt.x > rect.x && pt.x < rect.ex && pt.y > rect.y && pt.y < rect.ey;
  }
  if (!rect.center) {
    calcCenter(rect);
  }
  const pts = [{
    x: rect.x,
    y: rect.y
  }, {
    x: rect.ex,
    y: rect.y
  }, {
    x: rect.ex,
    y: rect.ey
  }, {
    x: rect.x,
    y: rect.ey
  }];
  pts.forEach(item => {
    rotatePoint(item, rect.rotate, rect.pivot || rect.center);
  });
  return pointInVertices(pt, pts);
}
function pointInSimpleRect(pt, rect, r = 0) {
  const {
    x,
    y,
    ex,
    ey
  } = rect;
  return pt.x >= x - r && pt.x <= ex + r && pt.y >= y - r && pt.y <= ey + r;
}
function calcCenter(rect) {
  if (!rect.center) {
    rect.center = {};
  }
  rect.center.x = rect.x + rect.width / 2;
  rect.center.y = rect.y + rect.height / 2;
}
function rect_calcRightBottom(rect) {
  rect.ex = rect.x + rect.width;
  rect.ey = rect.y + rect.height;
}
function calcPivot(rect, pivot) {
  if (!rect.pivot) {
    rect.pivot = {};
  }
  rect.pivot.x = rect.x + rect.width * pivot.x;
  rect.pivot.y = rect.y + rect.height * pivot.y;
}
function pointInVertices(point, vertices) {
  if (vertices.length < 3) {
    return false;
  }
  let isIn = false;
  let last = vertices[vertices.length - 1];
  for (const item of vertices) {
    if (last.y > point.y !== item.y > point.y) {
      if (item.x + (point.y - item.y) * (last.x - item.x) / (last.y - item.y) > point.x) {
        isIn = !isIn;
      }
    }
    last = item;
  }
  return isIn;
}
function getRect(pens) {
  const points = [];
  pens.forEach(pen => {
    if (pen.isRuleLine) {
      return;
    }
    const rect = pen.calculative.worldRect;
    if (rect) {
      const pts = rectToPoints(rect);
      // rectToPoints 已经计算过 rotate 无需重复计算
      points.push(...pts);
    }
  });
  const rect = getRectOfPoints(points);
  calcCenter(rect);
  return rect;
}
function rectToPoints(rect) {
  const pts = [{
    x: rect.x,
    y: rect.y
  }, {
    x: rect.ex,
    y: rect.y
  }, {
    x: rect.ex,
    y: rect.ey
  }, {
    x: rect.x,
    y: rect.ey
  }];
  if (rect.rotate) {
    if (!rect.center) {
      calcCenter(rect);
    }
    pts.forEach(pt => {
      rotatePoint(pt, rect.rotate, rect.pivot || rect.center);
    });
  }
  return pts;
}
function getRectOfPoints(points) {
  let x = Infinity;
  let y = Infinity;
  let ex = -Infinity;
  let ey = -Infinity;
  points?.forEach(item => {
    if (!isFinite(item.x) || !isFinite(item.y)) {
      return;
    }
    x = Math.min(x, item.x);
    y = Math.min(y, item.y);
    ex = Math.max(ex, item.x);
    ey = Math.max(ey, item.y);
  });
  return {
    x,
    y,
    ex,
    ey,
    width: ex - x,
    height: ey - y
  };
}
function rectInRect(source, target, allIn) {
  if (source.rotate) {
    // 根据 rotate 扩大 rect
    source = getRectOfPoints(rectToPoints(source)); // 更改 source 引用地址值，不影响原值
  }
  if (allIn) {
    return source.x > target.x && source.ex < target.ex && source.y > target.y && source.ey < target.ey;
  }
  return !(source.x > target.ex || source.ex < target.x || source.ey < target.y || source.y > target.ey);
}
/**
 * 一个 rect 在另一个 rect 的 四个角，即水平区域不重合，垂直区域不重合
 */
function rectInFourAngRect(source, target) {
  return (target.x > source.ex || target.ex < source.x) && (target.y > source.ey || target.ey < source.y);
}
/**
 * 扩大 rect ，x，y，ex，ey 值都会变
 * @param rect 原 rect ，无副作用
 * @param size padding 类型，可传四个方向的值，也可以只传一个值
 */
function expandRect(rect, size) {
  const padding = formatPadding(size);
  const retRect = {
    x: rect.x - padding[3],
    y: rect.y - padding[0],
    width: rect.width + padding[1] + padding[3],
    height: rect.height + padding[0] + padding[2]
  };
  rect_calcRightBottom(retRect);
  return retRect;
}
function translateRect(rect, x, y) {
  rect.x += x;
  rect.y += y;
  rect.ex += x;
  rect.ey += y;
  if (rect.center) {
    rect.center.x += x;
    rect.center.y += y;
  }
  if (rect.pivot) {
    rect.pivot.x += x;
    rect.pivot.y += y;
  }
}
/**
 * 通过两条线段计算出相交的点
 * @param line1 线段1
 * @param line2 线段2
 */
function getIntersectPoint(line1, line2) {
  const k1 = (line1.to.y - line1.from.y) / (line1.to.x - line1.from.x);
  const k2 = (line2.to.y - line2.from.y) / (line2.to.x - line2.from.x);
  return getIntersectPointByK({
    k: k1,
    point: line1.from
  }, {
    k: k2,
    point: line2.from
  });
}
/**
 * 该方法作用同上，不过此方法需要传的是 斜率
 * @param line1 线段1
 * @param line2 线段2
 * @returns
 */
function getIntersectPointByK(line1, line2) {
  if (isEqual(line1.k, 0)) {
    return {
      x: line2.point.x,
      y: line1.point.y
    };
  } else if (isEqual(line2.k, 0)) {
    return {
      x: line1.point.x,
      y: line2.point.y
    };
  }
  const b1 = line1.point.y - line1.k * line1.point.x;
  const b2 = line2.point.y - line2.k * line2.point.x;
  const x = (b2 - b1) / (line1.k - line2.k);
  const y = line1.k * x + b1;
  return {
    x,
    y
  };
}
/**
 * 通过 4 个点和旋转角度，计算出原矩形（旋转前的矩形）
 * @param pts 4 个点
 * @param rotate 旋转角度
 */
function pointsToRect(pts, rotate) {
  // 1. 计算 center，认为 0，2 ；1，3 的连线相交就是 center 点
  const center = getIntersectPoint({
    from: pts[0],
    to: pts[2]
  }, {
    from: pts[1],
    to: pts[3]
  });
  // 2. 把点反向转 rotate °
  for (const pt of pts) {
    rotatePoint(pt, -rotate, center);
  }
  // 3. 计算区域
  return getRectOfPoints(pts);
}
function resizeRect(rect, offsetX, offsetY, resizeIndex) {
  let calcRotate = rect.rotate ? rect.rotate % 360 : 0;
  if (calcRotate) {
    // 计算出外边的四个点
    const pts = rectToPoints(rect);
    // 斜率不改变，提前计算
    const k1 = (pts[0].y - pts[1].y) / (pts[0].x - pts[1].x);
    const k2 = (pts[1].y - pts[2].y) / (pts[1].x - pts[2].x);
    if (resizeIndex < 4) {
      // 斜对角的四个点
      // resize 的点
      pts[resizeIndex].x += offsetX;
      if (rect.ratio) {
        if (resizeIndex === 0 || resizeIndex === 2) {
          let calcOffsetY = offsetX * Math.tan((90 - (360 - calcRotate) - Math.atan(rect.width / rect.height) / Math.PI * 180) / 180 * Math.PI);
          pts[resizeIndex].y += calcOffsetY;
        } else {
          let calcOffsetY = offsetX * Math.tan((90 - (360 - calcRotate) + Math.atan(rect.width / rect.height) / Math.PI * 180) / 180 * Math.PI);
          pts[resizeIndex].y += calcOffsetY;
        }
      } else {
        pts[resizeIndex].y += offsetY;
      }
      // 不变的点
      const noChangePoint = pts[(resizeIndex + 2) % 4];
      // 由于斜率是不变的，我们只需要根据斜率 和 已知的两点求出相交的 另外两点
      pts[(resizeIndex + 1) % 4] = getIntersectPointByK({
        k: resizeIndex % 2 ? k2 : k1,
        point: pts[resizeIndex]
      }, {
        k: resizeIndex % 2 ? k1 : k2,
        point: noChangePoint
      });
      pts[(resizeIndex + 4 - 1) % 4] = getIntersectPointByK({
        k: resizeIndex % 2 ? k1 : k2,
        point: pts[resizeIndex]
      }, {
        k: resizeIndex % 2 ? k2 : k1,
        point: noChangePoint
      });
    } else {
      // 边缘四个点有两个点固定
      const k = [4, 6].includes(resizeIndex) ? k2 : k1;
      if (!isEqual(k, 0)) {
        pts[resizeIndex % 4].y += offsetY;
        pts[resizeIndex % 4].x += offsetY / k;
        pts[(resizeIndex + 1) % 4].y += offsetY;
        pts[(resizeIndex + 1) % 4].x += offsetY / k;
      } else {
        pts[resizeIndex % 4].x += offsetX;
        pts[(resizeIndex + 1) % 4].x += offsetX;
      }
    }
    if ((pts[0].x - pts[1].x) ** 2 + (pts[0].y - pts[1].y) ** 2 < 25 || (pts[1].x - pts[2].x) ** 2 + (pts[1].y - pts[2].y) ** 2 < 25) {
      // 距离小于 5 不能继续 resize 了
      return;
    }
    const retRect = pointsToRect(pts, rect.rotate);
    calcCenter(retRect);
    Object.assign(rect, retRect);
    return;
  }
  switch (resizeIndex) {
    case 0:
      if (rect.width - offsetX < 5 || rect.height - offsetY < 5) {
        break;
      }
      rect.x += offsetX;
      rect.y += offsetY;
      rect.width -= offsetX;
      rect.height -= offsetY;
      break;
    case 1:
      if (rect.width + offsetX < 5 || rect.height - offsetY < 5) {
        break;
      }
      rect.ex += offsetX;
      rect.y += offsetY;
      rect.width += offsetX;
      rect.height -= offsetY;
      break;
    case 2:
      if (rect.width + offsetX < 5 || rect.height + offsetY < 5) {
        break;
      }
      rect.ex += offsetX;
      rect.ey += offsetY;
      rect.width += offsetX;
      rect.height += offsetY;
      break;
    case 3:
      if (rect.width - offsetX < 5 || rect.height + offsetY < 5) {
        break;
      }
      rect.x += offsetX;
      rect.ey += offsetY;
      rect.width -= offsetX;
      rect.height += offsetY;
      break;
    case 4:
      if (rect.height - offsetY < 5) {
        break;
      }
      rect.y += offsetY;
      rect.height -= offsetY;
      break;
    case 5:
      if (rect.width + offsetX < 5) {
        break;
      }
      rect.ex += offsetX;
      rect.width += offsetX;
      break;
    case 6:
      if (rect.height + offsetY < 5) {
        break;
      }
      rect.ey += offsetY;
      rect.height += offsetY;
      break;
    case 7:
      if (rect.width - offsetX < 5) {
        break;
      }
      rect.x += offsetX;
      rect.width -= offsetX;
      break;
  }
}
function scaleRect(rect, scale, center, pivot) {
  if (!rect) {
    return;
  }
  rect.width *= scale;
  rect.height *= scale;
  scalePoint(rect, scale, center);
  rect_calcRightBottom(rect);
  calcCenter(rect);
  if (pivot) {
    calcPivot(rect, pivot);
  }
}
function calcRelativeRect(rect, worldRect) {
  const relRect = {
    x: (rect.x - worldRect.x) / worldRect.width,
    y: (rect.y - worldRect.y) / worldRect.height,
    width: rect.width / worldRect.width,
    height: rect.height / worldRect.height
  };
  rect_calcRightBottom(relRect);
  return relRect;
}
/**
 * 计算相对点 ，anchors 中的值都是百分比
 * @param pt 绝对坐标
 * @param worldRect 图形外接矩形
 * @returns 相对坐标点
 */
function calcRelativePoint(pt, worldRect) {
  const {
    x,
    y,
    width,
    height
  } = worldRect;
  const {
    penId,
    connectTo
  } = pt;
  const point = Object.assign({}, pt, {
    x: width ? (pt.x - x) / width : 0,
    y: height ? (pt.y - y) / height : 0
  });
  if (pt.prev) {
    point.prev = {
      penId,
      connectTo,
      x: width ? (pt.prev.x - x) / width : 0,
      y: height ? (pt.prev.y - y) / height : 0
    };
  }
  if (pt.next) {
    point.next = {
      penId,
      connectTo,
      x: width ? (pt.next.x - x) / width : 0,
      y: height ? (pt.next.y - y) / height : 0
    };
  }
  return point;
}
//射线法 判断点是否在多边形内部
function pointInPolygon(pt, pts) {
  let inside = false;
  for (let i = 0, j = pts.length - 1; i < pts.length; j = i++) {
    let xi = pts[i].x,
      yi = pts[i].y;
    let xj = pts[j].x,
      yj = pts[j].y;
    let intersect = yi > pt.y != yj > pt.y && pt.x < (xj - xi) * (pt.y - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
;// ./node_modules/@kyvi/cobweb/src/rect/index.js

;// ./node_modules/@kyvi/cobweb/src/diagrams/svg/parse.js

// This logic is shamelessly borrowed from Yqnn/svg-path-editor
// https://github.com/Yqnn/svg-path-editor
const commandRegex = /^[\t\n\f\r ]*([MLHVZCSQTAmlhvzcsqta])[\t\n\f\r ]*/;
const flagRegex = /^[01]/;
const numberRegex = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/;
const commaWsp = /^(([\t\n\f\r ]+,?[\t\n\f\r ]*)|(,[\t\n\f\r ]*))/;
const grammar = {
  M: [numberRegex, numberRegex],
  L: [numberRegex, numberRegex],
  H: [numberRegex],
  V: [numberRegex],
  Z: [],
  C: [numberRegex, numberRegex, numberRegex, numberRegex, numberRegex, numberRegex],
  S: [numberRegex, numberRegex, numberRegex, numberRegex],
  Q: [numberRegex, numberRegex, numberRegex, numberRegex],
  T: [numberRegex, numberRegex],
  A: [numberRegex, numberRegex, numberRegex, flagRegex, flagRegex, numberRegex, numberRegex]
};
function parseSvgPath(path) {
  let cursor = 0;
  const commands = [];
  while (cursor < path.length) {
    const match = path.slice(cursor).match(commandRegex);
    if (match !== null) {
      const command = match[1];
      cursor += match[0].length;
      const parser = parseCommands(command, path, cursor);
      cursor = parser.cursor;
      commands.push(...parser.commands);
    } else {
      throw new Error('malformed path (first error at ' + cursor + ')');
    }
  }
  return {
    commands
  };
}
function parse_getRect(path) {
  let x = Infinity;
  let y = Infinity;
  let ex = -Infinity;
  let ey = -Infinity;
  calcWorldPositions(path);
  path.commands.forEach(item => {
    item.worldPoints.forEach((num, index) => {
      if (index % 2 === 0) {
        if (num < x) {
          x = num;
        }
        if (num > ex) {
          ex = num;
        }
      } else {
        if (num < y) {
          y = num;
        }
        if (num > ey) {
          ey = num;
        }
      }
    });
  });
  --x;
  --y;
  return {
    x,
    y,
    ex,
    ey,
    width: ex - x + 1,
    height: ey - y + 1
  };
}
function translatePath(path, x, y) {
  if (y == null) {
    y = x;
  }
  path.commands.forEach((item, index) => {
    if (item.relative && index) {
      return;
    }
    switch (item.key) {
      case 'A':
      case 'a':
        item.values[5] += x;
        item.values[6] += y;
        break;
      case 'V':
      case 'v':
        item.values[0] += y;
        break;
      default:
        item.values.forEach((val, i) => {
          item.values[i] = val + (i % 2 === 0 ? x : y);
        });
        break;
    }
  });
}
function scalePath(path, x, y) {
  if (y == null) {
    y = x;
  }
  path.commands.forEach(item => {
    switch (item.key) {
      case 'A':
      case 'a':
        const a = item.values[0];
        const b = item.values[1];
        const angle = Math.PI * item.values[2] / 180;
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const A = b * b * y * y * cos * cos + a * a * y * y * sin * sin;
        const B = 2 * x * y * cos * sin * (b * b - a * a);
        const C = a * a * x * x * cos * cos + b * b * x * x * sin * sin;
        const F = -(a * a * b * b * x * x * y * y);
        const det = B * B - 4 * A * C;
        const val1 = Math.sqrt((A - C) * (A - C) + B * B);
        // New rotation:
        item.values[2] = B !== 0 ? Math.atan((C - A - val1) / B) * 180 / Math.PI : A < C ? 0 : 90;
        // New radius-x, radius-y
        item.values[0] = -Math.sqrt(2 * det * F * (A + C + val1)) / det;
        item.values[1] = -Math.sqrt(2 * det * F * (A + C - val1)) / det;
        // New target
        item.values[5] *= x;
        item.values[6] *= y;
        // New sweep flag
        item.values[4] = x * y >= 0 ? item.values[4] : 1 - item.values[4];
        break;
      case 'V':
      case 'v':
        item.values[0] *= y;
        break;
      default:
        item.values.forEach((val, index) => {
          item.values[index] = val * (index % 2 === 0 ? x : y);
        });
        break;
    }
  });
}
function pathToString(path) {
  let text = '';
  path.commands.forEach(item => {
    text += item.key + ' ';
    item.values.forEach(num => {
      text += num + ' ';
    });
  });
  return text;
}
function parseCommands(type, path, cursor) {
  const expectedRegexList = grammar[type.toUpperCase()];
  const commands = [];
  while (cursor <= path.length) {
    const command = {
      key: type,
      values: []
    };
    for (const regex of expectedRegexList) {
      const match = path.slice(cursor).match(regex);
      if (match !== null) {
        command.values.push(+match[0]);
        cursor += match[0].length;
        const ws = path.slice(cursor).match(commaWsp);
        if (ws !== null) {
          cursor += ws[0].length;
        }
      } else if (command.values.length === 0) {
        return {
          cursor,
          commands
        };
      } else {
        throw new Error('malformed path (first error at ' + cursor + ')');
      }
    }
    command.relative = command.key.toUpperCase() !== command.key;
    commands.push(command);
    if (expectedRegexList.length === 0) {
      return {
        cursor,
        commands
      };
    }
    if (type === 'm') {
      type = 'l';
    }
    if (type === 'M') {
      type = 'L';
    }
  }
  throw new Error('malformed path (first error at ' + cursor + ')');
}
function calcWorldPoints(command, previous) {
  const worldPoints = [];
  let current = command.relative && previous ? {
    x: previous.worldPoints[previous.worldPoints.length - 2],
    y: previous.worldPoints[previous.worldPoints.length - 1]
  } : {
    x: 0,
    y: 0
  };
  for (let i = 0; i < command.values.length - 1; i += 2) {
    worldPoints.push(current.x + command.values[i]);
    worldPoints.push(current.y + command.values[i + 1]);
  }
  command.worldPoints = worldPoints;
}
function calcWorldPositions(path) {
  let previous;
  let x = 0;
  let y = 0;
  path.commands.forEach(item => {
    switch (item.key) {
      case 'Z':
      case 'z':
        item.worldPoints = [x, y];
        break;
      case 'H':
        item.worldPoints = [item.values[0], previous.worldPoints[previous.worldPoints.length - 1]];
        break;
      case 'h':
        item.worldPoints = [item.values[0] + previous.worldPoints[previous.worldPoints.length - 2], previous.worldPoints[previous.worldPoints.length - 1]];
        break;
      case 'V':
        item.worldPoints = [previous.worldPoints[previous.worldPoints.length - 2], item.values[0]];
        break;
      case 'v':
        item.worldPoints = [previous.worldPoints[previous.worldPoints.length - 2], item.values[0] + previous.worldPoints[previous.worldPoints.length - 1]];
        break;
      case 'A':
        item.worldPoints = [previous.worldPoints[previous.worldPoints.length - 2], item.values[0] + previous.worldPoints[previous.worldPoints.length - 1]];
        break;
      default:
        calcWorldPoints(item, previous);
        break;
    }
    if (item.key === 'M' || item.key === 'm' || item.key === 'Z' || item.key === 'z') {
      x = item.worldPoints[item.worldPoints.length - 2];
      y = item.worldPoints[item.worldPoints.length - 1];
    }
    previous = item;
  });
}
;// ./node_modules/@kyvi/cobweb/src/diagrams/svgPath.js


function svgPath(pen, ctx) {
  const store = pen.calculative.canvas.store;
  const pathText = store.data.paths[pen.pathId];
  if (!pathText) {
    return new Path2D();
  }
  const path = parseSvgPath(pathText);
  pen.calculative.svgRect = parse_getRect(path);
  calcCenter(pen.calculative.svgRect);
  if (pen.calculative.svgRect.width !== pen.calculative.worldRect.width || pen.calculative.svgRect.height !== pen.calculative.worldRect.height) {
    scalePath(path, pen.calculative.worldRect.width / pen.calculative.svgRect.width, pen.calculative.worldRect.height / pen.calculative.svgRect.height);
  }
  const rect = parse_getRect(path);
  calcCenter(rect);
  translatePath(path, pen.calculative.worldRect.x - rect.x, pen.calculative.worldRect.y - rect.y);
  const pathStr = pathToString(path);
  if (ctx) {
    ctx.svgPath?.(pathStr);
    return;
  }
  const path2D = new Path2D(pathStr);
  // TODO: 为何要闭合曲线
  // path2D.closePath();
  return path2D;
}
;// ./node_modules/@kyvi/cobweb/src/diagrams/pentagram.js

function pentagram(pen, ctx) {
  if (!pen.onResize) {
    pen.onResize = resize;
  }
  const path = !ctx ? new Path2D() : ctx;
  const {
    width,
    height,
    center
  } = pen.calculative.worldRect;
  const r = width > height ? height : width;
  //旋转中心点
  const centerx = center.x;
  const centery = center.y;
  const basey = centery - r / 2;
  const baseyi = centery - r / 4;
  const lx = -(baseyi - centery) * Math.sin(Math.PI / 180 * 324) + centerx;
  const ly = (baseyi - centery) * Math.cos(Math.PI / 180 * 324) + centery;
  path.moveTo(lx, ly);
  for (let i = 0; i < 5; ++i) {
    // TODO: Math.sin Math.cos 考虑优化下
    path.lineTo(-(basey - centery) * Math.sin(Math.PI / 180 * 72 * i) + centerx, (basey - centery) * Math.cos(Math.PI / 180 * 72 * i) + centery);
    path.lineTo((lx - centerx) * Math.cos(Math.PI / 180 * 72 * (i + 1)) - (ly - centery) * Math.sin(Math.PI / 180 * 72 * (i + 1)) + centerx, (lx - centerx) * Math.sin(Math.PI / 180 * 72 * (i + 1)) + (ly - centery) * Math.cos(Math.PI / 180 * 72 * (i + 1)) + centery);
  }
  path.closePath();
  if (path instanceof Path2D) return path;
}
function pentagramAnchors(pen) {
  // TODO: 组合状态下的 width height 成了固定的百分比
  const {
    width,
    height
  } = pen;
  const r = width > height ? height : width;
  const anchors = [];
  for (let i = 0; i < 5; ++i) {
    anchors.push({
      flag: 1,
      // 默认锚点
      id: String(i),
      penId: pen.id,
      x: 0.5 + r / 2 * Math.sin(Math.PI / 180 * 72 * i) / width,
      y: -r / 2 * Math.cos(Math.PI / 180 * 72 * i) / height + 0.5
    });
  }
  pen.anchors = anchors;
}
function resize(pen) {
  // 过滤出非默认锚点，即自定义锚点
  const manualPoints = pen.anchors.filter(point => point.flag !== 1);
  pentagramAnchors(pen);
  pen.anchors = pen.anchors.concat(...manualPoints);
}
;// ./node_modules/@kyvi/cobweb/src/diagrams/cube.js
function cube(ctx, pen) {
  const {
    x,
    y,
    width,
    ex,
    ey
  } = pen.calculative.worldRect;
  let offset = width * 0.25;
  const z = pen.z;
  if (z > 1) {
    offset = z;
  } else if (z > 0) {
    offset = width * z;
  }
  const p1 = {
    x: x,
    y: y + offset
  };
  const p2 = {
    x: ex - offset,
    y: y + offset
  };
  const p3 = {
    x: ex - offset,
    y: ey
  };
  const p4 = {
    x: x,
    y: ey
  };
  // front
  face(ctx, [p1, p2, p3, p4], pen.backgroundFront || pen.background, pen.color);
  // up
  face(ctx, [p1, {
    x: x + offset,
    y: y
  }, {
    x: ex,
    y: y
  }, p2], pen.backgroundUp || pen.background, pen.color);
  // right
  face(ctx, [p2, {
    x: ex,
    y: y
  }, {
    x: ex,
    y: ey - offset
  }, p3], pen.backgroundRight || pen.background, pen.color);
}
function face(ctx, points, fillStyle = '', strokeStyle = '') {
  ctx.save();
  fillStyle && (ctx.fillStyle = fillStyle);
  strokeStyle && (ctx.strokeStyle = strokeStyle);
  ctx.beginPath();
  for (let i = 0; i < points.length; ++i) {
    if (i) {
      ctx.lineTo(points[i].x, points[i].y);
    } else {
      ctx.moveTo(points[i].x, points[i].y);
    }
  }
  ctx.closePath();
  fillStyle && ctx.fill();
  ctx.stroke();
  ctx.restore();
}
;// ./node_modules/@kyvi/cobweb/src/diagrams/line/curve.js




function curve(store, pen, mousedwon) {
  if (!pen.calculative.worldAnchors) {
    pen.calculative.worldAnchors = [];
  }
  if (mousedwon) {
    if (pen.calculative.activeAnchor) {
      pen.calculative.activeAnchor.next = {
        penId: pen.id,
        x: mousedwon.x,
        y: mousedwon.y
      };
      if (distance(pen.calculative.activeAnchor.next, pen.calculative.activeAnchor) < 5) {
        pen.calculative.activeAnchor.next = undefined;
      } else {
        pen.calculative.activeAnchor.prev = {
          ...pen.calculative.activeAnchor.next
        };
        rotatePoint(pen.calculative.activeAnchor.prev, 180, pen.calculative.activeAnchor);
      }
    }
  } else {
    const from = pen.calculative.worldAnchors[0];
    if (!from.next) {
      const fromFace = facePen(from, store.pens[from.connectTo]);
      calcCurveCP(from, fromFace, 50);
      from.prev = undefined;
    }
    const to = pen.calculative.worldAnchors[pen.calculative.worldAnchors.length - 1];
    if (to && to !== from && !to.prev) {
      const toFace = facePen(to, store.pens[to.connectTo]);
      calcCurveCP(to, toFace, -50);
      to.next = undefined;
    }
  }
}
function calcCurveCP(pt, d, dis) {
  switch (d) {
    case Direction.Up:
      pt.prev = {
        penId: pt.penId,
        x: pt.x,
        y: pt.y + dis
      };
      pt.next = {
        penId: pt.penId,
        x: pt.x,
        y: pt.y - dis
      };
      break;
    case Direction.Right:
      pt.prev = {
        penId: pt.penId,
        x: pt.x - dis,
        y: pt.y
      };
      pt.next = {
        penId: pt.penId,
        x: pt.x + dis,
        y: pt.y
      };
      break;
    case Direction.Bottom:
      pt.prev = {
        penId: pt.penId,
        x: pt.x,
        y: pt.y - dis
      };
      pt.next = {
        penId: pt.penId,
        x: pt.x,
        y: pt.y + dis
      };
      break;
    case Direction.Left:
      pt.prev = {
        penId: pt.penId,
        x: pt.x + dis,
        y: pt.y
      };
      pt.next = {
        penId: pt.penId,
        x: pt.x - dis,
        y: pt.y
      };
      break;
  }
}
// Get a point in quadratic.
// pos - The position of point in quadratic. It is expressed as a percentage(0 - 1).
function getQuadraticPoint(step, from, cp, to) {
  const pos = 1 - step;
  const x = pos * pos * from.x + 2 * pos * step * cp.x + step * step * to.x;
  const y = pos * pos * from.y + 2 * pos * step * cp.y + step * step * to.y;
  return {
    x,
    y,
    step
  };
}
// Get a point in bezier.
// pos - The position of point in bezier. It is expressed as a percentage(0 - 1).
function getBezierPoint(step, from, cp1, cp2, to) {
  const {
    x: x1,
    y: y1
  } = from;
  const {
    x: x2,
    y: y2
  } = to;
  const {
    x: cx1,
    y: cy1
  } = cp1;
  const {
    x: cx2,
    y: cy2
  } = cp2;
  const pos = 1 - step;
  const x = x1 * pos * pos * pos + 3 * cx1 * step * pos * pos + 3 * cx2 * step * step * pos + x2 * step * step * step;
  const y = y1 * pos * pos * pos + 3 * cy1 * step * pos * pos + 3 * cy2 * step * step * pos + y2 * step * step * step;
  return {
    x,
    y,
    step
  };
}
function lerp(pt1, pt2, t) {
  return {
    x: pt1.x + t * (pt2.x - pt1.x),
    y: pt1.y + t * (pt2.y - pt1.y)
  };
}
function getSplitAnchor(pen, pt, index) {
  let from = pen.calculative.worldAnchors[index];
  let to = pen.calculative.worldAnchors[index + 1];
  if (!to && pen.close) {
    to = pen.calculative.worldAnchors[0];
  }
  const t = pt.step;
  let anchor;
  if (from.next && to.prev) {
    const p0 = from;
    const p1 = from.next;
    const p2 = to.prev;
    const p3 = to;
    const p4 = lerp(p0, p1, t);
    const p5 = lerp(p1, p2, t);
    const p6 = lerp(p2, p3, t);
    const p7 = lerp(p4, p5, t);
    const p8 = lerp(p5, p6, t);
    anchor = lerp(p7, p8, t);
    p7.penId = pen.id;
    anchor.prev = p7;
    p8.penId = pen.id;
    anchor.next = p8;
    from.next.x = p4.x;
    from.next.y = p4.y;
    to.prev.x = p6.x;
    to.prev.y = p6.y;
  } else if (from.next || to.prev) {
    const p0 = from;
    const p1 = from.next || to.prev;
    const p2 = to;
    const p3 = lerp(p0, p1, t);
    const p4 = lerp(p1, p2, t);
    anchor = pt;
    p3.penId = pen.id;
    p4.penId = pen.id;
    anchor.prev = p3;
    anchor.next = p4;
    from.next = undefined;
    to.prev = undefined;
  } else {
    // 并非贝塞尔点，即 from 和 to 之间是一条直线
    anchor = pt;
  }
  anchor.penId = pen.id;
  anchor.id = s8();
  anchor.prevNextType = PrevNextType.Bilateral;
  return anchor;
}
function mind(store, pen, mousedwon) {
  if (!pen.calculative.worldAnchors) {
    pen.calculative.worldAnchors = [];
  }
  if (pen.calculative.worldAnchors.length < 2) {
    return;
  }
  let from = pen.calculative.activeAnchor;
  let to = mousedwon || getToAnchor(pen);
  if (!from || !to) {
    return;
  }
  const dis = 20;
  const fromPen = store.pens[from.connectTo];
  let fromFace = facePen(from, fromPen);
  if (fromFace === Direction.None) {
    if (to.x > from.x) {
      fromFace = Direction.Right;
    } else {
      fromFace = Direction.Left;
    }
  }
  from.next = {
    id: s8(),
    penId: pen.id,
    x: from.x,
    y: from.y,
    prevNextType: 2
  };
  to.prev = {
    id: s8(),
    penId: pen.id,
    x: to.x,
    y: to.y,
    prevNextType: 2
  };
  switch (fromFace) {
    case Direction.Up:
      from.next.y -= dis;
      to.prev.y = from.y;
      break;
    case Direction.Bottom:
      from.next.y += dis;
      to.prev.y = from.y;
      break;
    case Direction.Left:
      from.next.x -= dis;
      to.prev.x = from.x;
      break;
    default:
      from.next.x += dis;
      to.prev.x = from.x;
      break;
  }
}
;// ./node_modules/@kyvi/cobweb/src/diagrams/line/line.js





function line(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  if (pen.lineName === 'line' || pen.lineName === 'polyline') {
    if (pen.calculative.lineSmooth) {
      let _path = getGradientAnimatePath(pen);
      path.addPath(_path);
      if (path instanceof Path2D) return path;
    }
  }
  const worldAnchors = pen.calculative.worldAnchors;
  if (worldAnchors.length > 1) {
    let from; // 上一个点
    worldAnchors.forEach(pt => {
      if (from) {
        draw(path, from, pt);
      } else {
        pt.start = true;
      }
      from = pt;
    });
    if (pen.close) {
      if (pen.lineName === 'curve') {
        draw(path, from, worldAnchors[0]);
      } else {
        path.closePath();
      }
    }
  }
  if (path instanceof Path2D) return path;
}
function lineSegment(store, pen, mousedwon) {
  if (!pen.calculative.worldAnchors) {
    pen.calculative.worldAnchors = [];
  }
  if (pen.calculative.worldAnchors.length < 2 || pen.anchors?.length > 1) {
    return;
  }
  const from = getFromAnchor(pen);
  const to = getToAnchor(pen);
  if (!from || !to || !to.id || from === to) {
    return;
  }
  from.next = undefined;
  deleteTempAnchor(pen);
  to.prev = undefined;
  pen.calculative.worldAnchors.push(to);
}
function draw(path, from, to) {
  if (!to || to.isTemp) {
    return;
  }
  from.start && path.moveTo(from.x, from.y);
  if (from.next) {
    if (to.prev) {
      path.bezierCurveTo(from.next.x, from.next.y, to.prev.x, to.prev.y, to.x, to.y);
    } else {
      path.quadraticCurveTo(from.next.x, from.next.y, to.x, to.y);
    }
  } else {
    if (to.prev) {
      path.quadraticCurveTo(to.prev.x, to.prev.y, to.x, to.y);
    } else {
      path.lineTo(to.x, to.y);
    }
  }
}
function getLineRect(pen) {
  getLineLength(pen);
  return getRectOfPoints(getLinePoints(pen));
}
/**
 * 获取连线的 points ，并非 worldAnchors ，worldAnchors 之前的路径点也会记录
 */
function getLinePoints(pen) {
  const pts = [];
  let from; // 上一个点
  pen.calculative.worldAnchors.forEach(pt => {
    pts.push(pt);
    from && pts.push(...getPoints(from, pt, pen));
    from = pt;
  });
  if (pen.close && pen.calculative.worldAnchors.length > 1) {
    pts.push(...getPoints(from, pen.calculative.worldAnchors[0], pen));
  }
  return pts;
}
function getLineR(pen) {
  return pen?.lineWidth ? pen.lineWidth / 2 + 4 : 4;
}
function getPoints(from, to, pen) {
  const pts = [];
  if (!to) {
    return pts;
  }
  let step = 0.02;
  if (from.lineLength) {
    const r = getLineR(pen);
    step = r / from.lineLength;
  }
  if (from.next) {
    if (to.prev) {
      for (let i = step; i < 1; i += step) {
        pts.push(getBezierPoint(i, from, from.next, to.prev, to));
      }
    } else {
      for (let i = step; i < 1; i += step) {
        pts.push(getQuadraticPoint(i, from, from.next, to));
      }
    }
  } else {
    if (to.prev) {
      for (let i = step; i < 1; i += step) {
        pts.push(getQuadraticPoint(i, from, to.prev, to));
      }
    } else {
      pts.push({
        x: to.x,
        y: to.y
      });
    }
  }
  if (pts.length > 1) {
    from.curvePoints = pts;
  }
  return pts;
}
function pointInLine(pt, pen) {
  const r = getLineR(pen);
  let i = 0;
  let from; // 上一个点
  let point;
  for (const anchor of pen.calculative.worldAnchors) {
    if (from) {
      point = pointInLineSegment(pt, from, anchor, r);
      if (point) {
        return {
          i,
          point
        };
      }
      ++i;
    }
    from = anchor;
  }
  if (pen.close && pen.calculative.worldAnchors.length > 1 && (point = pointInLineSegment(pt, from, pen.calculative.worldAnchors[0], r))) {
    return {
      i,
      point
    };
  }
}
function pointInLineSegment(pt, pt1, pt2, r = 4) {
  if (!pt1.next && !pt2.prev) {
    const {
      x: x1,
      y: y1
    } = pt1;
    const {
      x: x2,
      y: y2
    } = pt2;
    const minX = Math.min(x1, x2);
    const maxX = Math.max(x1, x2);
    const minY = Math.min(y1, y2);
    const maxY = Math.max(y1, y2);
    if (!(pt.x >= minX - r && pt.x <= maxX + r && pt.y >= minY - r && pt.y <= maxY + r)) {
      return;
    }
    return pointToLine(pt, pt1, pt2, r);
  } else if (pt1.curvePoints) {
    for (const point of pt1.curvePoints) {
      if (hitPoint(pt, point, r)) {
        return point;
      }
    }
  }
}
function pointToLine(pt, pt1, pt2, r = 4) {
  // 竖线
  if (pt1.x === pt2.x) {
    const len = Math.abs(pt.x - pt1.x);
    if (len <= r) {
      return {
        x: pt1.x,
        y: pt.y
      };
    }
  } else {
    const A = (pt1.y - pt2.y) / (pt1.x - pt2.x);
    const B = pt1.y - A * pt1.x;
    const len = Math.abs((A * pt.x + B - pt.y) / Math.sqrt(A * A + 1));
    if (len <= r) {
      const m = pt.x + A * pt.y;
      const x = (m - A * B) / (A * A + 1);
      return {
        x,
        y: A * x + B
      };
    }
  }
}
function lineLen(from, cp1, cp2, to) {
  if (!cp1 && !cp2) {
    return Math.sqrt(Math.pow(Math.abs(from.x - to.x), 2) + Math.pow(Math.abs(from.y - to.y), 2)) || 0;
  }
  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  if (cp1 && cp2) {
    path.setAttribute('d', `M${from.x} ${from.y} C${cp1.x} ${cp1.y} ${cp2.x} ${cp2.y} ${to.x} ${to.y}`);
  } else if (cp1) {
    path.setAttribute('d', `M${from.x} ${from.y} Q${cp1.x} ${cp1.y} ${to.x} ${to.y}`);
  } else {
    path.setAttribute('d', `M${from.x} ${from.y} Q${cp2.x} ${cp2.y} ${to.x} ${to.y}`);
  }
  return path.getTotalLength() || 0;
}
function getLineLength(pen) {
  if (pen.calculative.worldAnchors.length < 2) {
    return 0;
  }
  let len = 0;
  let from; // 上一个点
  pen.calculative.worldAnchors.forEach(pt => {
    if (from) {
      from.lineLength = lineLen(from, from.next, pt.prev, pt);
      len += from.lineLength;
    }
    from = pt;
  });
  if (pen.close) {
    // pen.close ，下一个点即第一个点
    const to = getFromAnchor(pen);
    from.lineLength = lineLen(from, from.next, to.prev, to);
    len += from.lineLength;
  }
  if (pen.calculative.animatePos) {
    pen.calculative.animatePos = len / pen.length * pen.calculative.animatePos;
  }
  pen.length = len;
  return len;
}
/**
 * 连线在 rect 内， 连线与 rect 相交
 */
function lineInRect(line, rect) {
  // 判断是直线还是贝塞尔
  const worldAnchors = line.calculative.worldAnchors;
  for (let index = 0; index < worldAnchors.length - 1; index++) {
    const current = worldAnchors[index];
    const next = worldAnchors[index + 1];
    if (!current.next && !next.prev) {
      // 线段
      if (isLineIntersectRectangle(current, next, rect)) {
        return true;
      }
    } else {
      // 贝塞尔
      if (isBezierIntersectRectangle(current, next, rect)) {
        return true;
      }
    }
  }
  return false;
}
/**
 * 线段与矩形是否相交
 * @param rect 矩形
 */
function isLineIntersectRectangle(pt1, pt2, rect) {
  if (pointInSimpleRect(pt1, rect) || pointInSimpleRect(pt2, rect)) {
    // 存在一个点在矩形内部
    return true;
  }
  const linePointX1 = pt1.x;
  const linePointY1 = pt1.y;
  const linePointX2 = pt2.x;
  const linePointY2 = pt2.y;
  let rectangleLeftTopX = rect.x;
  let rectangleLeftTopY = rect.y;
  let rectangleRightBottomX = rect.ex;
  let rectangleRightBottomY = rect.ey;
  const lineHeight = linePointY1 - linePointY2;
  const lineWidth = linePointX2 - linePointX1; // 计算叉乘
  const c = linePointX1 * linePointY2 - linePointX2 * linePointY1;
  if (lineHeight * rectangleLeftTopX + lineWidth * rectangleLeftTopY + c >= 0 && lineHeight * rectangleRightBottomX + lineWidth * rectangleRightBottomY + c <= 0 || lineHeight * rectangleLeftTopX + lineWidth * rectangleLeftTopY + c <= 0 && lineHeight * rectangleRightBottomX + lineWidth * rectangleRightBottomY + c >= 0 || lineHeight * rectangleLeftTopX + lineWidth * rectangleRightBottomY + c >= 0 && lineHeight * rectangleRightBottomX + lineWidth * rectangleLeftTopY + c <= 0 || lineHeight * rectangleLeftTopX + lineWidth * rectangleRightBottomY + c <= 0 && lineHeight * rectangleRightBottomX + lineWidth * rectangleLeftTopY + c >= 0) {
    if (rectangleLeftTopX > rectangleRightBottomX) {
      const temp = rectangleLeftTopX;
      rectangleLeftTopX = rectangleRightBottomX;
      rectangleRightBottomX = temp;
    }
    if (rectangleLeftTopY < rectangleRightBottomY) {
      const temp1 = rectangleLeftTopY;
      rectangleLeftTopY = rectangleRightBottomY;
      rectangleRightBottomY = temp1;
    }
    if (linePointX1 < rectangleLeftTopX && linePointX2 < rectangleLeftTopX || linePointX1 > rectangleRightBottomX && linePointX2 > rectangleRightBottomX || linePointY1 > rectangleLeftTopY && linePointY2 > rectangleLeftTopY || linePointY1 < rectangleRightBottomY && linePointY2 < rectangleRightBottomY) {
      return false;
    } else {
      return true;
    }
  } else {
    return false;
  }
}
/**
 * 贝塞尔曲线与矩形是否相交
 * @param from 前点
 * @param to 后点
 * @param rect 矩形
 */
function isBezierIntersectRectangle(from, to, rect) {
  const step = 0.02;
  if (!from.next && !to.prev) {
    // 直线
    return isLineIntersectRectangle(from, to, rect);
  } else if (from.next && to.prev) {
    for (let i = step; i < 1; i += step) {
      const point = getBezierPoint(i, from, from.next, to.prev, to);
      if (pointInSimpleRect(point, rect)) {
        return true;
      }
    }
  } else if (from.next || to.prev) {
    for (let i = step; i < 1; i += step) {
      const point = getQuadraticPoint(i, from, from.next || to.prev, to);
      if (pointInSimpleRect(point, rect)) {
        return true;
      }
    }
  }
  return false;
}
;// ./node_modules/@kyvi/cobweb/src/diagrams/line/polyline.js




let faceSpace = 10;
function polyline(store, pen, mousedwon) {
  if (!pen.calculative.worldAnchors) {
    pen.calculative.worldAnchors = [];
  }
  faceSpace = store.options.polylineSpace || 10;
  if (pen.calculative.worldAnchors.length < 2) {
    return;
  }
  let from = getFromAnchor(pen);
  let to = getToAnchor(pen);
  if (!from || !to) {
    return;
  }
  // 拖拽起点
  let dragFrom;
  if (pen.anchors?.length && from === pen.calculative.activeAnchor) {
    dragFrom = true;
    from = to;
    to = getFromAnchor(pen);
  } else if ((!pen.anchors || !pen.anchors.length) && from !== pen.calculative.activeAnchor) {
    from = pen.calculative.activeAnchor;
  }
  if (!from || !to) {
    return;
  }
  from.next = undefined;
  to.prev = undefined;
  const connected = to.connectTo;
  deleteTempAnchor(pen);
  const pts = [];
  const fromPen = store.pens[from.connectTo];
  const toPen = store.pens[to.connectTo];
  const fromFace = facePen(from, fromPen);
  const toFace = facePen(to, toPen);
  let a = getFacePoint(from, fromFace, faceSpace);
  if (a) {
    from = a;
    pts.push(a);
  }
  a = getFacePoint(to, toFace, faceSpace);
  const end = to;
  let corner = undefined;
  if (a) {
    to = a;
    if (end.connectTo) {
      if (a.y > end.y && from.y < end.y || a.y < end.y && from.y > end.y) {
        //拐角 防止连线覆盖
        corner = a;
        let _faceSpace = faceSpace;
        if (from.x < a.x) {
          _faceSpace = -_faceSpace;
        }
        if (Math.abs(from.x - a.x) < _faceSpace) {
          _faceSpace = -_faceSpace;
        }
        const point = {
          x: a.x + _faceSpace,
          y: a.y,
          id: s8()
        };
        to = point;
      }
    }
  }
  switch (fromFace) {
    case Direction.Up:
      pts.push(...getNextPointsOfUp(from, to, toFace));
      break;
    case Direction.Right:
      pts.push(...getNextPointsOfRight(from, to, toFace));
      break;
    case Direction.Bottom:
      pts.push(...getNextPointsOfBottom(from, to, toFace));
      break;
    case Direction.Left:
      pts.push(...getNextPointsOfLeft(from, to, toFace));
      break;
    default:
      pts.push(...getNextPoints(pen, from, to));
      break;
  }
  pts.forEach(anchor => {
    anchor.id = s8();
    anchor.penId = pen.id;
    pen.calculative.worldAnchors.push(anchor);
  });
  pen.calculative.worldAnchors.push(to);
  if (corner) {
    pen.calculative.worldAnchors.push(corner);
  }
  if (a) {
    pen.calculative.worldAnchors.push(end);
  }
  if (dragFrom) {
    pen.calculative.worldAnchors.reverse();
  }
  if (connected) {
    const i = pen.calculative.worldAnchors.length - 2;
    pen.calculative.worldAnchors[i].isTemp = false;
    pen.calculative.worldAnchors[1].isTemp = false;
  }
}
function getFacePoint(pt, d, dis) {
  const point = {
    x: pt.x,
    y: pt.y,
    id: s8()
  };
  switch (d) {
    case Direction.Up:
      point.y -= dis;
      break;
    case Direction.Right:
      point.x += dis;
      break;
    case Direction.Bottom:
      point.y += dis;
      break;
    case Direction.Left:
      point.x -= dis;
      break;
    default:
      {
        return;
      }
  }
  return point;
}
function getNextPointsOfUp(from, to, toFace) {
  if (from.x === to.x || from.y === to.y) {
    return [];
  }
  const pts = [];
  let x;
  let y;
  switch (toFace) {
    case Direction.Up:
      if (from.y < to.y) {
        x = to.x;
        y = from.y;
      } else {
        x = from.x;
        y = to.y;
      }
      pts.push({
        x,
        y
      });
      break;
    case Direction.Bottom:
      x = to.x;
      y = from.y;
      if (to.y > from.y) {
        x = from.x + (to.x - from.x) / 2;
        pts.push({
          x,
          y: from.y
        }, {
          x,
          y: to.y
        });
      } else {
        const centerY = (from.y + to.y) / 2;
        pts.push({
          x: from.x,
          y: centerY
        }, {
          x: to.x,
          y: centerY
        });
      }
      break;
    case Direction.Right:
      x = to.x;
      y = from.y;
      if (to.x < from.x && to.y < from.y) {
        x = from.x;
        y = to.y;
      }
      pts.push({
        x,
        y
      });
      break;
    case Direction.Left:
      x = to.x;
      y = from.y;
      if (to.x > from.x && to.y < from.y) {
        x = from.x;
        y = to.y;
      }
      pts.push({
        x,
        y
      });
      break;
    default:
      if (to.y > from.y - faceSpace) {
        x = from.x + (to.x - from.x) / 2;
        pts.push({
          x,
          y: from.y
        }, {
          x,
          y: to.y
        });
      } else {
        const centerY = (from.y + to.y + faceSpace) / 2;
        pts.push({
          x: from.x,
          y: centerY
        }, {
          x: to.x,
          y: centerY
        });
      }
      break;
  }
  return pts;
}
function getNextPointsOfRight(from, to, toFace) {
  if (from.x === to.x || from.y === to.y) {
    return [];
  }
  const pts = [];
  let x;
  let y;
  switch (toFace) {
    case Direction.Up:
      x = from.x;
      y = to.y;
      if (to.x > from.x && to.y > from.y) {
        x = to.x;
        y = from.y;
      }
      pts.push({
        x,
        y
      });
      break;
    case Direction.Bottom:
      x = from.x;
      y = to.y;
      if (to.x > from.x && to.y < from.y) {
        x = to.x;
        y = from.y;
      }
      pts.push({
        x,
        y
      });
      break;
    case Direction.Left:
      x = to.x;
      y = from.y;
      if (to.x < from.x) {
        y = from.y + (to.y - from.y) / 2;
        pts.push({
          x: from.x,
          y
        }, {
          x: to.x,
          y
        });
      } else {
        const centerX = (from.x + to.x) / 2;
        pts.push({
          x: centerX,
          y
        }, {
          x: centerX,
          y: to.y
        });
      }
      break;
    case Direction.Right:
      if (to.x < from.x) {
        pts.push({
          x: from.x,
          y: to.y
        });
      } else {
        pts.push({
          x: to.x,
          y: from.y
        });
      }
      break;
    default:
      x = to.x;
      y = to.y;
      if (to.x < from.x + faceSpace) {
        pts.push({
          x: from.x,
          y
        });
      } else {
        const centerX = (from.x + to.x - faceSpace) / 2;
        pts.push({
          x: centerX,
          y: from.y
        }, {
          x: centerX,
          y
        });
      }
      break;
  }
  return pts;
}
function getNextPointsOfBottom(from, to, toFace) {
  if (from.x === to.x || from.y === to.y) {
    return [];
  }
  const pts = [];
  let x;
  let y;
  switch (toFace) {
    case Direction.Up:
      x = from.x;
      y = to.y;
      if (to.y < from.y) {
        x = from.x + (to.x - from.x) / 2;
        pts.push({
          x,
          y: from.y
        }, {
          x,
          y: to.y
        });
      } else {
        const centerY = (from.y + to.y) / 2;
        pts.push({
          x,
          y: centerY
        }, {
          x: to.x,
          y: centerY
        });
      }
      break;
    case Direction.Right:
      x = to.x;
      y = from.y;
      if (to.x < from.x && to.y > from.y) {
        x = from.x;
        y = to.y;
      }
      pts.push({
        x,
        y
      });
      break;
    case Direction.Bottom:
      if (from.y > to.y) {
        x = to.x;
        y = from.y;
      } else {
        x = from.x;
        y = to.y;
      }
      pts.push({
        x,
        y
      });
      break;
    case Direction.Left:
      x = to.x;
      y = from.y;
      if (to.x > from.x && to.y > from.y) {
        x = from.x;
        y = to.y;
      }
      pts.push({
        x,
        y
      });
      break;
    default:
      x = from.x;
      if (to.y < from.y + faceSpace) {
        x = from.x + (to.x - from.x) / 2;
        pts.push({
          x,
          y: from.y
        }, {
          x,
          y: to.y
        });
      } else {
        const centerY = (from.y + to.y - faceSpace) / 2;
        pts.push({
          x,
          y: centerY
        }, {
          x: to.x,
          y: centerY
        });
      }
      break;
  }
  return pts;
}
function getNextPointsOfLeft(from, to, toFace) {
  if (from.x === to.x || from.y === to.y) {
    return [];
  }
  const pts = [];
  let x;
  let y;
  switch (toFace) {
    case Direction.Up:
      x = from.x;
      y = to.y;
      if (to.x < from.x && to.y > from.y) {
        x = to.x;
        y = from.y;
      }
      pts.push({
        x,
        y
      });
      break;
    case Direction.Bottom:
      x = from.x;
      y = to.y;
      if (to.x < from.x && to.y < from.y) {
        x = to.x;
        y = from.y;
      }
      pts.push({
        x,
        y
      });
      break;
    case Direction.Right:
      x = from.x;
      y = to.y;
      if (to.x > from.x) {
        x = to.x;
        y = from.y + (to.y - from.y) / 2;
        pts.push({
          x: from.x,
          y
        }, {
          x: to.x,
          y
        });
      } else {
        const centerX = (from.x + to.x) / 2;
        pts.push({
          x: centerX,
          y: from.y
        }, {
          x: centerX,
          y: to.y
        });
      }
      break;
    case Direction.Left:
      if (to.x > from.x) {
        pts.push({
          x: from.x,
          y: to.y
        });
      } else {
        pts.push({
          x: to.x,
          y: from.y
        });
      }
      break;
    default:
      x = from.x;
      y = to.y;
      if (to.x < from.x - faceSpace) {
        const centerX = (from.x + to.x + faceSpace) / 2;
        pts.push({
          x: centerX,
          y: from.y
        }, {
          x: centerX,
          y
        });
      } else {
        pts.push({
          x: from.x,
          y
        });
      }
      break;
  }
  return pts;
}
function getNextPoints(pen, from, to) {
  const pts = [];
  if (pen.calculative.drawlineH == undefined) {
    pen.calculative.drawlineH = Math.abs(to.x - from.x) > Math.abs(to.y - from.y);
  }
  let index = pen.calculative.worldAnchors.findIndex(anchor => anchor.id == from.id);
  if (index > 1) {
    let prev = pen.calculative.worldAnchors[index - 1];
    if (prev.x === from.x && prev.y !== from.y) {
      //水平
      pts.push({
        x: to.x,
        y: from.y
      });
      return pts;
    } else if (prev.y === from.y && prev.x !== from.x) {
      //垂直
      pts.push({
        x: from.x,
        y: to.y
      });
      return pts;
    }
  }
  if (pen.calculative.worldAnchors.length) {
    to.isTemp = undefined;
    if (pen.calculative.drawlineH) {
      pts.push({
        x: to.x,
        y: from.y
      });
      if (Math.abs(to.y - from.y) < faceSpace) {
        to.isTemp = true;
      }
    } else {
      pts.push({
        x: from.x,
        y: to.y
      });
      if (Math.abs(to.x - from.x) < faceSpace) {
        to.isTemp = true;
      }
    }
  }
  return pts;
}
function anchorInHorizontal(pen, anchor, from = true) {
  let anchors = pen.calculative.worldAnchors;
  if (!from) {
    anchors = [];
    pen.calculative.worldAnchors.forEach(item => {
      anchors.unshift(item);
    });
  }
  for (let i = 0; i < anchors.length; i++) {
    if (anchors[i].id === anchor.id) {
      break;
    }
    if (anchors[i].y !== anchor.y) {
      return false;
    }
    if (anchors[i].x === anchors[i + 1]?.x && anchors[i].y !== anchors[i + 1]?.y) {
      return false;
    }
  }
  return true;
}
function anchorInVertical(pen, anchor, from = true) {
  let anchors = pen.calculative.worldAnchors;
  if (!from) {
    anchors = [];
    pen.calculative.worldAnchors.forEach(item => {
      anchors.unshift(item);
    });
  }
  for (let i = 0; i < anchors.length; i++) {
    if (anchors[i].id === anchor.id) {
      break;
    }
    if (anchors[i].x !== anchor.x) {
      return false;
    }
    if (anchors[i].y === anchors[i + 1]?.y && anchors[i].x !== anchors[i + 1]?.x) {
      return false;
    }
  }
  return true;
}
function translatePolylineAnchor(pen, anchor, pt) {
  if (!pen.calculative.worldAnchors) {
    return;
  }
  const i = pen.calculative.worldAnchors.findIndex(item => item.id === anchor.id);
  const from = getFromAnchor(pen);
  const to = getToAnchor(pen);
  let prev = pen.calculative.worldAnchors[i - 1];
  let next = pen.calculative.worldAnchors[i + 1];
  if (pen.calculative.h == undefined) {
    if (from.connectTo) {
      if (anchorInHorizontal(pen, anchor, true)) {
        pen.calculative.h = true;
      } else if (anchorInVertical(pen, anchor, true)) {
        pen.calculative.h = false;
      }
    }
    if (pen.calculative.h == undefined && to.connectTo) {
      if (anchorInHorizontal(pen, anchor, false)) {
        pen.calculative.h = true;
      } else if (anchorInVertical(pen, anchor, false)) {
        pen.calculative.h = false;
      }
    }
    if (pen.calculative.h == undefined) {
      if (prev) {
        pen.calculative.h = prev.y === anchor.y;
      } else if (next) {
        pen.calculative.h = next.y === anchor.y;
      }
    }
  }
  // 水平
  if (pen.calculative.h) {
    anchor.x = pt.x;
    if (from.connectTo && anchorInHorizontal(pen, anchor, true)) {
      if (next && next.y !== anchor.y) {
        next.x = anchor.x;
      }
      return;
    }
    if (to.connectTo && anchorInHorizontal(pen, anchor, false)) {
      if (prev && prev.y !== anchor.y) {
        prev.x = anchor.x;
      }
      return;
    }
    const a = pen.anchors[i];
    let d;
    for (let pos = i - 1; pos > -1; pos--) {
      prev = pen.anchors[pos];
      if (d == undefined) {
        d = prev.y === a.y;
      }
      if (d === true) {
        if (prev.y === a.y) {
          pen.calculative.worldAnchors[pos].y = pt.y;
        } else {
          break;
        }
      } else {
        if (prev.x === a.x) {
          pen.calculative.worldAnchors[pos].x = pt.x;
        } else {
          break;
        }
      }
    }
    d = undefined;
    for (let pos = i + 1; pos < pen.calculative.worldAnchors.length; pos++) {
      next = pen.anchors[pos];
      if (next) {
        if (d == undefined) {
          d = next.y === a.y;
        }
        if (d === true) {
          if (next.y === a.y) {
            pen.calculative.worldAnchors[pos].y = pt.y;
          } else {
            break;
          }
        } else {
          if (next.x === a.x) {
            pen.calculative.worldAnchors[pos].x = pt.x;
          } else {
            break;
          }
        }
      } else {
        break;
      }
    }
    anchor.y = pt.y;
  }
  // 垂直
  else {
    anchor.y = pt.y;
    if (from.connectTo && anchorInVertical(pen, anchor, true)) {
      if (next && next.x !== anchor.x) {
        next.y = anchor.y;
      }
      return;
    }
    if (to.connectTo && anchorInVertical(pen, anchor, false)) {
      if (prev && prev.x !== anchor.x) {
        prev.y = anchor.y;
      }
      return;
    }
    const a = pen.anchors[i];
    let d;
    for (let pos = i - 1; pos > -1; pos--) {
      prev = pen.anchors[pos];
      if (d == undefined) {
        d = prev.x === a.x;
      }
      if (d === true) {
        if (prev.x === a.x) {
          pen.calculative.worldAnchors[pos].x = pt.x;
        } else {
          break;
        }
      } else {
        if (prev.y === a.y) {
          pen.calculative.worldAnchors[pos].y = pt.y;
        } else {
          break;
        }
      }
    }
    d = undefined;
    for (let pos = i + 1; pos < pen.calculative.worldAnchors.length; pos++) {
      next = pen.anchors[pos];
      if (next) {
        if (d == undefined) {
          d = next.x === a.x;
        }
        if (d === true) {
          if (next.x === a.x) {
            pen.calculative.worldAnchors[pos].x = pt.x;
          } else {
            break;
          }
        } else {
          if (next.y === a.y) {
            pen.calculative.worldAnchors[pos].y = pt.y;
          } else {
            break;
          }
        }
      } else {
        break;
      }
    }
    anchor.x = pt.x;
  }
}
;// ./node_modules/@kyvi/cobweb/src/diagrams/line/smooth.js


function simplify(points, length, start, end) {
  const newPoints = [];
  let maxDist, index, xx, yy, dx, dy, ddx, ddy, p1, p2, p, t, dist, dist1;
  p1 = points[start];
  p2 = points[end];
  xx = p1.x;
  yy = p1.y;
  ddx = p2.x - xx;
  ddy = p2.y - yy;
  dist1 = ddx * ddx + ddy * ddy;
  maxDist = length;
  for (let i = start + 1; i < end; i++) {
    p = points[i];
    if (ddx !== 0 || ddy !== 0) {
      t = ((p.x - xx) * ddx + (p.y - yy) * ddy) / dist1;
      if (t > 1) {
        dx = p.x - p2.x;
        dy = p.y - p2.y;
      } else if (t > 0) {
        dx = p.x - (xx + ddx * t);
        dy = p.y - (yy + ddy * t);
      } else {
        dx = p.x - xx;
        dy = p.y - yy;
      }
    } else {
      dx = p.x - xx;
      dy = p.y - yy;
    }
    dist = dx * dx + dy * dy;
    if (dist > maxDist) {
      index = i;
      maxDist = dist;
    }
  }
  if (maxDist > length) {
    // continue simplification while maxDist > length
    if (index - start > 1) {
      newPoints.push(...simplify(points, length, start, index));
    }
    newPoints.push({
      id: points[index].id,
      penId: points[index].penId,
      x: points[index].x,
      y: points[index].y
    });
    if (end - index > 1) {
      newPoints.push(...simplify(points, length, index, end));
    }
  }
  return newPoints;
}
function smoothLine(points, cornerThres = 0.8, match = false) {
  if (points.length < 3) {
    return points;
  }
  // adds bezier control points at points if lines have angle less than thres
  let p1, p2, p3, dist1, dist2, x, y, endP, len, angle, newPoints, aLen, nx1, nx2, ny1, ny2;
  const dot = (x, y, xx, yy) => {
    dist1 = Math.sqrt(x * x + y * y);
    if (dist1 > 0) {
      // normalise
      nx1 = x / dist1;
      ny1 = y / dist1;
    } else {
      nx1 = 1; // need to have something so this will do as good as anything
      ny1 = 0;
    }
    dist2 = Math.sqrt(xx * xx + yy * yy);
    if (dist2 > 0) {
      nx2 = xx / dist2;
      ny2 = yy / dist2;
    } else {
      nx2 = 1;
      ny2 = 0;
    }
    return Math.acos(nx1 * nx2 + ny1 * ny2);
  };
  newPoints = [];
  aLen = points.length;
  p1 = points[0];
  endP = points[aLen - 1];
  newPoints.push({
    ...points[0]
  });
  for (let i = 0; i < aLen - 1; i++) {
    p2 = points[i];
    p3 = points[i + 1];
    angle = Math.abs(dot(p2.x - p1.x, p2.y - p1.y, p3.x - p2.x, p3.y - p2.y));
    if (dist1) {
      // dist1 and dist2 come from dot function
      if (angle < cornerThres * 3.14) {
        // bend it if angle between lines is small
        if (match) {
          dist1 = Math.min(dist1, dist2);
          dist2 = dist1;
        }
        // use the two normalized vectors along the lines to create the tangent vector
        x = (nx1 + nx2) / 2;
        y = (ny1 + ny2) / 2;
        len = Math.sqrt(x * x + y * y); // normalise the tangent
        if (len === 0) {
          newPoints.push({
            ...p2
          });
        } else {
          x /= len;
          y /= len;
          const pt = {
            ...p2
          };
          pt.prevNextType = PrevNextType.Bilateral;
          pt.prev = {
            penId: pt.penId,
            x: p2.x - x * dist1 * 0.25,
            y: p2.y - y * dist1 * 0.25
          };
          pt.next = {
            penId: pt.penId,
            x: p2.x + x * dist2 * 0.25,
            y: p2.y + y * dist2 * 0.25
          };
          newPoints.push(pt);
        }
      } else {
        newPoints.push({
          ...p2
        });
      }
    }
    p1 = p2;
  }
  newPoints.push({
    ...points[points.length - 1]
  });
  return newPoints;
}
;// ./node_modules/@kyvi/cobweb/src/diagrams/line/arrow.js

//箭头动画
function drawArrow(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const worldAnchors = pen.calculative.worldAnchors;
  let scale = pen.calculative.canvas.store.data.scale;
  let size = (pen.calculative.animateLineWidth || 6) * scale; // 箭头大小
  let arrowLength = (pen.animateLineWidth * 2 || 12) * scale; // 箭头长度
  if (pen.lineAnimateType === LineAnimateType.WaterDrop) {
    arrowLength = (pen.animateLineWidth * 4 || 24) * scale; // 水滴长度
  }
  let d = (pen.animateInterval || 100) * scale; // 箭头间距
  let smoothLenth = pen.calculative.lineWidth * (pen.calculative.lineSmooth || 0); //*scale;
  let lineWidth = (pen.calculative.animateLineWidth / 2 || 3) * scale;
  if (pen.animateReverse) {
    //箭头反向
    arrowLength = -arrowLength;
    size = -size;
  }
  if (worldAnchors.length > 1) {
    let from; // 上一个点
    let lastLength = 0;
    for (let i = 0; i < worldAnchors.length; i++) {
      let pt = worldAnchors[i];
      //获取箭头角度
      if (from) {
        let angle = arrow_getAngle(from, pt);
        let newP = {
          x: from.x + (pen.calculative.animatePos - lastLength) % d * Math.cos(angle * Math.PI / 180),
          y: from.y - (pen.calculative.animatePos - lastLength) % d * Math.sin(angle * Math.PI / 180)
        };
        if (pen.animateReverse) {
          newP = {
            x: from.x + (pen.length - (pen.calculative.animatePos + lastLength)) % d * Math.cos(angle * Math.PI / 180),
            y: from.y - (pen.length - (pen.calculative.animatePos + lastLength)) % d * Math.sin(angle * Math.PI / 180)
          };
        }
        let newPTFrom = Math.sqrt((newP.x - from.x) ** 2 + (newP.y - from.y) ** 2);
        let ptTFrom = Math.sqrt((pt.x - from.x) ** 2 + (pt.y - from.y) ** 2);
        while (newPTFrom < ptTFrom) {
          if ((pen.animateReverse && newPTFrom - arrowLength < ptTFrom ||
          //不允许超出连线绘制
          !pen.animateReverse && newPTFrom > arrowLength) && newPTFrom > smoothLenth + arrowLength && ptTFrom - newPTFrom > smoothLenth) {
            if (pen.lineAnimateType === LineAnimateType.Arrow) {
              arrow(path, newP, size, angle, lineWidth, arrowLength);
            } else if (pen.lineAnimateType === LineAnimateType.WaterDrop) {
              waterDrop(path, newP, pen.animateReverse, angle, lineWidth, arrowLength);
            }
          }
          newP.x += d * Math.cos(angle * Math.PI / 180);
          newP.y -= d * Math.sin(angle * Math.PI / 180);
          newPTFrom = Math.sqrt((newP.x - from.x) ** 2 + (newP.y - from.y) ** 2);
        }
        // lastLength += ptTFrom-newPTFrom;
      }
      from = pt;
    }
  }
  if (path instanceof Path2D) return path;
}
//获取两点连线和水平线的夹角
function arrow_getAngle(p1, p2) {
  let dx = p2.x - p1.x;
  let dy = p2.y - p1.y;
  let angle = Math.atan(dy / dx) * 180 / Math.PI;
  if (p2.x >= p1.x) {
    angle = -angle;
  } else {
    angle = 180 - angle;
  }
  return angle;
}
//获取p相对rp旋转_angle后的点坐标
function getRotatePoint(p, rp, _angle) {
  let angle = (180 - _angle) * Math.PI / 180;
  return {
    x: (p.x - rp.x) * Math.cos(angle) - (p.y - rp.y) * Math.sin(angle) + rp.x,
    y: (p.x - rp.x) * Math.sin(angle) + (p.y - rp.y) * Math.cos(angle) + rp.y
  };
}
//标准箭头
function arrow(path, newP, size, angle, lineWidth, arrowLength) {
  let pr = getRotatePoint({
    x: newP.x + size,
    y: newP.y + 0.57 * size
  }, {
    x: newP.x,
    y: newP.y
  }, angle);
  let pl = getRotatePoint({
    x: newP.x + size,
    y: newP.y - 0.57 * size
  }, {
    x: newP.x,
    y: newP.y
  }, angle);
  let pr1 = getRotatePoint({
    x: newP.x + size,
    y: newP.y + lineWidth / 2
  }, {
    x: newP.x,
    y: newP.y
  }, angle);
  let pr2 = getRotatePoint({
    x: newP.x + arrowLength,
    y: newP.y + lineWidth / 2
  }, {
    x: newP.x,
    y: newP.y
  }, angle);
  let pl1 = getRotatePoint({
    x: newP.x + size,
    y: newP.y - lineWidth / 2
  }, {
    x: newP.x,
    y: newP.y
  }, angle);
  let pl2 = getRotatePoint({
    x: newP.x + arrowLength,
    y: newP.y - lineWidth / 2
  }, {
    x: newP.x,
    y: newP.y
  }, angle);
  path.moveTo(pr.x, pr.y);
  path.lineTo(newP.x, newP.y);
  path.lineTo(pl.x, pl.y);
  path.lineTo(pl1.x, pl1.y);
  path.lineTo(pl2.x, pl2.y);
  path.lineTo(pr2.x, pr2.y);
  path.lineTo(pr1.x, pr1.y);
  path.lineTo(pr.x, pr.y);
}
//水滴
function waterDrop(path, newP, reverse, angle, lineWidth, arrowLength) {
  let dis = lineWidth / 2;
  if (reverse) {
    dis = -lineWidth / 2;
  }
  let pl1 = getRotatePoint({
    x: newP.x,
    y: newP.y + dis
  }, {
    x: newP.x,
    y: newP.y
  }, angle);
  let pE = getRotatePoint({
    x: newP.x + arrowLength,
    y: newP.y
  }, {
    x: newP.x,
    y: newP.y
  }, angle);
  let rAngle = Math.PI / 2;
  if (reverse) {
    rAngle = -Math.PI / 2;
  }
  path.moveTo(newP.x, newP.y);
  path.arc(newP.x, newP.y, lineWidth / 2, -rAngle - angle / 180 * Math.PI, rAngle - angle / 180 * Math.PI, false);
  path.lineTo(pE.x, pE.y);
  path.lineTo(pl1.x, pl1.y);
}
;// ./node_modules/@kyvi/cobweb/src/diagrams/line/index.js





;// ./node_modules/@kyvi/cobweb/src/diagrams/iframe.js


function iframe(pen) {
  if (!pen.onDestroy) {
    pen.onDestroy = destory;
    pen.onMove = move;
    pen.onResize = move;
    pen.onRotate = move;
    pen.onValue = move;
    pen.onMouseMove = mouseMove;
    pen.onBeforeValue = beforeValue;
    pen.onRenderPenRaw = iframe_renderPenRaw;
  }
  if (!pen.calculative.singleton) {
    pen.calculative.singleton = {};
  }
  const worldRect = pen.calculative.worldRect;
  if (!pen.calculative.singleton.div) {
    const div = document.createElement('div');
    div.style.position = 'absolute';
    div.style.outline = 'none';
    div.style.left = '-9999px';
    div.style.top = '-9999px';
    div.style.width = worldRect.width + 'px';
    div.style.height = worldRect.height + 'px';
    document.body.appendChild(div);
    pen.calculative.canvas.externalElements?.parentElement.appendChild(div);
    render_setElemPosition(pen, div);
    pen.calculative.singleton.div = div;
    const iframe = document.createElement('iframe');
    iframe.style.width = '100%';
    iframe.style.height = '100%';
    iframe.scrolling = pen.scrolling || 'no';
    iframe.frameBorder = '0';
    iframe.style.border = 'none';
    iframe.src = pen.iframe;
    pen.calculative.iframe = pen.iframe;
    div.appendChild(iframe);
    generateAroundDiv(pen);
    iframe.onload = () => {
      iframe.setAttribute('document.domain', '');
    };
  }
  if (pen.calculative.patchFlags) {
    render_setElemPosition(pen, pen.calculative.singleton.div);
  }
  pen.onRenderPenRaw(pen);
  return new Path2D();
}
function destory(pen) {
  updatePointerEvents(pen);
  if (pen.calculative.singleton && pen.calculative.singleton.div) {
    pen.calculative.singleton.div.remove();
    delete pen.calculative.singleton.div;
  }
}
function move(pen) {
  pen.calculative.singleton.div && render_setElemPosition(pen, pen.calculative.singleton.div);
}
function beforeValue(pen, value) {
  if (value.iframe) {
    if (pen.calculative.singleton.div) {
      pen.calculative.singleton.div.children[0].src = value.iframe;
      pen.calculative.iframe = value.iframe;
    }
  }
  if (value.operationalRect || value['operationalRect.x'] !== undefined || value['operationalRect.y'] !== undefined || value['operationalRect.width'] !== undefined || value['operationalRect.height'] !== undefined) {
    if (!pen.operationalRect) {
      pen.operationalRect = {};
    }
    let _value = deepClone(value);
    if (!_value.operationalRect) {
      _value.operationalRect = {};
    }
    if (_value['operationalRect.x'] !== undefined) {
      _value.operationalRect.x = _value['operationalRect.x'];
    }
    if (_value['operationalRect.y'] !== undefined) {
      _value.operationalRect.y = _value['operationalRect.y'];
    }
    if (_value['operationalRect.width'] !== undefined) {
      _value.operationalRect.width = _value['operationalRect.width'];
    }
    if (_value['operationalRect.height'] !== undefined) {
      _value.operationalRect.height = _value['operationalRect.height'];
    }
    Object.assign(pen.operationalRect, _value.operationalRect);
    if (pen.calculative.singleton.div) {
      let length = pen.calculative.singleton.div.children.length;
      if (length === 1) {
        //没有创建
        generateAroundDiv(pen);
      } else {
        //有更新值
        pen.calculative.singleton.div.children[1].style.height = pen.operationalRect.y * 100 + '%';
        pen.calculative.singleton.div.children[1].style.left = pen.operationalRect.x * 100 + '%';
        pen.calculative.singleton.div.children[1].style.width = pen.operationalRect.width * 100 + '%';
        pen.calculative.singleton.div.children[2].style.width = (1 - pen.operationalRect.x - pen.operationalRect.width) * 100 + '%';
        pen.calculative.singleton.div.children[3].style.height = (1 - pen.operationalRect.y - pen.operationalRect.height) * 100 + '%';
        pen.calculative.singleton.div.children[3].style.left = pen.operationalRect.x * 100 + '%';
        pen.calculative.singleton.div.children[3].style.width = pen.operationalRect.width * 100 + '%';
        pen.calculative.singleton.div.children[4].style.width = pen.operationalRect.x * 100 + '%';
      }
    }
  }
  if (value.blur !== undefined) {
    for (let i = 1; i < 5; i++) {
      pen.calculative.singleton.div.children[i].style['backdrop-filter'] = `blur(${value.blur || 2}px)`;
    }
  }
  if (value.blurBackground !== undefined) {
    for (let i = 1; i < 5; i++) {
      pen.calculative.singleton.div.children[i].style.backgroundColor = value.blurBackground;
    }
  }
  return value;
}
function mouseMove(pen, e) {
  if (!pen.calculative.canvas.store.data.locked && !pen.locked) {
    return;
  }
  if (initOperationalRect(pen.operationalRect)) {
    if (pen.calculative.zIndex < 5 && e.x > pen.x + pen.width * pen.operationalRect.x && e.x < pen.x + pen.width * (pen.operationalRect.x + pen.operationalRect.width) && e.y > pen.y + pen.height * pen.operationalRect.y && e.y < pen.y + pen.height * (pen.operationalRect.y + pen.operationalRect.height)) {
      if (pen.calculative.singleton.div) {
        let children = pen.calculative.singleton.div.parentNode.children;
        for (let i = 0; i < 6; i++) {
          children[i].style.pointerEvents = 'none';
        }
      }
    }
  }
}
function initOperationalRect(operationalRect) {
  if (operationalRect) {
    if (!operationalRect.width || !operationalRect.height) {
      return false;
    }
    //默认居中
    if (operationalRect.x === undefined) {
      operationalRect.x = (1 - operationalRect.width) / 2;
    }
    if (operationalRect.y === undefined) {
      operationalRect.y = (1 - operationalRect.height) / 2;
    }
    return true;
  } else {
    return false;
  }
}
function generateAroundDiv(pen) {
  if (!initOperationalRect(pen.operationalRect)) {
    return;
  }
  const div = pen.calculative.singleton.div;
  if (!div) {
    return;
  }
  const top = document.createElement('div');
  top.style.position = 'absolute';
  top.style.left = pen.operationalRect.x * 100 + '%';
  top.style.top = '0px';
  top.style.width = pen.operationalRect.width * 100 + '%';
  top.style.height = pen.operationalRect.y * 100 + '%';
  top.style['backdrop-filter'] = `blur(${pen.blur || 2}px)`;
  top.style.backgroundColor = pen.blurBackground;
  div.appendChild(top);
  const right = document.createElement('div');
  right.style.position = 'absolute';
  right.style.right = '0px';
  right.style.top = '0px';
  right.style.width = (1 - pen.operationalRect.x - pen.operationalRect.width) * 100 + '%';
  right.style.height = '100%';
  right.style['backdrop-filter'] = `blur(${pen.blur || 2}px)`;
  right.style.backgroundColor = pen.blurBackground;
  div.appendChild(right);
  const bottom = document.createElement('div');
  bottom.style.position = 'absolute';
  bottom.style.left = pen.operationalRect.x * 100 + '%';
  bottom.style.bottom = '0px';
  bottom.style.width = pen.operationalRect.width * 100 + '%';
  bottom.style.height = (1 - pen.operationalRect.y - pen.operationalRect.height) * 100 + '%';
  bottom.style['backdrop-filter'] = `blur(${pen.blur || 2}px)`;
  bottom.style.backgroundColor = pen.blurBackground;
  div.appendChild(bottom);
  const left = document.createElement('div');
  left.style.position = 'absolute';
  left.style.left = '0px';
  left.style.top = '0px';
  left.style.width = pen.operationalRect.x * 100 + '%';
  left.style.height = '100%';
  left.style['backdrop-filter'] = `blur(${pen.blur || 2}px)`;
  left.style.backgroundColor = pen.blurBackground;
  div.appendChild(left);
  let mouseEnter = () => {
    updatePointerEvents(pen);
  };
  top.onmouseenter = mouseEnter;
  bottom.onmouseenter = mouseEnter;
  right.onmouseenter = mouseEnter;
  left.onmouseenter = mouseEnter;
  div.onmouseleave = mouseEnter;
  // }
}
function updatePointerEvents(pen) {
  if (!pen.calculative.canvas.store.data.locked && !pen.locked) {
    return;
  }
  if (pen.calculative.zIndex < 5) {
    let children = pen.calculative.singleton.div.parentNode.children;
    for (let i = 1; i < 6; i++) {
      children[i].style.pointerEvents = 'initial';
    }
  }
}
function iframe_renderPenRaw(pen) {
  if (pen.thumbImg) {
    if (!pen.calculative.img) {
      const img = new Image();
      img.crossOrigin = pen.crossOrigin === 'undefined' ? undefined : pen.crossOrigin || 'anonymous';
      if (pen.calculative.canvas.store.options.cdn && !(pen.thumbImg.startsWith('http') || pen.thumbImg.startsWith('//') || pen.thumbImg.startsWith('data:image'))) {
        img.src = pen.calculative.canvas.store.options.cdn + pen.thumbImg;
      } else {
        img.src = pen.thumbImg;
      }
      img.onerror = e => {
        img.remove();
        pen.calculative.img = undefined;
      };
      pen.calculative.img = img;
    }
  } else {
    // if (pen.calculative.singleton && pen.calculative.singleton.div) {
    //   try {
    //     // handleSaveImg(pen);
    //   } catch (e) {
    //     console.warn(e);
    //     pen.calculative.img = null;
    //   }
    // }
  }
}
async function handleSaveImg(pen) {
  let iframeHtml = pen.calculative.singleton.div.children[0].contentWindow;
  const iframeBody = iframeHtml.document.getElementsByTagName('body')[0];
  const iframeScrollY = iframeHtml.document.documentElement.scrollTop;
  const iframeScrollX = iframeHtml.document.documentElement.scrollLeft;
  var fillContent = document.createElement('div');
  // 把需要转换成图片的元素内容赋给创建的元素
  fillContent.innerHTML = iframeBody.outerHTML;
  document.body.appendChild(fillContent);
  iframeHtml.document.domain = getRootDomain();
  if (globalThis.html2canvas) {
    const canvas = await globalThis.html2canvas(fillContent, {
      allowTaint: true,
      useCORS: true,
      width: pen.width,
      // TODO 截屏按照1920*1080分辨率下的预览窗口宽高
      height: pen.height,
      x: iframeScrollX,
      y: iframeScrollY
      // foreignObjectRendering: true,
    });
    // canvas.getContext('2d', {
    //   willReadFrequently: true,
    // });
    const img = new Image();
    img.crossOrigin = pen.crossOrigin === 'undefined' ? undefined : pen.crossOrigin || 'anonymous';
    img.src = canvas.toDataURL('image/png', 0.1);
    if (img.src.length > 10) {
      pen.calculative.img = img;
    }
    document.body.removeChild(fillContent);
  }
  // globalThis.html2canvas &&
  //   globalThis
  //     .html2canvas(iframeBody, {
  //       allowTaint: true,
  //       useCORS: true,
  //       width: pen.width, // TODO 截屏按照1920*1080分辨率下的预览窗口宽高
  //       height: pen.height,
  //       x: iframeScrollX,
  //       y: iframeScrollY,
  //       foreignObjectRendering: true,
  //     })
  //     .then((canvas) => {
  //       // 转成图片，生成图片地址
  //       // imgBase64 = canvas.toDataURL('image/png');
  //       const img = new Image();
  //       img.crossOrigin =
  //         pen.crossOrigin === 'undefined'
  //           ? undefined
  //           : pen.crossOrigin || 'anonymous';
  //       img.src = canvas.toDataURL('image/png', 0.1);
  //       if (img.src.length > 10) {
  //         pen.calculative.img = img;
  //       }
  //     })
  //     .catch((e) => {
  //       console.warn(e);
  //     });
}
;// ./node_modules/@kyvi/cobweb/src/diagrams/video.js

const videos = {};
const mutedIcons = ['<svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M473.088 125.44L256 256H52.224C23.552 256 0 279.552 0 308.224V716.8c0 28.16 23.04 51.2 51.2 51.2h204.8l217.088 130.56c16.896 10.24 38.912-2.048 38.912-22.016V147.456c0-19.968-21.504-32.256-38.912-22.016zM699.904 320.512c-20.992-18.944-53.248-17.408-72.192 3.584-18.944 20.992-17.408 53.248 3.584 72.192 0.512 0.512 58.368 54.784 58.368 121.344 0 37.888-19.456 74.752-58.368 110.08-20.992 18.944-22.528 51.2-3.584 72.192 10.24 11.264 24.064 16.896 37.888 16.896 12.288 0 24.576-4.608 34.304-13.312 61.44-55.296 92.16-117.76 92.16-185.856 0-112.64-88.576-193.536-92.16-197.12z" fill="" p-id="2434"></path><path d="M853.504 166.4c-20.992-18.944-53.248-16.896-72.192 4.096-18.944 20.992-16.896 53.248 4.096 72.192 1.536 1.024 135.68 122.88 135.68 280.576 0 90.624-45.568 177.152-135.68 257.536-20.992 18.944-23.04 51.2-4.096 72.192 10.24 11.264 24.064 16.896 38.4 16.896 12.288 0 24.576-4.096 34.304-12.8 112.64-100.864 169.984-212.992 169.984-333.824-1.024-202.752-163.84-350.208-170.496-356.864z"></path></svg>', '<svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" ><path d="M256 768H51.2c-28.16 0-51.2-23.04-51.2-51.2V308.224C0 279.552 23.552 256 52.224 256H256v512zM512 147.456v728.576c0 19.968-21.504 32.256-38.912 22.016L256 768V256l217.088-130.56c17.408-10.24 38.912 2.048 38.912 22.016zM623.104 656.896c-19.968-19.968-19.968-52.224 0-72.192l217.088-217.088c19.968-19.968 52.224-19.968 72.192 0 19.968 19.968 19.968 52.224 0 72.192l-217.088 217.088c-19.456 19.968-52.224 19.968-72.192 0z" fill="" p-id="2582"></path><path d="M623.104 367.104c19.968-19.968 52.224-19.968 72.192 0l217.088 217.088c19.968 19.968 19.968 52.224 0 72.192-19.968 19.968-52.224 19.968-72.192 0l-217.088-217.088c-19.968-19.456-19.968-52.224 0-72.192z"></path></svg>'];
function video(pen) {
  if (!pen.onDestroy) {
    pen.onDestroy = video_destory;
    pen.onMove = video_move;
    pen.onResize = video_move;
    pen.onRotate = video_move;
    pen.onClick = click;
    pen.onValue = value;
    pen.onChangeId = changeId;
  }
  if (!videos[pen.id]) {
    const player = document.createElement('div');
    const progress = document.createElement('div');
    progress.style.position = 'absolute';
    progress.style.outline = 'none';
    progress.style.left = '0';
    progress.style.bottom = '0';
    progress.style.width = '0';
    progress.style.height = '2px';
    progress.style.background = '#52c41a';
    progress.style.zIndex = '1';
    if (pen.hideProgress) {
      progress.style.display = 'none';
    }
    const muted = document.createElement('div');
    muted.innerHTML = mutedIcons[1];
    muted.style.position = 'absolute';
    muted.style.right = '0';
    muted.style.bottom = '0';
    muted.style.width = '20px';
    muted.style.height = '20px';
    muted.style.fill = 'hsla(0, 0%, 100%, .8)';
    muted.style.zIndex = '1';
    muted.style.display = 'none';
    player.appendChild(progress);
    player.appendChild(muted);
    muted.onclick = e => {
      e.stopPropagation();
      if (pen.calculative.media.muted) {
        muted.innerHTML = mutedIcons[0];
        pen.calculative.media.muted = false;
      } else {
        muted.innerHTML = mutedIcons[1];
        pen.calculative.media.muted = true;
      }
    };
    if (!pen.calculative.singleton) {
      pen.calculative.singleton = {};
    }
    pen.calculative.singleton.muted = muted;
    player.onmouseenter = e => {
      muted.style.display = 'block';
    };
    player.onmouseleave = e => {
      muted.style.display = 'none';
    };
    player.onclick = e => {
      e.stopPropagation();
      click(pen);
    };
    let media;
    if (pen.video) {
      media = document.createElement('video');
      media.src = pen.video;
    } else if (pen.audio) {
      media = document.createElement('audio');
      media.src = pen.audio;
    }
    media.loop = pen.playLoop;
    media.ontimeupdate = () => {
      resizeProcessWidth(progress, media, pen.calculative.worldRect.width);
    };
    media.onended = () => {
      pen.calculative.onended && pen.calculative.onended(pen);
    };
    pen.calculative.media = media;
    media.style.position = 'absolute';
    media.style.outline = 'none';
    media.style.left = '0';
    media.style.top = '0';
    media.style.width = '100%';
    media.style.height = '100%';
    player.appendChild(media);
    videos[pen.id] = player;
    pen.calculative.canvas.externalElements?.parentElement.appendChild(player);
    render_setElemPosition(pen, player);
    if (pen.autoPlay) {
      media.autoplay = true;
      media.muted = true;
    }
  } else if (pen.video && pen.calculative.media && pen.video !== pen.calculative.video) {
    console.warn('video 更改, 此处是否执行？');
    pen.calculative.media.src = pen.video;
    if (pen.autoPlay) {
      pen.calculative.media.muted = true;
      pen.calculative.media.autoplay = true;
    }
    pen.calculative.media.loop = pen.playLoop;
    pen.calculative.video = pen.video;
  } else if (pen.audio && pen.calculative.media && pen.audio !== pen.calculative.audio) {
    pen.calculative.media.src = pen.audio;
    if (pen.autoPlay) {
      pen.calculative.media.muted = true;
      pen.calculative.media.autoplay = true;
    }
    pen.calculative.media.loop = pen.playLoop;
    pen.calculative.audio = pen.audio;
  }
  if (pen.calculative.patchFlags) {
    render_setElemPosition(pen, videos[pen.id]);
  }
  return new Path2D();
}
function video_destory(pen) {
  videos[pen.id].onclick = null;
  videos[pen.id].remove();
  videos[pen.id] = undefined;
}
function video_move(pen) {
  render_setElemPosition(pen, videos[pen.id]);
  const progress = videos[pen.id].children[0];
  const media = videos[pen.id].children[1];
  resizeProcessWidth(progress, media, pen.calculative.worldRect.width);
}
function click(pen) {
  if (pen.calculative.media) {
    pen.calculative.media.muted = false;
    pen.calculative.singleton.muted.innerHTML = mutedIcons[0];
    if (pen.calculative.media.paused) {
      pen.calculative.media.play();
    } else {
      pen.calculative.media.pause();
    }
  }
}
function resizeProcessWidth(progress, media, width) {
  // worldRect 会重新赋值，而 pen 不会变，这里才能取到实时的 worldRect
  progress.style.width = media.currentTime / media.duration * width + 'px';
}
function changeId(pen, oldId, newId) {
  if (!videos[oldId]) {
    return;
  }
  videos[newId] = videos[oldId];
  delete videos[oldId];
}
function value(pen) {
  const video = videos[pen.id];
  if (!video) {
    return;
  }
  render_setElemPosition(pen, video);
  const currentSrc = pen.calculative.media.getAttribute('src');
  if (pen.video) {
    if (currentSrc !== pen.video) {
      pen.calculative.media.src = pen.video;
    }
  } else if (pen.audio) {
    if (currentSrc !== pen.audio) {
      pen.calculative.media.src = pen.audio;
    }
  }
  // TODO: 下面每次都改动，是否影响性能？
  if (pen.autoPlay) {
    pen.calculative.media.muted = true;
    // TODO: 自动播放何时关？
    pen.calculative.media.autoplay = true;
  }
  pen.calculative.media.loop = pen.playLoop;
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-exception.stack.js
var web_dom_exception_stack = __webpack_require__(4979);
;// ./node_modules/@kyvi/cobweb/src/canvas/offscreen.js
function createOffscreen() {
  try {
    const offscreen = new OffscreenCanvas(0, 0);
    const context = offscreen.getContext('2d');
    if (context && context.arc) {
      return offscreen;
    }
    return document.createElement('canvas');
  } catch (e) {
    return document.createElement('canvas');
  }
}
;// ./node_modules/@kyvi/cobweb/src/tooltip/tooltip.js


class Tooltip {
  // 本次 tooltip 在哪个画笔上
  constructor(parentElement, store) {
    _defineProperty(this, "parentElement", void 0);
    _defineProperty(this, "store", void 0);
    _defineProperty(this, "box", void 0);
    _defineProperty(this, "text", void 0);
    _defineProperty(this, "arrowUp", void 0);
    _defineProperty(this, "arrowDown", void 0);
    _defineProperty(this, "x", void 0);
    _defineProperty(this, "y", void 0);
    _defineProperty(this, "currentPen", void 0);
    this.parentElement = parentElement;
    this.store = store;
    this.box = document.createElement('div');
    this.text = document.createElement('div');
    this.arrowUp = document.createElement('div');
    this.arrowDown = document.createElement('div');
    this.box.className = 'meta2d-tooltip';
    this.text.className = 'text';
    this.arrowUp.className = 'arrow';
    this.arrowDown.className = 'arrow down';
    this.box.appendChild(this.text);
    this.box.appendChild(this.arrowUp);
    this.box.appendChild(this.arrowDown);
    parentElement.appendChild(this.box);
    this.box.onmouseleave = () => {
      this.hide();
      this.store.lastHover = undefined;
    };
    let sheet;
    for (let i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].title === 'le5le.com/tooltip') {
        sheet = document.styleSheets[i];
      }
    }
    if (!sheet) {
      let style = document.createElement('style');
      style.type = 'text/css';
      style.title = 'le5le.com/tooltip';
      document.head.appendChild(style);
      style = document.createElement('style');
      style.type = 'text/css';
      document.head.appendChild(style);
      sheet = style.sheet;
      sheet.insertRule('.meta2d-tooltip{position:absolute;padding:8px 0;z-index:10;left: -9999px;top: -9999px;}');
      sheet.insertRule('.meta2d-tooltip .text{max-width:320px;min-height:30px;max-height:400px;outline:none;padding:8px 16px;border-radius:4px;background:#777777;color:#ffffff;line-height:1.8;overflow-y:auto;}');
      sheet.insertRule('.meta2d-tooltip .arrow{position:absolute;border:10px solid transparent;background:transparent;top:-5px;left:50%;transform:translateX(-50%)}');
      sheet.insertRule('.meta2d-tooltip .arrow.down{top:initial;bottom: -1px;}');
    }
  }
  /**
   * 通过 pen 的 titleFn titleFnJs title 来获取 title
   * @returns 此次应该展示的 title
   */
  static getTitle(pen) {
    if (pen.titleFnJs && !pen.titleFn) {
      try {
        pen.titleFn = new Function('pen', pen.titleFnJs);
      } catch (error) {
        console.log('titleFnJs', error);
      }
    }
    return pen.titleFn ? pen.titleFn(pen) : String(pen.title);
  }
  /**
   * 更改 tooltip dom 的文本
   * @returns 返回设置前的 rect
   */
  setText(pen) {
    const oldElemRect = this.box.getBoundingClientRect();
    let marked = globalThis.marked;
    const title = Tooltip.getTitle(pen);
    if (marked) {
      this.text.innerHTML = marked(title);
      const a = this.text.getElementsByTagName('A');
      for (let i = 0; i < a.length; ++i) {
        a[i].setAttribute('target', '_blank');
      }
    } else {
      this.text.innerHTML = title;
    }
    return oldElemRect;
  }
  /**
   * 更新文字
   */
  updateText(pen) {
    if (this.currentPen?.id !== pen.id) {
      return;
    }
    if (Tooltip.titleEmpty(pen)) {
      return;
    }
    const oldRect = this.setText(pen);
    const newRect = this.box.getBoundingClientRect();
    this.changePositionByText(oldRect, newRect);
  }
  /**
   * 改变文字会 影响 box 的大小，需要重新设置位置
   * @param oldRect 原
   * @param newRect 新
   */
  changePositionByText(oldRect, newRect) {
    this.x -= (newRect.width - oldRect.width) / 2;
    this.y -= newRect.height - oldRect.height;
    this.box.style.left = this.x + 'px';
    this.box.style.top = this.y + 'px';
  }
  static titleEmpty(pen) {
    return !pen.title && !pen.titleFn && !pen.titleFnJs;
  }
  show(pen, pos) {
    this.currentPen = pen;
    if (Tooltip.titleEmpty(pen)) {
      let parent = getParent(pen, true);
      if (parent) {
        this.show(parent, pos);
      }
      return;
    }
    this.setText(pen);
    const elemRect = this.box.getBoundingClientRect();
    const rect = pen.calculative.worldRect;
    let x = pen.calculative.canvas.store.data.x + pos.x - elemRect.width / 2;
    let y = pen.calculative.canvas.store.data.y + pos.y - elemRect.height;
    if (!pen.type) {
      x = pen.calculative.canvas.store.data.x + rect.x - (elemRect.width - rect.width) / 2;
      y = pen.calculative.canvas.store.data.y + rect.ey - elemRect.height - rect.height;
    }
    if (y > 0) {
      this.arrowUp.style.borderBottomColor = 'transparent';
      this.arrowDown.style.borderTopColor = '#777777';
    } else {
      y += elemRect.height + rect.height + 5;
      this.arrowUp.style.borderBottomColor = '#777777';
      this.arrowDown.style.borderTopColor = 'transparent';
    }
    this.x = x;
    this.y = y;
    this.box.style.left = this.x + 'px';
    this.box.style.top = this.y + 'px';
  }
  hide() {
    this.currentPen = null;
    this.x = -9999;
    this.box.style.left = '-9999px';
  }
  translate(x, y) {
    if (this.x < -1000) {
      return;
    }
    this.x += x;
    this.y += y;
    this.box.style.left = this.x + 'px';
    this.box.style.top = this.y + 'px';
  }
  destroy() {
    this.box.onmouseleave = null;
  }
}
;// ./node_modules/@kyvi/cobweb/src/tooltip/index.js

;// ./node_modules/@kyvi/cobweb/src/scroll/scroll.js


class Scroll {
  //页面模式
  constructor(parent) {
    _defineProperty(this, "parent", void 0);
    _defineProperty(this, "h", void 0);
    _defineProperty(this, "v", void 0);
    _defineProperty(this, "isDownH", void 0);
    _defineProperty(this, "isDownV", void 0);
    _defineProperty(this, "x", void 0);
    _defineProperty(this, "y", void 0);
    _defineProperty(this, "hSize", void 0);
    _defineProperty(this, "vSize", void 0);
    _defineProperty(this, "scrollX", void 0);
    _defineProperty(this, "scrollY", void 0);
    _defineProperty(this, "lastScrollX", void 0);
    _defineProperty(this, "lastScrollY", void 0);
    _defineProperty(this, "rect", void 0);
    _defineProperty(this, "isShow", void 0);
    _defineProperty(this, "pageMode", void 0);
    _defineProperty(this, "onMouseDownH", e => {
      e.preventDefault();
      e.stopPropagation();
      this.isDownH = e.x;
      this.x = this.parent.store.data.x || 0;
      this.lastScrollX = this.scrollX;
    });
    _defineProperty(this, "onMouseDownV", e => {
      e.preventDefault();
      e.stopPropagation();
      this.isDownV = e.y;
      this.y = this.parent.store.data.y || 0;
      this.lastScrollY = this.scrollY;
    });
    _defineProperty(this, "onMouseMove", e => {
      if (this.isDownH) {
        const x = e.x - this.isDownH;
        this.scrollX = this.lastScrollX + x;
        this.h.style.left = `${this.scrollX}px`;
        this.parent.store.data.x = this.x - x * this.rect.width / this.parent.parentElement.clientWidth;
      }
      if (this.isDownV) {
        const y = e.y - this.isDownV;
        if (this.pageMode && this.canMouseMove(y)) {
          return;
        }
        this.scrollY = this.lastScrollY + y;
        this.v.style.top = `${this.scrollY}px`;
        this.parent.store.data.y = this.y - y * this.rect.height / this.parent.parentElement.clientHeight;
      }
      if (this.isDownH || this.isDownV) {
        this.parent.onMovePens();
        this.parent.canvasTemplate.init();
        this.parent.canvasImage.init();
        this.parent.canvasImageBottom.init();
        this.parent.render();
      }
    });
    _defineProperty(this, "onMouseUp", e => {
      if (!this.isDownH && !this.isDownV) {
        return;
      }
      this.isDownH = undefined;
      this.isDownV = undefined;
      if (this.scrollX < 20) {
        this.scrollX = 20;
        this.h.style.left = `${this.scrollX}px`;
      } else if (this.scrollX > this.parent.parentElement.clientWidth - this.hSize - 20) {
        this.scrollX = this.parent.parentElement.clientWidth - this.hSize - 20;
        this.h.style.left = `${this.scrollX}px`;
      }
      if (this.scrollY < 20) {
        this.scrollY = 20;
        this.v.style.top = `${this.scrollY}px`;
      } else if (this.scrollY > this.parent.parentElement.clientHeight - this.vSize - 20) {
        this.scrollY = this.parent.parentElement.clientHeight - this.vSize - 20;
        this.v.style.top = `${this.scrollY}px`;
      }
      this.resize();
    });
    this.parent = parent;
    this.h = document.createElement('div');
    this.v = document.createElement('div');
    this.parent.externalElements.appendChild(this.h);
    this.parent.externalElements.appendChild(this.v);
    this.h.className = 'meta2d-scroll h';
    this.h.onmousedown = this.onMouseDownH;
    this.v.className = 'meta2d-scroll v';
    this.v.onmousedown = this.onMouseDownV;
    document.addEventListener('mousemove', this.onMouseMove);
    document.addEventListener('mouseup', this.onMouseUp);
    let sheet;
    for (let i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].title === 'le5le/scroll') {
        sheet = document.styleSheets[i];
      }
    }
    if (!sheet) {
      let style = document.createElement('style');
      style.type = 'text/css';
      style.title = 'le5le.com/scroll';
      document.head.appendChild(style);
      style = document.createElement('style');
      style.type = 'text/css';
      document.head.appendChild(style);
      sheet = style.sheet;
      sheet.insertRule('.meta2d-scroll{position:absolute;width:8px;height:200px;background:#dddddd;border-radius:10px;z-index:20;cursor:default;}');
      sheet.insertRule('.meta2d-scroll:hover{background:#cccccc;cursor:pointer}');
      sheet.insertRule('.meta2d-scroll.v{right:0;top:calc(50% - 100px);}');
      sheet.insertRule('.meta2d-scroll.h{bottom:2px;left:calc(50% - 100px);width:200px;height:8px;}');
    }
    this.init();
  }
  init() {
    this.isShow = true;
    this.resize();
    this.initPos();
  }
  canMouseMove(y) {
    const rect = this.parent.parent.getRect();
    if (y < 0 && rect.y + this.parent.store.data.y >= 0) {
      return true;
    }
    if (y > 0 && rect.ey - this.parent.height + this.parent.store.data.y <= 0) {
      return true;
    }
    return false;
  }
  changeMode() {
    this.pageMode = true;
    this.h.style.display = `none`;
    const rect = this.parent.parent.getRect();
    if (rect.height < this.parent.height) {
      this.v.style.display = `none`;
    }
  }
  initPos() {
    this.scrollX = (this.parent.parentElement.clientWidth - this.hSize) / 2;
    this.scrollY = (this.parent.parentElement.clientHeight - this.vSize) / 2;
    this.h.style.left = `${this.scrollX}px`;
    this.v.style.top = `${this.scrollY}px`;
  }
  resize() {
    this.rect = getRect(this.parent.store.data.pens);
    if (this.rect.width < 1400) {
      this.rect.width = 1400;
    }
    if (this.rect.height < 900) {
      this.rect.height = 900;
    }
    if (this.parent.store.data.x > 0) {
      this.rect.width += this.parent.store.data.x + (this.rect.x > 0 ? 0 : this.rect.x);
    } else {
      this.rect.width -= this.parent.store.data.x + (this.rect.x > 0 ? 0 : this.rect.x);
    }
    if (this.parent.store.data.y > 0) {
      this.rect.height += this.parent.store.data.y + (this.rect.y > 0 ? 0 : this.rect.y);
    } else {
      this.rect.height -= this.parent.store.data.y + (this.rect.y > 0 ? 0 : this.rect.y);
    }
    if (this.rect.width < 1400) {
      this.rect.width = 1400;
    }
    if (this.rect.height < 900) {
      this.rect.height = 900;
    }
    this.hSize = 1000 * this.parent.parentElement.clientWidth / this.rect.width / 3;
    this.vSize = 1000 * this.parent.parentElement.clientHeight / this.rect.height / 3;
    this.h.style.width = this.hSize + 'px';
    this.v.style.height = this.vSize + 'px';
  }
  show() {
    this.isShow = true;
    this.h.style.display = `block`;
    this.v.style.display = `block`;
    document.addEventListener('mousemove', this.onMouseMove);
    document.addEventListener('mouseup', this.onMouseUp);
  }
  hide() {
    this.isShow = false;
    this.h.style.display = `none`;
    this.v.style.display = `none`;
    this.destroy();
  }
  translate(x, y) {
    if (x) {
      this.scrollX -= x * this.parent.parentElement.clientWidth / this.rect.width;
      this.h.style.left = `${this.scrollX}px`;
    }
    if (y) {
      this.scrollY -= y * this.parent.parentElement.clientHeight / this.rect.height;
      this.v.style.top = `${this.scrollY}px`;
    }
  }
  wheel(up) {
    let y = 10;
    if (up) {
      y = -10;
    }
    if (this.pageMode && this.canMouseMove(y)) {
      return;
    }
    this.scrollY += y;
    this.v.style.top = `${this.scrollY}px`;
    this.parent.store.data.y -= y * this.rect.height / this.parent.parentElement.clientHeight;
    this.parent.onMovePens();
    this.parent.canvasTemplate.init();
    this.parent.canvasImage.init();
    this.parent.canvasImageBottom.init();
    this.parent.render();
  }
  destroy() {
    document.removeEventListener('mousemove', this.onMouseMove);
    document.removeEventListener('mouseup', this.onMouseUp);
  }
}
;// ./node_modules/@kyvi/cobweb/src/scroll/index.js

;// ./node_modules/@kyvi/cobweb/src/canvas/canvasImage.js




class CanvasImage {
  constructor(parentElement, store, isBottom) {
    _defineProperty(this, "parentElement", void 0);
    _defineProperty(this, "store", void 0);
    _defineProperty(this, "isBottom", void 0);
    _defineProperty(this, "canvas", document.createElement('canvas'));
    /**
     * 非图片的绘制
     * isBottom true 指背景颜色，背景网格
     * isBottom false 指 标尺
     */
    _defineProperty(this, "otherOffsreen", createOffscreen());
    // 非图片的
    _defineProperty(this, "offscreen", createOffscreen());
    _defineProperty(this, "animateOffsScreen", createOffscreen());
    _defineProperty(this, "fitOffscreen", createOffscreen());
    _defineProperty(this, "fitFlag", false);
    //开启自定义填充
    _defineProperty(this, "currentFit", void 0);
    _defineProperty(this, "activeFit", void 0);
    this.parentElement = parentElement;
    this.store = store;
    this.isBottom = isBottom;
    parentElement.appendChild(this.canvas);
    this.canvas.style.backgroundRepeat = 'no-repeat';
    this.canvas.style.backgroundSize = '100% 100%';
    this.canvas.style.position = 'absolute';
    this.canvas.style.top = '0';
    this.canvas.style.left = '0';
  }
  resize(w, h) {
    this.canvas.style.width = w + 'px';
    this.canvas.style.height = h + 'px';
    w = w * this.store.dpiRatio | 0;
    h = h * this.store.dpiRatio | 0;
    this.canvas.width = w;
    this.canvas.height = h;
    this.otherOffsreen.width = w;
    this.otherOffsreen.height = h;
    this.offscreen.width = w;
    this.offscreen.height = h;
    this.animateOffsScreen.width = w;
    this.animateOffsScreen.height = h;
    this.fitOffscreen.width = w;
    this.fitOffscreen.height = h;
    this.otherOffsreen.getContext('2d').scale(this.store.dpiRatio, this.store.dpiRatio);
    this.otherOffsreen.getContext('2d').textBaseline = 'middle';
    this.offscreen.getContext('2d').scale(this.store.dpiRatio, this.store.dpiRatio);
    this.offscreen.getContext('2d').textBaseline = 'middle';
    this.animateOffsScreen.getContext('2d').scale(this.store.dpiRatio, this.store.dpiRatio);
    this.animateOffsScreen.getContext('2d').textBaseline = 'middle';
    this.fitOffscreen.getContext('2d').scale(this.store.dpiRatio, this.store.dpiRatio);
    this.fitOffscreen.getContext('2d').textBaseline = 'middle';
    this.init();
  }
  init() {
    this.offscreen.getContext('2d').clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.animateOffsScreen.getContext('2d').clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.fitOffscreen.getContext('2d').clearRect(0, 0, this.canvas.width, this.canvas.height);
    for (const pen of this.store.data.pens) {
      if (this.hasImage(pen)) {
        // 只影响本层的
        pen.calculative.imageDrawed = false;
      }
    }
    if (this.isBottom) {
      this.store.patchFlagsBackground = true;
    } else {
      this.store.patchFlagsTop = true;
    }
  }
  clear() {
    this.otherOffsreen.getContext('2d').clearRect(0, 0, this.otherOffsreen.width, this.otherOffsreen.height);
    this.offscreen.getContext('2d').clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.animateOffsScreen.getContext('2d').clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.fitOffscreen.getContext('2d').clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.canvas.getContext('2d').clearRect(0, 0, this.canvas.width, this.canvas.height);
  }
  hasImage(pen) {
    pen.calculative.hasImage = pen.calculative && pen.calculative.inView && (
    // !pen.isBottom == !this.isBottom && // undefined == false 结果 false
    this.isBottom && pen.canvasLayer === CanvasLayer.CanvasImageBottom || !this.isBottom && pen.canvasLayer === CanvasLayer.CanvasImage) && pen.image && pen.calculative.img && pen.name !== 'gif';
    return pen.calculative.hasImage;
  }
  render() {
    let patchFlags = false;
    let patchFlagsAnimate = false;
    for (const pen of this.store.data.pens) {
      if (this.hasImage(pen)) {
        if (this.store.animates.has(pen)) {
          patchFlagsAnimate = true;
        } else if (!pen.calculative.imageDrawed) {
          patchFlags = true;
        }
        if (pen.parentId && this.store.animates.has(getParent(pen, true))) {
          patchFlagsAnimate = true;
        }
      }
    }
    const patchFlagsBackground = this.store.patchFlagsBackground;
    // if (patchFlagsBackground && this.isBottom) {
    //   const ctx = this.otherOffsreen.getContext('2d');
    //   ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    //   const width = this.store.data.width || this.store.options.width;
    //   const height = this.store.data.height || this.store.options.height;
    //   const x = this.store.data.x || this.store.options.x;
    //   const y = this.store.data.y || this.store.options.y;
    //   if (width && height && this.store.bkImg) {
    //     ctx.save();
    //     ctx.drawImage(
    //       this.store.bkImg,
    //       this.store.data.origin.x + x,
    //       this.store.data.origin.y + y,
    //       width * this.store.data.scale,
    //       height * this.store.data.scale
    //     );
    //     ctx.restore();
    //   }
    //   const background =
    //     this.store.data.background ||
    //     (this.store.bkImg ? undefined : this.store.options.background);
    //   if (background) {
    //     ctx.save();
    //     ctx.fillStyle = background;
    //     if (width && height) {
    //       ctx.fillRect(
    //         this.store.data.origin.x + x,
    //         this.store.data.origin.y + y,
    //         width * this.store.data.scale,
    //         height * this.store.data.scale
    //       );
    //     } else {
    //       ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    //     }
    //     ctx.restore();
    //   }
    //   this.renderGrid(ctx);
    // }
    const patchFlagsTop = this.store.patchFlagsTop;
    if (patchFlagsTop && !this.isBottom) {
      const ctx = this.otherOffsreen.getContext('2d');
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      this.renderRule(ctx);
    }
    // 从有图片画布层切换到无图片画布
    const patchFlagsLast = this.store.patchFlagsLast;
    if (patchFlagsLast) {
      const ctx = this.offscreen.getContext('2d');
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    if (patchFlags) {
      const ctx = this.offscreen.getContext('2d');
      ctx.save();
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      ctx.translate(this.store.data.x, this.store.data.y);
      for (const pen of this.store.data.pens) {
        //pen.calculative.imageDrawed  只用于判断是否需要重绘整块画布，不用于判断改图片节点是否绘制过
        if (!pen.calculative.hasImage || this.store.animates.has(pen) || this.store.animates.has(getParent(pen, true))) {
          continue;
        }
        // if (pen.template) {
        if (pen.canvasLayer === CanvasLayer.CanvasTemplate) {
          continue;
        }
        pen.calculative.imageDrawed = true;
        ctx.save();
        ctxFlip(ctx, pen);
        if (pen.calculative.rotate) {
          ctxRotate(ctx, pen);
        }
        setGlobalAlpha(ctx, pen);
        drawImage(ctx, pen);
        ctx.restore();
      }
      ctx.restore();
    }
    if (patchFlagsAnimate) {
      const ctx = this.animateOffsScreen.getContext('2d');
      ctx.save();
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      ctx.translate(this.store.data.x, this.store.data.y);
      for (const pen of this.store.animates) {
        if (!pen.calculative.hasImage) {
          continue;
        }
        // if (pen.template) {
        if (pen.canvasLayer === CanvasLayer.CanvasTemplate) {
          continue;
        }
        pen.calculative.imageDrawed = true;
        ctx.save();
        ctxFlip(ctx, pen);
        if (pen.calculative.rotate) {
          ctxRotate(ctx, pen);
        }
        setGlobalAlpha(ctx, pen);
        drawImage(ctx, pen);
        ctx.restore();
      }
      //图片组合节点 动画
      for (const pen of this.store.data.pens) {
        if (!pen.calculative.hasImage || !pen.parentId) {
          continue;
        }
        // if (pen.template) {
        if (pen.canvasLayer === CanvasLayer.CanvasTemplate) {
          continue;
        }
        if (this.store.animates.has(getParent(pen, true))) {
          pen.calculative.imageDrawed = true;
          ctx.save();
          ctxFlip(ctx, pen);
          if (pen.calculative.rotate) {
            ctxRotate(ctx, pen);
          }
          setGlobalAlpha(ctx, pen);
          drawImage(ctx, pen);
          ctx.restore();
        }
      }
      ctx.restore();
    }
    if (!this.isBottom && !this.store.data.locked && this.fitFlag) {
      const width = (this.store.data.width || this.store.options.width) * this.store.data.scale;
      const height = (this.store.data.height || this.store.options.height) * this.store.data.scale;
      const x = this.store.data.origin.x + this.store.data.x || this.store.options.x || 0;
      const y = this.store.data.origin.y + this.store.data.y || this.store.options.y || 0;
      const ctx = this.fitOffscreen.getContext('2d');
      ctx.save();
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      ctx.fillStyle = '#ffffff66';
      ctx.strokeStyle = this.store.options.activeColor;
      this.store.data.fits?.forEach((item, index) => {
        ctx.fillRect(x + width * item.x, y + height * item.y, width * item.width, height * item.height);
        if (item.active) {
          ctx.strokeRect(x + width * item.x, y + height * item.y, width * item.width, height * item.height);
        }
      });
      ctx.restore();
    }
    if (patchFlags || patchFlagsAnimate || patchFlagsBackground && this.isBottom ||
    // this.isBottom ||
    patchFlagsTop && !this.isBottom) {
      const ctxCanvas = this.canvas.getContext('2d');
      ctxCanvas.clearRect(0, 0, this.canvas.width, this.canvas.height);
      if (this.isBottom) {
        //   ctxCanvas.drawImage(
        //     this.otherOffsreen,
        //     0,
        //     0,
        //     this.canvas.width,
        //     this.canvas.height
        //   );
        this.store.patchFlagsBackground = false;
      }
      ctxCanvas.drawImage(this.offscreen, 0, 0, this.canvas.width, this.canvas.height);
      ctxCanvas.drawImage(this.animateOffsScreen, 0, 0, this.canvas.width, this.canvas.height);
      if (!this.isBottom) {
        ctxCanvas.drawImage(this.otherOffsreen, 0, 0, this.canvas.width, this.canvas.height);
        this.store.patchFlagsTop = false;
        if (!this.store.data.locked && this.fitFlag) {
          ctxCanvas.drawImage(this.fitOffscreen, 0, 0, this.canvas.width, this.canvas.height);
        }
      }
    }
  }
  // renderGrid(
  //   ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D
  // ) {
  //   const { data, options } = this.store;
  //   const { grid, gridRotate, gridColor, gridSize, scale } = data;
  //   if (!(grid ?? options.grid)) {
  //     // grid false 时不绘制, undefined 时看 options.grid
  //     return;
  //   }
  //   ctx.save();
  //   const { width, height } = this.canvas;
  //   if (gridRotate) {
  //     ctx.translate(width / 2, height / 2);
  //     ctx.rotate((gridRotate * Math.PI) / 180);
  //     ctx.translate(-width / 2, -height / 2);
  //   }
  //   ctx.lineWidth = 1;
  //   ctx.strokeStyle = gridColor || options.gridColor;
  //   ctx.beginPath();
  //   const size = (gridSize || options.gridSize) * scale;
  //   const longSide = Math.max(width, height);
  //   const count = Math.ceil(longSide / size);
  //   for (let i = -size * count; i < longSide * 2; i += size) {
  //     ctx.moveTo(i, -longSide);
  //     ctx.lineTo(i, longSide * 2);
  //   }
  //   for (let i = -size * count; i < longSide * 2; i += size) {
  //     ctx.moveTo(-longSide, i);
  //     ctx.lineTo(longSide * 2, i);
  //   }
  //   ctx.stroke();
  //   ctx.restore();
  // }
  renderRule(ctx) {
    const {
      data,
      options
    } = this.store;
    const {
      rule,
      ruleColor,
      scale,
      origin
    } = data;
    if (!(rule ?? options.rule)) {
      // rule false 时不绘制, undefined 时看 options.rule
      return;
    }
    const span = scale * 10;
    ctx.save();
    const finalRuleColor = ruleColor || options.ruleColor;
    ctx.strokeStyle = rgba(finalRuleColor, 0.7);
    const x = origin.x + data.x;
    const y = origin.y + data.y;
    const {
      width,
      height
    } = this.canvas;
    let h = options.ruleOptions?.height || 20;
    if (options.ruleOptions?.background) {
      //背景颜色
      ctx.beginPath();
      ctx.fillStyle = options.ruleOptions?.background;
      ctx.rect(0, 0, width, h);
      ctx.fill();
      ctx.rect(0, 0, h, height);
      ctx.fill();
    }
    if (options.ruleOptions?.underline) {
      ctx.beginPath();
      ctx.fillStyle = rgba(finalRuleColor, 0.7);
      ctx.moveTo(0, h);
      ctx.lineTo(width, h);
      ctx.stroke();
      ctx.moveTo(h, 0);
      ctx.lineTo(h, height);
      ctx.stroke();
    }
    let b_y = h / 4;
    if (options.ruleOptions?.baseline === "bottom") {
      b_y = h * 3 / 4;
    }
    // horizontal rule
    ctx.beginPath();
    ctx.lineWidth = h / 2;
    ctx.lineDashOffset = -x % span;
    ctx.setLineDash([1, span - 1]);
    ctx.moveTo(0, b_y);
    ctx.lineTo(width, b_y);
    ctx.stroke();
    // vertical rule
    ctx.beginPath();
    ctx.lineDashOffset = -y % span;
    ctx.moveTo(b_y, 0);
    ctx.lineTo(b_y, height);
    ctx.stroke();
    // the big rule
    ctx.strokeStyle = finalRuleColor;
    ctx.beginPath();
    ctx.lineWidth = h;
    ctx.lineDashOffset = -x % (span * 10);
    ctx.setLineDash([1, span * 10 - 1]);
    ctx.moveTo(0, h / 2);
    ctx.lineTo(width, h / 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.lineDashOffset = -y % (span * 10);
    ctx.moveTo(h / 2, 0);
    ctx.lineTo(h / 2, height);
    ctx.stroke();
    ctx.beginPath();
    ctx.fillStyle = options.ruleOptions?.textColor || ctx.strokeStyle;
    let text = 0 - Math.floor(x / span / 10) * 100;
    let textTop = options.ruleOptions?.textTop || 16;
    let textLeft = options.ruleOptions?.textLeft || 4;
    if (x < 0) {
      text -= 100;
    }
    for (let i = x % (span * 10); i < width; i += 10 * span, text += 100) {
      if (span < 3 && text % 500) {
        continue;
      }
      ctx.fillText(text.toString(), i + textLeft, textTop);
    }
    text = 0 - Math.floor(y / span / 10) * 100;
    if (y < 0) {
      text -= 100;
    }
    for (let i = y % (span * 10); i < height; i += 10 * span, text += 100) {
      if (span < 3 && text % 500) {
        continue;
      }
      ctx.save();
      ctx.beginPath();
      ctx.translate(textTop, i - textLeft);
      ctx.rotate(270 * Math.PI / 180);
      ctx.fillText(text.toString(), 0, 0);
      ctx.restore();
    }
    ctx.restore();
  }
}
;// ./node_modules/@kyvi/cobweb/src/canvas/magnifierCanvas.js


class MagnifierCanvas {
  constructor(parentCanvas, parentElement, store) {
    _defineProperty(this, "parentCanvas", void 0);
    _defineProperty(this, "parentElement", void 0);
    _defineProperty(this, "store", void 0);
    _defineProperty(this, "canvas", document.createElement('canvas'));
    _defineProperty(this, "magnifierScreen", createOffscreen());
    _defineProperty(this, "offscreen", createOffscreen());
    _defineProperty(this, "magnifierSize", 300);
    _defineProperty(this, "magnifier", void 0);
    this.parentCanvas = parentCanvas;
    this.parentElement = parentElement;
    this.store = store;
    parentElement.appendChild(this.canvas);
    this.canvas.style.backgroundRepeat = 'no-repeat';
    this.canvas.style.backgroundSize = '100% 100%';
    this.canvas.style.position = 'absolute';
    this.canvas.style.top = '0';
    this.canvas.style.left = '0';
  }
  resize(w, h) {
    this.canvas.style.width = w + 'px';
    this.canvas.style.height = h + 'px';
    w = w * this.store.dpiRatio | 0;
    h = h * this.store.dpiRatio | 0;
    this.canvas.width = w;
    this.canvas.height = h;
    this.offscreen.width = w;
    this.offscreen.height = h;
    this.offscreen.getContext('2d').scale(this.store.dpiRatio, this.store.dpiRatio);
    this.offscreen.getContext('2d').textBaseline = 'middle';
    this.magnifierScreen.width = this.magnifierSize + 5;
    this.magnifierScreen.height = this.magnifierSize + 5;
  }
  /**
   * 绘制到 该画布的 离屏层
   */
  renderMagnifier() {
    if (!this.magnifier) {
      return;
    }
    const r = this.magnifierSize / 2;
    const size = this.magnifierSize + 5;
    const ctx = this.magnifierScreen.getContext('2d');
    ctx.clearRect(0, 0, size, size);
    ctx.lineWidth = 5;
    ctx.save();
    ctx.translate(2.5, 2.5);
    ctx.save();
    ctx.arc(r, r, r, 0, Math.PI * 2, false);
    ctx.clip();
    // ctx.fillStyle =
    //   this.store.data.background || this.store.options.background || '#f4f4f4';
    // ctx.fillRect(0, 0, size, size);
    ctx.translate(-r, -r);
    ctx.scale(2, 2);
    const pt = {
      x: (this.parentCanvas.mousePos.x + this.store.data.x) * this.store.dpiRatio,
      y: (this.parentCanvas.mousePos.y + this.store.data.y) * this.store.dpiRatio
    };
    const drawOffscreens = [this.parentCanvas.canvasTemplate.bgOffscreen, this.parentCanvas.canvasTemplate.offscreen, this.parentCanvas.canvasImageBottom.offscreen, this.parentCanvas.canvasImageBottom.animateOffsScreen, this.parentCanvas.offscreen, this.parentCanvas.canvasImage.offscreen, this.parentCanvas.canvasImage.animateOffsScreen];
    drawOffscreens.forEach(offscreen => {
      ctx.drawImage(offscreen, pt.x - r, pt.y - r, this.magnifierSize, this.magnifierSize, 0, 0, this.magnifierSize, this.magnifierSize);
    });
    ctx.restore();
    ctx.beginPath();
    const gradient = ctx.createRadialGradient(r, r, r - 5, r, r, r);
    gradient.addColorStop(0, 'rgba(0,0,0,0.2)');
    gradient.addColorStop(0.8, 'rgb(200,200,200)');
    gradient.addColorStop(0.9, 'rgb(200,200,200)');
    gradient.addColorStop(1.0, 'rgba(200,200,200,0.9)');
    ctx.strokeStyle = gradient;
    ctx.arc(r, r, r, 0, Math.PI * 2, false);
    ctx.stroke();
    ctx.restore();
    const offscreenCtx = this.offscreen.getContext('2d');
    offscreenCtx.drawImage(this.magnifierScreen, 0, 0, this.magnifierSize + 5, this.magnifierSize + 5, (pt.x - r - 2.5) / this.store.dpiRatio, (pt.y - r - 2.5) / this.store.dpiRatio, (this.magnifierSize + 5) / this.store.dpiRatio, (this.magnifierSize + 5) / this.store.dpiRatio);
  }
  render() {
    this.offscreen.getContext('2d').clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.renderMagnifier();
    const ctx = this.canvas.getContext('2d');
    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    ctx.drawImage(this.offscreen, 0, 0, this.canvas.width, this.canvas.height);
  }
}
;// ./node_modules/@kyvi/cobweb/src/utils/error.js
function lockedError(store) {
  if (store.data.locked) {
    throw new Error('canvas is locked');
  }
}
;// ./node_modules/@kyvi/cobweb/src/dialog/dialog.js

class Dialog {
  constructor(parentElement) {
    _defineProperty(this, "parentElement", void 0);
    _defineProperty(this, "box", void 0);
    _defineProperty(this, "iframe", void 0);
    _defineProperty(this, "dialog", void 0);
    _defineProperty(this, "close", void 0);
    _defineProperty(this, "title", void 0);
    _defineProperty(this, "body", void 0);
    _defineProperty(this, "x", void 0);
    _defineProperty(this, "y", void 0);
    _defineProperty(this, "url", void 0);
    this.parentElement = parentElement;
    this.box = document.createElement('div');
    this.dialog = document.createElement('div');
    let header = document.createElement('div');
    this.title = document.createElement('div');
    this.close = document.createElement('span');
    this.close.innerHTML = `
      <svg fill="none" viewBox="0 0 16 16" width="1em" height="1em">
      <path
        fill="currentColor"
        d="M8 8.92L11.08 12l.92-.92L8.92 8 12 4.92 11.08 4 8 7.08 4.92 4 4 4.92 7.08 8 4 11.08l.92.92L8 8.92z"
        fill-opacity="0.9"
      ></path>
    </svg>`;
    this.body = document.createElement('div');
    this.iframe = document.createElement('iframe');
    this.iframe.setAttribute('frameborder', '0');
    this.box.className = 'meta2d-dialog_mask';
    this.dialog.className = 'meta2d-dialog';
    this.body.className = 'meta2d-dialog_body';
    header.className = 'meta2d-dialog_header';
    this.title.className = 'meta2d-dialog-content';
    this.close.className = 'meta2d-dialog-close';
    header.appendChild(this.title);
    header.appendChild(this.close);
    this.body.appendChild(this.iframe);
    this.dialog.appendChild(header);
    this.dialog.appendChild(this.body);
    this.box.appendChild(this.dialog);
    parentElement.appendChild(this.box);
    this.dialog.onclick = e => {
      e.stopPropagation();
    };
    this.box.onclick = () => {
      this.hide();
    };
    this.close.onclick = () => {
      this.hide();
    };
    let sheet;
    for (let i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].title === 'le5le.com/dialog') {
        sheet = document.styleSheets[i];
      }
    }
    if (!sheet) {
      let style = document.createElement('style');
      style.type = 'text/css';
      style.title = 'le5le.com/dialog';
      document.head.appendChild(style);
      style = document.createElement('style');
      style.type = 'text/css';
      document.head.appendChild(style);
      sheet = style.sheet;
      sheet.insertRule(`.meta2d-dialog_mask {
        display: none;
        position: absolute;
        top: 0%;
        left: 0%;
        width: 100%;
        height: 100%;
        background-color: #0000006f;
        z-index: 9999;`);
      sheet.insertRule(`.meta2d-dialog_mask .meta2d-dialog {
            position: absolute;
            top: 15vh;
            left: 10%;
            width: 80%;
            height:420px;
            padding: 16px 20px;
            border-radius: 9px;
            background-color: #1e2430;
            z-index: 19999;
            overflow: auto;
        }`);
      sheet.insertRule(`.meta2d-dialog_header {
            display: flex;
        }`);
      sheet.insertRule(`.meta2d-dialog-content {
            width: calc(100% - 20px);
            font-weight: 600;
            font-size: 14px;
            color: #bdc7db;
            padding-bottom:8px;
        }`);
      sheet.insertRule(`.meta2d-dialog-close {
            width: 20px;
            height: 20px;
            line-height: 20px;
            text-align: center;
            color: #617b91;
            position: absolute;
            right:20px;
            top:18px;
        }`);
      sheet.insertRule(`.meta2d-dialog-close :hover{
            cursor: pointer;
        }`);
      sheet.insertRule(`.meta2d-dialog_body{
            // margin-top: 4px;
        } `);
      sheet.insertRule(`.meta2d-dialog_body iframe{
            width: 100%;
            height: 100%;
        }`);
    }
  }
  show(title, url, rect) {
    if (!url) {
      return;
    }
    if (url !== this.url) {
      this.iframe.setAttribute('src', url);
      this.url = url;
    }
    title && (this.title.innerText = title);
    if (!title) {
      this.dialog.style.padding = '0px';
      this.title.style.display = 'none';
      this.body.style.height = '100%';
      this.body.style.overflow = 'hidden';
    } else {
      this.dialog.style.padding = '16px 20px';
      this.title.style.display = 'block';
      this.body.style.height = 'calc(100% - 26px)';
    }
    if (rect) {
      this.dialog.style.top = rect.y ? rect.y + 'px' : '15vh';
      this.dialog.style.left = rect.x ? rect.x + 'px' : '10%';
      this.dialog.style.width = rect.width ? rect.width + 'px' : '80%';
      this.dialog.style.height = rect.height ? rect.height + 'px' : '420px';
      this.box.style.display = 'block';
    }
  }
  hide() {
    this.box.style.display = 'none';
  }
  destroy() {
    this.dialog.onclick = undefined;
    this.box.onclick = undefined;
    this.close.onclick = undefined;
  }
}
;// ./node_modules/@kyvi/cobweb/src/title/title.js

class Title {
  // 本次 tooltip 在哪个画笔上
  constructor(parentElement) {
    _defineProperty(this, "parentElement", void 0);
    _defineProperty(this, "box", void 0);
    _defineProperty(this, "currentAnchor", void 0);
    this.parentElement = parentElement;
    this.box = document.createElement('div');
    this.box.className = 'meta2d-title';
    parentElement.appendChild(this.box);
    // this.box.onmouseleave = () => {
    //   this.hide();
    // };
    let sheet;
    for (let i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].title === 'le5le.com/title') {
        sheet = document.styleSheets[i];
      }
    }
    if (!sheet) {
      let style = document.createElement('style');
      style.type = 'text/css';
      style.title = 'le5le.com/title';
      document.head.appendChild(style);
      style = document.createElement('style');
      style.type = 'text/css';
      document.head.appendChild(style);
      sheet = style.sheet;
      sheet.insertRule('.meta2d-title{position:absolute;padding:0;z-index:10;left: -9999px;top: -9999px;background:#fff;color:#000; cursor: crosshair;border: 1px solid black;}');
    }
  }
  /**
   * @returns 此次应该展示的 title
   */
  static getTitle(anchor) {
    // if (anchor.titleFnJs && !anchor.titleFn) {
    //   try {
    //     anchor.titleFn = new Function('anchor', anchor.titleFnJs) as (
    //       anchor: Point
    //     ) => string;
    //   } catch (error) {
    //     console.log('titleFnJs', error);
    //   }
    // }
    // return anchor.titleFn ? anchor.titleFn(anchor) : String(anchor.title);
  }
  /**
   * @returns 返回设置前的 rect
   */
  setText(anchor) {
    // this.box.title = anchor.title;
    this.box.innerText = anchor.title;
  }
  /**
   * 更新文字
   */
  updateText(anchor) {
    if (this.currentAnchor?.id !== anchor.id) {
      return;
    }
    if (Title.titleEmpty(anchor)) {
      return;
    }
    this.setText(anchor);
    this.changePositionByAnchor(anchor);
  }
  /**
   * 改变文字会 影响 box 的大小，需要重新设置位置
   * @param oldRect 原
   * @param newRect 新
   */
  changePositionByAnchor(anchor) {
    this.box.style.left = anchor.x + 10 + 'px';
    this.box.style.top = anchor.y + 10 + 'px';
  }
  static titleEmpty(anchor) {
    return !anchor.title; // && !anchor.titleFn && !anchor.titleFnJs;
  }
  show(anchor, pen) {
    if (Title.titleEmpty(anchor)) {
      return;
    }
    this.currentAnchor = anchor;
    this.setText(anchor);
    let pos = {
      x: pen.calculative.canvas.store.data.x + anchor.x,
      y: pen.calculative.canvas.store.data.y + anchor.y
    };
    this.changePositionByAnchor(pos);
  }
  hide() {
    this.box.style.left = '-9999px';
    this.box.innerText = '';
    this.currentAnchor = null;
  }
  destroy() {
    this.box.onmouseleave = null;
  }
}
;// ./node_modules/@kyvi/cobweb/src/canvas/canvasTemplate.js



class CanvasTemplate {
  constructor(parentElement, store) {
    _defineProperty(this, "parentElement", void 0);
    _defineProperty(this, "store", void 0);
    _defineProperty(this, "canvas", document.createElement('canvas'));
    _defineProperty(this, "offscreen", createOffscreen());
    _defineProperty(this, "bgOffscreen", createOffscreen());
    _defineProperty(this, "patchFlags", void 0);
    _defineProperty(this, "bgPatchFlags", void 0);
    this.parentElement = parentElement;
    this.store = store;
    parentElement.appendChild(this.canvas);
    this.canvas.style.backgroundRepeat = 'no-repeat';
    this.canvas.style.backgroundSize = '100% 100%';
    this.canvas.style.position = 'absolute';
    this.canvas.style.top = '0';
    this.canvas.style.left = '0';
  }
  resize(w, h) {
    this.canvas.style.width = w + 'px';
    this.canvas.style.height = h + 'px';
    w = w * this.store.dpiRatio | 0;
    h = h * this.store.dpiRatio | 0;
    this.canvas.width = w;
    this.canvas.height = h;
    this.bgOffscreen.width = w;
    this.bgOffscreen.height = h;
    this.offscreen.width = w;
    this.offscreen.height = h;
    this.bgOffscreen.getContext('2d').scale(this.store.dpiRatio, this.store.dpiRatio);
    this.bgOffscreen.getContext('2d').textBaseline = 'middle';
    this.offscreen.getContext('2d').scale(this.store.dpiRatio, this.store.dpiRatio);
    this.offscreen.getContext('2d').textBaseline = 'middle';
    this.init();
  }
  init() {
    this.bgOffscreen.getContext('2d').clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.offscreen.getContext('2d').clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.patchFlags = true;
    this.bgPatchFlags = true;
    // for (const pen of this.store.data.pens) {
    //   if (this.hasImage(pen)) {
    //     // 只影响本层的
    //     pen.calculative.imageDrawed = false;
    //   }
    // }
    // this.store.patchFlagsBackground = true;
    // this.store.patchFlagsTop = true;
  }
  hidden() {
    this.canvas.style.display = 'none';
  }
  show() {
    this.canvas.style.display = 'block';
  }
  clear() {
    this.bgOffscreen.getContext('2d').clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.offscreen.getContext('2d').clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.canvas.getContext('2d').clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.bgPatchFlags = true;
    this.patchFlags = true;
  }
  render() {
    if (this.bgPatchFlags) {
      const ctx = this.bgOffscreen.getContext('2d');
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      const width = this.store.data.width || this.store.options.width;
      const height = this.store.data.height || this.store.options.height;
      const x = this.store.data.x || this.store.options.x || 0;
      const y = this.store.data.y || this.store.options.y || 0;
      const background = this.store.data.background || this.store.options.background;
      if (background) {
        ctx.save();
        ctx.fillStyle = background;
        if (width && height) {
          ctx.globalAlpha = this.store.data.globalAlpha ?? this.store.options.globalAlpha;
          ctx.shadowOffsetX = this.store.options.shadowOffsetX;
          ctx.shadowOffsetY = this.store.options.shadowOffsetY;
          ctx.shadowBlur = this.store.options.shadowBlur;
          ctx.shadowColor = this.store.options.shadowColor;
          ctx.fillRect(this.store.data.origin.x + x, this.store.data.origin.y + y, width * this.store.data.scale, height * this.store.data.scale);
        } else {
          ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }
        ctx.restore();
      }
      if (width && height && this.store.bkImg) {
        ctx.save();
        ctx.drawImage(this.store.bkImg, this.store.data.origin.x + x, this.store.data.origin.y + y, width * this.store.data.scale, height * this.store.data.scale);
        ctx.restore();
      }
      this.renderGrid(ctx);
    }
    if (this.patchFlags) {
      const ctx = this.offscreen.getContext('2d');
      ctx.save();
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      ctx.translate(this.store.data.x, this.store.data.y);
      for (const pen of this.store.data.pens) {
        if (!isFinite(pen.x)) {
          continue;
        }
        if (
        // pen.template 
        pen.canvasLayer === CanvasLayer.CanvasTemplate && pen.calculative.inView) {
          //非图片
          renderPen(ctx, pen);
          //图片
          if (pen.image && pen.name !== 'gif' && pen.calculative.img) {
            ctx.save();
            ctxFlip(ctx, pen);
            if (pen.calculative.rotate) {
              ctxRotate(ctx, pen);
            }
            setGlobalAlpha(ctx, pen);
            drawImage(ctx, pen);
            ctx.restore();
          }
        }
      }
      ctx.restore();
    }
    if (this.patchFlags || this.bgPatchFlags) {
      const ctxCanvas = this.canvas.getContext('2d');
      ctxCanvas.clearRect(0, 0, this.canvas.width, this.canvas.height);
      ctxCanvas.drawImage(this.bgOffscreen, 0, 0, this.canvas.width, this.canvas.height);
      ctxCanvas.drawImage(this.offscreen, 0, 0, this.canvas.width, this.canvas.height);
      this.patchFlags = false;
      this.bgPatchFlags = false;
    }
  }
  renderGrid(ctx) {
    const {
      data,
      options
    } = this.store;
    const {
      grid,
      gridRotate,
      gridColor,
      gridSize,
      scale,
      origin
    } = data;
    if (!(grid ?? options.grid)) {
      // grid false 时不绘制, undefined 时看 options.grid
      return;
    }
    ctx.save();
    const width = (data.width || options.width) * scale;
    const height = (data.height || options.height) * scale;
    const startX = (data.x || options.x || 0) + origin.x;
    const startY = (data.y || options.y || 0) + origin.y;
    if (gridRotate) {
      ctx.translate(width / 2, height / 2);
      ctx.rotate(gridRotate * Math.PI / 180);
      ctx.translate(-width / 2, -height / 2);
    }
    ctx.lineWidth = 1;
    ctx.strokeStyle = gridColor || options.gridColor;
    ctx.beginPath();
    let size = (gridSize || options.gridSize) * scale;
    size = size < 0 ? 0 : size;
    if (!width || !height) {
      const ratio = this.store.dpiRatio;
      const cW = this.canvas.width / ratio;
      const cH = this.canvas.height / ratio;
      const m = startX / size;
      const n = startY / size;
      const offset = size * 10; //补偿值
      const newX = startX - Math.ceil(m) * size;
      const newY = startY - Math.ceil(n) * size;
      const endX = cW + newX + offset;
      const endY = cH + newY + offset;
      for (let i = newX; i <= endX; i += size) {
        ctx.moveTo(i, newY);
        ctx.lineTo(i, cH + newY + offset);
      }
      for (let i = newY; i <= endY; i += size) {
        ctx.moveTo(newX, i);
        ctx.lineTo(cW + newX + offset, i);
      }
    } else {
      const endX = width + startX;
      const endY = height + startY;
      for (let i = startX; i <= endX; i += size) {
        ctx.moveTo(i, startY);
        ctx.lineTo(i, height + startY);
      }
      for (let i = startY; i <= endY; i += size) {
        ctx.moveTo(startX, i);
        ctx.lineTo(width + startX, i);
      }
    }
    ctx.stroke();
    ctx.restore();
  }
}
;// ./node_modules/@kyvi/cobweb/src/canvas/canvas.js






























const movingSuffix = '-moving';
class Canvas {
  constructor(parent, parentElement, store) {
    _defineProperty(this, "parent", void 0);
    _defineProperty(this, "parentElement", void 0);
    _defineProperty(this, "store", void 0);
    _defineProperty(this, "canvas", document.createElement('canvas'));
    _defineProperty(this, "offscreen", createOffscreen());
    _defineProperty(this, "width", void 0);
    _defineProperty(this, "height", void 0);
    _defineProperty(this, "externalElements", document.createElement('div'));
    _defineProperty(this, "clientRect", void 0);
    _defineProperty(this, "canvasRect", void 0);
    _defineProperty(this, "activeRect", void 0);
    _defineProperty(this, "initActiveRect", void 0);
    _defineProperty(this, "dragRect", void 0);
    _defineProperty(this, "lastRotate", 0);
    _defineProperty(this, "sizeCPs", void 0);
    _defineProperty(this, "activeInitPos", void 0);
    _defineProperty(this, "hoverType", HoverType.None);
    _defineProperty(this, "resizeIndex", 0);
    _defineProperty(this, "mouseDown", void 0);
    _defineProperty(this, "hotkeyType", void 0);
    _defineProperty(this, "mouseRight", void 0);
    _defineProperty(this, "addCaches", void 0);
    _defineProperty(this, "touchCenter", void 0);
    _defineProperty(this, "initTouchDis", void 0);
    _defineProperty(this, "initScale", void 0);
    _defineProperty(this, "touchScaling", void 0);
    _defineProperty(this, "touchMoving", void 0);
    _defineProperty(this, "startTouches", void 0);
    _defineProperty(this, "lastOffsetX", 0);
    _defineProperty(this, "lastOffsetY", 0);
    _defineProperty(this, "drawingLineName", void 0);
    _defineProperty(this, "drawLineFns", [...defaultDrawLineFns]);
    _defineProperty(this, "drawingLine", void 0);
    _defineProperty(this, "pencil", void 0);
    _defineProperty(this, "pencilLine", void 0);
    _defineProperty(this, "movingPens", void 0);
    _defineProperty(this, "patchFlagsLines", new Set());
    _defineProperty(this, "dock", void 0);
    _defineProperty(this, "prevAnchor", void 0);
    _defineProperty(this, "nextAnchor", void 0);
    _defineProperty(this, "lastMouseTime", 0);
    _defineProperty(this, "hoverTimer", 0);
    _defineProperty(this, "fitTimer", 0);
    // 即将取消活动状态的画笔，用于Ctrl选中/取消选中画笔
    _defineProperty(this, "willInactivePen", void 0);
    _defineProperty(this, "patchFlags", false);
    _defineProperty(this, "lastRender", 0);
    _defineProperty(this, "touchStart", 0);
    _defineProperty(this, "touchStartTimer", void 0);
    _defineProperty(this, "timer", void 0);
    _defineProperty(this, "lastAnimateRender", 0);
    _defineProperty(this, "animateRendering", false);
    _defineProperty(this, "renderTimer", void 0);
    _defineProperty(this, "initPens", void 0);
    _defineProperty(this, "pointSize", 8);
    _defineProperty(this, "pasteOffset", true);
    _defineProperty(this, "opening", false);
    _defineProperty(this, "maxZindex", 5);
    _defineProperty(this, "canMoveLine", false);
    //moveConnectedLine=false
    _defineProperty(this, "randomIdObj", void 0);
    //记录拖拽前后id变化
    _defineProperty(this, "keyOptions", void 0);
    /**
     * @deprecated 改用 beforeAddPens
     */
    _defineProperty(this, "beforeAddPen", void 0);
    _defineProperty(this, "beforeAddPens", void 0);
    _defineProperty(this, "beforeAddAnchor", void 0);
    _defineProperty(this, "beforeRemovePens", void 0);
    _defineProperty(this, "beforeRemoveAnchor", void 0);
    _defineProperty(this, "customResizeDock", void 0);
    _defineProperty(this, "customMoveDock", void 0);
    _defineProperty(this, "inputParent", document.createElement('div'));
    // input = document.createElement('textarea');
    _defineProperty(this, "inputDiv", document.createElement('div'));
    _defineProperty(this, "inputRight", document.createElement('div'));
    _defineProperty(this, "dropdown", document.createElement('ul'));
    _defineProperty(this, "tooltip", void 0);
    _defineProperty(this, "title", void 0);
    _defineProperty(this, "mousePos", {
      x: 0,
      y: 0
    });
    _defineProperty(this, "scroll", void 0);
    _defineProperty(this, "movingAnchor", void 0);
    // 正在移动中的瞄点
    _defineProperty(this, "canvasTemplate", void 0);
    _defineProperty(this, "canvasImage", void 0);
    _defineProperty(this, "canvasImageBottom", void 0);
    _defineProperty(this, "magnifierCanvas", void 0);
    _defineProperty(this, "dialog", void 0);
    _defineProperty(this, "autoPolylineFlag", false);
    //标记open不自动计算
    _defineProperty(this, "stopPropagation", e => {
      e.stopPropagation();
    });
    _defineProperty(this, "curve", curve);
    _defineProperty(this, "polyline", polyline);
    _defineProperty(this, "mind", mind);
    _defineProperty(this, "line", lineSegment);
    _defineProperty(this, "onCopy", event => {
      if (this.store.options.disableClipboard) {
        return;
      }
      if (event.target !== this.externalElements && event.target !== document.body && event.target.offsetParent !== this.externalElements) {
        return;
      }
      this.copy();
    });
    _defineProperty(this, "onCut", event => {
      if (this.store.options.disableClipboard) {
        return;
      }
      if (event.target !== this.externalElements && event.target !== document.body && event.target.offsetParent !== this.externalElements) {
        return;
      }
      this.cut();
    });
    _defineProperty(this, "onPaste", event => {
      if (this.store.data.locked || this.store.options.disableClipboard) {
        return;
      }
      if (event.target !== this.externalElements && event.target !== document.body && event.target.offsetParent !== this.externalElements) {
        return;
      }
      // 是否粘贴图片
      let hasImages;
      if (navigator.clipboard && event.clipboardData) {
        const items = event.clipboardData.items;
        if (items) {
          for (let i = 0; i < items.length; i++) {
            if (items[i].type.indexOf('image') !== -1 && items[i].getAsFile()) {
              hasImages = true;
              break;
            }
          }
        }
      }
      if (hasImages) {
        const items = event.clipboardData.items;
        if (items) {
          for (let i = 0; i < items.length; i++) {
            if (items[i].type.indexOf('image') !== -1 && items[i].getAsFile()) {
              const {
                x,
                y
              } = this.mousePos;
              const blob = items[i].getAsFile();
              let name = items[i].type.slice(6) === 'gif' ? 'gif' : 'image';
              if (blob !== null) {
                let base64_str;
                const reader = new FileReader();
                reader.onload = e => {
                  base64_str = e.target.result;
                  const image = new Image();
                  image.src = base64_str;
                  image.onload = () => {
                    const {
                      width,
                      height
                    } = image;
                    const pen = {
                      name,
                      x: x - 50 / 2,
                      y: y - height / width * 50,
                      externElement: name === 'gif',
                      width: 100,
                      height: height / width * 100,
                      image: base64_str
                    };
                    this.addPens([pen]);
                    this.active([pen]);
                    this.copy([pen]);
                  };
                };
                reader.readAsDataURL(blob);
              }
            }
          }
        }
      } else {
        this.paste();
      }
    });
    _defineProperty(this, "onMessage", e => {
      if (typeof e.data !== 'string' || !e.data || e.data.startsWith('setImmediate')) {
        return;
      }
      let data = JSON.parse(e.data);
      if (typeof data === 'object') {
        this.parent.doMessageEvent(data.name);
      } else {
        this.parent.doMessageEvent(data);
      }
    });
    _defineProperty(this, "onwheel", e => {
      //输入模式不允许滚动
      if (this.inputDiv.contentEditable === 'true') {
        return;
      }
      //画线过程中不允许缩放
      if (this.drawingLine) {
        return;
      }
      if (this.pencil) {
        return;
      }
      if (this.store.hover) {
        if (this.store.hover.onWheel) {
          this.store.hover.onWheel(this.store.hover, e);
          return;
        }
      }
      if (this.store.data.disableScale || this.store.options.disableScale) {
        return;
      }
      e.preventDefault();
      e.stopPropagation();
      //移动画笔过程中不允许缩放
      if (this.mouseDown && (this.hoverType === HoverType.Node || this.hoverType === HoverType.Line)) return;
      if (this.store.data.locked === LockState.Disable) return;
      if (this.store.data.locked === LockState.DisableScale) return;
      if (this.store.data.locked === LockState.DisableMoveScale) return;
      // e.ctrlKey: false - 平移； true - 缩放。老windows触摸板不支持
      if (!e.ctrlKey && Math.abs(e.wheelDelta) < 100 && e.deltaY.toString().indexOf('.') === -1) {
        if (this.store.options.scroll && !e.metaKey && this.scroll) {
          this.scroll.wheel(e.deltaY < 0);
          return;
        }
        const scale = this.store.data.scale || 1;
        this.translate(-e.deltaX / scale, -e.deltaY / scale);
        return;
      }
      if (Math.abs(e.wheelDelta) > 100) {
        //鼠标滚轮滚动 scroll模式下是上下滚动而不是缩放 ctrl可以控制缩放
        if (this.store.options.scroll && this.scroll && !this.store.options.scrollButScale && !(e.ctrlKey || e.metaKey)) {
          this.scroll.wheel(e.deltaY < 0);
          return;
        }
      }
      //禁止触摸屏双指缩放操作
      if (this.store.options.disableTouchPadScale) {
        return;
      }
      let scaleOff = 0.015;
      if (this.store.options.scaleOff) {
        scaleOff = this.store.options.scaleOff;
        if (e.deltaY > 0) {
          scaleOff = -this.store.options.scaleOff;
        }
      } else {
        let isMac = /mac os /i.test(navigator.userAgent);
        if (isMac) {
          if (!e.ctrlKey) {
            scaleOff *= e.wheelDeltaY / 240;
          } else if (e.deltaY > 0) {
            scaleOff *= -1;
          }
        } else {
          let offset = 0.2;
          if (e.deltaY.toString().indexOf('.') !== -1) {
            offset = 0.01;
          }
          if (e.deltaY > 0) {
            scaleOff = -offset;
          } else {
            scaleOff = offset;
          }
        }
      }
      let {
        offsetX: x,
        offsetY: y
      } = e;
      // if (this.parent.map && e.target === this.parent.map?.box) {
      //   //放大镜缩放
      //   const width = this.store.data.width || this.store.options.width;
      //   const height = this.store.data.height || this.store.options.height;
      //   if (width && height) {
      //     //大屏
      //     x =
      //       (x / this.parent.map.boxWidth) * width * this.store.data.scale +
      //       this.store.data.origin.x;
      //     y =
      //       (y / this.parent.map.boxHeight) * height * this.store.data.scale +
      //       this.store.data.origin.y;
      //     const rect = this.canvas.getBoundingClientRect();
      //     x = x + rect.left;
      //     y = y + rect.top;
      //   } else {
      //     const rect = this.parent.getRect();
      //     x =
      //       (x / this.parent.map.boxWidth) * rect.width +
      //       rect.x +
      //       this.store.data.x;
      //     y =
      //       (y / this.parent.map.boxHeight) * rect.height +
      //       rect.y +
      //       this.store.data.y;
      //   }
      // }
      this.scale(this.store.data.scale + scaleOff, {
        x,
        y
      });
      this.externalElements.focus(); // 聚焦
    });
    _defineProperty(this, "onkeydown", e => {
      if (this.store.data.locked >= LockState.DisableEdit && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA' && !e.target.dataset.meta2dIgnore) {
        this.store.active.forEach(pen => {
          pen.onKeyDown?.(pen, e.key);
        });
      }
      if (this.store.data.locked >= LockState.DisableEdit || e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.dataset.meta2dIgnore) {
        return;
      }
      if (this.store.options.unavailableKeys.includes(e.key)) {
        return;
      }
      if (!this.keyOptions) {
        this.keyOptions = {};
      }
      this.keyOptions.altKey = e.altKey;
      this.keyOptions.shiftKey = e.shiftKey;
      this.keyOptions.ctrlKey = e.ctrlKey;
      this.keyOptions.metaKey = e.metaKey;
      let x = 10;
      let y = 10;
      let vRect = null;
      if (this.store.options.strictScope) {
        const width = this.store.data.width || this.store.options.width;
        const height = this.store.data.height || this.store.options.height;
        if (width && height) {
          vRect = {
            x: this.store.data.origin.x,
            y: this.store.data.origin.y,
            width: width * this.store.data.scale,
            height: height * this.store.data.scale
          };
        }
      }
      switch (e.key) {
        case ' ':
          this.hotkeyType = HotkeyType.Translate;
          break;
        case 'Control':
          if (this.drawingLine) {
            this.drawingLine.calculative.drawlineH = !this.drawingLine.calculative.drawlineH;
          } else if (!this.hotkeyType) {
            this.patchFlags = true;
            this.hotkeyType = HotkeyType.Select;
          }
          break;
        case 'Meta':
          break;
        case 'Shift':
          if (this.store.active.length === 1 && this.store.active[0].type && this.store.activeAnchor) {
            this.toggleAnchorHand();
          } else if (!this.hotkeyType) {
            this.patchFlags = true;
            if (!this.store.options.resizeMode) {
              this.hotkeyType = HotkeyType.Resize;
            }
          }
          break;
        case 'Alt':
          if (!e.ctrlKey && !e.shiftKey && this.drawingLine) {
            const to = getToAnchor(this.drawingLine);
            if (to !== this.drawingLine.calculative.activeAnchor) {
              deleteTempAnchor(this.drawingLine);
              this.drawingLine.calculative.worldAnchors.push(to);
            } else {
              this.drawingLine.calculative.worldAnchors.push({
                x: to.x,
                y: to.y
              });
            }
            const index = this.drawLineFns.indexOf(this.drawingLineName);
            this.drawingLineName = this.drawLineFns[(index + 1) % this.drawLineFns.length];
            this.drawingLine.lineName = this.drawingLineName;
            this.drawline();
            this.patchFlags = true;
          }
          e.preventDefault();
          break;
        case 'a':
        case 'A':
          if (e.ctrlKey || e.metaKey) {
            // TODO: ctrl + A 会选中 visible == false 的元素
            this.active(this.store.data.pens.filter(pen => !pen.parentId && pen.locked !== LockState.Disable));
            e.preventDefault();
          } else {
            this.toggleAnchorMode();
          }
          break;
        case 'Delete':
        case 'Backspace':
          if (this.canvasImage.fitFlag && this.canvasImage.activeFit) {
            this.deleteFit();
            break;
          }
          !this.store.data.locked && this.delete();
          break;
        case 'ArrowLeft':
          if (this.movingAnchor) {
            this.translateAnchor(-1, 0);
            break;
          }
          x = -1;
          if (e.shiftKey) {
            x = -5;
          }
          if (e.ctrlKey || e.metaKey) {
            x = -10;
          }
          x = x * this.store.data.scale;
          if (this.store.activeAnchor && this.store.active && this.store.active.length === 1 && this.store.active[0].type) {
            this.moveLineAnchor({
              x: this.store.activeAnchor.x + x,
              y: this.store.activeAnchor.y
            }, {});
            break;
          }
          if (vRect && this.activeRect.x + x < vRect.x) {
            x = vRect.x - this.activeRect.x;
          }
          this.translatePens(this.store.active, x, 0);
          break;
        case 'ArrowUp':
          if (this.movingAnchor) {
            this.translateAnchor(0, -1);
            break;
          }
          y = -1;
          if (e.shiftKey) {
            y = -5;
          }
          if (e.ctrlKey || e.metaKey) {
            y = -10;
          }
          y = y * this.store.data.scale;
          if (vRect && this.activeRect.y + y < vRect.y) {
            y = vRect.y - this.activeRect.y;
          }
          if (this.store.activeAnchor && this.store.active && this.store.active.length === 1 && this.store.active[0].type) {
            this.moveLineAnchor({
              x: this.store.activeAnchor.x,
              y: this.store.activeAnchor.y + y
            }, {});
            break;
          }
          this.translatePens(this.store.active, 0, y);
          break;
        case 'ArrowRight':
          if (this.movingAnchor) {
            this.translateAnchor(1, 0);
            break;
          }
          x = 1;
          if (e.shiftKey) {
            x = 5;
          }
          if (e.ctrlKey || e.metaKey) {
            x = 10;
          }
          x = x * this.store.data.scale;
          if (this.store.activeAnchor && this.store.active && this.store.active.length === 1 && this.store.active[0].type) {
            this.moveLineAnchor({
              x: this.store.activeAnchor.x + x,
              y: this.store.activeAnchor.y
            }, {});
            break;
          }
          if (vRect && this.activeRect.x + this.activeRect.width + x > vRect.x + vRect.width) {
            x = vRect.x + vRect.width - (this.activeRect.x + this.activeRect.width);
          }
          this.translatePens(this.store.active, x, 0);
          break;
        case 'ArrowDown':
          if (this.movingAnchor) {
            this.translateAnchor(0, 1);
            break;
          }
          y = 1;
          if (e.shiftKey) {
            y = 5;
          }
          if (e.ctrlKey || e.metaKey) {
            y = 10;
          }
          y = y * this.store.data.scale;
          if (vRect && this.activeRect.y + this.activeRect.height + y > vRect.y + vRect.height) {
            y = vRect.y + vRect.height - (this.activeRect.y + this.activeRect.height);
          }
          if (this.store.activeAnchor && this.store.active && this.store.active.length === 1 && this.store.active[0].type) {
            this.moveLineAnchor({
              x: this.store.activeAnchor.x,
              y: this.store.activeAnchor.y + y
            }, {});
            break;
          }
          this.translatePens(this.store.active, 0, y);
          break;
        case 'd':
        case 'D':
          if (!this.store.active[0]?.locked) {
            this.removeAnchorHand();
          }
          break;
        case 'h':
        case 'H':
          if (!this.store.active[0]?.locked) {
            this.addAnchorHand();
          }
          break;
        case 'm':
        case 'M':
          this.toggleMagnifier();
          break;
        case 'g':
        case 'G':
          // 进入移动瞄点状态
          if (this.hoverType === HoverType.NodeAnchor) {
            this.movingAnchor = this.store.hoverAnchor;
            this.externalElements.style.cursor = 'move';
          }
          break;
        case 's':
        case 'S':
          // 分割线
          if (!this.store.data.locked && this.hoverType === HoverType.LineAnchor && this.store.hover === this.store.active[0]) {
            this.splitLine(this.store.active[0], this.store.hoverAnchor);
          }
          // 保存
          (e.ctrlKey || e.metaKey) && this.store.emitter.emit('save', {
            event: e
          });
          break;
        case 'c':
        case 'C':
          if ((e.ctrlKey || e.metaKey) && this.store.options.disableClipboard) {
            this.copy();
          }
          break;
        case 'x':
        case 'X':
          if ((e.ctrlKey || e.metaKey) && this.store.options.disableClipboard) {
            this.cut();
          }
          break;
        case '√': //MAC OPTION + V
        case 'v':
        case 'V':
          if (!e.ctrlKey && !e.metaKey) {
            if (this.pencil) {
              this.stopPencil();
            }
            if (this.drawingLineName) {
              this.finishDrawline();
              this.drawingLineName = '';
            } else {
              this.drawingLineName = this.store.options.drawingLineName;
            }
          }
          if (!this.store.data.locked && (e.ctrlKey || e.metaKey) && (this.store.options.disableClipboard || !this.store.options.disableClipboard && e.altKey) //alt按下，paste事件无效
          ) {
            this.paste();
          }
          break;
        case 'b':
        case 'B':
          if (this.drawingLineName) {
            this.finishDrawline();
            this.drawingLineName = '';
          }
          if (this.pencil) {
            this.stopPencil();
          } else {
            this.drawingPencil();
          }
          break;
        case 'y':
        case 'Y':
          if (e.ctrlKey || e.metaKey) {
            this.redo();
          }
          break;
        case 'z':
        case 'Z':
          if (e.ctrlKey || e.metaKey) {
            this.undo();
          } else if (e.shiftKey) {
            this.redo();
          }
          break;
        case 'Enter':
          if (this.drawingLineName) {
            this.finishDrawline(true);
            if (this.store.active[0].anchors[0].connectTo) {
              this.drawingLineName = '';
            } else {
              this.drawingLineName = this.store.options.drawingLineName;
            }
          }
          if (this.store.active) {
            this.store.active.forEach(pen => {
              if (pen.type) {
                pen.close = !pen.close;
                if (pen.close) {
                  getLinePoints(pen);
                }
                this.store.path2dMap.set(pen, globalStore.path2dDraws.line(pen));
                getLineLength(pen);
              } else {
                //图元进入编辑模式
                pen.calculative.focus = true;
              }
            });
            this.render();
          }
          break;
        case 'Escape':
          if (this.drawingLineName) {
            this.finishDrawline();
          }
          this.drawingLineName = undefined;
          this.stopPencil();
          if (this.store.active) {
            this.store.active.forEach(pen => {
              if (pen.type) {} else {
                //图元退出编辑模式
                pen.calculative.focus = false;
              }
            });
          }
          if (this.movingPens) {
            this.getAllByPens(this.movingPens).forEach(pen => {
              this.store.pens[pen.id] = undefined;
            });
            this.movingPens = undefined;
            this.mouseDown = undefined;
            this.clearDock();
            this.store.active?.forEach(pen => {
              this.updateLines(pen);
            });
            this.calcActiveRect();
            this.patchFlags = true;
          }
          this.hotkeyType = HotkeyType.None;
          this.movingAnchor = undefined;
          if (this.magnifierCanvas.magnifier) {
            this.magnifierCanvas.magnifier = false;
            this.patchFlags = true;
          }
          break;
        case 'E':
        case 'e':
          this.store.options.disableAnchor = !this.store.options.disableAnchor;
          this.store.emitter.emit('disableAnchor', this.store.options.disableAnchor);
          break;
        case '=':
          if (e.ctrlKey || e.metaKey) {
            this.scale(this.store.data.scale + 0.1);
            e.preventDefault();
            e.stopPropagation();
          }
          break;
        case '-':
          if (e.ctrlKey || e.metaKey) {
            this.scale(this.store.data.scale - 0.1);
            e.preventDefault();
            e.stopPropagation();
          }
          break;
        case 'l':
        case 'L':
          this.canMoveLine = true;
          break;
        case '[':
          //下一层
          this.parent.down();
          break;
        case ']':
          //上一层
          this.parent.up();
          break;
        case '{':
          // 置底
          this.parent.bottom();
          break;
        case '}':
          //置顶
          this.parent.top();
          break;
        case 'F':
        case 'f':
          this.setFollowers();
          break;
      }
      this.render(false);
    });
    _defineProperty(this, "onkeyup", e => {
      switch (e.key) {
        case 'l':
        case 'L':
          this.canMoveLine = false;
          break;
        // case 'Alt':
        //   if (this.drawingLine) {
        //     this.store.options.autoAnchor = !this.store.options.autoAnchor;
        //   }
        //   break;
      }
      if (this.hotkeyType) {
        this.render();
      }
      if (this.hotkeyType < HotkeyType.AddAnchor) {
        this.hotkeyType = HotkeyType.None;
      }
    });
    _defineProperty(this, "ondrop", async event => {
      if (this.store.data.locked) {
        console.warn('canvas is locked, can not drop');
        return;
      }
      // Fix bug: 在 firefox 上拖拽图片会打开新页
      event.preventDefault();
      event.stopPropagation();
      const json = event.dataTransfer.getData('Meta2d') || event.dataTransfer.getData('Text');
      let obj = null;
      try {
        if (json) {
          obj = JSON.parse(json);
        }
      } catch (e) {}
      if (!obj) {
        const {
          files
        } = event.dataTransfer;
        if (files.length && files[0].type.match('image.*') && !(this.addCaches && this.addCaches.length)) {
          // 必须是图片类型
          const isGif = files[0].type === 'image/gif';
          obj = await this.fileToPen(files[0], isGif);
        } else if (this.addCaches && this.addCaches.length) {
          obj = this.addCaches;
          this.addCaches = [];
        } else {
          this.store.emitter.emit('drop', undefined);
          return;
        }
      }
      obj = Array.isArray(obj) ? obj : [obj];
      if (obj[0] && obj[0].draggable !== false) {
        const pt = {
          x: event.offsetX,
          y: event.offsetY
        };
        this.calibrateMouse(pt);
        this.dropPens(obj, pt);
        this.addCaches = [];
        // 拖拽新增图元判断是否是在容器上
        this.getContainerHover(pt);
        this.mousePos.x = pt.x;
        this.mousePos.y = pt.y;
        this.store.emitter.emit('mouseup', {
          x: pt.x,
          y: pt.y,
          pen: this.store.hoverContainer
        });
      }
      this.store.emitter.emit('drop', obj || json);
    });
    _defineProperty(this, "ontouchstart", e => {
      if (this.store.data.locked === LockState.Disable) {
        return;
      }
      if (this.touchStartTimer) {
        clearTimeout(this.touchStartTimer);
      }
      this.touchStartTimer = setTimeout(() => {
        this.touchStart = performance.now();
        const x = e.touches[0].pageX - this.clientRect.x;
        const y = e.touches[0].pageY - this.clientRect.y;
        const pos = {
          x,
          y
        };
        this.calibrateMouse(pos);
        this.getHover(pos);
        this.onMouseDown({
          x,
          y,
          clientX: e.touches[0].clientX,
          clientY: e.touches[0].clientY,
          pageX: e.touches[0].pageX,
          pageY: e.touches[0].pageY,
          ctrlKey: e.ctrlKey || e.metaKey,
          shiftKey: e.shiftKey,
          altKey: e.altKey,
          buttons: 1
        });
        if (e.touches.length === 2) {
          this.initTouchDis = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
          this.initScale = this.store.data.scale;
          this.startTouches = e.touches;
          this.touchCenter = {
            x: e.touches[0].pageX + (e.touches[1].pageX - e.touches[0].pageX) / 2 - this.clientRect.x,
            y: e.touches[0].pageY + (e.touches[1].pageY - e.touches[0].pageY) / 2 - this.clientRect.y
          };
          return;
        } else if (e.touches.length === 3) {
          this.store.emitter.emit('contextmenu', {
            e: {
              x,
              y,
              clientX: e.touches[0].clientX,
              clientY: e.touches[0].clientY,
              pageX: e.touches[0].pageX,
              pageY: e.touches[0].pageY
            },
            clientRect: this.clientRect
          });
          e.preventDefault();
          e.stopPropagation();
        }
        this.touchStartTimer = undefined;
      }, 50);
    });
    _defineProperty(this, "ontouchmove", event => {
      if (this.store.data.locked === LockState.Disable) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      const now = performance.now();
      if (now - this.touchStart < 50) {
        return;
      }
      this.touchStart = now;
      const touches = event.touches;
      const len = touches.length;
      const x = event.touches[0].pageX - this.clientRect.x;
      const y = event.touches[0].pageY - this.clientRect.y;
      if (len === 1) {
        this.onMouseMove({
          x,
          y,
          clientX: event.changedTouches[0].clientX,
          clientY: event.changedTouches[0].clientY,
          pageX: event.changedTouches[0].pageX,
          pageY: event.changedTouches[0].pageY,
          ctrlKey: event.ctrlKey || event.metaKey,
          shiftKey: event.shiftKey,
          altKey: event.altKey,
          buttons: 1
        });
      } else if (len === 2 && this.startTouches?.length === 2) {
        if (!this.touchMoving && !this.touchScaling) {
          const x1 = this.startTouches[0].pageX - touches[0].pageX;
          const x2 = this.startTouches[1].pageX - touches[1].pageX;
          const y1 = this.startTouches[0].pageY - touches[0].pageY;
          const y2 = this.startTouches[1].pageY - touches[1].pageY;
          if ((x1 >= 0 && x2 < 0 || x1 <= 0 && x2 > 0) && (y1 >= 0 && y2 < 0 || y1 <= 0 && y2 > 0)) {
            this.touchScaling = true;
          } else {
            this.touchMoving = true;
          }
        }
        if (this.touchScaling) {
          if (this.store.data.disableScale || this.store.options.disableScale) {
            return;
          }
          const scale = Math.hypot(touches[0].pageX - touches[1].pageX, touches[0].pageY - touches[1].pageY) / this.initTouchDis;
          this.scale(this.initScale * scale, deepClone(this.touchCenter));
        }
        if (this.touchMoving) {
          if (this.store.data.locked >= LockState.DisableMove && this.store.data.locked !== LockState.DisableScale || this.store.data.disableScale || this.store.options.disableScale) {
            return;
          }
          if (this.lastOffsetX) {
            const {
              scale
            } = this.store.data;
            this.translate((x - this.lastOffsetX) / scale, (y - this.lastOffsetY) / scale);
          }
          this.lastOffsetX = x;
          this.lastOffsetY = y;
        }
      }
    });
    _defineProperty(this, "ontouchend", event => {
      if (this.store.data.locked === LockState.Disable) {
        return;
      }
      this.touchCenter = undefined;
      this.touchScaling = undefined;
      this.touchMoving = undefined;
      this.startTouches = undefined;
      this.lastOffsetX = 0;
      this.lastOffsetY = 0;
      const x = event.changedTouches[0].pageX - this.clientRect.x;
      const y = event.changedTouches[0].pageY - this.clientRect.y;
      this.onMouseUp({
        x,
        y,
        clientX: event.changedTouches[0].clientX,
        clientY: event.changedTouches[0].clientY,
        pageX: event.changedTouches[0].pageX,
        pageY: event.changedTouches[0].pageY,
        ctrlKey: event.ctrlKey || event.metaKey,
        shiftKey: event.shiftKey,
        altKey: event.altKey,
        buttons: 1
      });
      setTimeout(() => {
        this.render();
      }, 20);
    });
    _defineProperty(this, "onGesturestart", e => {
      e.preventDefault();
    });
    _defineProperty(this, "onMouseDown", e => {
      if (e.buttons === 2 && !this.drawingLine) {
        this.mouseRight = MouseRight.Down;
      }
      this.hideInput();
      if (this.store.data.locked === LockState.Disable || e.buttons !== 1 && e.buttons !== 2) {
        this.hoverType = HoverType.None;
        return;
      }
      if (this.magnifierCanvas.magnifier) {
        return;
      }
      this.calibrateMouse(e);
      this.mousePos.x = e.x;
      this.mousePos.y = e.y;
      this.mouseDown = e;
      this.lastMouseTime = performance.now();
      if (this.canvasImage.fitFlag) {
        if (!this.canvasImage.currentFit) {
          //选中布局容器
          this.calcuActiveFit();
        }
        return;
      }
      // Set anchor of pen.
      if (this.hotkeyType === HotkeyType.AddAnchor) {
        this.setAnchor(this.store.pointAt);
        return;
      }
      //shift 快捷添加锚点并连线
      if (!this.store.options.autoAnchor && !this.drawingLine) {
        if (e.shiftKey && e.ctrlKey && e.altKey) {
          this.setAnchor(this.store.pointAt);
          this.drawingLineName = this.store.options.drawingLineName;
          const anchor = this.store.activeAnchor;
          if (!anchor) {
            return;
          }
          const pt = {
            id: s8(),
            x: anchor.x,
            y: anchor.y
          };
          this.drawingLine = this.createDrawingLine(pt);
          let _pt = getFromAnchor(this.drawingLine);
          this.drawingLine.calculative.activeAnchor = _pt;
          connectLine(this.store.hover, anchor, this.drawingLine, pt);
          this.drawline();
          return;
        }
      }
      // Translate
      if (this.hotkeyType === HotkeyType.Translate || this.mouseRight === MouseRight.Down && !this.store.options.mouseRightActive) {
        return;
      }
      // 正在连线
      if (this.drawingLine) {
        // 单击在锚点上，完成绘画
        if (this.store.hoverAnchor) {
          const to = getToAnchor(this.drawingLine);
          if (this.store.hoverAnchor.type === PointType.Line) {
            getDistance(to, this.store.hoverAnchor, this.store);
          } else {
            to.x = this.store.hoverAnchor.x;
            to.y = this.store.hoverAnchor.y;
          }
          connectLine(this.store.hover, this.store.hoverAnchor, this.drawingLine, to);
          this.drawline();
          this.finishDrawline(true);
          return;
        }
        //shift快捷添加锚点并完成连线
        if (!this.store.options.autoAnchor) {
          if (e.shiftKey && e.altKey && e.ctrlKey) {
            this.setAnchor(this.store.pointAt);
            const to = getToAnchor(this.drawingLine);
            const anchor = this.store.activeAnchor;
            if (!anchor) {
              return;
            }
            to.x = anchor.x;
            to.y = anchor.y;
            connectLine(this.store.hover, anchor, this.drawingLine, to);
            this.drawline();
            this.finishDrawline(true);
            return;
          }
        }
        // 右键，完成绘画
        if (e.buttons === 2 || this.drawingLineName === 'mind' && this.drawingLine?.calculative.worldAnchors.length > 1 || this.store.options.drawingLineLength && this.drawingLine?.calculative.worldAnchors.length > this.store.options.drawingLineLength) {
          this.finishDrawline(true);
          if (this.store.active[0]?.anchors[0].connectTo || this.store.active.length == 0) {
            this.drawingLineName = '';
          } else {
            this.drawingLineName = this.store.options.drawingLineName;
          }
          return;
        }
        // 自动锚点（单击节点），完成绘画
        if (this.store.options.autoAnchor && this.hoverType === HoverType.Node) {
          const to = getToAnchor(this.drawingLine);
          const anchor = nearestAnchor(this.store.hover, e);
          to.x = anchor.x;
          to.y = anchor.y;
          this.drawingLine.autoTo = true;
          connectLine(this.store.hover, anchor, this.drawingLine, to);
          this.drawline();
          this.finishDrawline(true);
          return;
        }
        // 添加点
        const to = getToAnchor(this.drawingLine);
        if (to.isTemp) {
          this.drawingLine.calculative.activeAnchor = this.drawingLine.calculative.worldAnchors[this.drawingLine.calculative.worldAnchors.length - 2];
          to.isTemp = undefined;
        } else {
          this.drawingLine.calculative.activeAnchor = to;
          this.drawingLine.calculative.worldAnchors.push({
            x: to.x,
            y: to.y,
            penId: to.penId
          });
        }
        this.drawingLine.calculative.drawlineH = undefined;
        this.drawingLineName !== 'polyline' && this.drawline();
      }
      // 单击在节点上，通过自动锚点连线
      if (this.drawingLineName) {
        if (this.hoverType === HoverType.Node) {
          if (this.store.options.autoAnchor) {
            this.inactive(true);
            const anchor = nearestAnchor(this.store.hover, e);
            this.store.hoverAnchor = anchor;
            const pt = {
              id: s8(),
              x: anchor.x,
              y: anchor.y
            };
            this.drawingLine = this.createDrawingLine(pt);
            this.drawingLine.autoFrom = true;
            connectLine(this.store.hover, anchor, this.drawingLine, pt);
          } else {
            this.inactive();
            this.hoverType = HoverType.None;
          }
        } else if (this.hoverType === HoverType.NodeAnchor) {
          //钢笔模式下 可以连节点锚点
          this.drawingLineName = this.store.options.drawingLineName;
          const pt = {
            id: s8(),
            x: this.store.hoverAnchor.x,
            y: this.store.hoverAnchor.y
          };
          this.drawingLine = this.createDrawingLine(pt);
          this.drawingLine.calculative.activeAnchor = pt;
          connectLine(this.store.hover, this.store.hoverAnchor, this.drawingLine, pt);
          // this.drawline();
        } else if (!this.drawingLine && this.drawingLineName !== 'curve') {
          this.inactive(true);
          const pt = {
            id: s8(),
            x: e.x,
            y: e.y
          };
          this.drawingLine = this.createDrawingLine(pt);
          this.drawingLine.calculative.activeAnchor = pt;
        }
      } else if (this.pencil) {
        this.inactive(true);
        const penId = s8();
        const pt = {
          x: e.x,
          y: e.y,
          id: s8(),
          penId
        };
        this.pencilLine = this.getInitPencilLine(pt);
      } else {
        switch (this.hoverType) {
          case HoverType.None:
            (this.store.data.rule || this.store.options.rule) && !this.store.options.disableRuleLine && this.addRuleLine(e);
            if (this.store.options.resizeMode) {
              this.hotkeyType = HotkeyType.None;
            }
            this.inactive();
            break;
          case HoverType.Node:
          case HoverType.Line:
            if (this.store.hover) {
              const parentPen = getParent(this.store.hover, true);
              let pen = parentPen || this.store.hover;
              if (parentPen && (parentPen.container || this.store.options.containerShapes?.includes(parentPen.name))) {
                pen = this.store.hover;
              }
              // const pen = getParent(this.store.hover, true) || this.store.hover;
              if (e.ctrlKey && !e.shiftKey) {
                if (pen.calculative.active) {
                  this.willInactivePen = pen;
                } else {
                  if (this.store.active.length > 0) {
                    pen.calculative.active = true;
                    setChildrenActive(pen); // 子节点也设置为active
                    this.store.active.push(pen);
                    this.store.emitter.emit('active', this.store.active);
                  }
                }
                this.patchFlags = true;
              } else if (e.ctrlKey && e.shiftKey && this.store.hover.parentId) {
                this.active([this.store.hover]);
              } else {
                if (!(this.activeRect && pointInRect({
                  x: e.x,
                  y: e.y
                }, this.activeRect)) || this.store.active.length == 1) {
                  if (!pen.calculative.active) {
                    this.active([pen]);
                    if (this.store.options.resizeMode) {
                      this.hotkeyType = HotkeyType.Resize;
                    }
                  }
                }
              }
              this.calcActiveRect();
            }
            break;
          case HoverType.LineAnchor:
            this.store.activeAnchor = this.store.hoverAnchor;
            this.store.hover.calculative.activeAnchor = this.store.hoverAnchor;
            this.active([this.store.hover]);
            break;
          case HoverType.LineAnchorPrev:
          case HoverType.LineAnchorNext:
            if (this.store.activeAnchor) {
              // 备份，方便移动锚点方向
              this.prevAnchor = {
                ...this.store.activeAnchor.prev
              };
              this.nextAnchor = {
                ...this.store.activeAnchor.next
              };
            }
            break;
          case HoverType.Resize:
            this.activeInitPos = [];
            this.store.active.forEach(pen => {
              this.activeInitPos.push({
                x: (pen.calculative.worldRect.x - this.activeRect.x) / this.activeRect.width,
                y: (pen.calculative.worldRect.y - this.activeRect.y) / this.activeRect.height
              });
            });
            break;
        }
        if (this.store.hover) {
          this.store.hover.calculative.mouseDown = true;
        }
        this.store.emitter.emit('mousedown', {
          x: e.x,
          y: e.y,
          pen: this.store.hover
        });
      }
      this.render();
    });
    _defineProperty(this, "onMouseMove", e => {
      if (this.store.data.locked === LockState.Disable) {
        this.hoverType = HoverType.None;
        return;
      }
      // 防止异常情况导致mouseup事件没有触发
      if (this.mouseDown && !this.mouseDown.restore && e.buttons !== 1 && e.buttons !== 2) {
        this.onMouseUp(e);
        return;
      }
      // 避免鼠标点击和移动一起触发，误抖动
      if (this.lastMouseTime) {
        const now = performance.now();
        if (now - this.lastMouseTime < 50) {
          this.lastMouseTime = 0;
          return;
        }
        this.lastMouseTime = 0;
      }
      this.calibrateMouse(e);
      this.mousePos.x = e.x;
      this.mousePos.y = e.y;
      if (this.magnifierCanvas.magnifier) {
        this.render();
        return;
      }
      if (this.canvasImage.fitFlag) {
        if (this.canvasImage.activeFit) {
          const now = performance.now();
          if (now - this.fitTimer > 100) {
            if (this.mouseDown) {
              // 容器大小变化
              this.updateFit(e);
            } else {
              this.inFitBorder(this.mousePos);
            }
            this.fitTimer = now;
          }
          return;
        }
      }
      if (this.mouseDown && !this.store.options.disableTranslate && !this.store.data.disableTranslate) {
        // 画布平移前提
        if (this.mouseRight === MouseRight.Down) {
          this.mouseRight = MouseRight.Translate;
        }
        // Translate
        if (this.store.data.locked === LockState.DisableEdit || this.store.data.locked === LockState.DisableScale || this.hotkeyType === HotkeyType.Translate || this.mouseRight === MouseRight.Translate) {
          const {
            scale
          } = this.store.data;
          // if (Math.abs(e.x - this.mouseDown.x) > 30) {
          //   return;
          // }
          let x = (e.x - this.mouseDown.x) / scale;
          let y = (e.y - this.mouseDown.y) / scale;
          e.shiftKey && !e.ctrlKey && (y = 0);
          e.ctrlKey && (x = 0);
          this.translate(x, y);
          return;
        }
        if (this.store.data.locked) {
          return;
        }
        if (!this.drawingLine && !this.pencil) {
          if (!this.drawingLineName && !this.movingAnchor) {
            // 在锚点上开始连线
            if (this.hoverType === HoverType.NodeAnchor) {
              if (!this.store.hoverAnchor) {
                return;
              }
              this.drawingLineName = this.store.options.drawingLineName;
              const pt = {
                id: s8(),
                x: this.store.hoverAnchor.x,
                y: this.store.hoverAnchor.y
              };
              this.drawingLine = this.createDrawingLine(pt);
              this.drawingLine.calculative.activeAnchor = pt;
              connectLine(this.store.hover, this.store.hoverAnchor, this.drawingLine, pt);
              this.drawline();
              return;
            }
          }
          // 钢笔画线
          else if (this.drawingLineName && this.hoverType === HoverType.None) {
            const pt = {
              id: s8(),
              x: e.x,
              y: e.y
            };
            this.drawingLine = this.createDrawingLine(pt);
            this.drawingLine.calculative.activeAnchor = pt;
            this.drawline();
            return;
          }
          // 框选
          if (e.buttons === 1 && (e.ctrlKey || !this.hoverType && !this.hotkeyType) && !(e.ctrlKey && (this.store.activeAnchor || this.store.active?.length))) {
            this.dragRect = {
              x: Math.min(this.mouseDown.x, e.x),
              y: Math.min(this.mouseDown.y, e.y),
              ex: Math.max(this.mouseDown.x, e.x),
              ey: Math.max(this.mouseDown.y, e.y),
              width: Math.abs(e.x - this.mouseDown.x),
              height: Math.abs(e.y - this.mouseDown.y)
            };
            this.render();
            return;
          }
          // 移动节点锚点
          if (this.movingAnchor) {
            const x = e.x - this.movingAnchor.x;
            const y = e.y - this.movingAnchor.y;
            this.translateAnchor(x, y);
            this.render();
            return;
          } else if (!this.store.active[0]?.locked) {
            const pt = {
              x: e.x,
              y: e.y
            };
            // Move line anchor
            if (this.hoverType === HoverType.LineAnchor) {
              if ((this.dockInAnchor(e) || this.store.active[0]?.lineName === 'line') && !this.store.options.disableDock && !this.store.options.disableLineDock) {
                this.clearDock();
                this.dock = calcAnchorDock(this.store, pt, this.store.activeAnchor);
                this.dock?.xDock && (pt.x += this.dock.xDock.step);
                this.dock?.yDock && (pt.y += this.dock.yDock.step);
              }
              this.moveLineAnchor(pt, e);
              return;
            }
            // Move line anchor prev
            if (this.hoverType === HoverType.LineAnchorPrev) {
              this.moveLineAnchorPrev(e);
              return;
            }
            // Move line anchor next
            if (this.hoverType === HoverType.LineAnchorNext) {
              this.moveLineAnchorNext(e);
              return;
            }
          }
          // Rotate
          if (this.hoverType === HoverType.Rotate) {
            this.rotatePens({
              x: e.x,
              y: e.y
            });
            return;
          }
          // Resize
          if (this.hoverType === HoverType.Resize) {
            this.resizePens(e);
            return;
          }
          // Move
          if (this.hoverType === HoverType.Node || this.hoverType === HoverType.Line) {
            const x = e.x - this.mouseDown.x;
            const y = e.y - this.mouseDown.y;
            const shake = 20;
            if (e.ctrlKey && !e.shiftKey && (Math.abs(x) >= shake || Math.abs(y) >= shake)) {
              this.willInactivePen = undefined;
            }
            if (this.store.active.length === 1) {
              const activePen = this.store.active[0];
              if (activePen.locked === undefined || activePen.locked < LockState.DisableMove) {
                activePen?.onMouseMove?.(activePen, this.mousePos);
              }
              if (activePen.calculative.focus) {
                //执行图元的操作
                return;
              }
            }
            this.movePens(e);
            //图元是否进入容器图元
            this.getContainerHover(e);
            return;
          }
        } else if (this.pencil) {
          const {
            x,
            y
          } = e;
          const pt = {
            x,
            y
          };
          pt.id = s8();
          pt.penId = this.pencilLine.id;
          this.pencilLine.calculative.worldAnchors.push(pt);
          this.store.path2dMap.set(this.pencilLine, globalStore.path2dDraws[this.pencilLine.name](this.pencilLine));
          this.patchFlags = true;
        }
      }
      if (this.drawingLine) {
        const {
          x,
          y
        } = e;
        const pt = {
          x,
          y
        };
        pt.id = s8();
        pt.penId = this.drawingLine.id;
        // dock
        if (!this.store.options.disableDock && !this.store.options.disableLineDock) {
          this.clearDock();
          this.dock = calcAnchorDock(this.store, pt);
          this.dock?.xDock && (pt.x += this.dock.xDock.step);
          this.dock?.yDock && (pt.y += this.dock.yDock.step);
        }
        if (this.mouseDown && this.drawingLineName === 'curve' && !this.drawingLine.calculative.worldAnchors[0].connectTo) {
          this.drawline(pt);
        } else {
          let to;
          if (this.drawingLine.calculative.worldAnchors.length > 1) {
            to = getToAnchor(this.drawingLine);
          }
          if (to) {
            to.prev = undefined;
            to.next = undefined;
            if (!to.id) {
              to.id = s8();
            }
            to.x = pt.x;
            to.y = pt.y;
            to.connectTo = undefined;
          } else {
            to = {
              ...pt
            };
            this.drawingLine.calculative.worldAnchors.push(to);
          }
          if (this.hoverType === HoverType.NodeAnchor || this.hoverType === HoverType.LineAnchor) {
            if (this.store.hoverAnchor.type !== PointType.Line) {
              to.x = this.store.hoverAnchor.x;
              to.y = this.store.hoverAnchor.y;
            }
            to.connectTo = this.store.hoverAnchor.penId;
            if (this.drawingLineName === 'polyline') {
              to.isTemp = false;
            }
          }
          if (this.drawingLineName === 'line') {
            if (e.ctrlKey && !e.shiftKey) {
              to.x = this.drawingLine.calculative.worldAnchors[this.drawingLine.calculative.worldAnchors.length - 2].x;
            } else if (e.shiftKey && !e.ctrlKey) {
              to.y = this.drawingLine.calculative.worldAnchors[this.drawingLine.calculative.worldAnchors.length - 2].y;
            } else if (e.shiftKey && e.ctrlKey) {
              let last = this.drawingLine.calculative.worldAnchors[this.drawingLine.calculative.worldAnchors.length - 2];
              this.getSpecialAngle(to, last);
            }
          }
          this.drawline();
        }
      }
      globalThis.debug && console.time('hover');
      const now = performance.now();
      if (now - this.hoverTimer > 50) {
        this.hoverTimer = now;
        this.getHover(e);
      }
      globalThis.debug && console.timeEnd('hover');
      if (this.hotkeyType === HotkeyType.AddAnchor) {
        this.patchFlags = true;
      }
      this.render(false);
    });
    _defineProperty(this, "onMouseUp", e => {
      if (this.store.data.locked === LockState.Disable) {
        this.hoverType = HoverType.None;
        return;
      }
      if (!this.mouseDown) {
        return;
      }
      if (this.mouseRight === MouseRight.Down) {
        if (this.store.hover && this.store.hover.calculative.focus) {
          this.store.hover.onContextmenu && this.store.hover.onContextmenu(this.store.hover, e);
        } else {
          this.store.emitter.emit('contextmenu', {
            e,
            clientRect: this.clientRect,
            pen: this.store.hover
          });
        }
      }
      this.mouseRight = MouseRight.None;
      this.calibrateMouse(e);
      this.mousePos.x = e.x;
      this.mousePos.y = e.y;
      this.pencil && this.finishPencil();
      if (this.drawingLine) {
        // 在锚点上，完成绘画
        if (this.store.hoverAnchor) {
          const to = getToAnchor(this.drawingLine);
          if (this.store.hoverAnchor.type === PointType.Line) {
            getDistance(to, this.store.hoverAnchor, this.store);
          } else {
            to.x = this.store.hoverAnchor.x;
            to.y = this.store.hoverAnchor.y;
          }
          connectLine(this.store.hover, this.store.hoverAnchor, this.drawingLine, to);
          this.drawline();
          this.finishDrawline(true);
          return;
        }
        // 自动锚点（单击节点），完成绘画
        if (this.store.options.autoAnchor && this.hoverType === HoverType.Node) {
          const to = getToAnchor(this.drawingLine);
          const anchor = nearestAnchor(this.store.hover, e);
          to.x = anchor.x;
          to.y = anchor.y;
          this.drawingLine.autoTo = true;
          connectLine(this.store.hover, anchor, this.drawingLine, to);
          this.drawline();
          this.finishDrawline(true);
          return;
        }
      }
      // 拖拽连线锚点
      if (this.hoverType === HoverType.LineAnchor && this.store.hover && this.store.active[0] && this.store.active[0].name === 'line' && this.store.active[0] !== this.store.hover) {
        const line = this.store.active[0];
        const from = getFromAnchor(line);
        const to = getToAnchor(line);
        if (this.store.hoverAnchor) {
          const hover = this.store.hover;
          const isHoverFrom = getFromAnchor(hover) === this.store.hoverAnchor;
          const isHoverTo = getToAnchor(hover) === this.store.hoverAnchor;
          const isActiveFrom = from === this.store.activeAnchor;
          const isActiveTo = to === this.store.activeAnchor;
          if ((e.ctrlKey || e.altKey) && hover.type === PenType.Line && (isHoverFrom || isHoverTo) && (isActiveFrom || isActiveTo)) {
            // 合并连线
            const hoverAnchors = hover.calculative.worldAnchors.map(anchor => {
              return {
                ...anchor,
                penId: line.id
              };
            });
            if (isHoverFrom) {
              hoverAnchors.shift();
            } else if (isHoverTo) {
              hoverAnchors.pop();
            }
            if (isHoverFrom && isActiveFrom || isHoverTo && isActiveTo) {
              hoverAnchors.reverse();
            }
            if (isActiveFrom) {
              line.calculative.worldAnchors[0].connectTo = undefined;
              line.calculative.worldAnchors.unshift(...hoverAnchors);
            } else if (isActiveTo) {
              line.calculative.worldAnchors[line.calculative.worldAnchors.length - 1].connectTo = undefined;
              line.calculative.worldAnchors.push(...hoverAnchors);
            }
            this.delete([hover]);
            // TODO: 历史记录
            this.render();
          } else {
            // 连接连线
            if (this.store.activeAnchor) {
              /**
               * 线的锚点需要存所连接锚点的位置
               */
              if (this.store.hoverAnchor.type === PointType.Line) {
                getDistance(this.store.activeAnchor, this.store.hoverAnchor, this.store);
              } else {
                this.store.activeAnchor.x = this.store.hoverAnchor.x;
                this.store.activeAnchor.y = this.store.hoverAnchor.y;
              }
              connectLine(this.store.hover, this.store.hoverAnchor, line, this.store.activeAnchor);
            }
          }
          if (this[line.lineName] && line.lineName !== 'polyline') {
            this[line.lineName](this.store, line);
          }
          this.store.path2dMap.set(line, globalStore.path2dDraws.line(line));
          this.initLineRect(line);
        } else {
          // 连线起始点自动关联 到 pen
          if (from === this.store.activeAnchor && line.autoFrom) {
            this.calcAutoAnchor(line, from, this.store.hover);
          } else if (to === this.store.activeAnchor && line.autoTo) {
            this.calcAutoAnchor(line, to, this.store.hover);
          }
        }
      }
      // Add pen
      if (this.addCaches && this.addCaches.length) {
        if (!this.store.data.locked) {
          if (this.dragRect) {
            // 只存在一个缓存图元
            if (this.addCaches.length === 1) {
              const target = this.addCaches[0];
              target.width = this.dragRect.width / this.store.data.scale;
              target.height = this.dragRect.height / this.store.data.scale;
              e.x = (this.dragRect.x + this.dragRect.ex) / 2;
              e.y = (this.dragRect.y + this.dragRect.ey) / 2;
            }
          }
          this.dropPens(this.addCaches, e);
        }
        this.addCaches = undefined;
      }
      // Rotate
      if (this.hoverType === HoverType.Rotate) {
        this.getSizeCPs();
        this.store.active.forEach(pen => {
          pen.rotate = pen.calculative.rotate;
        });
      }
      this.patchFlagsLines.forEach(pen => {
        if (pen.type) {
          this.initLineRect(pen);
        }
      });
      this.patchFlagsLines.clear();
      if (this.dragRect) {
        if (this.canvasImage.fitFlag) {
          this.makeFit();
        } else {
          const pens = this.store.data.pens.filter(pen => {
            if (pen.visible === false || pen.locked >= LockState.DisableMove || pen.parentId || pen.isRuleLine) {
              return false;
            }
            if (rectInRect(pen.calculative.worldRect, this.dragRect, e.ctrlKey || this.store.options.dragAllIn)) {
              // 先判断在区域内，若不在区域内，则锚点肯定不在框选区域内，避免每条连线过度计算
              if (pen.type === PenType.Line && !this.store.options.dragAllIn) {
                return lineInRect(pen, this.dragRect);
              }
              return true;
            }
          });
          //框选
          this.active(pens);
        }
      }
      if (e.button !== 2) {
        if (distance(this.mouseDown, e) < 2) {
          if (this.store.hover && this.store.hover.input) {
            this.showInput(this.store.hover);
          }
          this.store.emitter.emit('click', {
            x: e.x,
            y: e.y,
            pen: this.store.hover
          });
        }
        if (this.store.hover) {
          this.store.hover.calculative.mouseDown = false;
        }
        if (this.store.hover != this.store.hoverContainer) {
          this.store.emitter.emit('mouseup', {
            x: e.x,
            y: e.y,
            pen: this.store.hover
          });
        }
        this.store.emitter.emit('mouseup', {
          x: e.x,
          y: e.y,
          pen: this.store.hoverContainer
        });
      }
      if (this.willInactivePen) {
        this.willInactivePen.calculative.active = undefined;
        setChildrenActive(this.willInactivePen, false); // 子节点取消激活
        const index = this.store.active.findIndex(p => p === this.willInactivePen);
        if (index >= 0) {
          this.store.active.splice(index, 1);
        }
        this.calcActiveRect();
        this.willInactivePen = undefined;
        this.store.emitter.emit('inactive', [this.willInactivePen]);
        this.render();
      }
      if (this.movingPens) {
        if (e.altKey && !e.shiftKey) {
          this.copyMovedPens();
        } else {
          this.movedActivePens(e.ctrlKey && e.shiftKey);
        }
        this.getAllByPens(this.movingPens).forEach(pen => {
          this.store.pens[pen.id] = undefined;
        });
        this.movingPens = undefined;
      }
      if (this.store.active && this.store.active[0]) {
        this.store.active[0].calculative.h = undefined;
      }
      this.mouseDown = undefined;
      this.lastOffsetX = 0;
      this.lastOffsetY = 0;
      this.clearDock();
      this.dragRect = undefined;
      this.initActiveRect = undefined;
      this.render();
    });
    _defineProperty(this, "clearDock", () => {
      const xPenId = this.dock?.xDock?.penId;
      const yPenId = this.dock?.yDock?.penId;
      const xPen = this.store.pens[xPenId];
      if (xPen) {
        xPen.calculative.isDock = false;
      }
      const yPen = this.store.pens[yPenId];
      if (yPen) {
        yPen.calculative.isDock = false;
      }
      this.dock = undefined;
    });
    _defineProperty(this, "onResize", () => {
      if (this.timer) {
        clearTimeout(this.timer);
      }
      this.timer = setTimeout(() => {
        this.resize();
        this.timer = undefined;
      }, 100);
    });
    _defineProperty(this, "onScroll", () => {
      if (this.timer) {
        clearTimeout(this.timer);
      }
      this.timer = setTimeout(() => {
        this.clientRect = this.canvas.getBoundingClientRect();
        this.timer = undefined;
      }, 100);
    });
    _defineProperty(this, "calibrateMouse", pt => {
      pt.x -= this.store.data.x;
      pt.y -= this.store.data.y;
      return pt;
    });
    _defineProperty(this, "getContainerHover", pt => {
      if (this.dragRect) {
        return;
      }
      this.store.hoverContainer = undefined;
      const containerPens = this.store.data.pens.filter(pen => pen.container || this.store.options.containerShapes?.includes(pen.name));
      if (containerPens.length) {
        for (let i = containerPens.length - 1; i >= 0; --i) {
          const pen = containerPens[i];
          if (pen.visible == false || pen.calculative.inView == false || pen.locked === LockState.Disable) {
            continue;
          }
          if (pointInRect(pt, pen.calculative.worldRect)) {
            this.store.hoverContainer = pen;
            pen?.onMouseMove?.(pen, pt);
            if (this.store.lastHoverContainer !== this.store.hoverContainer) {
              this.patchFlags = true;
              if (this.store.lastHoverContainer) {
                this.store.lastHoverContainer.calculative.containerHover = false;
                this.store.emitter.emit('leave', this.store.lastHoverContainer);
              }
              if (this.store.hoverContainer) {
                this.store.hoverContainer.calculative.containerHover = true;
                this.store.emitter.emit('enter', this.store.hoverContainer);
              }
              this.store.lastHoverContainer = this.store.hoverContainer;
            }
          } else {
            if (pen === this.store.hoverContainer) {
              this.store.hoverContainer = undefined;
              if (this.store.lastHoverContainer !== this.store.hoverContainer) {
                this.patchFlags = true;
                const movingPen = this.store.lastHoverContainer.calculative.canvas.store.pens[this.store.lastHoverContainer.id + movingSuffix];
                if (this.store.lastHoverContainer && !movingPen) {
                  this.store.lastHoverContainer.calculative.containerHover = false;
                  this.store.emitter.emit('leave', this.store.lastHoverContainer);
                }
                this.store.lastHoverContainer = this.store.hoverContainer;
              }
            }
          }
        }
      }
    });
    _defineProperty(this, "getHover", pt => {
      if (this.dragRect) {
        return;
      }
      if (this.canvasImage.fitFlag) {
        return;
      }
      let hoverType = HoverType.None;
      this.store.hover = undefined;
      this.store.hoverAnchor = undefined;
      this.title.hide();
      this.store.pointAt = undefined;
      this.store.pointAtIndex = undefined;
      const activeLine = this.store.active.length === 1 && this.store.active[0].type;
      if (!this.drawingLineName && this.hotkeyType !== HotkeyType.AddAnchor && this.activeRect && !activeLine && !this.store.data.locked) {
        const activePensLock = getPensLock(this.store.active);
        const activePensDisableRotate = getPensDisableRotate(this.store.active) || this.store.options.disableRotate;
        const activePensDisableResize = getPensDisableResize(this.store.active) || this.store.options.disableSize;
        if (!activePensLock && !activePensDisableRotate) {
          const rotatePt = {
            x: this.activeRect.center.x,
            y: this.activeRect.y - 30
          };
          if (this.activeRect.rotate) {
            rotatePoint(rotatePt, this.activeRect.rotate, this.activeRect.pivot || this.activeRect.center);
          }
          // 旋转控制点
          if (!this.hotkeyType && hitPoint(pt, rotatePt, this.pointSize)) {
            hoverType = HoverType.Rotate;
            this.externalElements.style.cursor = `url("${this.store.options.rotateCursor}"), auto`;
          }
        }
        // 大小控制点
        if (!activePensLock && !activePensDisableResize) {
          for (let i = 0; i < 8; i++) {
            const firstFour = i < 4;
            const hotKeyIsResize = this.hotkeyType === HotkeyType.Resize || firstFour && !this.hotkeyType;
            if (hotKeyIsResize && hitPoint(pt, this.sizeCPs[i], this.pointSize)) {
              let cursors = firstFour ? defaultCursors : rotatedCursors;
              let offset = 0;
              if (Math.abs(this.activeRect.rotate % 90 - 45) < 25) {
                cursors = firstFour ? rotatedCursors : defaultCursors;
                offset = Math.round((this.activeRect.rotate - 45) / 90) + (firstFour ? 0 : 1);
              } else {
                offset = Math.round(this.activeRect.rotate / 90);
              }
              hoverType = HoverType.Resize;
              this.resizeIndex = i;
              this.externalElements.style.cursor = cursors[(i + offset) % 4];
              break;
            }
          }
        }
      }
      if (hoverType === HoverType.None) {
        hoverType = this.inPens(pt, this.store.data.pens);
      }
      if (!hoverType && !activeLine && pointInRect(pt, this.activeRect)) {
        hoverType = HoverType.Node;
        this.externalElements.style.cursor = 'move';
      }
      this.hoverType = hoverType;
      if (hoverType === HoverType.None) {
        if (this.drawingLineName || this.pencil) {
          this.externalElements.style.cursor = 'crosshair';
        } else if (!this.mouseDown) {
          this.externalElements.style.cursor = 'default';
        }
        this.store.hover = undefined;
      }
      if (this.store.lastHover !== this.store.hover) {
        this.patchFlags = true;
        if (this.store.lastHover) {
          this.store.lastHover.calculative.hover = false;
          setHover(getParent(this.store.lastHover, true) || this.store.lastHover, false);
          this.store.emitter.emit('leave', this.store.lastHover);
          this.tooltip.hide();
        }
        if (this.store.hover) {
          this.store.hover.calculative.hover = true;
          setHover(getParent(this.store.hover, true) || this.store.hover);
          this.store.emitter.emit('enter', this.store.hover);
          this.tooltip.show(this.store.hover, pt);
        }
        this.store.lastHover = this.store.hover;
      }
      this.store.hover?.onMouseMove?.(this.store.hover, this.mousePos);
    });
    _defineProperty(this, "inPens", (pt, pens) => {
      let hoverType = HoverType.None;
      outer: for (let i = pens.length - 1; i >= 0; --i) {
        const pen = pens[i];
        if (pen.visible == false || pen.calculative.inView == false || pen.locked === LockState.Disable) {
          continue;
        }
        const r = getLineR(pen);
        if (!pen.calculative.active && !pointInSimpleRect(pt, pen.calculative.worldRect, r) && !pointInRect(pt, pen.calculative.worldRect)) {
          continue;
        }
        //anchor title
        // if (this.store.data.locked) {
        //   // locked>0
        //   if (pen.calculative.worldAnchors) {
        //     for (const anchor of pen.calculative.worldAnchors) {
        //       if (
        //         hitPoint(
        //           pt,
        //           anchor,
        //           this.pointSize,
        //           anchor.penId ? this.store.pens[anchor.penId] : undefined
        //         )
        //       ) {
        //         this.title.show(anchor, pen);
        //         if (anchor.title) {
        //           break outer;
        //         }
        //       }
        //     }
        //   }
        // }
        // 锚点
        if (!this.store.data.locked && this.hotkeyType !== HotkeyType.Resize) {
          if (pen.calculative.worldAnchors) {
            for (const anchor of pen.calculative.worldAnchors) {
              hoverType = this.inAnchor(pt, pen, anchor);
              if (hoverType) {
                //title显示
                let _anchor = deepClone(anchor);
                Object.assign(_anchor, pt);
                this.title.show(_anchor, pen);
                break outer;
              }
            }
          }
        }
        // 图形
        if (pen.type) {
          if (pen.isRuleLine) {
            let ruleH = this.store.options.ruleOptions?.height || 20;
            if (pt.x + this.store.data.x > ruleH && pt.y + this.store.data.y > ruleH) {
              break;
            }
          }
          const pos = pointInLine(pt, pen);
          if (pos) {
            if (!this.store.data.locked && !pen.locked) {
              if (this.hotkeyType === HotkeyType.AddAnchor) {
                this.externalElements.style.cursor = 'pointer';
              } else {
                this.externalElements.style.cursor = 'move';
              }
            } else {
              this.externalElements.style.cursor = this.store.options.hoverCursor;
            }
            if (pen.calculative.disabled) {
              this.externalElements.style.cursor = 'not-allowed';
            }
            this.store.hover = pen;
            this.store.pointAt = pos.point;
            this.store.pointAtIndex = pos.i;
            this.initTemplateCanvas([this.store.hover]);
            hoverType = HoverType.Line;
            break;
          }
        } else {
          if (pen.children) {
            const pens = []; // TODO: 只考虑了一级子
            pen.children.forEach(id => {
              this.store.pens[id] && pens.push(this.store.pens[id]);
            });
            hoverType = this.inPens(pt, pens);
            if (hoverType) {
              break;
            }
          }
          let isIn = false;
          if (pen.name === 'line') {
            isIn = pointInSimpleRect(pt, pen.calculative.worldRect, pen.lineWidth);
          } else {
            isIn = pointInRect(pt, pen.calculative.worldRect);
          }
          if (isIn) {
            if (pen.type === PenType.Node && pen.name === 'line') {
              let pIn = pointInPolygon(pt, pen.calculative.worldAnchors);
              if (!pIn) {
                continue;
              }
            }
            if (!this.store.data.locked && !pen.locked) {
              if (this.hotkeyType === HotkeyType.AddAnchor) {
                this.externalElements.style.cursor = 'pointer';
              } else {
                this.externalElements.style.cursor = 'move';
              }
            } else {
              this.externalElements.style.cursor = this.store.options.hoverCursor;
            }
            if (pen.calculative.disabled) {
              this.externalElements.style.cursor = 'not-allowed';
            }
            this.store.hover = pen;
            this.initTemplateCanvas([this.store.hover]);
            hoverType = HoverType.Node;
            this.store.pointAt = pt;
            // 锚点贴边吸附
            if (!pt.ctrlKey) {
              let {
                x,
                y,
                ex,
                ey,
                rotate,
                center
              } = this.store.hover.calculative.worldRect;
              if (rotate) {
                const pts = [{
                  x,
                  y
                }, {
                  x: ex,
                  y: y
                }, {
                  x: ex,
                  y: ey
                }, {
                  x: x,
                  y: ey
                }];
                pts.forEach(item => {
                  rotatePoint(item, rotate, center);
                });
                let last = pts[pts.length - 1];
                for (const item of pts) {
                  if (last.y > pt.y !== item.y > pt.y) {
                    const tempx = item.x + (pt.y - item.y) * (last.x - item.x) / (last.y - item.y);
                    if (Math.abs(tempx - this.store.pointAt.x) < 10) {
                      this.store.pointAt.x = tempx;
                    }
                  }
                  last = item;
                }
              } else {
                if (this.store.pointAt.x - 10 < x) {
                  this.store.pointAt.x = x;
                } else if (this.store.pointAt.x + 10 > ex) {
                  this.store.pointAt.x = ex;
                }
                if (this.store.pointAt.y - 10 < y) {
                  this.store.pointAt.y = y;
                } else if (this.store.pointAt.y + 10 > ey) {
                  this.store.pointAt.y = ey;
                }
              }
            }
            break;
          }
        }
      }
      return hoverType;
    });
    _defineProperty(this, "dockInAnchor", pt => {
      this.store.hover = undefined;
      for (let i = this.store.data.pens.length - 1; i >= 0; --i) {
        const pen = this.store.data.pens[i];
        if (pen.visible == false || pen.locked === LockState.Disable || pen === this.store.active[0]) {
          continue;
        }
        let r = getLineR(pen);
        r += 2 * this.store.options.anchorRadius;
        if (!pointInSimpleRect(pt, pen.calculative.worldRect, r)) {
          continue;
        }
        this.store.hover = pen;
        // 锚点
        if (this.hotkeyType !== HotkeyType.Resize) {
          if (pen.calculative.worldAnchors) {
            for (const anchor of pen.calculative.worldAnchors) {
              if (anchor.twoWay === TwoWay.In) {
                const to = getToAnchor(this.store.active[0]);
                if (this.store.activeAnchor.id !== to.id) {
                  continue;
                }
              }
              if (anchor.twoWay === TwoWay.Out) {
                const from = getFromAnchor(this.store.active[0]);
                if (this.store.activeAnchor.id !== from.id) {
                  continue;
                }
              }
              if (anchor.twoWay === TwoWay.DisableConnected || anchor.twoWay === TwoWay.Disable || this.store.activeAnchor?.twoWay === TwoWay.DisableConnectTo || this.store.activeAnchor?.twoWay === TwoWay.Disable) {
                continue;
              }
              this.title.hide();
              if (this.inAnchor(pt, pen, anchor)) {
                let _anchor = deepClone(anchor);
                Object.assign(_anchor, pt);
                this.title.show(_anchor, pen);
                return true;
              }
            }
          }
        }
      }
    });
    _defineProperty(this, "imageTimer", void 0);
    _defineProperty(this, "templateImageTimer", void 0);
    _defineProperty(this, "render", patchFlags => {
      if (patchFlags) {
        this.opening = false;
      }
      if (this.opening) {
        return;
      }
      let now;
      if (patchFlags == null || patchFlags === true || patchFlags === Infinity) {
        now = performance.now();
        this.patchFlags = true;
      } else if (patchFlags > 1) {
        now = patchFlags;
      } else {
        now = performance.now();
      }
      if (!this.patchFlags) {
        return;
      }
      if (now - this.lastRender < this.store.options.interval) {
        if (this.renderTimer) {
          cancelAnimationFrame(this.renderTimer);
        }
        this.renderTimer = requestAnimationFrame(this.render);
        return;
      }
      this.renderTimer = undefined;
      this.lastRender = now;
      const offscreenCtx = this.offscreen.getContext('2d');
      offscreenCtx.clearRect(0, 0, this.offscreen.width, this.offscreen.height);
      offscreenCtx.save();
      offscreenCtx.translate(this.store.data.x, this.store.data.y);
      globalThis.debugRender && console.time('renderPens');
      this.renderPens();
      globalThis.debugRender && console.timeEnd('renderPens');
      this.renderBorder();
      this.renderHoverPoint();
      offscreenCtx.restore();
      this.magnifierCanvas.render();
      const ctx = this.canvas.getContext('2d');
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      ctx.drawImage(this.offscreen, 0, 0, this.width, this.height);
      this.canvasTemplate.render();
      this.canvasImageBottom.render();
      this.canvasImage.render();
      this.patchFlags = false;
    });
    _defineProperty(this, "renderPens", () => {
      const ctx = this.offscreen.getContext('2d');
      ctx.strokeStyle = getGlobalColor(this.store);
      for (const pen of this.store.data.pens) {
        if (!isFinite(pen.x)) {
          continue;
        }
        // if (pen.template) {
        if (pen.canvasLayer === CanvasLayer.CanvasTemplate) {
          continue;
        }
        if (pen.calculative.inView) {
          if (pen.canvasLayer === CanvasLayer.CanvasMain && pen.name !== 'gif' && pen.image && pen.calculative.img) {
            ctx.save();
            ctxFlip(ctx, pen);
            if (pen.calculative.rotate) {
              ctxRotate(ctx, pen);
            }
            setGlobalAlpha(ctx, pen);
            drawImage(ctx, pen);
            ctx.restore();
          }
          renderPen(ctx, pen);
        }
      }
      if (this.drawingLine) {
        renderPen(ctx, this.drawingLine);
      }
      if (this.pencilLine) {
        renderPen(ctx, this.pencilLine);
      }
      if (this.movingPens) {
        this.movingPens.forEach(pen => {
          this.renderPenContainChild(ctx, pen);
        });
      }
    });
    _defineProperty(this, "renderPenContainChild", (ctx, pen) => {
      pen.calculative.inView && renderPen(ctx, pen); // 可见才绘制，组合为状态只显示其中一个
      pen.children?.forEach(id => {
        const child = this.store.pens[id];
        child && this.renderPenContainChild(ctx, child);
      });
    });
    _defineProperty(this, "renderBorder", () => {
      if (!this.store.data.locked) {
        // Occupied territory.
        if (this.activeRect && !(this.store.active.length === 1 && this.store.active[0].type) && !this.movingPens) {
          const ctx = this.offscreen.getContext('2d');
          ctx.save();
          ctx.translate(0.5, 0.5);
          const pivot = this.activeRect.pivot || this.activeRect.center;
          if (this.activeRect.rotate) {
            ctx.translate(pivot.x, pivot.y);
            ctx.rotate(this.activeRect.rotate * Math.PI / 180);
            ctx.translate(-pivot.x, -pivot.y);
          }
          ctx.strokeStyle = this.store.options.activeColor;
          ctx.globalAlpha = this.store.options.activeGlobalAlpha === undefined ? 0.3 : this.store.options.activeGlobalAlpha;
          ctx.beginPath();
          ctx.lineWidth = this.store.options.activeLineWidth || 1;
          ctx.setLineDash(this.store.options.activeLineDash || []);
          ctx.strokeRect(this.activeRect.x, this.activeRect.y, this.activeRect.width, this.activeRect.height);
          ctx.setLineDash([]);
          ctx.lineWidth = 1;
          ctx.globalAlpha = 1;
          if (getPensLock(this.store.active) || getPensDisableRotate(this.store.active) || this.store.options.disableRotate) {
            ctx.restore();
            return;
          }
          // Draw rotate control line.
          ctx.beginPath();
          ctx.moveTo(this.activeRect.center.x, this.activeRect.y);
          ctx.lineTo(this.activeRect.center.x, this.activeRect.y - 30);
          ctx.stroke();
          // Draw rotate control points.
          ctx.beginPath();
          ctx.strokeStyle = this.store.options.activeColor;
          ctx.fillStyle = '#ffffff';
          ctx.arc(this.activeRect.center.x, this.activeRect.y - 30, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          ctx.restore();
        }
      }
    });
    _defineProperty(this, "renderHoverPoint", () => {
      if (this.store.data.locked) {
        return;
      }
      const ctx = this.offscreen.getContext('2d');
      ctx.save();
      ctx.translate(0.5, 0.5);
      if (!this.store.options.disableAnchor && this.store.hover && !this.store.hover.disableAnchor && (this.hotkeyType !== HotkeyType.Resize || this.store.active.length !== 1 || this.store.active[0] !== this.store.hover)) {
        const anchors = [...this.store.hover.calculative.worldAnchors];
        if (this.store.pointAt && this.hotkeyType === HotkeyType.AddAnchor) {
          anchors.push(this.store.pointAt);
        }
        if (anchors) {
          ctx.strokeStyle = this.store.hover.anchorColor || this.store.options.anchorColor;
          ctx.fillStyle = this.store.hover.anchorBackground || this.store.options.anchorBackground;
          anchors.forEach(anchor => {
            if (anchor.hidden && anchor.locked > LockState.DisableEdit) {
              return;
            }
            if (anchor === this.store.hoverAnchor) {
              ctx.save();
              const hoverAnchorColor = this.store.hover.hoverAnchorColor || this.store.options.hoverAnchorColor;
              ctx.strokeStyle = hoverAnchorColor;
              ctx.fillStyle = hoverAnchorColor;
            }
            ctx.beginPath();
            let size = anchor.radius || this.store.hover.anchorRadius || this.store.options.anchorRadius;
            if (this.store.hover.type && !anchor.radius && !this.store.hover.anchorRadius) {
              size = 3;
              if (this.store.hover.calculative.lineWidth > 3) {
                size = this.store.hover.calculative.lineWidth;
              }
            }
            if (anchor.type === PointType.Line) {
              //旋转的情况
              let _rotate = this.store.pens[anchor.penId].rotate || 0;
              if (this.store.pens[anchor.penId].calculative.flipX) {
                _rotate *= -1;
              }
              if (this.store.pens[anchor.penId].calculative.flipY) {
                _rotate *= -1;
              }
              let rotate = anchor.rotate + _rotate;
              if (this.store.pens[anchor.penId].calculative.flipX) {
                rotate *= -1;
              }
              if (this.store.pens[anchor.penId].calculative.flipY) {
                rotate *= -1;
              }
              ctx.save();
              ctx.translate(anchor.x, anchor.y);
              ctx.rotate(rotate * Math.PI / 180);
              ctx.translate(-anchor.x, -anchor.y);
              ctx.rect(anchor.x - anchor.length * this.store.data.scale / 2, anchor.y - size, anchor.length * this.store.data.scale, size * 2);
              ctx.restore();
            } else {
              ctx.arc(anchor.x, anchor.y, size, 0, Math.PI * 2);
            }
            if (this.store.hover.type && this.store.hoverAnchor === anchor) {
              ctx.save();
              ctx.strokeStyle = this.store.hover.activeColor || this.store.options.activeColor;
              ctx.fillStyle = ctx.strokeStyle;
            } else if (anchor.color || anchor.background) {
              ctx.save();
              ctx.strokeStyle = anchor.color;
              ctx.fillStyle = anchor.background;
            }
            ctx.fill();
            ctx.stroke();
            if (anchor === this.store.hoverAnchor) {
              ctx.restore();
            }
            if (this.store.hover.type && this.store.hoverAnchor === anchor) {
              ctx.restore();
            } else if (anchor.color || anchor.background) {
              ctx.restore();
            }
            //根父节点
            if (!this.store.hover.parentId && this.store.hover.children && this.store.hover.children.length > 0) {
              if (anchor === this.store.hoverAnchor) {
                ctx.save();
                ctx.beginPath();
                ctx.lineWidth = 3;
                const hoverAnchorColor = this.store.hover.hoverAnchorColor || this.store.options.hoverAnchorColor;
                if (globalThis.pSBC) {
                  ctx.strokeStyle = globalThis.pSBC(0.5, hoverAnchorColor);
                }
                ctx.arc(anchor.x, anchor.y, size + 1.5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
              }
            }
          });
        }
      }
      // Draw size control points.
      if (this.hotkeyType !== HotkeyType.AddAnchor && !this.movingPens &&
      // 不在移动中
      this.activeRect && !(this.store.active.length === 1 && this.store.active[0].type)) {
        if (!getPensLock(this.store.active) && !getPensDisableResize(this.store.active) && !this.store.options.disableSize) {
          ctx.strokeStyle = this.store.options.activeColor;
          ctx.fillStyle = '#ffffff';
          this.sizeCPs.forEach((pt, i) => {
            if (this.activeRect.rotate) {
              ctx.save();
              ctx.translate(pt.x, pt.y);
              ctx.rotate(this.activeRect.rotate * Math.PI / 180);
              ctx.translate(-pt.x, -pt.y);
            }
            if (i < 4 || this.hotkeyType === HotkeyType.Resize) {
              ctx.beginPath();
              ctx.fillRect(pt.x - 4.5, pt.y - 4.5, 8, 8);
              ctx.strokeRect(pt.x - 5.5, pt.y - 5.5, 10, 10);
            }
            if (this.activeRect.rotate) {
              ctx.restore();
            }
          });
        }
      }
      if (!this.store.data.locked && this.dragRect) {
        ctx.save();
        ctx.fillStyle = rgba(this.store.options.dragColor, 0.2);
        ctx.strokeStyle = this.store.options.dragColor;
        ctx.beginPath();
        ctx.strokeRect(this.dragRect.x, this.dragRect.y, this.dragRect.width, this.dragRect.height);
        ctx.fillRect(this.dragRect.x, this.dragRect.y, this.dragRect.width, this.dragRect.height);
        ctx.restore();
      }
      if (this.dock) {
        ctx.strokeStyle = this.store.options.dockColor;
        if (this.dock.xDock) {
          ctx.beginPath();
          ctx.moveTo(this.dock.xDock.x, this.dock.xDock.y);
          ctx.lineTo(this.dock.xDock.x, this.dock.xDock.prev.y);
          ctx.stroke();
        }
        if (this.dock.yDock) {
          ctx.beginPath();
          ctx.moveTo(this.dock.yDock.x, this.dock.yDock.y);
          ctx.lineTo(this.dock.yDock.prev.x, this.dock.yDock.y);
          ctx.stroke();
        }
      }
      ctx.restore();
    });
    /**
     *
     * @param pen 当前复制的画笔
     * @param parentId 父节点 id
     * @param clipboard 本次复制的全部画笔，包含子节点, 以及 origin 和 scale
     * @returns 复制后的画笔
     */
    _defineProperty(this, "pastePen", (pen, parentId) => {
      const oldId = pen.id;
      randomId(pen);
      pen.parentId = parentId;
      if (pen.type === PenType.Line) {
        this.changeNodeConnectedLine(oldId, pen, this.store.clipboard.pens);
      } else {
        this.changeLineAnchors(oldId, pen, this.store.clipboard.pens);
      }
      if (!pen.parentId) {
        const rect = this.getPenRect(pen, this.store.clipboard.origin, this.store.clipboard.scale);
        const initRect = this.getPenRect(this.store.clipboard.initRect, this.store.clipboard.origin, this.store.clipboard.scale);
        const {
          origin,
          scale
        } = this.store.data;
        pen.x = origin.x + rect.x * scale;
        pen.y = origin.y + rect.y * scale;
        pen.width = rect.width * scale;
        pen.height = rect.height * scale;
        initRect.x = origin.x + initRect.x * scale;
        initRect.y = origin.y + initRect.y * scale;
        calcCenter(initRect);
        if (this.store.clipboard.pos) {
          pen.x -= initRect.center.x - this.store.clipboard.pos.x;
          pen.y -= initRect.center.y - this.store.clipboard.pos.y;
        }
        if (this.keyOptions && this.keyOptions.altKey && (this.keyOptions.ctrlKey || this.keyOptions.metaKey)) {
          pen.x = -this.store.data.x + this.width / 2 - pen.width / 2;
          pen.y = -this.store.data.y + this.height / 2 - pen.height / 2;
        } else if (this.keyOptions && this.keyOptions.shiftKey && (this.keyOptions.ctrlKey || this.keyOptions.metaKey)) {} else {
          pen.x += this.store.clipboard.offset * this.store.data.scale;
          pen.y += this.store.clipboard.offset * this.store.data.scale;
        }
      }
      this.makePen(pen);
      const newChildren = [];
      if (Array.isArray(pen.children)) {
        for (const childId of pen.children) {
          const childPen = this.store.clipboard.pens.find(pen => pen.id === childId);
          childPen && newChildren.push(this.pastePen(childPen, pen.id).id);
        }
      }
      pen.children = newChildren;
      calcInView(pen, true);
      return pen;
    });
    _defineProperty(this, "ondblclick", e => {
      if (this.store.hover && (!this.store.data.locked || this.store.hover.dbInput) && !this.store.options.disableInput) {
        if (this.store.hover.onShowInput) {
          this.store.hover.onShowInput(this.store.hover, e);
        } else {
          this.showInput(this.store.hover);
        }
      }
      this.store.emitter.emit('dblclick', {
        x: e.x,
        y: e.y,
        pen: this.store.hover
      });
    });
    _defineProperty(this, "showInput", (pen, rect, background = 'transparent') => {
      if (!window || !this.store.hover || this.store.hover.locked || this.store.hover.externElement || this.store.hover.disableInput || this.store.hover.disabled) {
        return;
      }
      if (this.inputDiv.dataset.penId === pen.id) {
        this.inputDiv.dataset.isInput = 'true';
        this.inputDiv.contentEditable = 'true';
        this.inputDiv.focus();
        const range = window.getSelection(); //创建range
        range.selectAllChildren(this.inputDiv); //range 选择obj下所有子内容
        range.collapseToEnd(); //光标移至最后
        this.inputDiv.scrollTop = this.inputDiv.scrollHeight;
        this.inputDiv.scrollLeft = this.inputDiv.scrollWidth;
        return;
      }
      //过滤table2图元
      if (!rect && !pen.dbInput) {
        this.setInputStyle(pen);
      } else {
        this.inputDiv.style.width = '100%';
        this.inputDiv.style.height = '100%';
      }
      const textRect = rect || pen.calculative.worldTextRect;
      //value和innerText问题
      const preInputText = pen.calculative.tempText === undefined ? pen.text + '' || '' : pen.calculative.tempText;
      const textArr = preInputText.replace(/\x20/g, '&nbsp;').split(/[\s\n]/);
      const finalText = `${textArr.join('</div><div>')}</div>`.replace('</div>', '').replace(/\<div\>\<\/div\>/g, '<div><br></div>');
      this.inputDiv.innerHTML = finalText;
      // this.inputDiv.style.fontSize = pen.calculative.fontSize + 'px';
      // this.inputDiv.style.color = getTextColor(pen, this.store);
      this.inputParent.style.left = textRect.x + this.store.data.x - (pen.textLeft || 0) + 'px'; //+ 5
      this.inputParent.style.top = textRect.y + this.store.data.y - (pen.textTop || 0) + 'px'; //+ 5
      let _width = textRect.width + (pen.textLeft || 0);
      this.inputParent.style.width = (_width < 0 ? 12 : _width) + 'px'; //(textRect.width < pen.width ? 0 : 10)
      this.inputParent.style.height = textRect.height + (pen.textTop || 0) + 'px'; //   (textRect.height < pen.height ? 0 : 10)
      this.inputParent.style.zIndex = '9999';
      this.inputParent.style.background = background;
      if (pen.rotate % 360) {
        this.inputParent.style.transform = `rotate(${pen.rotate}deg)`;
      } else {
        this.inputParent.style.transform = null;
      }
      this.inputParent.style.display = 'flex';
      this.inputDiv.dataset.penId = pen.id;
      this.inputDiv.contentEditable = pen.disableInput == undefined ? 'true' : pen.disableInput.toString();
      if (pen.dropdownList && this.dropdown.style.display !== 'block') {
        if (!this.store.data.locked) {
          this.inputRight.style.display = 'none';
        }
        this.setDropdownList();
      } else {
        this.inputRight.style.display = 'none';
      }
      this.inputDiv.contentEditable = 'true';
      this.inputDiv.focus();
      const range = window.getSelection(); //创建range
      range.selectAllChildren(this.inputDiv); //range 选择obj下所有子内容
      range.collapseToEnd(); //光标移至最后
      this.inputDiv.scrollTop = this.inputDiv.scrollHeight;
      this.inputDiv.scrollLeft = this.inputDiv.scrollWidth;
      pen.calculative.text = undefined;
      this.initTemplateCanvas([pen]);
      this.render();
    });
    _defineProperty(this, "setInputStyle", pen => {
      if (!pen.text) {
        pen.text = '';
      }
      let sheet;
      for (let i = 0; i < document.styleSheets.length; i++) {
        if (document.styleSheets[i].title === 'le5le.com') {
          sheet = document.styleSheets[i];
        }
      }
      let style = 'overflow: scroll;';
      let div_style = '';
      let font_scale = 1;
      const {
        scale
      } = this.store.data;
      if (pen.fontSize < 12) {
        font_scale = 12 / pen.fontSize;
      }
      if (pen.textAlign) {
        style += `text-align: ${pen.textAlign};`;
      } else {
        style += 'text-align: center;';
      }
      if (pen.textAlign && pen.whiteSpace === 'pre-line') {
        let textAlign = {
          left: 'start',
          center: 'center',
          right: 'end'
        };
        style += `align-items: ${textAlign[pen.textAlign]};`;
      }
      if (pen.textBaseline) {
        let baseLine = {
          top: 'start',
          middle: 'center',
          bottom: 'end'
        };
        style += `justify-content: ${baseLine[pen.textBaseline]};`;
      } else {
        // if (pen.textWidth < pen.calculative.) {
        //   style += 'justify-content: start;';
        // } else {
        //文字高度超出整个rect高度时
        style += 'justify-content: center;';
        // }
      }
      if (pen.fontFamily) {
        style += `font-family: ${pen.fontFamily};`;
      }
      if (pen.fontSize) {
        if (pen.fontSize * scale < 12) {
          style += `font-size:${pen.fontSize}px;`;
          style += `zoom:${pen.fontSize / 12 * scale};`;
        } else {
          style += `font-size:${pen.fontSize * scale}px;`;
        }
      }
      style += `color:${getTextColor(pen, this.store)};`;
      if (pen.fontStyle) {
        style += `font-style: ${pen.fontStyle};`;
      }
      if (pen.fontWeight) {
        style += `font-weight: ${pen.fontWeight};`;
      }
      if (pen.textLeft) {
        style += `margin-left:${scale > 1 ? pen.textLeft * font_scale : pen.textLeft * font_scale / scale}px;`;
      }
      if (pen.textTop) {
        style += `margin-top:${scale > 1 ? pen.textTop * font_scale : pen.textTop * font_scale / scale}px;`;
      }
      if (pen.lineHeight) {
        style += `line-height:${scale > 1 ? pen.fontSize * pen.lineHeight * scale : pen.fontSize * pen.lineHeight * font_scale}px;`;
      }
      if (pen.textHeight) {
        style += `height:${scale > 1 ? pen.textHeight * font_scale * scale : pen.textHeight * font_scale}px;`;
      } else {
        let tem = pen.calculative.worldRect.height / scale;
        if (tem < 0) {
          tem = 0;
        }
        let height = pen.fontSize * scale < 12 ? tem * font_scale : tem * scale * font_scale;
        if (height < pen.fontSize * pen.lineHeight * scale) {
          height = pen.fontSize * pen.lineHeight * scale;
          style += `top:-${height / 2}px;`;
        }
        style += `height:${height}px;`;
      }
      let _textWidth = null;
      if (pen.textWidth) {
        _textWidth = pen.textWidth < 1 && pen.textWidth > -1 ? pen.textWidth * pen.calculative.worldRect.width : pen.textWidth;
        if (pen.whiteSpace !== 'pre-line') {
          if (_textWidth < pen.fontSize) {
            style += `width:${pen.fontSize * 1.2 * font_scale}px;`;
          } else {
            style += `width:${scale > 1 ? _textWidth * font_scale * scale : _textWidth * font_scale}px;`;
          }
        }
      } else {
        if (pen.whiteSpace === undefined || pen.whiteSpace === 'break-all') {
          let tem = (pen.calculative.worldTextRect.width || 12) / scale; //pen.width / scale - ( pen.textLeft || 0);
          if (tem < 0) {
            tem = 0;
          }
          style += `width:${pen.fontSize * scale < 12 ? tem * font_scale : tem * scale}px;`;
        }
        // if (pen.whiteSpace === 'pre-line') {
        //   //回车换行
        //   style += `overflow: visible;`;
        // }
      }
      if (pen.whiteSpace) {
        if (pen.whiteSpace === 'pre-line') {
          style += `white-space:pre;`;
          // if (!pen.textAlign) {
          //   style += `align-items: center;`;
          // }
        } else {
          style += `white-space:${pen.whiteSpace};`;
          if (pen.whiteSpace === 'nowrap') {
            div_style += 'display:contents;';
          }
        }
      }
      if (pen.whiteSpace !== 'nowrap') {
        let textWidth = pen.fontSize * 1.2 * pen.text.length;
        let contentWidth = (_textWidth || pen.calculative.worldRect.width / scale) * Math.floor(pen.calculative.worldRect.height / scale / (pen.lineHeight * pen.fontSize));
        if (textWidth > contentWidth) {
          style += 'justify-content: start;';
        }
      }
      sheet.deleteRule(0);
      sheet.deleteRule(0);
      sheet.insertRule(`.meta2d-input
      .input-div{
        resize:none;border:none;outline:none;background:transparent;position:absolute;flex-grow:1;height:100%;width: 100%;position:absolute;left:0;top:0;display:flex;flex-direction: column;cursor: text;${style}}`);
      sheet.insertRule(`.input-div div{${div_style}}`);
      // sheet.insertRule(`.meta2d-input .input-div-font{${style_font}}`);
    });
    _defineProperty(this, "hideInput", () => {
      if (this.inputParent.style.display === 'flex') {
        this.inputParent.style.display = 'none';
        const pen = this.store.pens[this.inputDiv.dataset.penId];
        if (!pen) {
          return;
        }
        pen.calculative.text = pen.text;
        this.inputDiv.dataset.value = this.inputDiv.innerHTML.replace(/\<div\>/g, '\n').replace(/\<\/div\>/g, '').replace(/\<br\>/g, '').replace(/&nbsp;/g, ' ').replace(/(<([^>]+)>)/gi, '');
        this.inputDiv.dataset.value = this.convertSpecialCharacter(this.inputDiv.dataset.value);
        if (pen.onInput) {
          pen.onInput(pen, this.inputDiv.dataset.value);
        } else if (pen.text !== this.inputDiv.dataset.value) {
          const initPens = [deepClone(pen, true)];
          pen.text = this.inputDiv.dataset.value;
          pen.calculative.text = pen.text;
          this.inputDiv.dataset.penId = undefined;
          if (pen.name === 'text' && pen.textAutoAdjust) {
            calcTextAutoWidth(pen);
          }
          calcTextRect(pen);
          this.patchFlags = true;
          this.pushHistory({
            type: EditType.Update,
            pens: [deepClone(pen, true)],
            initPens
          });
          this.store.emitter.emit('change', pen);
          this.store.emitter.emit('valueUpdate', pen);
        } else if (pen.text === this.inputDiv.dataset.value && pen.calculative.textLines.length == 0) {
          calcTextRect(pen);
        }
        this.initTemplateCanvas([pen]);
      }
      this.inputDiv.dataset.penId = undefined;
      this.dropdown.style.display = 'none';
      this.inputDiv.dataset.isInput = 'false';
      this.inputDiv.contentEditable = 'false';
      this.render();
    });
    _defineProperty(this, "setDropdownList", search => {
      this.clearDropdownList();
      const pen = this.store.pens[this.inputDiv.dataset.penId];
      if (!this.store.data.locked && !['tablePlus'].includes(pen.name)) {
        return;
      }
      this.dropdown.style.display = 'block';
      this.inputRight.style.display = 'block';
      setTimeout(() => {
        this.inputRight.style.transform = 'rotate(315deg)';
        this.inputRight.style.zoom = this.store.data.scale;
      });
      if (!pen || !pen.dropdownList) {
        this.dropdown.style.display = 'none';
        this.inputRight.style.display = 'none';
        this.inputRight.style.transform = 'rotate(135deg)';
        return;
      }
      if (!pen.dropdownList.length) {
        const none = document.createElement('div');
        none.innerText = 'None';
        none.style.padding = '5px 12px';
        none.style.color = '#ddd';
        this.dropdown.appendChild(none);
        return;
      }
      const text = this.inputDiv.innerHTML.replace(/\<div\>/g, '\n').replace(/\<\/div\>/g, '').replace(/\<br\>/g, '');
      let i = 0;
      for (const item of pen.dropdownList) {
        const t = typeof item === 'string' ? item : item.text;
        if (search && text) {
          if (t.includes(text)) {
            // 过滤
            this.dropdownAppendOption(t, i);
          }
        } else {
          this.dropdownAppendOption(t, i);
        }
        ++i;
      }
      if (!this.dropdown.hasChildNodes()) {
        const none = document.createElement('div');
        none.innerText = 'None';
        none.style.padding = '5px 12px';
        none.style.color = '#ddd';
        this.dropdown.appendChild(none);
      }
    });
    _defineProperty(this, "selectDropdown", e => {
      const li = e.target;
      const pen = this.store.pens[this.inputDiv.dataset.penId];
      if (!li || !pen || !pen.dropdownList) {
        return;
      }
      const index = +li.dataset.i;
      const dropdown = pen.dropdownList[index];
      if (!dropdown) {
        return;
      }
      const initPens = [deepClone(pen, true)];
      if (typeof dropdown === 'object') {
        this.updateValue(pen, {
          ...dropdown
        });
        pen.calculative.text = undefined;
        this.calcActiveRect();
      } else {
        pen.text = dropdown + '';
      }
      this.inputDiv.innerText = pen.text;
      // this.dropdown.style.display = 'none';
      // this.inputRight.style.transform = 'rotate(135deg)';
      this.hideInput();
      this.pushHistory({
        type: EditType.Update,
        pens: [deepClone(pen, true)],
        initPens
      });
      this.render();
      this.store.emitter.emit('change', pen);
      this.store.emitter.emit('valueUpdate', pen);
    });
    _defineProperty(this, "inFitBorder", pt => {
      let current = undefined;
      const width = this.store.data.width || this.store.options.width;
      const height = this.store.data.height || this.store.options.height;
      let point = {
        x: (pt.x - this.store.data.origin.x) / this.store.data.scale,
        y: (pt.y - this.store.data.origin.y) / this.store.data.scale
      };
      const fit = this.canvasImage.activeFit;
      // if (pointInRect(point, { x:fit.x-0.01, y:0, width, height })) {
      this.externalElements.style.cursor = 'default';
      if (point.y > height * fit.y - 10 && point.y < height * fit.y + 10) {
        current = 'top';
        this.externalElements.style.cursor = 'row-resize';
      }
      if (point.y > height * (fit.y + fit.height) - 10 && point.y < height * (fit.y + fit.height) + 10) {
        current = 'bottom';
        this.externalElements.style.cursor = 'row-resize';
      }
      if (point.x > width * fit.x - 10 && point.x < width * fit.x) {
        current = 'left';
        this.externalElements.style.cursor = 'col-resize';
      }
      if (point.x > width * (fit.x + fit.width) - 10 && point.x < width * (fit.x + fit.width) + 10) {
        current = 'right';
        this.externalElements.style.cursor = 'col-resize';
      }
      // }
      this.canvasImage.currentFit = current;
    });
    this.parent = parent;
    this.parentElement = parentElement;
    this.store = store;
    this.canvasTemplate = new CanvasTemplate(parentElement, store);
    this.canvasTemplate.canvas.style.zIndex = '1';
    this.canvasImageBottom = new CanvasImage(parentElement, store, true);
    this.canvasImageBottom.canvas.style.zIndex = '2';
    parentElement.appendChild(this.canvas);
    this.canvas.style.position = 'absolute';
    this.canvas.style.backgroundRepeat = 'no-repeat';
    this.canvas.style.backgroundSize = '100% 100%';
    this.canvas.style.zIndex = '3';
    this.canvasImage = new CanvasImage(parentElement, store);
    this.canvasImage.canvas.style.zIndex = '4';
    this.magnifierCanvas = new MagnifierCanvas(this, parentElement, store);
    this.magnifierCanvas.canvas.style.zIndex = '5';
    this.externalElements.style.position = 'absolute';
    this.externalElements.style.left = '0';
    this.externalElements.style.top = '0';
    this.externalElements.style.outline = 'none';
    this.externalElements.style.background = 'transparent';
    this.externalElements.style.zIndex = '5';
    parentElement.style.position = 'relative';
    parentElement.appendChild(this.externalElements);
    this.createInput();
    this.tooltip = new Tooltip(parentElement, store);
    this.tooltip.box.onmouseleave = e => {
      this.patchFlags = true;
      this.store.lastHover && (this.store.lastHover.calculative.hover = false);
      let hover = this.store.data.pens.find(item => item.calculative.hover === true);
      setHover(hover, false);
    };
    this.dialog = new Dialog(parentElement);
    this.title = new Title(parentElement);
    if (this.store.options.scroll) {
      this.scroll = new Scroll(this);
    }
    this.store.dpiRatio = globalThis.devicePixelRatio || 1;
    if (this.store.dpiRatio < 1) {
      this.store.dpiRatio = 1;
    } else if (this.store.dpiRatio > 1 && this.store.dpiRatio < 1.5) {
      this.store.dpiRatio = 1.5;
    }
    this.clientRect = this.externalElements.getBoundingClientRect();
    this.listen();
    window?.addEventListener('resize', this.onResize);
    window?.addEventListener('scroll', this.onScroll);
    window?.addEventListener('message', this.onMessage);
  }
  listen() {
    // ios
    this.externalElements.addEventListener('gesturestart', this.onGesturestart);
    this.externalElements.ondragover = e => e.preventDefault();
    this.externalElements.ondrop = this.ondrop;
    this.externalElements.oncontextmenu = e => e.preventDefault();
    this.store.options.interval = 50;
    this.externalElements.ontouchstart = this.ontouchstart;
    this.externalElements.ontouchmove = this.ontouchmove;
    this.externalElements.ontouchend = this.ontouchend;
    this.externalElements.onmousedown = e => {
      this.onMouseDown({
        x: e.offsetX,
        y: e.offsetY,
        clientX: e.clientX,
        clientY: e.clientY,
        pageX: e.pageX,
        pageY: e.pageY,
        ctrlKey: e.ctrlKey || e.metaKey,
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        buttons: e.buttons
      });
    };
    this.externalElements.onmousemove = e => {
      if (e.target !== this.externalElements) {
        return;
      }
      this.onMouseMove({
        x: e.offsetX,
        y: e.offsetY,
        clientX: e.clientX,
        clientY: e.clientY,
        pageX: e.pageX,
        pageY: e.pageY,
        ctrlKey: e.ctrlKey || e.metaKey,
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        buttons: e.buttons
      });
    };
    this.externalElements.onmouseup = e => {
      this.onMouseUp({
        x: e.offsetX,
        y: e.offsetY,
        clientX: e.clientX,
        clientY: e.clientY,
        pageX: e.pageX,
        pageY: e.pageY,
        ctrlKey: e.ctrlKey || e.metaKey,
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        buttons: e.buttons,
        button: e.button
      });
    };
    this.externalElements.onmouseleave = e => {
      //离开画布取消所有选中
      this.store.data.pens.forEach(pen => {
        if (pen.calculative.hover) {
          pen.calculative.hover = false;
        }
      });
      if (this.store.hover) {
        this.store.hover.calculative.hover = false;
        this.store.hover = undefined;
      }
      this.render();
      if (e.toElement !== this.tooltip.box && e.toElement !== this.tooltip.arrowUp && e.toElement !== this.tooltip.arrowDown) {
        this.tooltip.hide();
        this.store.lastHover = undefined;
      }
    };
    this.externalElements.ondblclick = this.ondblclick;
    this.externalElements.tabIndex = 0;
    this.externalElements.onblur = () => {
      this.mouseDown = undefined;
    };
    this.externalElements.onwheel = this.onwheel;
    document.addEventListener('copy', this.onCopy);
    document.addEventListener('cut', this.onCut);
    document.addEventListener('paste', this.onPaste);
    switch (this.store.options.keydown) {
      case KeydownType.Document:
        document.addEventListener('keydown', this.onkeydown);
        document.addEventListener('keyup', this.onkeyup);
        break;
      case KeydownType.Canvas:
        this.externalElements.addEventListener('keydown', this.onkeydown);
        this.externalElements.addEventListener('keyup', this.onkeyup);
        break;
    }
  }
  /**
   * 分割连线的锚点，变成两条线
   * @param line 连线
   * @param anchor 锚点，连线的某个锚点，引用相同
   */
  splitLine(line, anchor) {
    const worldAnchors = line.calculative.worldAnchors;
    const index = worldAnchors.findIndex(a => a === anchor);
    if ([-1, 0, worldAnchors.length - 1].includes(index)) {
      // 没找到，起终点不处理
      return;
    }
    const initLine = deepClone(line, true);
    const newLine = deepClone(line, true);
    const id = s8();
    newLine.id = id;
    newLine.calculative.canvas = this;
    newLine.calculative.active = false;
    newLine.calculative.hover = false;
    // index 作为公共点
    const preAnchors = deepClone(worldAnchors.slice(0, index + 1));
    const laterAnchors = deepClone(worldAnchors.slice(index)).map(a => {
      a.penId = id;
      return a;
    });
    line.calculative.worldAnchors = preAnchors;
    newLine.calculative.worldAnchors = laterAnchors;
    this.initLineRect(line);
    this.initLineRect(newLine);
    this.store.data.pens.push(newLine);
    this.store.pens[id] = newLine;
    this.pushHistory({
      type: EditType.Add,
      pens: [deepClone(newLine, true)],
      step: 2
    });
    this.pushHistory({
      type: EditType.Update,
      initPens: [initLine],
      pens: [deepClone(line, true)],
      step: 2
    });
  }
  translateAnchor(x, y) {
    this.movingAnchor.x += x;
    this.movingAnchor.y += y;
    // 点不在范围内，移动到范围内
    const penId = this.movingAnchor.penId;
    if (penId) {
      const pen = this.store.pens[penId];
      const rect = pen.calculative.worldRect;
      if (this.movingAnchor.x < rect.x) {
        this.movingAnchor.x = rect.x;
      } else if (this.movingAnchor.x > rect.ex) {
        this.movingAnchor.x = rect.ex;
      }
      if (this.movingAnchor.y < rect.y) {
        this.movingAnchor.y = rect.y;
      } else if (this.movingAnchor.y > rect.ey) {
        this.movingAnchor.y = rect.ey;
      }
      const anchor = calcRelativePoint(this.movingAnchor, rect);
      // 更改 pen 的 anchors 属性
      const index = pen.anchors.findIndex(anchor => anchor.id === this.movingAnchor.id);
      pen.anchors[index] = anchor;
      this.patchFlags = true;
    }
  }
  async fileToPen(file, isGif) {
    let url = '';
    if (this.store.options.uploadFn) {
      url = await this.store.options.uploadFn(file);
    } else if (this.store.options.uploadUrl) {
      url = await uploadFile(file, this.store.options.uploadUrl, this.store.options.uploadParams, this.store.options.uploadHeaders);
    } else {
      url = await fileToBase64(file);
    }
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        globalStore.htmlElements[url] = img;
        resolve({
          width: img.width,
          height: img.height,
          name: isGif ? 'gif' : 'image',
          image: url
        });
      };
      img.onerror = e => {
        reject(e);
      };
      img.crossOrigin = 'anonymous';
      img.src = url;
    });
  }
  async dropPens(pens, e) {
    this.randomIdObj = {};
    for (const pen of pens) {
      // 只修改 树根处的 祖先节点, randomCombineId 会递归更改子节点
      !pen.parentId && this.randomCombineId(pen, pens);
    }
    if (Object.keys(this.randomIdObj).length !== 0) {
      for (const pen of pens) {
        if (pen.type) {
          pen.anchors[0].connectTo = this.randomIdObj[pen.anchors[0].connectTo];
          pen.anchors[pen.anchors.length - 1].connectTo = this.randomIdObj[pen.anchors[pen.anchors.length - 1].connectTo];
        } else {
          pen.connectedLines?.forEach(item => {
            item.lineAnchor = this.randomIdObj[item.lineAnchor];
            item.lineId = this.randomIdObj[item.lineId];
          });
        }
      }
    }
    for (const pen of pens) {
      // TODO: randomCombineId 会更改 id， 此处应该不存在空 id
      if (!pen.id) {
        pen.id = s8();
      }
      !pen.calculative && (pen.calculative = {
        canvas: this
      });
      this.store.pens[pen.id] = pen;
    }
    // // 计算区域
    // for (const pen of pens) {
    //   // 组合节点才需要提前计算
    //   Array.isArray(pen.children) && pen.children.length > 0 && this.updatePenRect(pen);
    // }
    let num = 0;
    let lastH = 0;
    let lastW = 0;
    for (const pen of pens) {
      if (!pen.parentId) {
        pen.width *= this.store.data.scale;
        pen.height *= this.store.data.scale;
        pen.x = e.x - pen.width / 2 + lastW;
        pen.y = e.y - pen.height / 2 + lastH;
        if (pen.tags && pen.tags.includes('meta3d')) {
          pen.x = this.store.data.origin.x;
          pen.y = this.store.data.origin.y;
        }
        if (pen.dataset) {
          if (num % 2 === 0) {
            lastW = pen.width - 40 * this.store.data.scale;
          } else {
            lastW = 0;
          }
          num++;
          if (num % 2 === 0) {
            lastH += pen.height + 10 * this.store.data.scale;
          }
        }
      }
    }
    //大屏区域
    const width = this.store.data.width || this.store.options.width;
    const height = this.store.data.height || this.store.options.height;
    if (width && height) {
      let rect = {
        x: this.store.data.origin.x,
        y: this.store.data.origin.y,
        width: width * this.store.data.scale,
        height: height * this.store.data.scale
      };
      let flag = true;
      for (const pen of pens) {
        if (!pen.parentId) {
          let points = [{
            x: pen.x,
            y: pen.y
          }, {
            x: pen.x + pen.width,
            y: pen.y
          }, {
            x: pen.x,
            y: pen.y + pen.height
          }, {
            x: pen.x + pen.width,
            y: pen.y + pen.height
          }, {
            x: pen.x + pen.width / 2,
            y: pen.y + pen.height / 2
          }];
          if (pen.x === rect.x && pen.y === rect.y && pen.width === rect.width && pen.height === rect.height || points.some(point => pointInRect(point, rect))) {
            flag = false;
            //严格范围模式下对齐大屏边界
            if (this.store.options.strictScope) {
              if (pen.x < rect.x) {
                pen.x = rect.x;
              }
              if (pen.y < rect.y) {
                pen.y = rect.y;
              }
              if (pen.x + pen.width > rect.x + rect.width) {
                pen.x = rect.x + rect.width - pen.width;
              }
              if (pen.y + pen.height > rect.y + rect.height) {
                pen.y = rect.y + rect.height - pen.height;
              }
            }
            break;
          }
        }
      }
      if (flag) {
        console.info('画笔在大屏范围外');
        return;
      }
    }
    await this.addPens(pens, true);
    this.active(pens.filter(pen => !pen.parentId));
    this.render();
    this.externalElements.focus(); // 聚焦
  }
  randomCombineId(pen, pens, parentId) {
    let beforeIds = null;
    if (pen.type) {
      if (pen.anchors[0].connectTo || pen.anchors[pen.anchors.length - 1].connectTo) {
        beforeIds = [pen.id, pen.anchors[0].id, pen.anchors[pen.anchors.length - 1].id];
      }
    } else {
      if (pen.connectedLines && pen.connectedLines.length) {
        beforeIds = [pen.id];
      }
    }
    randomId(pen);
    if (beforeIds) {
      if (beforeIds.length === 1) {
        this.randomIdObj[beforeIds[0]] = pen.id;
      } else {
        this.randomIdObj[beforeIds[0]] = pen.id;
        this.randomIdObj[beforeIds[1]] = pen.anchors[0].id;
        this.randomIdObj[beforeIds[2]] = pen.anchors[pen.anchors.length - 1].id;
      }
    }
    //处理链接关系
    pen.parentId = parentId;
    const newChildren = [];
    if (Array.isArray(pen.children)) {
      for (const childId of pen.children) {
        const childPen = pens.find(pen => pen.id === childId);
        childPen && newChildren.push(this.randomCombineId(childPen, pens, pen.id).id);
        // TODO: 既已成为 组合节点，连接关系是否仍需要考虑呢？
      }
    }
    pen.children = newChildren;
    return pen;
  }
  async addPens(pens, history) {
    if (this.beforeAddPens && (await this.beforeAddPens(pens)) != true) {
      return [];
    }
    const list = [];
    for (const pen of pens) {
      if (this.beforeAddPen && this.beforeAddPen(pen) != true) {
        continue;
      }
      this.makePen(pen);
      list.push(pen);
    }
    this.render();
    this.store.emitter.emit('add', list);
    if (history) {
      this.pushHistory({
        type: EditType.Add,
        pens: deepClone(list, true)
      });
    }
    return list;
  }
  /**
   * 获取初始化的 pencilLine
   * @param pt 需包含 penId
   */
  getInitPencilLine(pt) {
    const {
      data,
      options
    } = this.store;
    const scale = data.scale;
    const lineWidth = data.lineWidth || 1;
    return {
      id: pt.penId,
      name: 'line',
      x: pt.x,
      y: pt.y,
      type: PenType.Line,
      calculative: {
        canvas: this,
        pencil: true,
        active: true,
        worldAnchors: [pt],
        lineWidth: lineWidth * scale
      },
      fromArrow: data.fromArrow || options.fromArrow,
      toArrow: data.toArrow || options.toArrow,
      lineWidth
    };
  }
  /**
   * 获取初始化的 drawingLine
   * @param pt 需包含 penId
   */
  createDrawingLine(pt) {
    this.inactive();
    const {
      data,
      options
    } = this.store;
    const scale = data.scale;
    const lineWidth = data.lineWidth || 1;
    pt.penId = s8();
    return {
      id: pt.penId,
      name: 'line',
      lineName: this.drawingLineName,
      x: pt.x,
      y: pt.y,
      type: PenType.Line,
      calculative: {
        canvas: this,
        active: true,
        worldAnchors: [pt],
        lineWidth: lineWidth * scale
      },
      fromArrow: data.fromArrow || options.fromArrow,
      toArrow: data.toArrow || options.toArrow,
      lineWidth
    };
  }
  addRuleLine(e) {
    const {
      x: offsetX,
      y: offsetY,
      scale,
      origin
    } = this.store.data;
    // 靠近左上角的 x ，y
    const x = e.x + offsetX;
    const y = e.y + offsetY;
    let lineX = e.x;
    let lineY = e.y;
    let width = 0;
    let height = 0;
    let otherPX = 0;
    let otherPY = 0;
    if (x <= y && x < 20) {
      // 绘制一条水平线
      lineX = -offsetX;
      width = this.width;
      otherPX = 1;
      if (!e.ctrlKey) {
        //找最近的标尺线
        lineY = Math.round((lineY - origin.y) / (scale * 10)) * (scale * 10) + origin.y;
      }
    } else if (y < x && y < 20) {
      // 绘制一条垂直线
      lineY = -offsetY;
      height = this.height;
      otherPY = 1;
      if (!e.ctrlKey) {
        //找最近的标尺线
        lineX = Math.round((lineX - origin.x) / (scale * 10)) * (scale * 10) + origin.x;
      }
    } else {
      return;
    }
    this.addPen({
      isRuleLine: true,
      // locked: LockState.DisableMove,
      type: PenType.Line,
      name: 'line',
      lineName: 'line',
      x: lineX,
      y: lineY,
      width,
      height,
      color: this.store.options.ruleLineColor,
      anchors: [{
        x: 0,
        y: 0
      }, {
        x: otherPX,
        y: otherPY
      }]
    });
  }
  clearRuleLines() {
    this.delete(this.ruleLines);
  }
  get ruleLines() {
    return this.store.data.pens.filter(p => p.isRuleLine);
  }
  /**
   * @description 调整pen的坐标，让pen按照网格自动对齐
   * @author Joseph Ho
   * @date 14/11/2023
   * @memberof Canvas
   */
  alignPenToGrid(pen) {
    const autoAlignGrid = this.store.options.autoAlignGrid && this.store.data.grid;
    // 如果开启了自动网格,并且不是连线，则使pen对齐网格
    if (autoAlignGrid && !pen.type) {
      const gridSize = this.store.data.gridSize || this.store.options.gridSize;
      const {
        origin,
        scale
      } = this.store.data;
      const {
        x,
        y
      } = pen;
      const obj = {
        x,
        y
      };
      const rect = this.getPenRect(pen);
      // 算出偏移了多少个网格
      const m = parseInt((rect.x / gridSize).toFixed());
      const n = parseInt((rect.y / gridSize).toFixed());
      const x1 = m * gridSize;
      const y1 = n * gridSize;
      // 算出最终的偏移坐标
      obj.x = origin.x + x1 * scale;
      obj.y = origin.y + y1 * scale;
      Object.assign(pen, obj);
      pen.onMove?.(pen);
      this.updatePenRect(pen);
      this.calcActiveRect();
      this.getSizeCPs();
    }
  }
  /**
   * 拖拽结束，数据更新到 active.pens
   */
  movedActivePens(readyConnect) {
    // 鼠标松手才更新，此处是更新前的值
    //follower
    let movedPens = this.getAllFollowersByPens(this.store.active, false);
    const initPens = deepClone(movedPens, true);
    // const pens = deepClone(this.store.active, true);
    const gridSize = this.store.data.gridSize || this.store.options.gridSize;
    const {
      origin,
      scale
    } = this.store.data;
    const autoAlignGrid = this.store.options.autoAlignGrid && this.store.data.grid;
    movedPens.forEach(pen => {
      const i = this.movingPens.findIndex(item => item.id === pen.id + movingSuffix);
      if (i < 0) {
        return;
      }
      const {
        x,
        y
      } = this.movingPens[i];
      const obj = {
        x,
        y
      };
      // 根据是否开启了自动网格对齐，来修正坐标
      if (autoAlignGrid && !this.movingPens[i].type) {
        const rect = this.getPenRect(this.movingPens[i]);
        // 算出偏移了多少个网格
        const m = parseInt((rect.x / gridSize).toFixed());
        const n = parseInt((rect.y / gridSize).toFixed());
        const x1 = m * gridSize;
        const y1 = n * gridSize;
        // 算出最终的偏移坐标
        obj.x = origin.x + x1 * scale;
        obj.y = origin.y + y1 * scale;
      }
      Object.assign(pen, obj);
      pen.onMove?.(pen);
      this.updatePenRect(pen);
      this.updateLines(pen);
      this.store.emitter.emit('updateLines', pen);
      // TODO: mouseup 中重复执行 patchFlagsLines
      this.patchFlagsLines.forEach(pen => {
        if (pen.type) {
          this.initLineRect(pen);
        }
      });
      this.patchFlagsLines.clear();
      pen.calculative.x = pen.x;
      pen.calculative.y = pen.y;
      if (pen.calculative.initRect) {
        pen.calculative.initRect.x = pen.calculative.x;
        pen.calculative.initRect.y = pen.calculative.y;
        pen.calculative.initRect.ex = pen.calculative.x + pen.calculative.width;
        pen.calculative.initRect.ey = pen.calculative.y + pen.calculative.height;
      }
      calcChildrenInitRect(pen);
    });
    // active 消息表示拖拽结束
    // this.store.emitter.emit('active', this.store.active);
    this.initImageCanvas(this.store.active);
    this.initTemplateCanvas(this.store.active);
    // 避免选中图元的出错情况，this.dock为undefined
    if (!this.dock) return;
    const {
      xDock,
      yDock
    } = this.dock;
    let dockPen;
    if (xDock) {
      dockPen = this.store.pens[xDock.penId];
    }
    if (!dockPen && yDock) {
      dockPen = this.store.pens[yDock.penId];
    }
    const pens = deepClone(this.store.active, true);
    // 移动到连线端点，自动连线
    if (readyConnect && this.store.active.length === 1 && dockPen?.type === 1 && (xDock?.anchorId || yDock?.anchorId)) {
      const from = getFromAnchor(dockPen);
      const to = getToAnchor(dockPen);
      if (xDock?.anchorId) {
        const anchor = this.store.pens[this.store.active[0].id + movingSuffix].calculative.worldAnchors.find(item => item.id === xDock.anchorId);
        if (anchor.x === from.x && anchor.y === from.y) {
          initPens.push(deepClone(dockPen, true));
          connectLine(this.store.active[0], anchor, dockPen, from);
          pens.push(deepClone(dockPen, true));
        } else if (anchor.x === to.x && anchor.y === to.y) {
          initPens.push(deepClone(dockPen, true));
          connectLine(this.store.active[0], anchor, dockPen, to);
          pens.push(deepClone(dockPen, true));
        }
      } else if (yDock?.anchorId) {
        const anchor = this.store.pens[this.store.active[0].id + movingSuffix].calculative.worldAnchors.find(item => item.id === yDock.anchorId);
        if (anchor.x === from.x && anchor.y === from.y) {
          initPens.push(deepClone(dockPen, true));
          connectLine(this.store.active[0], anchor, dockPen, from);
          pens.push(deepClone(dockPen, true));
        } else if (anchor.x === to.x && anchor.y === to.y) {
          initPens.push(deepClone(dockPen, true));
          connectLine(this.store.active[0], anchor, dockPen, to);
          pens.push(deepClone(dockPen, true));
        }
      }
    }
    // 如果开启自动网格对齐，则需要重算activeRect和sizeCPs
    if (autoAlignGrid) {
      this.calcActiveRect();
      this.getSizeCPs();
    }
    // 此处是更新后的值
    this.pushHistory({
      type: EditType.Update,
      pens,
      initPens
    });
    this.store.emitter.emit('translatePens', pens);
  }
  /**
   * 复制移动后的笔
   */
  copyMovedPens() {
    // 复制行为
    this.copy(this.store.active.map((pen, i) => {
      // TODO: 移动只更改 x,y 值，不更新其他属性
      // 若需要更改 anchors ，注意 anchors connectTo 问题
      // const { x, y, width, height, anchors } = this.movingPens[i];
      /**
       * TODO: line 类型无法取到移动后的 x，y 值
       * 所以 patchFlagsLines 需要放到 copyMovedPens 前
       * */
      const {
        x,
        y
      } = this.movingPens[i];
      this.updateLines(pen); //复制前更新被复制节点的连接关系
      return {
        ...pen,
        x,
        y
      };
    }));
    // 偏移量 0
    this.pasteOffset = false;
    this.paste();
  }
  /**
   * 若本次改变的画笔存在图片，并且在上层 or 下层，需要擦除上层 or 下层
   * 子节点中包含图片，也需要重绘
   * @param pens 本次改变的 pens
   */
  initImageCanvas(pens) {
    pens.some(pen => this.hasImage(pen, false)) && this.canvasImage.init();
    pens.some(pen => this.hasImage(pen, true)) && this.canvasImageBottom.init();
  }
  initTemplateCanvas(pens) {
    // pens.some((pen) => pen.template !== undefined) &&
    //   this.canvasTemplate.init();
    pens.some(pen => pen.canvasLayer === CanvasLayer.CanvasTemplate) && this.canvasTemplate.init();
  }
  hasImage(pen, isBottom) {
    // if (pen.image && pen.name !== 'gif' && !pen.isBottom == !isBottom) {
    //   return true;
    // }
    if (pen.image && pen.name !== 'gif') {
      if (isBottom) {
        if (pen.canvasLayer === CanvasLayer.CanvasImageBottom) {
          return true;
        } else {
          return false;
        }
      } else {
        if (pen.canvasLayer === CanvasLayer.CanvasImage) {
          return true;
        } else {
          return false;
        }
      }
    }
    return pen.children?.some(childId => {
      const child = this.store.pens[childId];
      return child && this.hasImage(child, isBottom);
    });
  }
  inactive(drawing) {
    if (!this.store.active.length) {
      return;
    }
    this.initTemplateCanvas(this.store.active);
    this.store.active.forEach(pen => {
      pen.calculative.active = undefined;
      pen.calculative.activeAnchor = undefined;
      pen.calculative.hover = false;
      setChildrenActive(pen, false);
    });
    !drawing && this.store.emitter.emit('inactive', this.store.active);
    this.store.active = [];
    this.activeRect = undefined;
    this.sizeCPs = undefined;
    this.store.activeAnchor = undefined;
    this.patchFlags = true;
  }
  active(pens, emit = true) {
    if (this.store.active) {
      emit && this.store.emitter.emit('inactive', this.store.active);
      for (const pen of this.store.active) {
        pen.calculative.active = undefined;
        pen.calculative.hover = false;
        setChildrenActive(pen, false);
      }
    }
    this.store.active = [];
    pens.forEach(pen => {
      pen.calculative.active = true;
      setChildrenActive(pen);
    });
    this.store.active.push(...pens);
    this.activeRect = undefined;
    this.calcActiveRect();
    this.initTemplateCanvas(pens);
    this.patchFlags = true;
    emit && this.store.emitter.emit('active', this.store.active);
  }
  getSizeCPs() {
    this.sizeCPs = rectToPoints(this.activeRect);
    // 正上 正右 正下 正左
    const pts = [{
      x: 0.5,
      y: 0
    }, {
      x: 1,
      y: 0.5
    }, {
      x: 0.5,
      y: 1
    }, {
      x: 0,
      y: 0.5
    }];
    const {
      x,
      y,
      width,
      height,
      rotate,
      center
    } = this.activeRect;
    pts.forEach(pt => {
      const p = {
        x: pt.x * width + x,
        y: pt.y * height + y
      };
      rotatePoint(p, rotate, center);
      this.sizeCPs.push(p);
    });
  }
  getSpecialAngle(to, last) {
    //快捷定位到特殊角度
    let angle = 0;
    let angleArr = [0, 30, 45, 60, 90, 120, 150, 135, 180];
    //获取实际角度
    if (to.x - last.x !== 0) {
      angle = Math.atan((last.y - to.y) / (to.x - last.x)) * 180 / Math.PI;
      if (to.x < last.x) {
        if (angle > 0) {
          angle -= 180;
        } else {
          angle += 180;
        }
      }
    } else {
      if (last.y > to.y) {
        angle = 90;
      } else if (last.y < to.y) {
        angle = -90;
      }
    }
    //取最近角度
    // let _min = 999;
    // let index = -1;
    // for (let i = 0; i < angleArr.length; i++) {
    //   if (angle < 0) {
    //     if (Math.abs(angle + angleArr[i]) < _min) {
    //       index = i;
    //       _min = Math.abs(angle + angleArr[i]);
    //     }
    //   } else {
    //     if (Math.abs(angle - angleArr[i]) < _min) {
    //       index = i;
    //       _min = Math.abs(angle - angleArr[i]);
    //     }
    //   }
    // }
    // if (angle < 0) {
    //   angle = -angleArr[index];
    // } else {
    //   angle = angleArr[index];
    // }
    angle = Math.round(angle / 15) * 15;
    let length = Math.sqrt((last.x - to.x) * (last.x - to.x) + (last.y - to.y) * (last.y - to.y));
    to.x = last.x + Math.cos(angle / 180 * Math.PI) * length;
    to.y = last.y - Math.sin(angle / 180 * Math.PI) * length;
  }
  clearHover() {
    this.hoverType = HoverType.None;
    this.store.hover = null;
    this.store.hoverAnchor = null;
  }
  inAnchor(pt, pen, anchor) {
    this.store.hoverAnchor = undefined;
    this.movingAnchor = undefined;
    if (!anchor || anchor.locked > LockState.DisableEdit) {
      return HoverType.None;
    }
    if (!(pen.type && pen.calculative.active) && this.store.options.disableAnchor || pen.disableAnchor) {
      return HoverType.None;
    }
    if ((this.mouseDown || this.drawingLine) && pen.name === 'line' && anchor.connectTo) {
      const connectPen = this.findOne(anchor.connectTo);
      if (connectPen?.calculative && !connectPen?.calculative.active) {
        pen = connectPen;
        const connectAnchor = connectPen.calculative.worldAnchors.find(item => item.id === anchor.anchorId);
        connectAnchor && (anchor = connectAnchor);
      }
    }
    if (anchor.twoWay === TwoWay.Disable && pen.name !== 'line') {
      return HoverType.None;
    }
    if (pen.name === 'line' && anchor.connectTo) {
      let _anchor = this.findOne(anchor.connectTo)?.anchors.find(item => item.id === anchor.anchorId);
      if (_anchor && _anchor.twoWay) {
        return HoverType.None;
      }
    }
    if (this.drawingLine) {
      if (anchor.twoWay === TwoWay.Out) {
        return HoverType.None;
      }
    } else {
      if (this.mouseDown && this.hoverType === HoverType.LineAnchor) {} else if (anchor.twoWay === TwoWay.In) {
        return HoverType.None;
      }
    }
    if (hitPoint(pt, anchor, this.pointSize, anchor.penId ? this.store.pens[anchor.penId] : undefined)) {
      if (anchor !== this.store.hoverAnchor) {
        this.patchFlags = true;
      }
      this.store.hoverAnchor = anchor;
      this.store.hover = pen;
      if (pen.type) {
        if (anchor.connectTo && !pen.calculative.active) {
          this.store.hover = this.store.pens[anchor.connectTo];
          if (this.store.hover) {
            this.store.hoverAnchor = this.store.hover.calculative.worldAnchors.find(a => a.id === anchor.anchorId);
            if (!this.store.hoverAnchor) {
              return HoverType.None;
            }
            this.externalElements.style.cursor = 'crosshair';
            return HoverType.NodeAnchor;
          }
        }
        if (this.hotkeyType === HotkeyType.AddAnchor) {
          this.externalElements.style.cursor = 'vertical-text';
        } else {
          this.externalElements.style.cursor = 'pointer';
        }
        return HoverType.LineAnchor;
      }
      if (this.hotkeyType === HotkeyType.AddAnchor) {
        this.externalElements.style.cursor = 'vertical-text';
      } else {
        this.externalElements.style.cursor = 'crosshair';
      }
      return HoverType.NodeAnchor;
    }
    if (!this.mouseDown && pen.type) {
      if (pen.calculative.active && anchor.prev && hitPoint(pt, anchor.prev, this.pointSize)) {
        this.store.hoverAnchor = anchor;
        this.store.hover = pen;
        this.externalElements.style.cursor = 'pointer';
        return HoverType.LineAnchorPrev;
      }
      if (pen.calculative.active && anchor.next && hitPoint(pt, anchor.next, this.pointSize)) {
        this.store.hoverAnchor = anchor;
        this.store.hover = pen;
        this.externalElements.style.cursor = 'pointer';
        return HoverType.LineAnchorNext;
      }
    }
    return HoverType.None;
  }
  resize(w, h) {
    w = w || this.parentElement.clientWidth;
    h = h || this.parentElement.clientHeight;
    this.width = w;
    this.height = h;
    this.canvasRect = {
      x: 0,
      y: 0,
      width: w,
      height: h
    };
    rect_calcRightBottom(this.canvasRect);
    this.canvas.style.width = w + 'px';
    this.canvas.style.height = h + 'px';
    this.externalElements.style.width = w + 'px';
    this.externalElements.style.height = h + 'px';
    this.canvasTemplate.resize(w, h);
    this.canvasImage.resize(w, h);
    this.canvasImageBottom.resize(w, h);
    this.magnifierCanvas.resize(w, h);
    w = w * this.store.dpiRatio | 0;
    h = h * this.store.dpiRatio | 0;
    this.canvas.width = w;
    this.canvas.height = h;
    this.offscreen.width = w;
    this.offscreen.height = h;
    this.clientRect = this.externalElements.getBoundingClientRect();
    this.canvas.getContext('2d').scale(this.store.dpiRatio, this.store.dpiRatio);
    this.offscreen.getContext('2d').scale(this.store.dpiRatio, this.store.dpiRatio);
    this.offscreen.getContext('2d').textBaseline = 'middle';
    // TODO 窗口大小变化没有刷新图纸
    for (const pen of this.store.data.pens) {
      if (pen.isRuleLine) {
        if (!pen.width) {
          pen.height = this.height;
        } else if (!pen.height) {
          pen.width = this.width;
        }
      }
      calcInView(pen);
    }
    this.render();
  }
  clearCanvas() {
    this.activeRect = undefined;
    this.sizeCPs = undefined;
    this.canvas.getContext('2d').clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.offscreen.getContext('2d').clearRect(0, 0, this.offscreen.width, this.offscreen.height);
    if (!this.store.data.template) {
      this.canvasTemplate.clear();
    }
    this.canvasImage.clear();
    this.canvasImageBottom.clear();
  }
  async addPen(pen, history, emit) {
    if (this.beforeAddPens && (await this.beforeAddPens([pen])) != true) {
      return;
    }
    if (this.beforeAddPen && this.beforeAddPen(pen) != true) {
      return;
    }
    this.makePen(pen);
    this.active([pen]);
    this.render();
    emit && this.store.emitter.emit('add', [pen]);
    if (history) {
      this.pushHistory({
        type: EditType.Add,
        pens: [pen]
      });
    }
    return pen;
  }
  pushHistory(action) {
    if (this.store.data.locked) {
      return;
    }
    const {
      origin,
      scale
    } = this.store.data;
    action.origin = deepClone(origin);
    action.scale = scale;
    if (action.type !== EditType.Update && action.pens) {
      action.pens.forEach(pen => {
        pen.calculative && (pen.calculative.layer = this.store.data.pens.findIndex(p => p.id === pen.id));
      });
    }
    if (this.store.historyIndex < this.store.histories.length - 1) {
      this.store.histories.splice(this.store.historyIndex + 1, this.store.histories.length - this.store.historyIndex - 1);
    }
    action.pens?.forEach(pen => {
      let found;
      if (action.initPens) {
        for (const p of action.initPens) {
          if (p.id === pen.id) {
            found = p;
          }
        }
      }
      if (found) {
        for (const k in pen) {
          if (found[k] == undefined) {
            found[k] = undefined;
          }
        }
      }
    });
    this.store.histories.push(action);
    this.store.historyIndex = this.store.histories.length - 1;
    this.store.emitter.emit('update', {
      previous: action.initPens,
      current: action.pens
    });
  }
  undo() {
    if (this.store.data.locked || this.store.historyIndex == null || this.store.historyIndex < 0) {
      return;
    }
    const action = this.store.histories[this.store.historyIndex--];
    this.doEditAction(action, true);
    let step = action.step;
    while (step > 1) {
      const action = this.store.histories[this.store.historyIndex--];
      this.doEditAction(action, true);
      step--;
    }
    if (action.type == EditType.Add || action.type == EditType.Delete || action.type == EditType.Update) {
      this.activeHistory();
    }
  }
  redo() {
    if (this.store.data.locked || this.store.historyIndex == null || this.store.historyIndex > this.store.histories.length - 2) {
      return;
    }
    const action = this.store.histories[++this.store.historyIndex];
    this.doEditAction(action, false);
    let step = action.step;
    while (step > 1) {
      const action = this.store.histories[++this.store.historyIndex];
      this.doEditAction(action, false);
      step--;
    }
    if (action.type == EditType.Add || action.type == EditType.Delete || action.type == EditType.Update) {
      this.activeHistory();
    }
  }
  activeHistory() {
    let now = this.store.histories[this.store.historyIndex + 1];
    const pens = [];
    if (now && now.type === EditType.Update) {
      now.pens.forEach(pen => {
        pens.push(this.store.pens[pen.id]);
      });
      this.active(pens);
      return;
    }
    let before = this.store.histories[this.store.historyIndex];
    if (before && (before.type === EditType.Add || before.type === EditType.Delete)) {
      before.pens.forEach(pen => {
        pens.push(this.store.pens[pen.id]);
      });
      this.active(pens);
    }
  }
  doEditAction(action, undo) {
    this.inactive();
    this.store.hoverAnchor = undefined;
    this.store.hover = undefined;
    switch (action.type) {
      case EditType.Add:
        action.pens.forEach(aPen => {
          const pen = deepClone(aPen, true);
          const i = this.store.data.pens.findIndex(item => item.id === pen.id);
          if (i > -1) {
            pen.onDestroy?.(this.store.pens[pen.id]);
            this.store.data.pens.splice(i, 1);
            this.store.pens[pen.id] = undefined;
            if (!pen.calculative) {
              pen.calculative = {};
            }
            pen.calculative.canvas = this;
            this.store.animates.delete(pen);
            this.store.animateMap.delete(pen);
          }
        });
        action.type = EditType.Delete;
        break;
      case EditType.Update:
        const pens = undo ? action.initPens : action.pens;
        const unPens = undo ? action.pens : action.initPens;
        pens.forEach(p => {
          const pen = deepClone(p, true);
          const i = this.store.data.pens.findIndex(item => item.id === pen.id);
          if (i > -1) {
            pen.calculative = this.store.data.pens[i].calculative;
            if (this.store.data.pens[i].type && this.store.data.pens[i].lastConnected) {
              for (let key in this.store.data.pens[i].lastConnected) {
                this.store.pens[key] && (this.store.pens[key].connectedLines = this.store.data.pens[i].lastConnected[key]);
              }
            }
            this.store.data.pens[i] = pen;
            this.store.pens[pen.id] = pen;
            for (const k in pen) {
              if (typeof pen[k] !== 'object' || k === 'lineDash') {
                pen.calculative[k] = pen[k];
              }
            }
            pen.calculative.image = undefined;
            const rect = this.getPenRect(pen, action.origin, action.scale);
            this.setPenRect(pen, rect, false);
            this.updateLines(pen, true);
            if (pen.calculative.canvas.parent.isCombine(pen)) {
              let unPen = unPens.find(item => item.id === pen.id);
              inheritanceProps.forEach(key => {
                if (pen[key] !== unPen[key]) {
                  this.parent.setValue({
                    id: pen.id,
                    [key]: pen[key]
                  }, {
                    render: true,
                    doEvent: false
                  });
                }
              });
            }
          }
        });
        break;
      case EditType.Delete:
        action.pens.reverse().forEach(aPen => {
          const pen = deepClone(aPen, true);
          if (!pen.calculative) {
            pen.calculative = {};
          }
          this.store.data.pens.splice(pen.calculative?.layer !== -1 ? pen.calculative?.layer : this.store.data.pens.length, 0, pen);
          // 先放进去，pens 可能是子节点在前，而父节点在后
          this.store.pens[pen.id] = pen;
          if (pen.type && pen.lastConnected) {
            for (let key in pen.lastConnected) {
              this.store.pens[key] && (this.store.pens[key].connectedLines = pen.lastConnected[key]);
            }
          }
          pen.calculative.canvas = this;
        });
        action.pens.reverse().forEach(aPen => {
          const pen = this.store.pens[aPen.id];
          const rect = this.getPenRect(pen, action.origin, action.scale);
          this.setPenRect(pen, rect, false);
          pen.calculative.image = undefined;
          pen.calculative.backgroundImage = undefined;
          pen.calculative.strokeImage = undefined;
          this.loadImage(pen);
        });
        action.type = EditType.Add;
        break;
      case EditType.Replace:
        {
          // undo pens则为新的pen
          const pens = undo ? action.initPens : action.pens;
          const unPens = undo ? action.pens : action.initPens;
          // 删除旧的
          unPens.forEach(aPen => {
            const pen = deepClone(aPen, true);
            const i = this.store.data.pens.findIndex(item => item.id === pen.id);
            if (i > -1) {
              pen.onDestroy?.(this.store.data.pens.find(i => i.id === pen.id));
              const i = this.store.data.pens.findIndex(item => item.id === pen.id);
              this.store.data.pens.splice(i, 1);
              this.store.pens[pen.id] = undefined;
              if (!pen.calculative) {
                pen.calculative = {};
              }
              pen.calculative.canvas = this;
              this.store.animates.delete(pen);
              this.store.animateMap.delete(pen);
            }
          });
          // 放置新的
          pens.reverse().forEach(aPen => {
            const pen = deepClone(aPen, true);
            if (!pen.calculative) {
              pen.calculative = {};
            }
            this.store.data.pens.splice(pen.calculative?.layer !== -1 ? pen.calculative?.layer : this.store.data.pens.length, 0, pen);
            // 先放进去，pens 可能是子节点在前，而父节点在后
            this.store.pens[pen.id] = pen;
            if (pen.type && pen.lastConnected) {
              for (let key in pen.lastConnected) {
                this.store.pens[key] && (this.store.pens[key].connectedLines = pen.lastConnected[key]);
              }
            }
            pen.calculative.canvas = this;
          });
          pens.reverse().forEach(aPen => {
            const pen = this.store.data.pens.find(i => i.id === aPen.id);
            const rect = this.getPenRect(pen, action.origin, action.scale);
            this.setPenRect(pen, rect, false);
            pen.calculative.image = undefined;
            pen.calculative.backgroundImage = undefined;
            pen.calculative.strokeImage = undefined;
            this.loadImage(pen);
          });
          action.type = EditType.Replace;
          break;
        }
    }
    if (action.type === EditType.Update) {
      let pens = [...action.pens, ...action.initPens];
      this.initImageCanvas(pens);
      this.initTemplateCanvas(pens);
    } else {
      this.initImageCanvas(action.pens);
      this.initTemplateCanvas(action.pens);
    }
    this.parent.onSizeUpdate();
    this.render();
    this.store.emitter.emit(undo ? 'undo' : 'redo', action);
  }
  makePen(pen) {
    if (!pen.id) {
      pen.id = s8();
    }
    if (Math.abs(this.store.lastScale - this.store.data.scale) < 0.0001 && this.store.sameTemplate && this.store.templatePens[pen.id] &&
    // pen.template
    pen.canvasLayer === CanvasLayer.CanvasTemplate) {
      pen = this.store.templatePens[pen.id];
      this.store.data.pens.push(pen);
      this.updatePenRect(pen);
      return;
    }
    this.store.data.pens.push(pen);
    this.store.pens[pen.id] = pen;
    // 集中存储path，避免数据冗余过大
    if (pen.path) {
      !pen.pathId && (pen.pathId = s8());
      const paths = this.store.data.paths;
      !paths[pen.pathId] && (paths[pen.pathId] = pen.path);
      pen.path = undefined;
    }
    // end
    if (pen.lineWidth == undefined) {
      pen.lineWidth = 1;
    }
    const {
      fontSize,
      lineHeight
    } = this.store.options;
    if (!pen.fontSize) {
      pen.fontSize = fontSize >= 0 ? fontSize : 12;
    } else if (pen.fontSize < 0) {
      pen.fontSize = 0;
    }
    if (!pen.lineHeight) {
      pen.lineHeight = lineHeight;
    }
    if (pen.image && pen.name !== 'gif' && pen.canvasLayer === undefined) {
      if (pen.isBottom) {
        pen.canvasLayer = CanvasLayer.CanvasImageBottom;
      } else {
        pen.canvasLayer = CanvasLayer.CanvasImage;
      }
      delete pen.isBottom;
    }
    if (pen.template) {
      pen.canvasLayer = CanvasLayer.CanvasTemplate;
    }
    pen.calculative = {
      canvas: this,
      singleton: pen.calculative?.singleton
    };
    if (pen.video || pen.audio) {
      pen.calculative.onended = pen => {
        this.nextAnimate(pen);
      };
    }
    for (const k in pen) {
      if (typeof pen[k] !== 'object' || k === 'lineDash') {
        pen.calculative[k] = pen[k];
      }
    }
    pen.calculative.image = undefined;
    pen.calculative.backgroundImage = undefined;
    pen.calculative.strokeImage = undefined;
    if (!pen.anchors && globalStore.anchors[pen.name]) {
      if (!pen.anchors) {
        pen.anchors = [];
      }
      globalStore.anchors[pen.name](pen);
    }
    if (!pen.anchors) {
      const anchors = deepClone(this.store.options.defaultAnchors);
      anchors.forEach((item, index) => {
        item.id = `${index}`;
        item.penId = pen.id;
      });
      pen.anchors = anchors;
    }
    this.updatePenRect(pen);
    if (!pen.anchors && pen.calculative.worldAnchors) {
      pen.anchors = pen.calculative.worldAnchors.map(pt => {
        return calcRelativePoint(pt, pen.calculative.worldRect);
      });
    }
    !pen.rotate && (pen.rotate = 0);
    this.loadImage(pen);
    this.parent.penNetwork(pen);
  }
  drawline(mouse) {
    if (!this.drawingLine) {
      return;
    }
    this[this.drawingLineName]?.(this.store, this.drawingLine, mouse);
    this.store.path2dMap.set(this.drawingLine, globalStore.path2dDraws.line(this.drawingLine));
    this.patchFlags = true;
  }
  initLineRect(pen) {
    if (!pen) {
      return;
    }
    if (!pen.calculative.worldAnchors?.length) {
      this._del([pen]);
      return;
    }
    if (!isFinite(pen.x) || !isFinite(pen.x)) {
      return;
    }
    if (pen.x == null || pen.y == null) {
      return;
    }
    const rect = getLineRect(pen);
    if (!pen.parentId) {
      Object.assign(pen, rect);
    }
    const {
      fontSize,
      lineHeight
    } = this.store.options;
    if (!pen.fontSize) {
      pen.fontSize = fontSize >= 0 ? fontSize : 12;
      pen.calculative.fontSize = pen.fontSize * this.store.data.scale;
    }
    if (!pen.lineHeight) {
      pen.lineHeight = lineHeight;
      pen.calculative.lineHeight = pen.lineHeight;
    }
    calcCenter(rect);
    pen.calculative.worldRect = rect;
    calcPadding(pen, rect);
    calcTextRect(pen);
    calcInView(pen);
    pen.calculative && (pen.calculative.gradientAnimatePath = undefined);
    this.store.path2dMap.set(pen, globalStore.path2dDraws[pen.name](pen));
    if (pen.calculative.worldAnchors) {
      pen.anchors = pen.calculative.worldAnchors.map(pt => {
        return calcRelativePoint(pt, pen.calculative.worldRect);
      });
    }
  }
  drawingPencil() {
    lockedError(this.store);
    this.pencil = true;
    this.externalElements.style.cursor = 'crosshair';
  }
  stopPencil() {
    this.pencil = false;
    this.pencilLine = undefined;
    this.externalElements.style.cursor = 'default';
  }
  async finishDrawline(end) {
    if (!this.drawingLine) {
      return;
    }
    const from = getFromAnchor(this.drawingLine);
    let to = getToAnchor(this.drawingLine);
    if (to.isTemp) {
      this.drawingLine.calculative.worldAnchors.pop();
      to = getToAnchor(this.drawingLine);
    }
    if (!end) {
      !to.connectTo && this.drawingLine.calculative.worldAnchors.pop();
      if (getFromAnchor(this.drawingLine) === this.drawingLine.calculative.activeAnchor) {
        this.drawingLine = undefined;
        this.render();
        return;
      }
    }
    if (!from.connectTo || !to.connectTo) {
      if (this.store.options.disableEmptyLine) {
        // 有一端未连线，且 禁止创建空线条
        if (from.connectTo) {
          this.store.pens[from.connectTo].connectedLines = this.store.pens[from.connectTo].connectedLines.filter(item => item.lineId !== this.drawingLine.id);
        }
        this.drawingLine = undefined;
        this.render();
        return;
      }
    } else {
      if (this.store.options.disableRepeatLine) {
        // 两边都连上了锚点，且 禁止创建重复连线
        const line = this.store.data.pens.find(pen => {
          if (pen.type) {
            const penFrom = getFromAnchor(pen);
            const penTo = getToAnchor(pen);
            return samePoint(penFrom, from) && samePoint(penTo, to);
          }
        });
        if (line) {
          // 存在重复连线
          this.drawingLine = undefined;
          this.render();
          return;
        }
      }
    }
    const rect = getLineRect(this.drawingLine);
    Object.assign(this.drawingLine, rect);
    this.drawingLine.calculative.worldRect = rect;
    this.drawingLine.calculative.activeAnchor = getToAnchor(this.drawingLine);
    this.store.activeAnchor = this.drawingLine.calculative.activeAnchor;
    const allowAdd = (!this.beforeAddPens || (await this.beforeAddPens([this.drawingLine]))) && (!this.beforeAddPen || this.beforeAddPen(this.drawingLine));
    if (allowAdd) {
      this.initLineRect(this.drawingLine);
      this.store.data.pens.push(this.drawingLine);
      this.store.pens[this.drawingLine.id] = this.drawingLine;
      this.store.emitter.emit('add', [this.drawingLine]);
      this.active([this.drawingLine]);
      this.pushHistory({
        type: EditType.Add,
        pens: deepClone([this.drawingLine], true)
      });
    }
    this.store.path2dMap.set(this.drawingLine, globalStore.path2dDraws[this.drawingLine.name](this.drawingLine));
    this.drawingLine = undefined;
    this.drawingLineName = undefined;
    this.render();
  }
  async finishPencil() {
    if (this.pencilLine) {
      const anchors = simplify(this.pencilLine.calculative.worldAnchors, 10, 0, this.pencilLine.calculative.worldAnchors.length - 1);
      let p = getFromAnchor(this.pencilLine);
      anchors.unshift({
        id: p.id,
        penId: p.penId,
        x: p.x,
        y: p.y
      });
      p = getToAnchor(this.pencilLine);
      anchors.push({
        id: p.id,
        penId: p.penId,
        x: p.x,
        y: p.y
      });
      this.pencilLine.calculative.worldAnchors = smoothLine(anchors);
      if (this.pencilLine.calculative.worldAnchors.length > 1) {
        this.pencilLine.calculative.pencil = false;
        this.store.path2dMap.set(this.pencilLine, globalStore.path2dDraws[this.pencilLine.name](this.pencilLine));
        const allowAdd = (!this.beforeAddPens || (await this.beforeAddPens([this.pencilLine]))) && (!this.beforeAddPen || this.beforeAddPen(this.pencilLine));
        if (allowAdd) {
          this.initLineRect(this.pencilLine);
          this.store.data.pens.push(this.pencilLine);
          this.store.pens[this.pencilLine.id] = this.pencilLine;
          this.store.emitter.emit('add', [this.pencilLine]);
          this.active([this.pencilLine]);
          this.pushHistory({
            type: EditType.Add,
            pens: deepClone([this.pencilLine], true)
          });
        }
      }
      this.pencilLine = undefined;
      this.render();
    }
  }
  /**
   * 火狐浏览器无法绘制 svg 不存在 width height 的问题
   * 此方法手动添加 width 和 height 解决火狐浏览器绘制 svg
   * @param pen
   */
  firefoxLoadSvg(pen) {
    const img = new Image();
    // request the XML of your svg file
    const request = new XMLHttpRequest();
    request.open('GET', pen.image, true);
    request.onload = () => {
      // once the request returns, parse the response and get the SVG
      const parser = new DOMParser();
      const result = parser.parseFromString(request.responseText, 'text/xml');
      const inlineSVG = result.getElementsByTagName('svg')[0];
      const {
        width,
        height
      } = pen.calculative.worldRect;
      // add the attributes Firefox needs. These should be absolute values, not relative
      inlineSVG.setAttribute('width', `${width}px`);
      inlineSVG.setAttribute('height', `${height}px`);
      // convert the SVG to a data uri
      const svg64 = btoa(unescape(encodeURIComponent(new XMLSerializer().serializeToString(inlineSVG))));
      const image64 = 'data:image/svg+xml;base64,' + svg64;
      // set that as your image source
      img.src = image64;
      // do your canvas work
      img.onload = () => {
        pen.calculative.img = img;
        pen.calculative.imgNaturalWidth = img.naturalWidth || pen.iconWidth;
        pen.calculative.imgNaturalHeight = img.naturalHeight || pen.iconHeight;
        globalStore.htmlElements[pen.image] = img;
        this.imageLoaded();
        // if (pen.template) {
        if (pen.canvasLayer === CanvasLayer.CanvasTemplate) {
          this.templateImageLoaded();
        }
      };
    };
    // send the request
    request.send();
  }
  loadImage(pen) {
    if (pen.image !== pen.calculative.image || !pen.calculative.img) {
      pen.calculative.img = undefined;
      if (pen.image) {
        if (globalStore.htmlElements[pen.image]) {
          const img = globalStore.htmlElements[pen.image];
          pen.calculative.img = img;
          pen.calculative.imgNaturalWidth = img.naturalWidth || pen.iconWidth;
          pen.calculative.imgNaturalHeight = img.naturalHeight || pen.iconHeight;
          this.imageLoaded(); // TODO: 重绘图片层 有延时器，可能卡顿
          // if (pen.template) {
          if (pen.canvasLayer === CanvasLayer.CanvasTemplate) {
            this.templateImageLoaded();
          }
        } else {
          if (navigator.userAgent.includes('Firefox') && pen.image.endsWith('.svg')) {
            // 火狐浏览器 svg 图片需要特殊处理
            this.firefoxLoadSvg(pen);
          } else {
            const img = new Image();
            img.crossOrigin = pen.crossOrigin === 'undefined' ? undefined : pen.crossOrigin || 'anonymous';
            img.src = pen.image;
            if (this.store.options.cdn && !(pen.image.startsWith('http') || pen.image.startsWith('//') || pen.image.startsWith('data:image'))) {
              img.src = this.store.options.cdn + pen.image;
            }
            img.onload = () => {
              // TODO: 连续的加载两张图片，若后开始加载 的图片先加载完成，可能会导致展示的是 先开始加载的图片
              pen.calculative.img = img;
              pen.calculative.imgNaturalWidth = img.naturalWidth || pen.iconWidth;
              pen.calculative.imgNaturalHeight = img.naturalHeight || pen.iconHeight;
              globalStore.htmlElements[pen.image] = img;
              this.imageLoaded();
              // if (pen.template) {
              if (pen.canvasLayer === CanvasLayer.CanvasTemplate) {
                this.templateImageLoaded();
              }
            };
          }
        }
      }
      pen.calculative.image = pen.image;
    }
    if (pen.backgroundImage !== pen.calculative.backgroundImage) {
      pen.calculative.backgroundImg = undefined;
      if (pen.backgroundImage) {
        if (globalStore.htmlElements[pen.backgroundImage]) {
          const img = globalStore.htmlElements[pen.backgroundImage];
          pen.calculative.backgroundImg = img;
        } else {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.src = pen.backgroundImage;
          if (this.store.options.cdn && !(pen.backgroundImage.startsWith('http') || pen.backgroundImage.startsWith('//') || pen.backgroundImage.startsWith('data:image'))) {
            img.src = this.store.options.cdn + pen.backgroundImage;
          }
          img.onload = () => {
            pen.calculative.backgroundImg = img;
            globalStore.htmlElements[pen.backgroundImage] = img;
            this.imageLoaded();
            // if (pen.template) {
            if (pen.canvasLayer === CanvasLayer.CanvasTemplate) {
              this.templateImageLoaded();
            }
          };
        }
      }
      pen.calculative.backgroundImage = pen.backgroundImage;
    }
    if (pen.strokeImage !== pen.calculative.strokeImage) {
      pen.calculative.strokeImg = undefined;
      if (pen.strokeImage) {
        if (globalStore.htmlElements[pen.strokeImage]) {
          const img = globalStore.htmlElements[pen.strokeImage];
          pen.calculative.strokeImg = img;
        } else {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.src = pen.strokeImage;
          if (this.store.options.cdn && !(pen.strokeImage.startsWith('http') || pen.strokeImage.startsWith('//') || pen.strokeImage.startsWith('data:image'))) {
            img.src = this.store.options.cdn + pen.strokeImage;
          }
          img.onload = () => {
            pen.calculative.strokeImg = img;
            globalStore.htmlElements[pen.strokeImage] = img;
            this.imageLoaded();
            if (
            // pen.template
            pen.canvasLayer === CanvasLayer.CanvasTemplate && pen.name !== 'gif') {
              this.templateImageLoaded();
            }
          };
        }
      }
      pen.calculative.strokeImage = pen.strokeImage;
    }
  }
  // 避免初始化图片加载重复调用 render，此处防抖
  imageLoaded() {
    this.imageTimer && clearTimeout(this.imageTimer);
    this.imageTimer = setTimeout(() => {
      // 加载完图片，重新渲染一次图片层
      this.canvasImage.init();
      this.canvasImageBottom.init();
      this.render();
    }, 100);
  }
  // 避免初始化图片加载重复调用 render，此处防抖
  templateImageLoaded() {
    this.templateImageTimer && clearTimeout(this.templateImageTimer);
    this.templateImageTimer = setTimeout(() => {
      // 加载完图片，重新渲染一次图片层
      this.canvasTemplate.init();
      this.render();
    }, 100);
  }
  setCalculativeByScale(pen) {
    const scale = this.store.data.scale;
    pen.calculative.lineWidth = pen.lineWidth * scale;
    pen.calculative.fontSize = pen.fontSize * scale;
    if (pen.fontSize < 1 && pen.fontSize > 0) {
      pen.calculative.fontSize = pen.fontSize * pen.calculative.worldRect.height;
    }
    pen.calculative.iconSize = pen.iconSize * scale;
    pen.calculative.iconWidth = pen.iconWidth * scale;
    pen.calculative.iconHeight = pen.iconHeight * scale;
    pen.calculative.iconLeft = pen.iconLeft < 1 && pen.iconLeft > -1 ? pen.iconLeft : pen.iconLeft * scale;
    pen.calculative.iconTop = pen.iconTop < 1 && pen.iconTop > -1 ? pen.iconTop : pen.iconTop * scale;
    pen.calculative.textWidth = pen.textWidth < 1 && pen.textWidth > -1 ? pen.textWidth : pen.textWidth * scale;
    pen.calculative.textHeight = pen.textHeight < 1 && pen.textHeight > -1 ? pen.textHeight : pen.textHeight * scale;
    pen.calculative.textLeft = pen.textLeft < 1 && pen.textLeft > -1 ? pen.textLeft * pen.calculative.worldRect.width : pen.textLeft * scale;
    pen.calculative.textTop = pen.textTop < 1 && pen.textTop > -1 ? pen.textTop * pen.calculative.worldRect.height : pen.textTop * scale;
    if (pen.type === PenType.Line && pen.borderWidth) {
      pen.calculative.borderWidth = pen.borderWidth * scale;
    }
  }
  updatePenRect(pen, {
    worldRectIsReady,
    playingAnimate
  } = {}) {
    if (worldRectIsReady) {
      calcPenRect(pen);
    } else {
      calcWorldRects(pen);
    }
    if (!playingAnimate) {
      this.setCalculativeByScale(pen);
    }
    calcWorldAnchors(pen);
    calcIconRect(this.store.pens, pen);
    calcTextRect(pen);
    calcInView(pen);
    globalStore.path2dDraws[pen.name] && this.store.path2dMap.set(pen, globalStore.path2dDraws[pen.name](pen));
    pen.calculative.patchFlags = true;
    this.patchFlags = true;
    if (pen.children) {
      pen.children.forEach(id => {
        const child = this.store.pens[id];
        child && this.updatePenRect(child, {
          worldRectIsReady: false
        });
      });
    }
    pen.type && this.initLineRect(pen);
    if (pen.calculative.gradientTimer) {
      clearTimeout(pen.calculative.gradientTimer);
    }
    pen.calculative.gradientTimer = setTimeout(() => {
      if (pen.calculative.lineGradient) {
        pen.calculative.lineGradient = null;
      }
      if (pen.calculative.gradient) {
        pen.calculative.gradient = null;
      }
      if (pen.calculative.radialGradient) {
        pen.calculative.radialGradient = null;
      }
      this.patchFlags = true;
      pen.calculative.gradientTimer = undefined;
    }, 50);
  }
  translate(x = 0, y = 0) {
    this.store.data.x += x * this.store.data.scale;
    this.store.data.y += y * this.store.data.scale;
    this.store.data.x = Math.round(this.store.data.x);
    this.store.data.y = Math.round(this.store.data.y);
    if (this.store.options.padding) {
      let p = formatPadding(this.store.options.padding);
      const width = this.store.data.width || this.store.options.width;
      const height = this.store.data.height || this.store.options.height;
      if (this.width < (width + p[1] + p[3]) * this.store.data.scale) {
        if (this.store.data.x + this.store.data.origin.x > p[3] * this.store.data.scale) {
          this.store.data.x = p[3] * this.store.data.scale - this.store.data.origin.x;
        }
        if (this.store.data.x + this.store.data.origin.x + width * this.store.data.scale < this.width - p[1] * this.store.data.scale) {
          this.store.data.x = this.width - p[1] * this.store.data.scale - (this.store.data.origin.x + width * this.store.data.scale);
        }
      }
      if (this.height < (height + p[0] + p[2]) * this.store.data.scale) {
        if (this.store.data.y + this.store.data.origin.y > p[0] * this.store.data.scale) {
          this.store.data.y = p[0] * this.store.data.scale - this.store.data.origin.y;
        }
        if (this.store.data.y + this.store.data.origin.y + height * this.store.data.scale < this.height - p[2] * this.store.data.scale) {
          this.store.data.y = this.height - p[2] * this.store.data.scale - (this.store.data.origin.y + height * this.store.data.scale);
        }
      }
    }
    //TODO 当初为什么加异步
    // setTimeout(() => {
    this.canvasTemplate.init();
    this.canvasImage.init();
    this.canvasImageBottom.init();
    this.render();
    // });
    this.store.emitter.emit('translate', {
      x: this.store.data.x,
      y: this.store.data.y
    });
    this.tooltip.translate(x, y);
    if (this.scroll && this.scroll.isShow) {
      this.scroll.translate(x, y);
    }
    this.onMovePens();
  }
  onMovePens() {
    const map = this.parent.map;
    if (map && map.isShow) {
      map.setView();
    }
    // 有移动操作的 画笔 需要执行移动
    for (const pen of this.store.data.pens) {
      calcInView(pen);
      pen.onMove?.(pen);
      if (pen.isRuleLine) {
        if (!pen.width) {
          // 垂直线，移动 y 即可
          pen.y = -this.store.data.y;
        } else if (!pen.height) {
          // 水平线
          pen.x = -this.store.data.x;
        }
        this.updatePenRect(pen);
      }
    }
  }
  /**
   * 缩放整个画布
   * @param scale 缩放比例，最终的 data.scale
   * @param center 中心点，引用类型，存在副作用，会更改原值
   */
  scale(scale, center = {
    x: 0,
    y: 0
  }) {
    const minScale = this.store.data.minScale || this.store.options.minScale;
    const maxScale = this.store.data.maxScale || this.store.options.maxScale;
    if (!(scale >= minScale && scale <= maxScale)) {
      return;
    }
    this.calibrateMouse(center);
    const s = scale / this.store.data.scale;
    this.store.data.scale = scale;
    this.store.data.center = center;
    if (this.store.clipboard?.pos) {
      scalePoint(this.store.clipboard.pos, s, center);
    }
    scalePoint(this.store.data.origin, s, center);
    this.store.data.pens.forEach(pen => {
      if (pen.parentId) {
        return;
      }
      scalePen(pen, s, center);
      pen.onScale && pen.onScale(pen);
      if (pen.isRuleLine) {
        // 扩大线的比例，若是放大，即不缩小，若是缩小，会放大
        const lineScale = 1 / s; //s > 1 ? 1 : 1 / s / s;
        // 中心点即为线的中心
        const lineCenter = pen.calculative.worldRect.center;
        if (!pen.width) {
          // 垂直线
          scalePen(pen, lineScale, lineCenter);
        } else if (!pen.height) {
          // 水平线
          scalePen(pen, lineScale, lineCenter);
        }
      }
      this.updatePenRect(pen, {
        worldRectIsReady: true
      });
      this.execPenResize(pen);
    });
    this.onMovePens();
    this.calcActiveRect();
    // setTimeout(() => {
    this.canvasTemplate.init();
    this.canvasImage.init();
    this.canvasImageBottom.init();
    const map = this.parent.map;
    if (map && map.isShow) {
      map.setView();
    }
    this.render();
    this.store.emitter.emit('scale', this.store.data.scale);
    // });
  }
  templateScale(scale, center = {
    x: 0,
    y: 0
  }) {
    const {
      minScale,
      maxScale
    } = this.store.options;
    if (!(scale >= minScale && scale <= maxScale)) {
      return;
    }
    const s = scale / this.store.data.scale;
    this.store.data.scale = scale;
    this.store.data.center = {
      x: 0,
      y: 0
    };
    this.store.data.origin = {
      x: 0,
      y: 0
    };
    this.store.data.pens.forEach(pen => {
      if (pen.parentId) {
        return;
      }
      scalePen(pen, s, center);
      pen.onScale && pen.onScale(pen);
      if (pen.isRuleLine) {
        // 扩大线的比例，若是放大，即不缩小，若是缩小，会放大
        const lineScale = s > 1 ? 1 : 1 / s / s;
        // 中心点即为线的中心
        const lineCenter = pen.calculative.worldRect.center;
        if (!pen.width) {
          // 垂直线
          scalePen(pen, lineScale, lineCenter);
        } else if (!pen.height) {
          // 水平线
          scalePen(pen, lineScale, lineCenter);
        }
      }
      // this.updatePenRect(pen, { worldRectIsReady: true });
      this.execPenResize(pen);
    });
    this.calcActiveRect();
  }
  rotatePens(e) {
    if (!this.initPens) {
      this.initPens = deepClone(this.getAllByPens(this.store.active));
    }
    this.activeRect.rotate = calcRotate(e, this.activeRect.center);
    if (this.activeRect.rotate % 90 < 10) {
      this.activeRect.rotate -= this.activeRect.rotate % 90;
    }
    if (this.activeRect.rotate % 90 > 80) {
      this.activeRect.rotate += 90 - this.activeRect.rotate % 90;
    }
    if (this.store.active.length === 1) {
      this.lastRotate = this.store.active[0].rotate || 0;
    }
    const angle = this.activeRect.rotate - this.lastRotate;
    for (const pen of this.store.active) {
      if (pen.parentId) {
        return;
      }
      this.rotatePen(pen, angle, this.activeRect);
      pen.onRotate && pen.onRotate(pen);
      this.updateLines(pen);
    }
    this.lastRotate = this.activeRect.rotate;
    this.getSizeCPs();
    this.initImageCanvas(this.store.active);
    this.initTemplateCanvas(this.store.active);
    this.render();
    this.store.emitter.emit('rotatePens', this.store.active);
    if (this.timer) {
      clearTimeout(this.timer);
    }
    this.timer = setTimeout(() => {
      this.timer = undefined;
      this.pushHistory({
        type: EditType.Update,
        pens: deepClone(this.getAllByPens(this.store.active)),
        initPens: this.initPens
      });
      this.initPens = undefined;
    }, 200);
  }
  resizePens(e) {
    if (!this.initPens) {
      this.initPens = deepClone(this.store.active, true);
    }
    if (!this.initActiveRect) {
      this.initActiveRect = deepClone(this.activeRect);
      return;
    }
    const p1 = {
      x: this.mouseDown.x,
      y: this.mouseDown.y
    };
    const p2 = {
      x: e.x,
      y: e.y
    };
    // rotatePoint(p1, -this.activeRect.rotate, this.activeRect.center);
    // rotatePoint(p2, -this.activeRect.rotate, this.activeRect.center);
    let x = p2.x - p1.x;
    let y = p2.y - p1.y;
    const rect = deepClone(this.initActiveRect);
    // 得到最准确的 rect 即 resize 后的
    resizeRect(rect, x, y, this.resizeIndex);
    calcCenter(rect);
    if (!this.store.options.disableDock) {
      this.clearDock();
      const resizeDock = this.customResizeDock || calcResizeDock;
      this.dock = resizeDock(this.store, rect, this.store.active, this.resizeIndex);
      const {
        xDock,
        yDock
      } = this.dock;
      if (xDock) {
        x += xDock.step;
        const dockPen = this.store.pens[xDock.penId];
        dockPen.calculative.isDock = true;
      }
      if (yDock) {
        y += yDock.step;
        const dockPen = this.store.pens[yDock.penId];
        dockPen.calculative.isDock = true;
      }
    }
    const w = this.activeRect.width;
    const h = this.activeRect.height;
    let offsetX = x - this.lastOffsetX;
    let offsetY = y - this.lastOffsetY;
    this.lastOffsetX = x;
    this.lastOffsetY = y;
    if (e.ctrlKey || this.initPens.length === 1 && this.initPens[0].ratio) {
      // 1，3 是右上角和左上角的点，此时的 offsetY 符号与 offsetX 是相反的
      const sign = [1, 3].includes(this.resizeIndex) ? -1 : 1;
      offsetY = sign * (offsetX * h) / w;
    }
    this.activeRect.ratio = this.initPens[0].ratio;
    resizeRect(this.activeRect, offsetX, offsetY, this.resizeIndex);
    //大屏区域
    if (this.store.options.strictScope) {
      const width = this.store.data.width || this.store.options.width;
      const height = this.store.data.height || this.store.options.height;
      if (width && height) {
        let vRect = {
          x: this.store.data.origin.x,
          y: this.store.data.origin.y,
          width: width * this.store.data.scale,
          height: height * this.store.data.scale
        };
        if (this.activeRect.x < vRect.x) {
          this.activeRect.width = this.activeRect.width - (vRect.x - this.activeRect.x);
          this.activeRect.x = vRect.x;
        }
        if (this.activeRect.y < vRect.y) {
          this.activeRect.height = this.activeRect.height - (vRect.y - this.activeRect.y);
          this.activeRect.y = vRect.y;
        }
        if (this.activeRect.x + this.activeRect.width > vRect.x + vRect.width) {
          this.activeRect.width = this.activeRect.width - (this.activeRect.x + this.activeRect.width - (vRect.x + vRect.width));
          this.activeRect.x = vRect.x + vRect.width - this.activeRect.width;
          this.activeRect.ex = this.activeRect.x + this.activeRect.width;
        }
        if (this.activeRect.y + this.activeRect.height > vRect.y + vRect.height) {
          this.activeRect.height = this.activeRect.height - (this.activeRect.y + this.activeRect.height - (vRect.y + vRect.height));
          this.activeRect.y = vRect.y + vRect.height - this.activeRect.height;
          this.activeRect.ey = this.activeRect.y + this.activeRect.height;
        }
      }
    }
    calcCenter(this.activeRect);
    const scaleX = this.activeRect.width / w;
    const scaleY = this.activeRect.height / h;
    this.store.active.forEach((pen, i) => {
      pen.calculative.worldRect.x = this.activeInitPos[i].x * this.activeRect.width + this.activeRect.x;
      pen.calculative.worldRect.y = this.activeInitPos[i].y * this.activeRect.height + this.activeRect.y;
      pen.calculative.worldRect.width *= scaleX;
      pen.calculative.iconWidth && (pen.calculative.iconWidth *= scaleX);
      pen.calculative.worldRect.height *= scaleY;
      pen.calculative.iconHeight && (pen.calculative.iconHeight *= scaleY);
      rect_calcRightBottom(pen.calculative.worldRect);
      calcCenter(pen.calculative.worldRect);
      this.updatePenRect(pen, {
        worldRectIsReady: true
      });
      this.execPenResize(pen);
      this.updateLines(pen);
    });
    this.getSizeCPs();
    this.initImageCanvas(this.store.active);
    this.initTemplateCanvas(this.store.active);
    this.render();
    this.store.emitter.emit('resizePens', this.store.active);
    if (this.timer) {
      clearTimeout(this.timer);
    }
    this.timer = setTimeout(() => {
      this.timer = undefined;
      this.pushHistory({
        type: EditType.Update,
        pens: deepClone(this.store.active, true),
        initPens: this.initPens
      });
      this.initPens = undefined;
    }, 200);
  }
  movePens(e) {
    if (!this.activeRect || this.store.data.locked) {
      return;
    }
    if (!this.initActiveRect) {
      this.initActiveRect = deepClone(this.activeRect);
      return;
    }
    if (!this.store.options.moveConnectedLine && !this.canMoveLine && this.store.active.length === 1 && (this.store.active[0].anchors[0]?.connectTo || this.store.active[0].anchors[this.store.active[0].anchors.length - 1]?.connectTo)) {
      return;
    }
    if (!this.movingPens) {
      this.initMovingPens();
      this.store.active.forEach(pen => {
        setHover(pen, false);
      });
      this.store.hover = undefined;
    }
    if (!this.mouseDown) {
      return;
    }
    let x = e.x - this.mouseDown.x;
    let y = e.y - this.mouseDown.y;
    e.shiftKey && !e.ctrlKey && (y = 0);
    e.ctrlKey && (x = 0);
    const rect = deepClone(this.initActiveRect);
    translateRect(rect, x, y);
    let vFlag = false;
    if (this.store.options.strictScope) {
      const width = this.store.data.width || this.store.options.width;
      const height = this.store.data.height || this.store.options.height;
      if (width && height) {
        let vRect = {
          x: this.store.data.origin.x,
          y: this.store.data.origin.y,
          width: width * this.store.data.scale,
          height: height * this.store.data.scale
        };
        if (rect.x < vRect.x) {
          rect.x = vRect.x;
          vFlag = true;
        }
        if (rect.y < vRect.y) {
          rect.y = vRect.y;
          vFlag = true;
        }
        if (rect.x + rect.width > vRect.x + vRect.width) {
          rect.x = vRect.x + vRect.width - rect.width;
          vFlag = true;
        }
        if (rect.y + rect.height > vRect.y + vRect.height) {
          rect.y = vRect.y + vRect.height - rect.height;
          vFlag = true;
        }
      }
    }
    const offset = {
      x: rect.x - this.activeRect.x,
      y: rect.y - this.activeRect.y
    };
    if (!this.store.options.disableDock && !vFlag) {
      this.clearDock();
      const moveDock = this.customMoveDock || calcMoveDock;
      this.dock = moveDock(this.store, rect, this.movingPens, offset);
      const {
        xDock,
        yDock
      } = this.dock;
      let dockPen;
      if (xDock) {
        offset.x += xDock.step;
        dockPen = this.store.pens[xDock.penId];
        dockPen.calculative.isDock = true;
      }
      if (yDock) {
        offset.y += yDock.step;
        dockPen = this.store.pens[yDock.penId];
        dockPen.calculative.isDock = true;
      }
    }
    this.translatePens(this.movingPens, offset.x, offset.y, true);
  }
  /**
   * 初始化移动，更改画笔的 id parentId 等关联关系
   * @param pen 要修改的画笔
   * @param pens 本次操作的画笔们，包含子画笔
   */
  changeIdsByMoving(pen, pens) {
    pen.id += movingSuffix;
    if (pen.parentId && pens.find(p => p.id === pen.parentId)) {
      pen.parentId += movingSuffix;
    }
    if (pen.children) {
      pen.children = pen.children.map(child => child + movingSuffix);
    }
    // 连接关系也需要变，用在 updateLines 中
    if (pen.connectedLines) {
      pen.connectedLines = pen.connectedLines.map(line => {
        if (pens.find(p => p.id === line.lineId)) {
          line.lineId += movingSuffix;
        }
        return line;
      });
    }
    if (pen.type && pen.calculative.worldAnchors) {
      pen.calculative.worldAnchors = pen.calculative.worldAnchors.map(anchor => {
        if (anchor.connectTo && pens.find(p => p.id === anchor.connectTo)) {
          anchor.connectTo += movingSuffix;
        }
        return anchor;
      });
    }
  }
  /**
   * 初始化 this.movingPens
   * 修改 ids （id parentId children 等）
   * 半透明，去图片
   */
  initMovingPens() {
    if (!this.store.options.moveConnectedLine && !this.canMoveLine) {
      for (let i = 0; i < this.store.active.length; i++) {
        const pen = this.store.active[i];
        if (pen.anchors[0]?.connectTo || pen.anchors[pen.anchors.length - 1]?.connectTo) {
          this.store.active.splice(i, 1);
          pen.calculative.active = undefined;
          --i;
        }
      }
    }
    this.movingPens = deepClone(this.store.active, true);
    this.movingPens = this.getAllFollowersByPens(this.movingPens);
    const containChildPens = this.getAllByPens(this.movingPens);
    const copyContainChildPens = deepClone(containChildPens, true);
    // 考虑父子关系，修改 id
    containChildPens.forEach(pen => {
      this.changeIdsByMoving(pen, copyContainChildPens);
      this.store.pens[pen.id] = pen; // updatePenRect 时需要计算
      pen.calculative.canvas = this;
      const value = {
        globalAlpha: 0.5
      };
      // 线宽为 0 ，看不到外边框，拖动过程中给个外边框
      pen.lineWidth === 0 && (value.lineWidth = 1);
      // TODO: 例如 pen.name = 'triangle' 的情况，但有图片，是否还需要变成矩形呢？
      if (pen.name.endsWith('Dom') || isDomShapes.includes(pen.name) || this.store.options.domShapes.includes(pen.name) || pen.image) {
        // 修改名称会执行 onDestroy ，清空它
        value.name = 'rectangle';
        value.onDestroy = undefined;
      }
      this.updateValue(pen, value);
      pen.calculative.image = undefined;
    });
  }
  moveLineAnchor(pt, keyOptions) {
    if (!this.activeRect || this.store.data.locked) {
      return;
    }
    if (!this.initPens) {
      this.initPens = deepClone(this.store.active, true);
    }
    if (this.store.activeAnchor?.connectTo) {
      const pen = this.store.pens[this.store.activeAnchor.connectTo];
      disconnectLine(pen, getAnchor(pen, this.store.activeAnchor.anchorId), this.store.pens[this.store.activeAnchor.penId], this.store.activeAnchor);
    }
    let anchorId = this.store.activeAnchor?.id;
    let connectedLine = this.store.pens[this.store.activeAnchor.penId]?.connectedLines?.filter(item => item.anchor === anchorId);
    if (connectedLine && connectedLine.length > 0) {
      connectedLine.forEach(connected => {
        const pen = this.store.pens[connected.lineId];
        disconnectLine(this.store.pens[this.store.activeAnchor.penId], this.store.activeAnchor, pen, getAnchor(pen, connected.lineAnchor));
      });
    }
    const line = this.store.active[0];
    const from = getFromAnchor(line);
    const to = getToAnchor(line);
    if (line.lineName === 'polyline' && !keyOptions.shiftKey) {
      translatePolylineAnchor(line, this.store.activeAnchor, pt);
    } else {
      let offsetX = 0;
      let offsetY = 0;
      if (line.lineName === 'line') {
        let index = line.calculative.worldAnchors.findIndex(anchor => anchor.id === this.store.activeAnchor.id);
        if (index === 0) {
          index = 2;
        }
        let relativePt = line.calculative.worldAnchors[index - 1];
        if (keyOptions.ctrlKey && keyOptions.shiftKey) {
          let _pt = deepClone(pt);
          this.getSpecialAngle(_pt, relativePt);
          offsetX = _pt.x - this.store.activeAnchor.x;
          offsetY = _pt.y - this.store.activeAnchor.y;
        } else if (!keyOptions.ctrlKey && keyOptions.shiftKey) {
          let _pt = {
            x: pt.x,
            y: relativePt.y
          };
          offsetX = _pt.x - this.store.activeAnchor.x;
          offsetY = _pt.y - this.store.activeAnchor.y;
        } else if (keyOptions.ctrlKey && !keyOptions.shiftKey) {
          let _pt = {
            x: relativePt.x,
            y: pt.y
          };
          offsetX = _pt.x - this.store.activeAnchor.x;
          offsetY = _pt.y - this.store.activeAnchor.y;
        } else {
          offsetX = pt.x - this.store.activeAnchor.x;
          offsetY = pt.y - this.store.activeAnchor.y;
        }
      } else {
        if (!keyOptions.ctrlKey && keyOptions.shiftKey) {
          offsetX = pt.x - this.store.activeAnchor.x;
          offsetY = 0;
        } else if (keyOptions.ctrlKey && !keyOptions.shiftKey) {
          offsetX = 0;
          offsetY = pt.y - this.store.activeAnchor.y;
        } else {
          offsetX = pt.x - this.store.activeAnchor.x;
          offsetY = pt.y - this.store.activeAnchor.y;
        }
      }
      translatePoint(this.store.activeAnchor, offsetX, offsetY);
      if (this.store.hover && this.store.hoverAnchor && this.store.hoverAnchor.penId !== this.store.activeAnchor.penId) {
        if (this.store.hoverAnchor.type === PointType.Line) {
          offsetX = pt.x - this.store.activeAnchor.x;
          offsetY = pt.y - this.store.activeAnchor.y;
          getDistance(this.store.activeAnchor, this.store.hoverAnchor, this.store);
        } else {
          offsetX = this.store.hoverAnchor.x - this.store.activeAnchor.x;
          offsetY = this.store.hoverAnchor.y - this.store.activeAnchor.y;
        }
        translatePoint(this.store.activeAnchor, offsetX, offsetY);
        to.prev = undefined;
        // 重新自动计算连线
        if (line.lineName !== 'polyline') {
          this[line.lineName]?.(this.store, line);
        }
      }
    }
    this.patchFlagsLines.add(line);
    this.store.path2dMap.set(line, globalStore.path2dDraws[line.name](line));
    this.render();
    this.store.active[0].calculative && (this.store.active[0].calculative.gradientAnimatePath = undefined);
    this.store.emitter.emit('moveLineAnchor', {
      pen: this.store.active[0],
      anchor: this.store.activeAnchor
    });
    if (this.timer) {
      clearTimeout(this.timer);
    }
    this.timer = setTimeout(() => {
      this.timer = undefined;
      this.pushHistory({
        type: EditType.Update,
        pens: deepClone(this.store.active, true),
        initPens: this.initPens
      });
      this.initPens = undefined;
    }, 500);
  }
  moveLineAnchorPrev(e) {
    if (!this.activeRect || this.store.data.locked || !this.store.activeAnchor) {
      return;
    }
    if (!this.initPens) {
      this.initPens = deepClone(this.store.active, true);
    }
    this.store.activeAnchor.prev.x = e.x;
    this.store.activeAnchor.prev.y = e.y;
    if (this.store.activeAnchor.next) {
      if (!this.store.activeAnchor.prevNextType) {
        this.store.activeAnchor.next.x = e.x;
        this.store.activeAnchor.next.y = e.y;
        rotatePoint(this.store.activeAnchor.next, 180, this.store.activeAnchor);
      } else if (this.store.activeAnchor.prevNextType === PrevNextType.Bilateral && this.prevAnchor) {
        const rotate = calcRotate(e, this.store.activeAnchor);
        const prevRotate = calcRotate(this.prevAnchor, this.store.activeAnchor);
        this.store.activeAnchor.next.x = this.nextAnchor.x;
        this.store.activeAnchor.next.y = this.nextAnchor.y;
        rotatePoint(this.store.activeAnchor.next, rotate - prevRotate, this.store.activeAnchor);
      }
    }
    const line = this.store.active[0];
    this.patchFlagsLines.add(line);
    this.store.path2dMap.set(line, globalStore.path2dDraws[line.name](line));
    this.render();
    if (this.timer) {
      clearTimeout(this.timer);
    }
    this.timer = setTimeout(() => {
      this.timer = undefined;
      this.pushHistory({
        type: EditType.Update,
        pens: deepClone(this.store.active, true),
        initPens: this.initPens
      });
      this.initPens = undefined;
    }, 200);
  }
  moveLineAnchorNext(e) {
    if (!this.activeRect || this.store.data.locked || !this.store.activeAnchor) {
      return;
    }
    if (!this.initPens) {
      this.initPens = deepClone(this.store.active, true);
    }
    this.store.activeAnchor.next.x = e.x;
    this.store.activeAnchor.next.y = e.y;
    if (this.store.activeAnchor.prev) {
      if (!this.store.activeAnchor.prevNextType) {
        this.store.activeAnchor.prev.x = e.x;
        this.store.activeAnchor.prev.y = e.y;
        rotatePoint(this.store.activeAnchor.prev, 180, this.store.activeAnchor);
      } else if (this.store.activeAnchor.prevNextType === PrevNextType.Bilateral && this.nextAnchor) {
        const rotate = calcRotate(e, this.store.activeAnchor);
        const nextRotate = calcRotate(this.nextAnchor, this.store.activeAnchor);
        this.store.activeAnchor.prev.x = this.prevAnchor.x;
        this.store.activeAnchor.prev.y = this.prevAnchor.y;
        rotatePoint(this.store.activeAnchor.prev, rotate - nextRotate, this.store.activeAnchor);
      }
    }
    const line = this.store.active[0];
    this.patchFlagsLines.add(line);
    this.store.path2dMap.set(line, globalStore.path2dDraws[line.name](line));
    this.render();
    if (this.timer) {
      clearTimeout(this.timer);
    }
    this.timer = setTimeout(() => {
      this.timer = undefined;
      this.pushHistory({
        type: EditType.Update,
        pens: deepClone(this.store.active, true),
        initPens: this.initPens
      });
      this.initPens = undefined;
    }, 200);
  }
  async setAnchor(e) {
    const initPens = [deepClone(this.store.hover, true)];
    const hoverPen = this.store.hover;
    if (this.store.hoverAnchor) {
      if (this.beforeRemoveAnchor && !(await this.beforeRemoveAnchor(hoverPen, this.store.hoverAnchor))) {
        return;
      }
      if (hoverPen.type === PenType.Line && hoverPen.calculative.worldAnchors?.length <= 2) {
        this.delete([hoverPen]);
      } else {
        removePenAnchor(hoverPen, this.store.hoverAnchor);
        if (hoverPen.type === PenType.Line) {
          this.initLineRect(hoverPen);
        }
      }
      this.store.hoverAnchor = undefined;
      this.store.activeAnchor = undefined;
      this.externalElements.style.cursor = 'default';
    } else if (hoverPen) {
      if (this.beforeAddAnchor && !(await this.beforeAddAnchor(hoverPen, this.store.pointAt))) {
        return;
      }
      if (hoverPen.type === PenType.Line) {
        this.store.activeAnchor = addLineAnchor(hoverPen, this.store.pointAt, this.store.pointAtIndex);
        this.initLineRect(hoverPen);
        const pt = {
          x: e.x,
          y: e.y
        };
        this.getHover(pt);
      } else {
        const pt = {
          id: s8(),
          x: e.x,
          y: e.y
        };
        this.store.activeAnchor = pushPenAnchor(hoverPen, pt);
      }
    }
    this.hotkeyType = HotkeyType.None;
    this.render();
    if (hoverPen) {
      this.pushHistory({
        type: EditType.Update,
        pens: [deepClone(hoverPen, true)],
        initPens
      });
    }
  }
  /**
   * 连线允许移动，若与其它图形有连接，但其它图形不在此次移动中，会断开连接
   * @param line 连线
   * @param pens 本次移动的全部图形，包含子节点
   */
  checkDisconnect(line, pens) {
    if (line.id.indexOf(movingSuffix) > 0) {
      const id = line.id;
      line = this.store.pens[id.replace(movingSuffix, '')];
    }
    // 连接
    line.anchors.forEach(anchor => {
      if (anchor.connectTo && !pens.find(p => p.id === anchor.connectTo || p.id === anchor.connectTo + movingSuffix)) {
        const pen = this.store.pens[anchor.connectTo];
        if (!pen || pen.type) {
          return;
        }
        disconnectLine(pen, getAnchor(pen, anchor.anchorId), line, anchor);
      }
    });
  }
  /**
   * 移动 画笔们
   * @param pens 画笔们，不包含子节点
   * @param x 偏移 x
   * @param y 偏移 y
   * @param doing 是否持续移动
   */
  translatePens(pens = this.store.active, x, y, doing) {
    if (!pens || !pens.length) {
      return;
    }
    let hasLocked = pens.some(item => {
      if (item.locked >= LockState.DisableMove) return true;
    });
    if (hasLocked) {
      return;
    }
    const initPens = !doing && deepClone(pens, true);
    this.activeRect && translateRect(this.activeRect, x, y);
    const containChildPens = this.getAllByPens(pens);
    pens.forEach(pen => {
      if (pen.locked >= LockState.DisableMove) {
        return;
      }
      if (pen.type === PenType.Line) {
        if (!this.store.options.moveConnectedLine && !this.canMoveLine) {
          return;
        }
        if (pen.isRuleLine) {
          return;
        }
        translateLine(pen, x, y);
        this.checkDisconnect(pen, containChildPens);
        this.store.path2dMap.set(pen, globalStore.path2dDraws[pen.name](pen));
        if (!doing) {
          this.initLineRect(pen);
          pen.connectedLines?.forEach(item => {
            const line = this.store.pens[item.lineId];
            this.initLineRect(line);
          });
        }
      } else {
        translateRect(pen.calculative.worldRect, x, y);
        this.updatePenRect(pen, {
          worldRectIsReady: true
        });
        pen.calculative.x = pen.x;
        pen.calculative.y = pen.y;
        if (pen.calculative.initRect) {
          pen.calculative.initRect.x = pen.calculative.x;
          pen.calculative.initRect.y = pen.calculative.y;
          pen.calculative.initRect.ex = pen.calculative.x + pen.calculative.width;
          pen.calculative.initRect.ey = pen.calculative.y + pen.calculative.height;
        }
      }
      this.updateLines(pen);
      pen.onMove?.(pen);
    });
    this.activeRect && this.getSizeCPs();
    this.render();
    this.tooltip.translate(x, y);
    if (!doing) {
      // 单次的移动需要记历史记录
      this.pushHistory({
        type: EditType.Update,
        pens: deepClone(pens, true),
        initPens
      });
      this.initImageCanvas(pens);
      this.initTemplateCanvas(pens);
      this.store.emitter.emit('translatePens', pens);
    }
    this.store.emitter.emit('translatingPens', pens);
  }
  /**
   * 移动 画笔们
   * @param pens 画笔们，不包含子节点
   * @param x 偏移 x
   * @param y 偏移 y
   * @param doing 是否持续移动
   */
  templateTranslatePens(pens = this.store.active, x, y) {
    if (!pens || !pens.length) {
      return;
    }
    const containChildPens = this.getAllByPens(pens);
    pens.forEach(pen => {
      if (pen.type === PenType.Line) {
        if (!this.store.options.moveConnectedLine && !this.canMoveLine) {
          return;
        }
        translateLine(pen, x, y);
        this.checkDisconnect(pen, containChildPens);
        this.store.path2dMap.set(pen, globalStore.path2dDraws[pen.name](pen));
      } else {
        translateRect(pen.calculative.worldRect, x, y);
        this.updatePenRect(pen, {
          worldRectIsReady: true
        });
        pen.calculative.x = pen.x;
        pen.calculative.y = pen.y;
        if (pen.calculative.initRect) {
          pen.calculative.initRect.x = pen.calculative.x;
          pen.calculative.initRect.y = pen.calculative.y;
          pen.calculative.initRect.ex = pen.calculative.x + pen.calculative.width;
          pen.calculative.initRect.ey = pen.calculative.y + pen.calculative.height;
        }
      }
      pen.onMove?.(pen);
    });
  }
  calcAutoAnchor(line, lineAnchor, pen, penConnection) {
    const from = getFromAnchor(line);
    const to = getToAnchor(line);
    const newAnchor = nearestAnchor(pen, lineAnchor === from ? to : from);
    if (!newAnchor) {
      return;
    }
    lineAnchor.x = newAnchor.x;
    lineAnchor.y = newAnchor.y;
    lineAnchor.prev = undefined;
    lineAnchor.next = undefined;
    if (penConnection) {
      penConnection.anchor = newAnchor.id;
    } else {
      connectLine(pen, newAnchor, line, lineAnchor);
    }
    if (this[line.lineName]) {
      this[line.lineName](this.store, line);
    }
    this.store.path2dMap.set(line, globalStore.path2dDraws.line(line));
    this.initLineRect(line);
  }
  restoreNodeAnimate(pen) {
    if (pen.calculative.initRect) {
      if (pen.keepAnimateState) {
        for (const k in pen) {
          if (pen.calculative[k] === undefined) {
            continue;
          }
          if (k !== 'x' && k !== 'y' && k !== 'width' && k !== 'height' && k !== 'initRect' && (typeof pen[k] !== 'object' || k === 'lineDash')) {
            if (k === 'fontSize' || k === 'lineWidth') {
              pen[k] = pen.calculative[k] / pen.calculative.canvas.store.data.scale;
            } else {
              pen[k] = pen.calculative[k];
            }
          }
        }
      } else {
        const rotate = pen.calculative.initRect.rotate - pen.calculative.rotate;
        for (const k in pen) {
          if (k !== 'x' && k !== 'y' && k !== 'width' && k !== 'height' && k !== 'initRect' && k !== 'rotate' && (typeof pen[k] !== 'object' || k === 'lineDash')) {
            pen.calculative[k] = pen[k];
          }
        }
        if (pen.children?.length) {
          if (rotate) {
            rotatePen(pen, rotate, pen.calculative.worldRect);
          }
        } else {
          pen.calculative.rotate = pen.rotate;
        }
        //其他回到最初始状态
        const originStatus = deepClone(this.store.animateMap.get(pen));
        if (originStatus) {
          originStatus.id = pen.id;
          this.parent.setValue(originStatus, {
            doEvent: false,
            render: true,
            history: false
          });
        }
        pen.calculative.worldRect = pen.calculative.initRect;
      }
      this.updatePenRect(pen, {
        worldRectIsReady: true
      });
      this.updateLines(pen);
      if (pen.image && pen.name !== 'gif') {
        this.canvasImage.init();
        this.canvasImageBottom.init();
      }
      if (pen.calculative.text !== pen.text) {
        pen.calculative.text = pen.text;
        text_calcTextLines(pen);
      }
      if (this.store.active?.length) {
        this.calcActiveRect();
      }
      pen.calculative.initRect = undefined;
    }
  }
  updateLines(pen, change) {
    pen.children?.forEach(child => {
      const childPen = this.store.pens[child];
      if (childPen) {
        // 每个子节点都会更新 line，包括子节点是 type 1 的情况
        this.updateLines(childPen, change);
      }
    });
    if (!pen.connectedLines) {
      return;
    }
    pen.connectedLines.forEach((item, index) => {
      const line = this.store.pens[item.lineId];
      // 活动层的线不需要更新，会在活动层处理
      if (!line || line.calculative.active) {
        return;
      }
      const lineAnchor = getAnchor(line, item.lineAnchor);
      if (!lineAnchor) {
        return;
      }
      if (!lineAnchor.connectTo) {
        // 如果pen有连接关系但连线中没有连接关系，删除pen的连接关系
        pen.connectedLines.splice(index, 1);
        return;
      }
      if (line.autoFrom) {
        const from = getFromAnchor(line);
        if (from.id === lineAnchor.id) {
          this.calcAutoAnchor(line, from, pen, item);
        }
      }
      if (line.autoTo) {
        const to = getToAnchor(line);
        if (to.id === lineAnchor.id) {
          this.calcAutoAnchor(line, to, pen, item);
        }
      }
      const penAnchor = getAnchor(pen, item.anchor);
      if (!penAnchor) {
        return;
      }
      let rotate = pen.rotate;
      if (pen.flipX) {
        rotate *= -1;
      }
      if (pen.flipY) {
        rotate *= -1;
      }
      let offsetX = lineAnchor.distance * this.store.data.scale * Math.cos((rotate + penAnchor.rotate) / 180 * Math.PI) || 0;
      let offsetY = lineAnchor.distance * this.store.data.scale * Math.sin((rotate + penAnchor.rotate) / 180 * Math.PI) || 0;
      if (pen.flipX) {
        offsetX = -offsetX;
      }
      if (pen.flipY) {
        offsetY = -offsetY;
      }
      translatePoint(lineAnchor, penAnchor.x - lineAnchor.x + offsetX, penAnchor.y - lineAnchor.y + offsetY);
      if (this.store.options.autoPolyline && !this.autoPolylineFlag && line.autoPolyline !== false && line.lineName === 'polyline') {
        let from = getFromAnchor(line);
        let to = getToAnchor(line);
        let found = false;
        if (from.id === lineAnchor.id) {
          from = lineAnchor;
          found = true;
        } else if (to.id === lineAnchor.id) {
          to = lineAnchor;
          found = true;
        }
        if (found) {
          line.calculative.worldAnchors = [from, to];
          line.calculative.activeAnchor = from;
          this.polyline(this.store, line, to);
          this.initLineRect(line);
        }
      }
      this.store.path2dMap.set(line, globalStore.path2dDraws[line.name](line));
      this.patchFlagsLines.add(line);
      if (line.calculative.gradientSmooth) {
        line.calculative.gradientAnimatePath = getGradientAnimatePath(line);
      }
      change && getLineLength(line);
    });
  }
  calcActiveRect() {
    // TODO: visible 不可见， 目前只是不计算 activeRect，考虑它是否进入活动层 store.active
    const canMovePens = this.store.active.filter(pen => (!pen.locked || pen.locked < LockState.DisableMove) && pen.visible != false);
    if (!canMovePens.length) {
      return;
    } else if (canMovePens.length === 1) {
      this.activeRect = deepClone(canMovePens[0].calculative.worldRect);
      this.activeRect.rotate = canMovePens[0].calculative.rotate || 0;
      calcCenter(this.activeRect);
    } else {
      this.activeRect = getRect(canMovePens);
      this.activeRect.rotate = 0;
    }
    this.lastRotate = 0;
    this.getSizeCPs();
  }
  /**
   * 旋转当前画笔包括子节点
   * @param pen 旋转的画笔
   * @param angle 本次的旋转值，加到 pen.calculative.rotate 上
   */
  rotatePen(pen, angle, rect) {
    if (pen.type) {
      pen.calculative.worldAnchors.forEach(anchor => {
        rotatePoint(anchor, angle, rect.center);
      });
      this.initLineRect(pen);
      calcPenRect(pen);
    } else {
      if (pen.calculative.rotate) {
        pen.calculative.rotate += angle;
      } else {
        pen.calculative.rotate = angle;
      }
      rotatePoint(pen.calculative.worldRect.center, angle, rect.center);
      if (pen.parentId) {
        pen.calculative.worldRect.x = pen.calculative.worldRect.center.x - pen.calculative.worldRect.width / 2;
        pen.calculative.worldRect.y = pen.calculative.worldRect.center.y - pen.calculative.worldRect.height / 2;
        pen.x = (pen.calculative.worldRect.x - rect.x) / rect.width;
        pen.y = (pen.calculative.worldRect.y - rect.y) / rect.height;
      } else {
        pen.x = pen.calculative.worldRect.center.x - pen.width / 2;
        pen.y = pen.calculative.worldRect.center.y - pen.height / 2;
      }
      pen.rotate = pen.calculative.rotate;
      this.updatePenRect(pen);
      if (pen.children) {
        pen.children.forEach(id => {
          const child = this.store.pens[id];
          this.rotatePen(child, angle, pen.calculative.worldRect);
        });
      }
    }
  }
  nextAnimate(pen) {
    if (!pen) {
      return;
    }
    this.store.emitter.emit('animateEnd', pen);
    let pens;
    if (pen.nextAnimate) {
      pens = this.store.data.pens.filter(p => {
        return p.id === pen.nextAnimate || p.tags && p.tags.indexOf(pen.nextAnimate) > -1;
      });
    }
    if (!pens) {
      return;
    }
    pens.forEach(pen => {
      if (pen.calculative.pause) {
        const d = Date.now() - pen.calculative.pause;
        pen.calculative.pause = undefined;
        pen.calculative.frameStart += d;
        pen.calculative.frameEnd += d;
      } else {
        if (pen.name === 'video') {
          pen.calculative.media.currentTime = 0;
          pen.calculative.media?.play();
          pen.onStartVideo?.(pen);
        } else if (pen.type || pen.frames?.length || pen.animations && pen.animations.length) {
          //存储动画初始状态
          if (!pen.type) {
            if (!pen.frames && pen.animations && pen.animations.length) {
              //无活动动画
              let autoIndex = pen.animations?.findIndex(i => i.autoPlay);
              let index = autoIndex === -1 ? 0 : autoIndex;
              const animate = deepClone(pen.animations[index]);
              delete animate.name;
              animate.currentAnimation = index;
              if (!pen.type && animate.frames) {
                animate.showDuration = this.parent.calcAnimateDuration(animate);
              }
              this.parent.setValue({
                id: pen.id,
                ...animate
              }, {
                doEvent: false,
                history: false
              });
            }
            this.store.animateMap.set(pen, this.getFrameProps(pen));
          } else {
            if (pen.animations?.length) {
              //默认执行line的第一个动画
              const animate = deepClone(pen.animations[0]);
              delete animate.name;
              animate.currentAnimation = 0;
              this.parent.setValue({
                id: pen.id,
                ...animate
              }, {
                doEvent: false,
                history: false
              });
            }
          }
          this.store.animates.add(pen);
        }
      }
    });
    this.animate();
  }
  getFrameProps(pen) {
    let initProps = {};
    pen.frames && pen.frames.forEach(frame => {
      for (let key in frame) {
        if (!['duration', 'x', 'y', 'width', 'height', 'rotate'].includes(key) && !initProps[key]) {
          initProps[key] = pen[key];
        }
      }
    });
    return initProps;
  }
  animate() {
    if (this.animateRendering) {
      return;
    }
    requestAnimationFrame(() => {
      const now = Date.now();
      if (now - this.lastAnimateRender < this.store.options.animateInterval) {
        if (this.store.animates.size > 0) {
          this.animate();
        }
        return;
      }
      this.lastAnimateRender = now;
      this.animateRendering = true;
      const dels = [];
      let active = false;
      for (const pen of this.store.animates) {
        if (pen.calculative.pause) {
          continue;
        }
        if (pen.calculative.active && !pen.type && !this.movingPens) {
          // 存在节点在活动层，并且不在移动中
          active = true;
        }
        if (!pen.type) {
          if (setNodeAnimate(pen, now)) {
            if (pen.calculative.patchFlags) {
              calcCenter(pen.calculative.worldRect);
              this.updatePenRect(pen, {
                worldRectIsReady: true,
                playingAnimate: true
              });
            }
          } else {
            // 避免未到绘画帧，用户点击了停止动画，产生了时间差数据
            requestAnimationFrame(() => {
              this.restoreNodeAnimate(pen);
            });
            dels.push(pen);
            this.nextAnimate(pen);
          }
          this.updateLines(pen, true);
        } else {
          if (!setLineAnimate(pen, now)) {
            if (pen.keepAnimateState) {
              for (const k in pen) {
                if (pen.calculative[k] === undefined) {
                  continue;
                }
                if (k === 'length') {
                  continue;
                }
                if (typeof pen[k] !== 'object' || k === 'lineDash') {
                  if (k === 'lineWidth') {
                    pen[k] = pen.calculative[k] / pen.calculative.canvas.store.data.scale;
                  } else {
                    pen[k] = pen.calculative[k];
                  }
                }
              }
              calcPenRect(pen);
            } else {
              for (const k in pen) {
                if (typeof pen[k] !== 'object' || k === 'lineDash') {
                  if (k === 'lineWidth') {
                    pen.calculative[k] = pen[k] * pen.calculative.canvas.store.data.scale;
                  } else {
                    pen.calculative[k] = pen[k];
                  }
                }
              }
            }
            dels.push(pen);
            this.nextAnimate(pen);
          }
        }
        this.patchFlags = true;
      }
      if (active) {
        this.calcActiveRect();
      }
      dels.forEach(pen => {
        this.store.animates.delete(pen);
      });
      this.render(false);
      this.animateRendering = false;
      this.animate();
    });
  }
  get clipboardName() {
    return 'meta2d-clipboard';
  }
  async copy(pens, emit = true) {
    const page = s8();
    // 得到当前活动层的，包括子节点
    const {
      origin,
      scale
    } = this.store.data;
    this.store.clipboard = undefined;
    localStorage.removeItem(this.clipboardName);
    sessionStorage.setItem('page', page);
    let copyPens = this.getAllByPens(deepClone(pens || this.store.active, true));
    //根据pens顺序复制
    copyPens.forEach(activePen => {
      activePen.copyIndex = this.store.data.pens.findIndex(pen => pen.id === activePen.id);
      if (activePen.pathId) {
        //复制svgpath
        activePen.path = this.store.data.paths[activePen.pathId];
      }
    });
    copyPens.sort((a, b) => {
      return a.copyIndex - b.copyIndex;
    });
    copyPens.forEach(activePen => {
      delete activePen.copyIndex;
    });
    const clipboard = {
      meta2d: true,
      pens: copyPens,
      origin: deepClone(origin),
      scale,
      page,
      initRect: deepClone(this.activeRect),
      offset: 10
    };
    if (navigator.clipboard && !this.store.options.disableClipboard && !navigator.userAgent.includes('Firefox')) {
      try {
        await navigator.clipboard.writeText(JSON.stringify(clipboard));
      } catch {
        localStorage.setItem(this.clipboardName, JSON.stringify(clipboard));
      }
    } else {
      localStorage.setItem(this.clipboardName, JSON.stringify(clipboard));
    }
    emit && this.store.emitter.emit('copy', clipboard.pens);
  }
  cut(pens) {
    this.copy(pens, false);
    this.delete(pens);
    this.store.emitter.emit('cut', pens);
  }
  async paste() {
    let clipboardText;
    let clipboard;
    if (navigator.clipboard && !this.store.options.disableClipboard && !navigator.userAgent.includes('Firefox')) {
      try {
        clipboardText = await navigator.clipboard?.readText();
      } catch {
        clipboardText = localStorage.getItem(this.clipboardName);
      }
    } else {
      clipboardText = localStorage.getItem(this.clipboardName);
    }
    if (clipboardText) {
      try {
        clipboard = JSON.parse(clipboardText);
      } catch (e) {
        console.warn('剪切板数据不是json', e.message);
        return;
      }
      if (!clipboard || !clipboard.meta2d) {
        return;
      }
    } else {
      return;
    }
    if (this.beforeAddPens && (await this.beforeAddPens(clipboard.pens)) != true) {
      return;
    }
    let offset;
    let pos;
    if (this.store.clipboard) {
      offset = this.store.clipboard.offset + 10;
      pos = this.store.clipboard.pos;
    }
    this.store.clipboard = deepClone(clipboard);
    const curPage = sessionStorage.getItem('page');
    if (curPage !== clipboard.page) {
      this.store.clipboard.pos = {
        x: this.mousePos.x,
        y: this.mousePos.y
      };
      this.store.clipboard.offset = 0;
    } else if (!this.pasteOffset) {
      this.store.clipboard.offset = 0;
      this.pasteOffset = true;
    } else {
      offset && (this.store.clipboard.offset = offset);
      pos && (this.store.clipboard.pos = pos);
    }
    const rootPens = this.store.clipboard.pens.filter(pen => !pen.parentId);
    for (const pen of rootPens) {
      this.pastePen(pen, undefined);
    }
    sessionStorage.setItem('page', clipboard.page);
    this.active(rootPens);
    this.pushHistory({
      type: EditType.Add,
      pens: this.store.clipboard.pens
    });
    this.render();
    this.store.emitter.emit('add', this.store.clipboard.pens);
    this.store.emitter.emit('paste', this.store.clipboard.pens);
  }
  /**
   * 获取 pens 列表中的所有节点（包含子节点）
   * @param pens 不包含子节点
   */
  getAllByPens(pens) {
    const retPens = [];
    for (const pen of pens) {
      retPens.push(...deepClone(getAllChildren(pen, this.store), true));
    }
    return retPens.concat(pens);
  }
  getAllFollowersByPens(pens, deep = true) {
    const retPens = pens;
    for (const pen of pens) {
      let followers = getAllFollowers(pen, this.store);
      if (deep) {
        followers = deepClone(followers, true);
      }
      for (const follower of followers) {
        if (!retPens.find(p => p.id === follower.id)) {
          retPens.push(follower);
        }
      }
    }
    return retPens;
  }
  setFollowers(pens = this.store.active) {
    if (!pens) {
      return;
    }
    if (pens.length < 2) {
      pens[0].followers = [];
    } else {
      //以最后一个
      let ids = pens.map(pen => pen.id);
      ids.pop();
      const lastPen = pens[pens.length - 1];
      if (!lastPen.followers) {
        lastPen.followers = ids;
      } else {
        ids.forEach(id => {
          if (!lastPen.followers.includes(id)) {
            lastPen.followers.push(id);
          }
        });
      }
    }
  }
  /**
   * 修改对应连线的 anchors
   * @param oldId 老 id
   * @param pen 节点
   * @param pastePens 本次复制的 pens 包含子节点
   */
  changeLineAnchors(oldId, pen, pastePens) {
    if (!Array.isArray(pen.connectedLines)) {
      return;
    }
    for (let index = 0; index < pen.connectedLines.length; index++) {
      const {
        lineId
      } = pen.connectedLines[index];
      const line = pastePens.find(pen => pen.id === lineId);
      if (line) {
        const from = line.anchors[0];
        const to = line.anchors[line.anchors.length - 1];
        from.connectTo === oldId && (from.connectTo = pen.id);
        to.connectTo === oldId && (to.connectTo = pen.id);
      } else {
        // 说明它的连接线不在本次复制的范围内
        pen.connectedLines.splice(index, 1);
        index--;
      }
    }
  }
  /**
   * 复制连线的过程，修改 与 此线连接 node 的 connectedLines
   * @param oldId 线原 id
   * @param line 线
   * @param pastePens 此处复制的全部 pens (包含子节点)
   */
  changeNodeConnectedLine(oldId, line, pastePens) {
    const from = line.anchors[0];
    const to = line.anchors[line.anchors.length - 1];
    // 修改对应节点的 connectedLines
    const anchors = [from, to];
    for (const anchor of anchors) {
      const nodeId = anchor.connectTo;
      if (nodeId) {
        const node = pastePens.find(pen => pen.id === nodeId);
        if (node) {
          node.connectedLines?.forEach(cl => {
            if (cl.lineId === oldId) {
              cl.lineId = line.id;
              cl.lineAnchor = anchor.id;
            }
          });
        } else {
          // 节点不在本次复制的范围内
          anchor.connectTo = undefined;
          if (anchor.prev) {
            anchor.prev.connectTo = undefined;
          }
          if (anchor.next) {
            anchor.next.connectTo = undefined;
          }
        }
      }
    }
  }
  async delete(pens = this.store.active, canDelLocked = false, history = true) {
    if (!pens || !pens.length) {
      return;
    }
    if (this.beforeRemovePens && (await this.beforeRemovePens(pens)) != true) {
      return;
    }
    if (!canDelLocked) {
      pens = pens.filter(pen => !pen.locked);
    }
    if (!pens || !pens.length) {
      return;
    }
    const deletePens = [];
    this._del(pens, deletePens, canDelLocked);
    this.initImageCanvas(deletePens);
    this.initTemplateCanvas(deletePens);
    this.inactive();
    this.clearHover();
    this.render();
    // TODO: 连线的删除 ，连接的 node 的 connectLines 会变化（删除 node ，line 的 anchors 类似），未记历史记录
    if (history) {
      if (deletePens.length === 0) return;
      this.pushHistory({
        type: EditType.Delete,
        pens: deletePens
      });
    }
    this.store.emitter.emit('delete', pens);
  }
  _del(pens, delPens, canDelLocked) {
    if (!pens) {
      return;
    }
    pens.forEach(pen => {
      if (pen.type) {
        pen.lastConnected = {};
      }
      if (!pen.parentId) {
        if (!canDelLocked && pen.locked) {
          return;
        } else {
          if (delPens) {
            this.getDelPens(pen, delPens);
          }
          this.delForce(pen);
        }
      } else {
        const lockedParent = this.getLockedParent(pen);
        if (lockedParent) {
          console.warn('父节点锁定');
          return;
        } else {
          const parentPen = getParent(pen);
          const _index = parentPen.children.indexOf(pen.id);
          parentPen.children.splice(_index, 1);
          if (delPens) {
            this.getDelPens(pen, delPens);
          }
          this.delForce(pen);
        }
      }
    });
  }
  getDelPens(pen, delPens) {
    if (!pen) {
      return;
    }
    const i = this.store.data.pens.findIndex(item => item.id === pen.id);
    if (i > -1) {
      const delPen = this.store.pens[pen.id];
      delPen.calculative.active = undefined;
      delPens.push(delPen);
    }
    if (pen.children) {
      pen.children.forEach(id => {
        this.getDelPens(this.store.pens[id], delPens);
      });
    }
  }
  getLockedParent(pen) {
    if (!pen.parentId) {
      return false;
    }
    const parentPen = getParent(pen);
    if (parentPen.locked) {
      return parentPen;
    } else {
      this.getLockedParent(parentPen);
    }
  }
  delForce(pen) {
    if (!pen) {
      return;
    }
    const i = this.store.data.pens.findIndex(item => item.id === pen.id);
    if (i > -1) {
      this.delConnectedLines(this.store.data.pens[i]);
      this.store.data.pens.splice(i, 1);
      this.store.pens[pen.id] = undefined;
      delete this.store.pens[pen.id];
    }
    this.store.animates.delete(pen);
    this.store.animateMap.delete(pen);
    if (pen.children) {
      pen.children.forEach(id => {
        this.delForce(this.store.pens[id]);
      });
    }
    pen.onDestroy?.(pen);
  }
  delConnectedLines(pen) {
    if (pen.connectedLines) {
      for (let i = 0; i < pen.connectedLines.length; i++) {
        const {
          lineId,
          lineAnchor
        } = pen.connectedLines[i];
        const line = this.store.pens[lineId];
        if (line) {
          let anchor = line.anchors.find(anchor => anchor.id === lineAnchor);
          if (anchor?.connectTo === pen.id) {
            anchor.connectTo = undefined;
            anchor.anchorId = undefined;
            anchor.prev && (anchor.prev.connectTo = undefined);
            anchor.next && (anchor.next.connectTo = undefined);
          }
          anchor = getAnchor(line, lineAnchor);
          if (anchor) {
            anchor.connectTo = undefined;
            anchor.anchorId = undefined;
            anchor.prev && (anchor.prev.connectTo = undefined);
            anchor.next && (anchor.next.connectTo = undefined);
          }
        }
      }
    }
    if (!pen.type) {
      return;
    }
    pen.calculative.worldAnchors?.forEach((lineAnchor, index) => {
      if (!lineAnchor.connectTo) {
        return;
      }
      const connectTo = this.store.pens[lineAnchor.connectTo];
      if (connectTo) {
        connectTo.calculative.worldAnchors?.forEach(anchor => {
          disconnectLine(connectTo, anchor, pen, lineAnchor);
        });
      }
    });
  }
  convertSpecialCharacter(str) {
    var arrEntities = {
      lt: '<',
      gt: '>',
      nbsp: ' ',
      amp: '&',
      quot: '"'
    };
    return str.replace(/&(lt|gt|nbsp|amp|quot);/gi, function (all, t) {
      return arrEntities[t];
    });
  }
  createInput() {
    this.inputParent.classList.add('meta2d-input');
    this.inputRight.classList.add('right');
    this.inputDiv.classList.add('input-div');
    this.inputParent.appendChild(this.inputDiv);
    this.inputParent.appendChild(this.inputRight);
    this.dropdown.onmouseleave = () => {
      this.store.hover = null;
    };
    this.inputParent.appendChild(this.dropdown);
    this.externalElements.appendChild(this.inputParent);
    this.inputParent.onmousedown = this.stopPropagation;
    this.inputDiv.onmousedown = this.stopPropagation;
    this.inputDiv.contentEditable = 'false';
    this.inputRight.onmousedown = this.stopPropagation;
    this.dropdown.onmousedown = this.stopPropagation;
    this.inputRight.style.transform = 'rotate(135deg)';
    let sheet;
    for (let i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].title === 'le5le.com') {
        sheet = document.styleSheets[i];
      }
    }
    if (!sheet) {
      const style = document.createElement('style');
      style.title = 'le5le.com';
      document.head.appendChild(style);
      sheet = style.sheet;
      sheet.insertRule('.meta2d-input{display:none;position:absolute;outline:none;align-items: center;}');
      sheet.insertRule('.meta2d-input textarea{resize:none;border:none;outline:none;background:transparent;flex-grow:1;height:100%;left:0;top:0}');
      sheet.insertRule('.meta2d-input .right{width:10px;height:10px;flex-shrink:0;border-top: 1px solid;border-right: 1px solid;margin-right: 5px;transition: all .3s cubic-bezier(.645,.045,.355,1);position:absolute;right:1px;}');
      sheet.insertRule('.meta2d-input ul{position:absolute;top:100%;left:-5px;width:calc(100% + 10px);min-height:30px;border-radius: 2px;box-shadow: 0 2px 8px #00000026;list-style-type: none;background-color: #fff;padding: 4px 0;max-height: 105px;overflow-y: auto;}');
      sheet.insertRule('.meta2d-input ul li{padding: 5px 12px;line-height: 22px;white-space: nowrap;cursor: pointer;}');
      sheet.insertRule('.meta2d-input ul li:hover{background: #eeeeee;}');
      sheet.insertRule(`.input-div::-webkit-scrollbar {display:none}`);
      sheet.insertRule(`.input-div{scrollbar-width: none;}`);
      sheet.insertRule('.meta2d-input .input-div{resize:none;border:none;outline:none;background:transparent;flex-grow:1;height:100%;width: 100%;left:0;top:0;display:flex;text-align: center;justify-content: center;flex-direction: column;}');
      sheet.insertRule(`.input-div div{}`);
    }
    this.inputDiv.onfocus = e => {
      if (navigator.userAgent.includes('Firefox')) {
        if (!e.target.innerText) {
          let left = this.inputDiv.offsetWidth / 2;
          let inputDivStyle = window.getComputedStyle(this.inputDiv, null);
          if (inputDivStyle.textAlign !== 'center') {
            left = 0;
          }
          this.inputDiv.innerHTML = `<br style="margin-left:${left}px;margin-top:4px;" />`;
        }
      } else {
        //无文本时，光标确保居中
        if (!e.target.innerText) {
          let inputDivStyle = window.getComputedStyle(this.inputDiv, null);
          if (inputDivStyle.justifyContent === 'center') {
            this.inputDiv.style.paddingTop = ` ${this.inputDiv.offsetHeight / 2 - parseFloat(inputDivStyle.lineHeight) / 2}px`;
          }
        } else {
          this.inputDiv.style.paddingTop = '';
        }
      }
    };
    this.inputDiv.onblur = () => {
      setTimeout(() => {
        this.hideInput();
      }, 300);
    };
    this.inputDiv.oninput = e => {
      const pen = this.store.pens[this.inputDiv.dataset.penId];
      if (pen && pen.inputType === 'number') {
        const value = e.target.innerText;
        const numericValue = value.replace(/[^0-9]/g, ''); // 移除非数字字符
        // 如果输入的值不是纯数字，则替换为纯数字
        if (value !== numericValue) {
          e.preventDefault();
          e.target.innerText = numericValue;
        }
      }
      // //无文本时，光标确保居中
      if (navigator.userAgent.includes('Firefox')) {
        if (!e.target.innerText.trim()) {
          let left = this.inputDiv.offsetWidth / 2;
          let inputDivStyle = window.getComputedStyle(this.inputDiv, null);
          if (inputDivStyle.textAlign !== 'center') {
            left = 0;
          }
          this.inputDiv.innerHTML = `<br style="margin-left:${left}px;margin-top:4px;" />`;
        }
      } else {
        if (!e.target.innerText) {
          let inputDivStyle = window.getComputedStyle(this.inputDiv, null);
          if (inputDivStyle.justifyContent === 'center') {
            this.inputDiv.style.paddingTop = ` ${this.inputDiv.offsetHeight / 2 - parseFloat(inputDivStyle.lineHeight) / 2}px`;
          }
        } else {
          this.inputDiv.style.paddingTop = '';
        }
      }
      this.store.emitter.emit('input', pen);
    };
    this.inputDiv.onclick = e => {
      e.stopPropagation();
      const pen = this.store.pens[this.inputDiv.dataset.penId];
      if (this.dropdown.style.display === 'block') {
        this.dropdown.style.display = 'none';
        this.inputRight.style.transform = 'rotate(135deg)';
      } else if (pen?.dropdownList && this.store.data.locked) {
        this.dropdown.style.display = 'block';
        this.inputRight.style.transform = 'rotate(315deg)';
      }
      this.store.emitter.emit('clickInput', pen);
    };
    this.inputDiv.onkeyup = e => {
      this.setDropdownList(true);
      const pen = this.store.pens[this.inputDiv.dataset.penId];
      this.store.emitter.emit('input', {
        pen,
        text: e.key
      });
      e.stopPropagation();
    };
    this.inputDiv.onkeydown = e => {
      e.stopPropagation();
    };
    this.inputDiv.onmousedown = this.stopPropagation;
    this.inputDiv.onwheel = e => {
      e.stopPropagation();
    };
    this.inputDiv.onpaste = e => {
      e.preventDefault();
      let text = '';
      if (e.clipboardData && e.clipboardData.getData) {
        text = e.clipboardData.getData('text/plain');
      }
      document.execCommand('insertHTML', false, text);
    };
  }
  clearDropdownList() {
    if (this.dropdown.hasChildNodes()) {
      for (let i = 0; i < this.dropdown.childNodes.length; i++) {
        this.dropdown.childNodes[i].remove();
        --i;
      }
    }
  }
  /**
   * 添加一个选项到 dropdown dom 中
   * @param text 选项文字
   * @param index 选项索引
   */
  dropdownAppendOption(text, index) {
    const li = document.createElement('li');
    li.onwheel = this.stopPropagation;
    li.innerText = text;
    li.style.overflow = 'hidden';
    li.style.textOverflow = 'ellipsis';
    li.title = text;
    li.style.zoom = this.store.data.scale;
    li.onmousedown = this.stopPropagation;
    li.dataset.i = index + '';
    li.onclick = this.selectDropdown;
    this.dropdown.appendChild(li);
  }
  find(idOrTag) {
    return this.store.data.pens.filter(pen => {
      return pen.id == idOrTag || pen.tags && pen.tags.indexOf(idOrTag) > -1;
    });
  }
  findOne(idOrTag) {
    return this.store.data.pens.find(pen => {
      return pen.id == idOrTag || pen.tags && pen.tags.indexOf(idOrTag) > -1;
    });
  }
  changePenId(oldId, newId) {
    if (oldId === newId) {
      return;
    }
    const pen = this.store.pens[oldId];
    if (!pen) {
      return;
    }
    if (this.store.pens[newId]) {
      return;
    }
    // 若新画笔不存在
    pen.id = newId;
    this.store.pens[newId] = this.store.pens[oldId];
    // dom 节点，需要更改 id
    pen.onChangeId?.(pen, oldId, newId);
    delete this.store.pens[oldId];
    // 父子
    if (pen.parentId) {
      const parent = this.store.pens[pen.parentId];
      const index = parent.children?.findIndex(id => id === oldId);
      index !== -1 && parent.children?.splice(index, 1, newId);
    }
    pen.children?.forEach(childId => {
      const child = this.store.pens[childId];
      child.parentId = newId;
    });
    // 连接关系
    if (pen.type === PenType.Line) {
      // TODO: 仍然存在 节点类型的 连线，此处判断需要更改
      this.changeNodeConnectedLine(oldId, pen, this.store.data.pens);
    } else {
      this.changeLineAnchors(oldId, pen, this.store.data.pens);
      pen.connectedLines?.forEach(({
        lineId
      }) => {
        const line = this.store.pens[lineId];
        calcWorldAnchors(line);
      });
    }
    //锚点
    pen.anchors?.forEach(anchor => anchor.penId = newId);
    pen.calculative.worldAnchors?.forEach(anchor => anchor.penId = newId);
  }
  updateValue(pen, data) {
    const penRect = this.getPenRect(pen);
    const oldName = pen.name;
    Object.assign(pen, data);
    // data 可能没有 name 属性
    const isChangedName = oldName !== pen.name; // name changed
    data.newId && this.changePenId(pen.id, data.newId);
    let willUpdatePath = false;
    let willCalcTextRect = false;
    let willPatchFlagsPenRect = false; // 是否需要重新计算世界坐标
    let willCalcIconRect = false; // 是否需要重现计算 icon 区域
    let willSetPenRect = false; // 是否重新 setPenRect
    let containIsBottom = false; // 是否包含 isBottom 属性修改
    let oldRotate = undefined;
    let willRenderImage = false; // 是否需要重新渲染图片
    for (const k in data) {
      // 单属性
      if (k.indexOf('.') === -1) {
        if (k === 'rotate') {
          oldRotate = pen.calculative.rotate || 0;
        } else if (k === 'canvasLayer' || k === 'isBottom' || k === 'showChild') {
          containIsBottom = true;
        } else if (k === 'image') {
          willRenderImage = true;
        }
        if (typeof pen[k] !== 'object' || k === 'lineDash') {
          pen.calculative[k] = data[k];
        }
        if (needCalcTextRectProps.includes(k)) {
          willCalcTextRect = true;
        }
        if (['name', 'borderRadius', 'lineSmooth', 'close'].includes(k)) {
          willUpdatePath = true;
        }
        if (needSetPenProps.includes(k)) {
          willSetPenRect = true;
        }
        if (needPatchFlagsPenRectProps.includes(k)) {
          willPatchFlagsPenRect = true;
        }
        if (needCalcIconRectProps.includes(k)) {
          willCalcIconRect = true;
        }
        if (pen.image && pen.name !== 'gif' && ['globalAlpha', 'flipY', 'flipX', 'x', 'y', 'width', 'height', 'iconWidth', 'iconHeight', 'imageRatio', 'iconLeft', 'iconTop', 'iconAlign', 'rotate'].includes(k)) {
          willRenderImage = true;
        }
      } else {
        // 复合属性，如abc.def.ghi
        delete pen[k];
        setter(pen, k, data[k]);
      }
      // anchors 或者 anchors.x都去执行
      if (k.split('.')[0] === 'anchors') {
        calcWorldAnchors(pen);
      }
    }
    this.setCalculativeByScale(pen); // 该方法计算量并不大，所以每次修改都计算一次
    if (isChangedName) {
      pen.onDestroy?.(pen);
      clearLifeCycle(pen);
      // 后续代码会重算 path2D
    }
    if (willSetPenRect) {
      const rect = {
        x: data.x ?? penRect.x,
        y: data.y ?? penRect.y,
        width: data.width ?? penRect.width,
        height: data.height ?? penRect.height
      };
      this.setPenRect(pen, rect, false);
      this.updateLines(pen, true);
      if (this.store.active && this.store.active.length && pen.id === this.store.active[0].id) {
        this.calcActiveRect();
      }
    } else if (willPatchFlagsPenRect) {
      this.updatePenRect(pen);
    } else {
      willCalcTextRect && calcTextRect(pen);
      willCalcIconRect && calcIconRect(this.store.pens, pen);
      if (willUpdatePath) {
        globalStore.path2dDraws[pen.name] && this.store.path2dMap.set(pen, globalStore.path2dDraws[pen.name](pen));
      }
    }
    // 若同时设置 x,y,width,height 与 rotate ，先 setPenRect ，再计算 rotate
    if (oldRotate !== undefined) {
      const currentRotate = pen.calculative.rotate;
      pen.calculative.rotate = oldRotate;
      // TODO: rotatePen 会执行 updatePenRect ，上面已经执行 updatePenRect
      this.rotatePen(pen, currentRotate - oldRotate, pen.calculative.worldRect);
    }
    if (data.image || data.backgroundImage || data.strokeImage) {
      pen.calculative.image = undefined;
      pen.calculative.backgroundImage = undefined;
      pen.calculative.strokeImage = undefined;
      this.loadImage(pen);
    }
    if (data.lineGradientColors) {
      pen.calculative.lineGradient = undefined;
      pen.calculative.gradientColorStop = undefined;
    }
    if (data.gradientColors) {
      pen.calculative.gradient = undefined;
      pen.calculative.radialGradient = undefined;
    }
    if (data.gradientRadius) {
      pen.calculative.gradient = undefined;
      pen.calculative.radialGradient = undefined;
    }
    if (data.animateLineWidth) {
      pen.calculative.gradientAnimatePath = undefined;
    }
    if (data.gradientSmooth) {
      pen.calculative.gradientAnimatePath = undefined;
    }
    if (containIsBottom) {
      this.canvasImage.init();
      this.canvasImageBottom.init();
    } else if (willRenderImage) {
      // 存在先有 image 后无 image 的情况
      // if (pen.isBottom) {
      //   this.canvasImageBottom.init();
      // } else {
      //   this.canvasImage.init();
      // }
      if (pen.canvasLayer === undefined) {
        pen.canvasLayer = CanvasLayer.CanvasImageBottom;
        pen.calculative.canvasLayer = CanvasLayer.CanvasImageBottom;
      }
      if (pen.canvasLayer === CanvasLayer.CanvasImageBottom) {
        this.canvasImageBottom.init();
      } else if (pen.canvasLayer === CanvasLayer.CanvasImage) {
        this.canvasImage.init();
      }
    }
    // else {
    //   this.initImageCanvas([pen]);
    // }
    // if (data.template !== undefined || pen.template) {
    //   this.initTemplateCanvas([pen]);
    // }
    if (data.canvasLayer !== undefined || pen.canvasLayer === CanvasLayer.CanvasTemplate) {
      this.initTemplateCanvas([pen]);
    }
    if (data.zIndex !== undefined) {
      pen.calculative.singleton?.div && render_setElemPosition(pen, pen.calculative.singleton.div);
    }
  }
  /**
   * 执行 pen ，以及 pen 的子孙节点的 onResize 生命周期函数
   */
  execPenResize(pen) {
    pen.onResize?.(pen);
    pen.children?.forEach(chlidId => {
      const child = this.store.pens[chlidId];
      child && this.execPenResize(child);
    });
  }
  setPenRect(pen, rect, render = true) {
    if (pen.parentId) {
      // 子节点的 rect 值，一定得是比例值
      Object.assign(pen, rect);
    } else {
      const {
        origin,
        scale
      } = this.store.data;
      pen.x = origin.x + rect.x * scale;
      pen.y = origin.y + rect.y * scale;
      pen.width = rect.width * scale;
      pen.height = rect.height * scale;
    }
    this.updatePenRect(pen);
    this.execPenResize(pen);
    render && this.render();
  }
  getPenRect(pen, origin = this.store.data.origin, scale = this.store.data.scale) {
    if (!pen) {
      return;
    }
    if (pen.parentId) {
      // 子节点的 rect 只与父节点 rect 有关
      return {
        x: pen.x,
        y: pen.y,
        width: pen.width,
        height: pen.height
      };
    }
    return {
      x: (pen.x - origin.x) / scale,
      y: (pen.y - origin.y) / scale,
      width: pen.width / scale,
      height: pen.height / scale
    };
  }
  toPng(padding = 2, callback, containBkImg = false, maxWidth) {
    const rect = getRect(this.store.data.pens);
    const _scale = this.store.data.scale;
    if (!isFinite(rect.width)) {
      throw new Error('can not to png, because width is not finite');
    }
    const oldRect = deepClone(rect);
    const storeData = this.store.data;
    // TODO: 目前背景颜色优先级更高
    const isDrawBkImg = containBkImg && !storeData.background && this.store.bkImg;
    // 主体在背景的右侧，下侧
    let isRight = false,
      isBottom = false;
    if (isDrawBkImg) {
      rect.x += storeData.x;
      rect.y += storeData.y;
      rect_calcRightBottom(rect);
      if (rectInRect(rect, this.canvasRect, true)) {
        // 全部在区域内，那么 rect 就是 canvasRect
        Object.assign(rect, this.canvasRect);
      } else {
        // 合并区域
        const mergeArea = getRectOfPoints([...rectToPoints(rect), ...rectToPoints(this.canvasRect)]);
        Object.assign(rect, mergeArea);
      }
      isRight = rect.x === 0;
      isBottom = rect.y === 0;
    }
    const width = this.store.data.width || this.store.options.width;
    const height = this.store.data.height || this.store.options.height;
    //大屏
    let isV = false;
    if (width && height && !this.store.data.component) {
      isV = true;
    }
    if (isV) {
      rect.x = this.store.data.origin.x;
      rect.y = this.store.data.origin.y;
      rect.width = width * this.store.data.scale;
      rect.height = height * this.store.data.scale;
    }
    const vRect = deepClone(rect);
    // 有背景图，也添加 padding
    const p = formatPadding(padding);
    rect.x -= p[3] * _scale;
    rect.y -= p[0] * _scale;
    rect.width += (p[3] + p[1]) * _scale;
    rect.height += (p[0] + p[2]) * _scale;
    // 扩大图
    // const scale =
    //   rect.width > rect.height ? longSide / rect.width : longSide / rect.height;
    const scale = (maxWidth || 1920) / rect.width;
    rect.width *= scale;
    rect.height *= scale;
    rect_calcRightBottom(rect);
    const canvas = document.createElement('canvas');
    canvas.width = rect.width;
    canvas.height = rect.height;
    if (canvas.width > 32767 || canvas.height > 32767 || !navigator.userAgent.includes('Firefox') && canvas.height * canvas.width > 268435456 || navigator.userAgent.includes('Firefox') && canvas.height * canvas.width > 472907776) {
      throw new Error('can not to png, because the size exceeds the browser limit');
    }
    const ctx = canvas.getContext('2d');
    // if (window.devicePixelRatio > 1) {
    //   canvas.width *= window.devicePixelRatio;
    //   canvas.height *= window.devicePixelRatio;
    //   canvas.style.width = `${canvas.width / window.devicePixelRatio}`;
    //   canvas.style.height = `${canvas.height / window.devicePixelRatio}`;
    //   ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    // }
    ctx.textBaseline = 'middle'; // 默认垂直居中
    ctx.scale(scale, scale);
    const background = this.store.data.background || this.store.options.background;
    if (background) {
      // 绘制背景颜色
      ctx.save();
      ctx.fillStyle = background;
      if (isV) {
        ctx.fillRect(0, 0, vRect.width + (p[1] + p[3]) * _scale, vRect.height + (p[0] + p[2]) * _scale);
      } else {
        ctx.fillRect(0, 0, oldRect.width + (p[3] + p[1]) * _scale, oldRect.height + (p[0] + p[2]) * _scale);
      }
      ctx.restore();
    }
    if (isDrawBkImg) {
      if (isV) {
        ctx.drawImage(this.store.bkImg, p[3] * _scale || 0, p[0] * _scale || 0, vRect.width, vRect.height);
      } else {
        const x = rect.x < 0 ? -rect.x : 0;
        const y = rect.y < 0 ? -rect.y : 0;
        ctx.drawImage(this.store.bkImg, x, y, this.canvasRect.width, this.canvasRect.height);
      }
    }
    if (!isDrawBkImg) {
      ctx.translate(-rect.x, -rect.y);
    } else {
      // 平移画布，画笔的 worldRect 不变化
      if (isV) {
        ctx.translate(-oldRect.x + p[3] * _scale || 0, -oldRect.y + p[0] * _scale || 0);
      } else {
        ctx.translate((isRight ? storeData.x : -oldRect.x) + p[3] * _scale || 0, (isBottom ? storeData.y : -oldRect.y) + p[0] * _scale || 0);
      }
    }
    for (const pen of this.store.data.pens) {
      // 不使用 calculative.inView 的原因是，如果 pen 在 view 之外，那么它的 calculative.inView 为 false，但是它的绘制还是需要的
      if (!isShowChild(pen, this.store) || pen.visible == false) {
        continue;
      }
      // TODO: hover 待考虑，若出现再补上
      const {
        active
      } = pen.calculative;
      pen.calculative.active = false;
      if (pen.calculative.img) {
        renderPenRaw(ctx, pen);
      } else {
        renderPen(ctx, pen, true);
      }
      pen.calculative.active = active;
    }
    if (callback) {
      canvas.toBlob(callback);
      return;
    }
    return canvas.toDataURL();
  }
  activeToPng(padding = 2, maxWidth) {
    return this.pensToPng(this.store.active, padding, maxWidth);
  }
  pensToPng(pens = this.store.active, padding = 2, maxWidth) {
    if (pens.length === 0) {
      return;
    }
    const allPens = this.getAllByPens(pens);
    let ids = allPens.map(pen => pen.id);
    const rect = getRect(allPens);
    if (!isFinite(rect.width)) {
      throw new Error('can not to png, because width is not finite');
    }
    const oldRect = deepClone(rect);
    const p = formatPadding(padding);
    rect.x -= p[3];
    rect.y -= p[0];
    rect.width += p[3] + p[1];
    rect.height += p[0] + p[2];
    rect_calcRightBottom(rect);
    const scale = (maxWidth || rect.width) / rect.width;
    rect.width *= scale;
    rect.height *= scale;
    const canvas = document.createElement('canvas');
    canvas.width = rect.width;
    canvas.height = rect.height;
    if (canvas.width > 32767 || canvas.height > 32767 || !navigator.userAgent.includes('Firefox') && canvas.height * canvas.width > 268435456 || navigator.userAgent.includes('Firefox') && canvas.height * canvas.width > 472907776) {
      throw new Error('can not to png, because the size exceeds the browser limit');
    }
    const ctx = canvas.getContext('2d');
    ctx.textBaseline = 'middle'; // 默认垂直居中
    ctx.scale(scale, scale);
    const background = this.store.data.background || this.store.options.background;
    if (background) {
      // 绘制背景颜色
      ctx.save();
      ctx.fillStyle = background;
      ctx.fillRect(0, 0, oldRect.width + (p[3] + p[1]), oldRect.height + (p[0] + p[2]));
      ctx.restore();
    }
    // // 平移画布，画笔的 worldRect 不变化
    ctx.translate(-oldRect.x + p[3], -oldRect.y + p[0]);
    for (const pen of this.store.data.pens) {
      if (ids.includes(pen.id)) {
        // 不使用 calculative.inView 的原因是，如果 pen 在 view 之外，那么它的 calculative.inView 为 false，但是它的绘制还是需要的
        if (!isShowChild(pen, this.store) || pen.visible == false) {
          continue;
        }
        const {
          active
        } = pen.calculative;
        pen.calculative.active = false;
        if (pen.calculative.img) {
          renderPenRaw(ctx, pen);
        } else {
          renderPen(ctx, pen);
        }
        pen.calculative.active = active;
      }
    }
    return canvas.toDataURL();
  }
  toggleAnchorMode() {
    if (!this.hotkeyType) {
      if (this.store.options.disableAnchor || this.store.hover?.disableAnchor) {
        return;
      }
      this.hotkeyType = HotkeyType.AddAnchor;
      if (this.store.hover) {
        this.externalElements.style.cursor = 'pointer';
      }
    } else if (this.hotkeyType === HotkeyType.AddAnchor) {
      this.hotkeyType = HotkeyType.None;
      if (this.store.hoverAnchor) {
        this.externalElements.style.cursor = 'vertical-text';
      } else if (this.store.hover) {
        this.externalElements.style.cursor = 'move';
      }
    }
    this.patchFlags = true;
  }
  addAnchorHand() {
    if (this.store.activeAnchor && this.store.active && this.store.active.length === 1 && this.store.active[0].type) {
      const initPens = [deepClone(this.store.active[0], true)];
      if (!this.store.activeAnchor.prev) {
        if (!this.store.activeAnchor.next) {
          this.store.activeAnchor.next = {
            penId: this.store.activeAnchor.penId,
            x: this.store.activeAnchor.x + 50,
            y: this.store.activeAnchor.y
          };
        }
        this.store.activeAnchor.prev = {
          ...this.store.activeAnchor.next
        };
        rotatePoint(this.store.activeAnchor.prev, 180, this.store.activeAnchor);
        this.initLineRect(this.store.active[0]);
        this.patchFlags = true;
      } else if (!this.store.activeAnchor.next) {
        this.store.activeAnchor.next = {
          ...this.store.activeAnchor.prev
        };
        rotatePoint(this.store.activeAnchor.next, 180, this.store.activeAnchor);
        this.initLineRect(this.store.active[0]);
        this.patchFlags = true;
      }
      this.pushHistory({
        type: EditType.Update,
        pens: [deepClone(this.store.active[0], true)],
        initPens
      });
    }
  }
  removeAnchorHand() {
    if (this.store.activeAnchor && this.store.active && this.store.active.length === 1 && this.store.active[0].type) {
      const initPens = [deepClone(this.store.active[0], true)];
      if (this.hoverType === HoverType.LineAnchorPrev) {
        this.store.activeAnchor.prev = undefined;
        this.initLineRect(this.store.active[0]);
        this.patchFlags = true;
      } else if (this.hoverType === HoverType.LineAnchorNext) {
        this.store.activeAnchor.next = undefined;
        this.initLineRect(this.store.active[0]);
        this.patchFlags = true;
      } else {
        this.store.activeAnchor.prev = undefined;
        this.store.activeAnchor.next = undefined;
        this.initLineRect(this.store.active[0]);
        this.patchFlags = true;
      }
      this.pushHistory({
        type: EditType.Update,
        pens: [deepClone(this.store.active[0])],
        initPens
      });
    }
  }
  toggleAnchorHand() {
    if (this.store.active.length === 1 && this.store.active[0].type && this.store.activeAnchor) {
      if (!this.store.activeAnchor.prevNextType) {
        this.store.activeAnchor.prevNextType = PrevNextType.Mirror;
      }
      this.store.activeAnchor.prevNextType = (this.store.activeAnchor.prevNextType + 1) % 3;
    }
  }
  gotoView(x, y) {
    let rect = getRect(this.store.data.pens);
    if (!isFinite(rect.width)) {
      throw new Error('can not move view, because width is not finite');
    }
    const width = this.store.data.width || this.store.options.width;
    const height = this.store.data.height || this.store.options.height;
    if (width && height) {
      //大屏
      rect = {
        x: this.store.data.origin.x,
        y: this.store.data.origin.y,
        width: width * this.store.data.scale,
        height: height * this.store.data.scale
      };
    }
    this.store.data.x = this.canvas.clientWidth / 2 - x * rect.width - rect.x;
    this.store.data.y = this.canvas.clientHeight / 2 - y * rect.height - rect.y;
    this.onMovePens();
    this.canvasTemplate.init();
    this.canvasImage.init();
    this.canvasImageBottom.init();
    this.render();
  }
  showMagnifier() {
    this.magnifierCanvas.magnifier = true;
    this.externalElements.style.cursor = 'default';
    this.render();
  }
  hideMagnifier() {
    this.magnifierCanvas.magnifier = false;
    this.externalElements.style.cursor = 'default';
    this.render();
  }
  showFit() {
    this.store.data.locked = 0;
    this.canvasImage.fitFlag = true;
    this.canvasImage.activeFit = undefined;
    this.canvasImage.currentFit = undefined;
    if (!this.store.data.fits) {
      this.store.data.fits = [];
    }
    this.store.data.fits.forEach(fit => fit.active = false);
    this.canvasImage.init();
    this.canvasImage.render();
  }
  hideFit() {
    this.canvasImage.fitFlag = false;
    this.canvasImage.activeFit = undefined;
    this.canvasImage.currentFit = undefined;
    this.canvasImage.init();
    this.canvasImage.render();
  }
  makeFit() {
    if (this.dragRect.width < 100 && this.dragRect.height < 100) {
      return;
    }
    //将所有当前框选的图元设置到该容器中
    const pens = this.store.data.pens.filter(pen => {
      if (
      // pen.locked >= LockState.DisableMove || 
      pen.parentId || pen.isRuleLine) {
        return false;
      }
      if (rectInRect(pen.calculative.worldRect, this.dragRect, true)) {
        // 先判断在区域内，若不在区域内，则锚点肯定不在框选区域内，避免每条连线过度计算
        if (pen.type === PenType.Line && !this.store.options.dragAllIn) {
          return lineInRect(pen, this.dragRect);
        }
        return true;
      }
    });
    if (!pens.length) {
      return;
    }
    const _rect = this.parent.getRect(pens);
    const scale = this.store.data.scale;
    const width = this.store.data.width || this.store.options.width;
    const height = this.store.data.height || this.store.options.height;
    let x = (Math.floor(_rect.x) - this.store.data.origin.x) / scale / width;
    let y = (Math.floor(_rect.y) - this.store.data.origin.y) / scale / height;
    let rect = {
      x,
      y,
      width: (Math.ceil(_rect.width) + 1) / scale / width,
      height: (Math.ceil(_rect.height) + 1) / scale / height,
      children: pens.map(pen => pen.id),
      id: s8(),
      active: true
    };
    if (rect.x < -0.1) {
      rect.x = -0.1;
    }
    if (rect.y < -0.1) {
      rect.y = -0.1;
    }
    if (rect.width > 0.5) {
      rect.left = true;
      rect.right = true;
      rect.leftValue = (rect.x - 0) * scale * width;
      rect.rightValue = (1 - (rect.x + rect.width)) * scale * width;
    } else {
      if (rect.x < 0.5) {
        rect.left = true;
        rect.leftValue = (rect.x - 0) * scale * width;
      } else {
        rect.right = true;
        rect.rightValue = (1 - (rect.x + rect.width)) * scale * width;
      }
    }
    if (rect.leftValue < 1) {
      rect.leftValue = 0;
    }
    if (rect.rightValue < 1) {
      rect.rightValue = 0;
    }
    if (rect.height > 0.5) {
      rect.top = true;
      rect.bottom = true;
      rect.topValue = (rect.y - 0) * scale * height;
      rect.bottomValue = (1 - (rect.y + rect.height)) * scale * height;
    } else {
      if (rect.y < 0.5) {
        rect.top = true;
        rect.topValue = (rect.y - 0) * scale * height;
      } else {
        rect.bottom = true;
        rect.bottomValue = (1 - (rect.y + rect.height)) * scale * height;
      }
    }
    if (rect.topValue < 1) {
      rect.topValue = 0;
    }
    if (rect.bottomValue < 1) {
      rect.bottomValue = 0;
    }
    if (!this.store.data.fits) {
      this.store.data.fits = [];
    }
    this.store.data.fits.forEach(fit => {
      fit.active = false;
    });
    this.store.data.fits.push(rect);
    this.canvasImage.activeFit = rect;
    this.store.emitter.emit('fit', rect);
    this.canvasImage.init();
    this.canvasImage.render();
  }
  updateFit(e) {
    const scale = this.store.data.scale;
    const width = this.store.data.width || this.store.options.width;
    const height = this.store.data.height || this.store.options.height;
    let x = (e.x - this.store.data.origin.x) / scale / width;
    let y = (e.y - this.store.data.origin.y) / scale / height;
    if (this.canvasImage.currentFit) {
      const fit = this.canvasImage.activeFit;
      if (this.canvasImage.currentFit === 'top') {
        if (y < -0.1) {
          y = -0.1;
        }
        let gap = y - fit.y;
        fit.height -= gap;
        if (fit.height < 0.01) {
          fit.height = 0.01;
          return;
        }
        fit.y = y;
      }
      if (this.canvasImage.currentFit === 'bottom') {
        if (y > 1.1) {
          y = 1.1;
        }
        fit.height = y - fit.y;
        if (fit.height <= 0.01) {
          fit.height = 0.01;
        }
      }
      if (this.canvasImage.currentFit === 'left') {
        if (x < -0.1) {
          x = -0.1;
        }
        let gap = x - fit.x;
        fit.width -= gap;
        if (fit.width < 0.01) {
          fit.width = 0.01;
          return;
        }
        fit.x = x;
      }
      if (this.canvasImage.currentFit === 'right') {
        if (x > 1.1) {
          x = 1.1;
        }
        fit.width = x - fit.x;
        if (fit.width <= 0.01) {
          fit.width = 0.01;
        }
      }
      let rect = {
        x: fit.x * width * scale + this.store.data.origin.x,
        y: fit.y * height * scale + this.store.data.origin.y,
        width: fit.width * width * scale,
        height: fit.height * height * scale
      };
      rect_calcRightBottom(rect);
      const pens = this.store.data.pens.filter(pen => {
        if (
        // pen.locked >= LockState.DisableMove || 
        pen.parentId || pen.isRuleLine) {
          return false;
        }
        if (rectInRect(pen.calculative.worldRect, rect, true)) {
          if (pen.type === PenType.Line && !this.store.options.dragAllIn) {
            return lineInRect(pen, rect);
          }
          return true;
        }
      });
      fit.left = undefined;
      fit.leftValue = undefined;
      fit.right = undefined;
      fit.rightValue = undefined;
      fit.top = undefined;
      fit.topValue = undefined;
      fit.bottom = undefined;
      fit.bottomValue = undefined;
      if (fit.width > 0.5) {
        fit.left = true;
        fit.right = true;
        fit.leftValue = (fit.x - 0) * scale * width;
        fit.rightValue = (1 - (fit.x + fit.width)) * scale * width;
      } else {
        if (fit.x < 0.5) {
          fit.left = true;
          fit.leftValue = (fit.x - 0) * scale * width;
        } else {
          fit.right = true;
          fit.rightValue = (1 - (fit.x + fit.width)) * scale * width;
        }
      }
      if (Math.abs(fit.leftValue) < 1) {
        fit.leftValue = 0;
      }
      if (Math.abs(fit.rightValue) < 1) {
        fit.rightValue = 0;
      }
      if (fit.height > 0.5) {
        fit.top = true;
        fit.bottom = true;
        fit.topValue = (fit.y - 0) * scale * height;
        fit.bottomValue = (1 - (fit.y + fit.height)) * scale * height;
      } else {
        if (fit.y < 0.5) {
          fit.top = true;
          fit.topValue = (fit.y - 0) * scale * height;
        } else {
          fit.bottom = true;
          fit.bottomValue = (1 - (fit.y + fit.height)) * scale * height;
        }
      }
      if (Math.abs(fit.topValue) < 1) {
        fit.topValue = 0;
      }
      if (Math.abs(fit.bottomValue) < 1) {
        fit.bottomValue = 0;
      }
      fit.children = pens.map(pen => pen.id);
      this.store.emitter.emit('fit', fit);
      this.mouseDown.x = e.x;
      this.mouseDown.y = e.y;
      this.canvasImage.init();
      this.canvasImage.render();
    }
  }
  updateFitRect(fit = this.canvasImage.activeFit) {
    const width = this.store.data.width || this.store.options.width;
    const height = this.store.data.height || this.store.options.height;
    if (fit.left) {
      if (fit.leftValue) {
        fit.x = Math.abs(fit.leftValue) < 1 ? fit.leftValue : fit.leftValue / width;
      } else {
        fit.x = 0;
      }
    }
    if (fit.right) {
      if (fit.rightValue) {
        fit.width = 1 - (Math.abs(fit.rightValue) < 1 ? fit.rightValue : fit.rightValue / width) - fit.x;
      } else {
        fit.width = 1 - fit.x;
      }
    }
    if (fit.top) {
      if (fit.topValue) {
        fit.y = Math.abs(fit.topValue) < 1 ? fit.topValue : fit.topValue / height;
      } else {
        fit.y = 0;
      }
    }
    if (fit.bottom) {
      if (fit.bottomValue) {
        fit.height = 1 - (Math.abs(fit.bottomValue) < 1 ? fit.bottomValue : fit.bottomValue / height) - fit.y;
      } else {
        fit.height = 1 - fit.y;
      }
    }
    this.canvasImage.init();
    this.canvasImage.render();
  }
  deleteFit(fit = this.canvasImage.activeFit) {
    if (!fit) {
      return;
    }
    const index = this.store.data.fits.findIndex(item => item.id === fit.id);
    this.store.data.fits.splice(index, 1);
    this.canvasImage.activeFit = undefined;
    this.canvasImage.init();
    this.canvasImage.render();
    this.store.emitter.emit('fit', undefined);
  }
  calcuActiveFit() {
    const width = this.store.data.width || this.store.options.width;
    const height = this.store.data.height || this.store.options.height;
    let downX = (this.mouseDown.x - this.store.data.origin.x) / this.store.data.scale / width;
    let downY = (this.mouseDown.y - this.store.data.origin.y) / this.store.data.scale / height;
    let idx = -1;
    let lastActiveIdx = -1;
    this.store.data.fits?.forEach((fit, index) => {
      fit.ex = null;
      fit.ey = null;
      if (pointInRect({
        x: downX,
        y: downY
      }, fit)) {
        idx = index;
      }
      ;
      if (fit.active) {
        lastActiveIdx = index;
      }
    });
    if (idx !== -1 && idx !== lastActiveIdx) {
      this.canvasImage.activeFit = this.store.data.fits[idx];
      this.store.data.fits[idx].active = true;
      if (lastActiveIdx !== -1) {
        this.store.data.fits[lastActiveIdx].active = false;
      }
      this.store.emitter.emit('fit', this.store.data.fits[idx]);
    } else if (idx === -1 && lastActiveIdx !== -1) {
      this.store.data.fits[lastActiveIdx].active = false;
      this.store.emitter.emit('fit', undefined);
      this.canvasImage.activeFit = null;
    }
    this.inactive();
    this.canvasImage.init();
    this.canvasImage.render();
  }
  toggleMagnifier() {
    this.magnifierCanvas.magnifier = !this.magnifierCanvas.magnifier;
    if (this.magnifierCanvas.magnifier) {
      this.externalElements.style.cursor = 'default';
    }
    this.render();
  }
  destroy() {
    this.scroll && this.scroll.destroy();
    this.tooltip?.destroy();
    this.dialog?.destroy();
    this.title?.destroy();
    // ios
    this.externalElements.removeEventListener('gesturestart', this.onGesturestart);
    this.externalElements.ondragover = e => e.preventDefault();
    this.externalElements.ondrop = undefined;
    this.externalElements.ontouchstart = undefined;
    this.externalElements.ontouchmove = undefined;
    this.externalElements.ontouchend = undefined;
    this.externalElements.onmousedown = undefined;
    this.externalElements.onmousemove = undefined;
    this.externalElements.onmouseup = undefined;
    this.externalElements.onmouseleave = undefined;
    this.externalElements.ondblclick = undefined;
    switch (this.store.options.keydown) {
      case KeydownType.Document:
        document.removeEventListener('keydown', this.onkeydown);
        document.removeEventListener('keyup', this.onkeyup);
        break;
      case KeydownType.Canvas:
        this.externalElements.removeEventListener('keydown', this.onkeydown);
        this.externalElements.removeEventListener('keyup', this.onkeyup);
        break;
    }
    document.removeEventListener('copy', this.onCopy);
    document.removeEventListener('cut', this.onCut);
    document.removeEventListener('paste', this.onPaste);
    window && window.removeEventListener('message', this.onMessage);
    window && window.removeEventListener('resize', this.onResize);
    window && window.removeEventListener('scroll', this.onScroll);
  }
}
;// ./node_modules/@kyvi/cobweb/src/canvas/index.js


;// ./node_modules/@kyvi/cobweb/src/diagrams/panel.js




function panel(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  if (!pen.onDestroy) {
    pen.onDestroy = panel_destory;
    pen.onMove = panel_move;
    pen.onRotate = panel_move;
    pen.onMouseEnter = mouseEnter;
    pen.onMouseLeave = mouseLeave;
    pen.onMouseMove = panel_mouseMove;
    pen.onMouseUp = mouseUp;
    pen.onInput = input;
  }
  let wr = pen.calculative.borderRadius || 0,
    hr = wr;
  const {
    x,
    y,
    width,
    height,
    ex,
    ey
  } = pen.calculative.worldRect;
  const {
    x: textX
  } = pen.calculative.worldTextRect;
  if (wr < 1) {
    wr = width * wr;
    hr = height * hr;
  }
  let r = wr < hr ? wr : hr;
  if (width < 2 * r) {
    r = width / 2;
  }
  if (height < 2 * r) {
    r = height / 2;
  }
  const textWidth = getTextWidth(pen.text, pen.calculative.fontSize);
  path.moveTo(x + r, y);
  path.lineTo(textX - 5, y);
  path.moveTo(textX + textWidth + 5, y);
  path.lineTo(textX + textWidth + 5, y);
  path.arcTo(ex, y, ex, ey, r);
  path.arcTo(ex, ey, x, ey, r);
  path.arcTo(x, ey, x, y, r);
  path.arcTo(x, y, ex, y, r);
  if (path instanceof Path2D) {
    return path;
  }
}
function getTextWidth(text, fontSize) {
  // 近似计算
  const chinese = text.match(/[^\x00-\xff]/g) || '';
  const chineseWidth = chinese.length * fontSize; // 中文占用的宽度
  const spaces = text.match(/\s/g) || '';
  const spaceWidth = spaces.length * fontSize * 0.3; // 空格占用的宽度
  const otherWidth = (text.length - chinese.length - spaces.length) * fontSize * 0.6; // 其他字符占用的宽度
  const currentWidth = chineseWidth + spaceWidth + otherWidth;
  return currentWidth;
}
function input(pen, text) {
  pen.text = text;
  pen.calculative.text = pen.text;
  // this.inputDiv.dataset.penId = undefined;
  pen.calculative.canvas.updatePenRect(pen);
  // this.patchFlags = true;
  // this.store.emitter.emit('valueUpdate', pen);
}
function panel_destory(pen) {}
function panel_move(pen) {}
function mouseEnter(pen) {
  // const activePens = pen.calculative.canvas.store.active;
  // if(activePens&&activePens.length){
  //   activePens.forEach((activePen:Pen)=>{
  //     if(rectInRect(activePen.calculative.worldRect,pen.calculative.worldRect,true)){
  //       if(!pen.followers){
  //         pen.followers =[];
  //       }
  //       if(!pen.followers.includes(activePen.id)){
  //         pen.followers.push(activePen.id);
  //       }
  //     }
  //   })
  // }
}
function mouseLeave(pen) {
  const activePens = pen.calculative.canvas.store.active;
  if (activePens && activePens.length) {
    activePens.forEach(activePen => {
      // if(!rectInRect(activePen.calculative.worldRect,pen.calculative.worldRect,true)){
      //   if(!pen.followers){
      //     pen.followers =[];
      //   }
      //   if(!pen.followers.includes(activePen.id)){
      //     pen.followers.push(activePen.id);
      //   }
      // }
      if (pen.followers) {
        let idx = pen.followers.findIndex(id => id === activePen.id);
        if (idx !== -1) {
          const movingPen = pen.calculative.canvas.store.pens[activePen.id + movingSuffix];
          if (movingPen && movingPen.calculative) {
            let isIn = rectInRect(movingPen.calculative.worldRect, pen.calculative.worldRect, true);
            if (!isIn) {
              pen.followers.splice(idx, 1);
            }
          }
        }
      }
    });
  }
}
function mouseUp(pen) {
  const activePens = pen.calculative.canvas.store.active;
  if (activePens && activePens.length) {
    activePens.forEach(activePen => {
      const movingPen = pen.calculative.canvas.store.pens[activePen.id + movingSuffix];
      if (movingPen && movingPen.calculative) {
        let inRect = deepClone(pen.calculative.worldRect);
        inRect.x -= 1;
        inRect.y -= 1;
        inRect.width += 2;
        inRect.height += 2;
        if (rectInRect(movingPen.calculative.worldRect, inRect, true)) {
          if (!pen.followers) {
            pen.followers = [];
          }
          if (!pen.followers.includes(activePen.id)) {
            pen.followers.push(activePen.id);
          }
        }
      }
    });
  }
}
function panel_mouseMove(pen, e) {
  //  console.log(e,pen.calculative.canvas.store.active);
}
;// ./node_modules/@kyvi/cobweb/src/diagrams/circle.js
function circle(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  path.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, Math.PI * 2);
  if (path instanceof Path2D) {
    return path;
  }
}
;// ./node_modules/@kyvi/cobweb/src/diagrams/diamond.js
function diamond(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  path.moveTo(x + width / 2, y);
  path.lineTo(x + width, y + height / 2);
  path.lineTo(x + width / 2, y + height);
  path.lineTo(x, y + height / 2);
  path.lineTo(x + width / 2, y);
  path.closePath();
  if (path instanceof Path2D) return path;
}
;// ./node_modules/@kyvi/cobweb/src/diagrams/triangle.js
function triangle(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  path.moveTo(x + width / 2, y);
  path.lineTo(x + width, y + height);
  path.lineTo(x, y + height);
  path.lineTo(x + width / 2, y);
  path.closePath();
  if (path instanceof Path2D) return path;
}
function triangleAnchors(pen) {
  const points = [{
    x: 0.5,
    y: 0
  }, {
    x: 0.75,
    y: 0.5
  }, {
    x: 0.5,
    y: 1
  }, {
    x: 0.25,
    y: 0.5
  }];
  pen.anchors = points.map(({
    x,
    y
  }, index) => {
    return {
      id: `${index}`,
      penId: pen.id,
      x,
      y
    };
  });
}
;// ./node_modules/@kyvi/cobweb/src/diagrams/pentagon.js
function pentagon(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  path.moveTo(x + width / 2, y);
  path.lineTo(x + width, y + height * 2 / 5);
  path.lineTo(x + width * 4 / 5, y + height);
  path.lineTo(x + width / 5, y + height);
  path.lineTo(x, y + height * 2 / 5);
  path.closePath();
  if (path instanceof Path2D) return path;
}
function pentagonAnchors(pen) {
  const points = [{
    x: 0.5,
    y: 0
  }, {
    x: 1,
    y: 0.4
  }, {
    x: 0.8,
    y: 1
  }, {
    x: 0.2,
    y: 1
  }, {
    x: 0,
    y: 0.4
  }];
  pen.anchors = points.map(({
    x,
    y
  }, index) => {
    return {
      id: `${index}`,
      penId: pen.id,
      x,
      y
    };
  });
}
;// ./node_modules/@kyvi/cobweb/src/diagrams/hexagon.js
function hexagon(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  path.moveTo(x + width / 4, y);
  path.lineTo(x + width * 3 / 4, y);
  path.lineTo(x + width, y + height / 2);
  path.lineTo(x + width * 3 / 4, y + height);
  path.lineTo(x + width * 1 / 4, y + height);
  path.lineTo(x, y + height / 2);
  path.lineTo(x + width / 4, y);
  path.closePath();
  if (path instanceof Path2D) return path;
}
// export function hexagonAnchors(pen: Pen) {
//   const anchors: Point[] = [];
//   anchors.push({
//     id: '0',
//     penId: pen.id,
//     x: 0.25,
//     y: 0,
//   });
//   anchors.push({
//     id: '1',
//     penId: pen.id,
//     x: 0.75,
//     y: 0,
//   });
//   anchors.push({
//     id: '2',
//     penId: pen.id,
//     x: 1,
//     y: 0.5,
//   });
//   anchors.push({
//     id: '3',
//     penId: pen.id,
//     x: 0.75,
//     y: 1,
//   });
//   anchors.push({
//     id: '4',
//     penId: pen.id,
//     x: 0.25,
//     y: 1,
//   });
//   anchors.push({
//     id: '5',
//     penId: pen.id,
//     x: 0,
//     y: 0.5,
//   });
//   pen.anchors = anchors;
// }
;// ./node_modules/@kyvi/cobweb/src/diagrams/arrow.js
function leftArrow(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  path.moveTo(x, y + height / 2);
  path.lineTo(x + height / 2, y);
  path.lineTo(x + height / 2, y + height / 3);
  path.lineTo(x + width, y + height / 3);
  path.lineTo(x + width, y + height * 2 / 3);
  path.lineTo(x + height / 2, y + height * 2 / 3);
  path.lineTo(x + height / 2, y + height * 2 / 3);
  path.lineTo(x + height / 2, y + height);
  path.closePath();
  if (path instanceof Path2D) return path;
}
function rightArrow(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  path.moveTo(x, y + height / 3);
  path.lineTo(x + (width - height / 2), y + height / 3);
  path.lineTo(x + (width - height / 2), y);
  path.lineTo(x + width, y + height / 2);
  path.lineTo(x + (width - height / 2), y + height);
  path.lineTo(x + (width - height / 2), y + height * 2 / 3);
  path.lineTo(x, y + height * 2 / 3);
  path.closePath();
  if (path instanceof Path2D) return path;
}
function twowayArrow(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  path.moveTo(x, y + height / 2);
  path.lineTo(x + height / 2, y);
  path.lineTo(x + height / 2, y + height / 3);
  path.lineTo(x + (width - height / 2), y + height / 3);
  path.lineTo(x + (width - height / 2), y);
  path.lineTo(x + width, y + height / 2);
  path.lineTo(x + (width - height / 2), y + height);
  path.lineTo(x + (width - height / 2), y + height * 2 / 3);
  path.lineTo(x + height / 2, y + height * 2 / 3);
  path.lineTo(x + height / 2, y + height);
  path.closePath();
  if (path instanceof Path2D) return path;
}
;// ./node_modules/@kyvi/cobweb/src/diagrams/message.js
function message(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height,
    ey
  } = pen.calculative.worldRect;
  path.moveTo(x, y);
  path.lineTo(x + width, y);
  path.lineTo(x + width, y + height * 3 / 4);
  path.lineTo(x + width * 8 / 16, y + height * 3 / 4);
  path.lineTo(x + width / 4, ey);
  path.lineTo(x + width * 5 / 16, y + height * 3 / 4);
  path.lineTo(x, y + height * 3 / 4);
  path.closePath();
  if (path instanceof Path2D) return path;
}
;// ./node_modules/@kyvi/cobweb/src/diagrams/cloud.js
function cloud(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  path.moveTo(x + width / 5, y + height * 13 / 16);
  path.bezierCurveTo(x - width / 15, y + height * 13 / 16, x - width / 15, y + height * 7 / 16, x + width / 5, y + height * 7 / 16);
  path.bezierCurveTo(x + width / 5, y, x + width * 4 / 5, y, x + width * 4 / 5, y + height * 7 / 16);
  path.bezierCurveTo(x + width * 16 / 15, y + height * 7 / 16, x + width * 16 / 15, y + height * 13 / 16, x + width * 4 / 5, y + height * 13 / 16);
  path.closePath();
  if (path instanceof Path2D) return path;
}
;// ./node_modules/@kyvi/cobweb/src/diagrams/file.js
function file(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    ex,
    ey
  } = pen.calculative.worldRect;
  const offsetX = width / 6;
  path.moveTo(x, y);
  path.lineTo(ex - offsetX, y);
  path.lineTo(ex, y + offsetX);
  path.lineTo(ex, ey);
  path.lineTo(x, ey);
  path.closePath();
  path.moveTo(ex - offsetX, y);
  path.lineTo(ex - offsetX, y + offsetX);
  path.lineTo(ex, y + offsetX);
  path.closePath();
  if (path instanceof Path2D) return path;
}
;// ./node_modules/@kyvi/cobweb/src/diagrams/people.js
function people(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    ex,
    ey
  } = pen.calculative.worldRect;
  const r = width / 4;
  const middle = x + width / 2;
  path.arc(middle, y + r, r, 0, Math.PI * 2);
  path.moveTo(x, y + r * 3);
  path.lineTo(ex, y + r * 3);
  path.moveTo(middle, y + r * 2);
  path.lineTo(middle, y + r * 4);
  path.moveTo(middle, y + r * 4);
  path.lineTo(x, ey);
  path.moveTo(middle, y + r * 4);
  path.lineTo(ex, ey);
  path.closePath();
  if (path instanceof Path2D) return path;
}
;// ./node_modules/@kyvi/cobweb/src/diagrams/gif.js

const gifsList = {};
function gif(pen) {
  if (!pen.onDestroy) {
    pen.onDestroy = gif_destory;
    pen.onMove = gif_move;
    pen.onResize = gif_resize;
    pen.onRotate = gif_move;
    pen.onValue = gif_value;
    pen.onChangeId = gif_changeId;
  }
  const path = new Path2D();
  if (!pen.image) {
    return;
  }
  if (!gifsList[pen.id]) {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.src = pen.image;
    if (pen.calculative.canvas.parent.store.options.cdn && !(pen.image.startsWith('http') || pen.image.startsWith('//') || pen.image.startsWith('data:image'))) {
      img.src = pen.calculative.canvas.parent.store.options.cdn + pen.image;
    }
    gifsList[pen.id] = img; // 提前赋值，避免重复创建
    img.onload = () => {
      if (gifsList[pen.id] !== img) {
        return;
      }
      pen.calculative.img = img;
      pen.calculative.imgNaturalWidth = img.naturalWidth || pen.iconWidth;
      pen.calculative.imgNaturalHeight = img.naturalHeight || pen.iconHeight;
      // pen.calculative.canvas.externalElements?.appendChild(img);
      pen.calculative.canvas.externalElements?.parentElement.appendChild(img);
      setImagePosition(pen, img);
    };
  }
  if (pen.calculative.patchFlags && gifsList[pen.id]) {
    setImagePosition(pen, gifsList[pen.id]);
  }
  return path;
}
function gif_destory(pen) {
  if (gifsList[pen.id]) {
    gifsList[pen.id].remove();
    gifsList[pen.id] = undefined;
  }
}
function gif_move(pen) {
  if (!gifsList[pen.id]) {
    return;
  }
  setImagePosition(pen, gifsList[pen.id]);
}
function gif_resize(pen) {
  if (!gifsList[pen.id]) {
    return;
  }
  setImagePosition(pen, gifsList[pen.id]);
}
function gif_value(pen) {
  if (!gifsList[pen.id]) {
    return;
  }
  setImagePosition(pen, gifsList[pen.id]);
  if (gifsList[pen.id].getAttribute('src') !== pen.image) {
    gifsList[pen.id].src = pen.image;
  }
}
function gif_changeId(pen, oldId, newId) {
  if (!gifsList[oldId]) {
    return;
  }
  gifsList[newId] = gifsList[oldId];
  delete gifsList[oldId];
}
/**
 * gif 保持比例，除了更改 position ，还需要是否可保持比例
 * @param pen 画笔
 * @param elem 图片 dom
 */
function setImagePosition(pen, elem) {
  // meta2d canvas 绘制图片 drawImage 保持比例，是短边填充
  elem.style.objectFit = pen.imageRatio ? 'contain' : 'fill';
  // elem.style.opacity = pen.globalAlpha + '';
  render_setElemPosition(pen, elem);
}
;// ./node_modules/@kyvi/cobweb/src/diagrams/mindNode.js



function mindNode(pen, ctx) {
  if (!pen.onResize) {
    pen.onResize = mindNode_resize;
    pen.onValue = mindNode_value;
  }
  return rectangle(pen, ctx);
}
function mindNode_resize(pen) {
  // 过滤出非默认锚点，即自定义锚点
  const manualPoints = pen.anchors.filter(point => point.flag !== 1);
  mindNodeAnchors(pen);
  pen.anchors = pen.anchors.concat(...manualPoints);
}
function mindNode_value(pen) {
  mindNode_resize(pen);
  calcWorldAnchors(pen);
}
function mindNodeAnchors(pen) {
  // TODO: 组合状态下的 width height 成了固定的百分比
  const anchors = [];
  const {
    x: rectX,
    y: rectY,
    width,
    height
  } = pen;
  const r = borderRadius(pen);
  // 上四
  const topN = 5; // 上方节点个数，控制位置，实际节点数依然是 4 个
  for (let i = 0; i < topN; i++) {
    if (i === 2) {
      continue;
    }
    let x = rectX + width * (i + 1) / (topN + 1);
    let y = rectY;
    if (x < rectX + r) {
      // 在左侧圆角
      y = getYByCircle(rectX + r, y + r, x, r, -1);
    } else if (x > rectX + width - r) {
      // 在右侧圆角
      y = getYByCircle(rectX + width - r, y + r, x, r, -1);
    }
    anchors.push({
      id: String(anchors.length),
      flag: 1,
      penId: pen.id,
      x: (x - rectX) / width,
      y: (y - rectY) / height
    });
  }
  // 右三
  const rightN = 3; // 右侧节点数
  for (let i = 0; i < rightN; i++) {
    let y = rectY + height * (i + 1) / (rightN + 1);
    let x = rectX + width;
    if (y < rectY + r) {
      // 在上侧圆角以内
      x = getXByCircle(x - r, rectY + r, y, r);
    } else if (y > rectY + height - r) {
      // 下侧圆角
      x = getXByCircle(x - r, rectY + height - r, y, r);
    }
    anchors.push({
      id: String(anchors.length),
      flag: 1,
      penId: pen.id,
      x: (x - rectX) / width,
      y: (y - rectY) / height
    });
  }
  // 下四
  const bottomN = 5; // 下侧节点数
  for (let i = 0; i < bottomN; i++) {
    if (i === 2) {
      continue;
    }
    let x = rectX + width * (i + 1) / (bottomN + 1);
    let y = rectY + height;
    if (x < rectX + r) {
      // 在左侧圆角
      y = getYByCircle(rectX + r, y - r, x, r);
    } else if (x > rectX + width - r) {
      // 在右侧圆角
      y = getYByCircle(rectX + width - r, y - r, x, r);
    }
    anchors.push({
      id: String(anchors.length),
      flag: 1,
      penId: pen.id,
      x: (x - rectX) / width,
      y: (y - rectY) / height
    });
  }
  // 左三
  const leftN = 3; // 左侧节点数
  for (let i = 0; i < leftN; i++) {
    let y = rectY + height * (i + 1) / (leftN + 1);
    let x = rectX;
    if (y < rectY + r) {
      // 在上侧圆角以内
      x = getXByCircle(x + r, rectY + r, y, r, -1);
    } else if (y > rectY + height - r) {
      // 下侧圆角
      x = getXByCircle(x + r, rectY + height - r, y, r, -1);
    }
    anchors.push({
      id: String(anchors.length),
      flag: 1,
      penId: pen.id,
      x: (x - rectX) / width,
      y: (y - rectY) / height
    });
  }
  pen.anchors = anchors;
}
/**
 * 得到元素实际计算半径
 * @param node 元素
 * @returns 元素实际半径
 */
function borderRadius(pen) {
  let wr = pen.calculative.borderRadius || 0;
  let hr = pen.calculative.borderRadius || 0;
  const {
    width,
    height
  } = pen;
  if (pen.calculative.borderRadius < 1) {
    wr = width * pen.calculative.borderRadius;
    hr = height * pen.calculative.borderRadius;
  }
  let r = wr < hr ? wr : hr;
  if (width < 2 * r) {
    r = width / 2;
  }
  if (height < 2 * r) {
    r = height / 2;
  }
  return r;
}
/**
 * 获取圆的 x 坐标
 * @param ox 圆心x
 * @param oy 圆心y
 * @param y y
 * @param r 半径
 * @param sqrt 点可能在左侧，左侧填-1，右侧1（默认值）
 */
function getXByCircle(ox, oy, y, r, sqrt = 1) {
  return sqrt * Math.sqrt(r ** 2 - (y - oy) ** 2) + ox;
}
/**
 * 获取圆的 y 坐标
 * @param ox 圆心x
 * @param oy 圆心y
 * @param y y
 * @param r 半径
 * @param sqrt 点可以在上侧，也可能在下侧，上侧-1，下侧1（默认）
 */
function getYByCircle(ox, oy, x, r, sqrt = 1) {
  return sqrt * Math.sqrt(r ** 2 - (x - ox) ** 2) + oy;
}
;// ./node_modules/@kyvi/cobweb/src/diagrams/mindLine.js
function mindLine(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  path.moveTo(x, y + height);
  path.lineTo(x + width, y + height);
  path.closePath();
  if (path instanceof Path2D) return path;
}
function mindLineAnchors(pen) {
  const points = [{
    x: 0,
    y: 1
  }, {
    x: 1,
    y: 1
  }];
  pen.anchors = points.map(({
    x,
    y
  }, index) => {
    return {
      id: index + '',
      x,
      y,
      penId: pen.id
    };
  });
}
;// ./node_modules/@kyvi/cobweb/src/diagrams/index.js






























// import { cube } from './cube';








function commonPens() {
  return {
    rectangle: rectangle,
    square: square,
    circle: circle,
    svgPath: svgPath,
    diamond: diamond,
    triangle: triangle,
    pentagon: pentagon,
    pentagram: pentagram,
    hexagon: hexagon,
    leftArrow: leftArrow,
    rightArrow: rightArrow,
    twowayArrow: twowayArrow,
    message: message,
    cloud: cloud,
    file: file,
    people: people,
    line: line,
    iframe: iframe,
    video: video,
    gif: gif,
    mindNode: mindNode,
    mindLine: mindLine,
    mindNode2: rectangle,
    panel: panel
  };
}
function commonAnchors() {
  return {
    triangle: triangleAnchors,
    pentagon: pentagonAnchors,
    pentagram: pentagramAnchors,
    mindNode: mindNodeAnchors,
    mindLine: mindLineAnchors
  };
}
;// ./node_modules/@kyvi/cobweb/src/event/event.js
var EventAction;
(function (EventAction) {
  EventAction[EventAction["Link"] = 0] = "Link";
  EventAction[EventAction["SetProps"] = 1] = "SetProps";
  EventAction[EventAction["StartAnimate"] = 2] = "StartAnimate";
  EventAction[EventAction["PauseAnimate"] = 3] = "PauseAnimate";
  EventAction[EventAction["StopAnimate"] = 4] = "StopAnimate";
  EventAction[EventAction["JS"] = 5] = "JS";
  EventAction[EventAction["GlobalFn"] = 6] = "GlobalFn";
  EventAction[EventAction["Emit"] = 7] = "Emit";
  EventAction[EventAction["StartVideo"] = 8] = "StartVideo";
  EventAction[EventAction["PauseVideo"] = 9] = "PauseVideo";
  EventAction[EventAction["StopVideo"] = 10] = "StopVideo";
  EventAction[EventAction["SendPropData"] = 11] = "SendPropData";
  EventAction[EventAction["SendVarData"] = 12] = "SendVarData";
  EventAction[EventAction["Navigator"] = 13] = "Navigator";
  EventAction[EventAction["Dialog"] = 14] = "Dialog";
  EventAction[EventAction["SendData"] = 15] = "SendData";
  EventAction[EventAction["PostMessage"] = 16] = "PostMessage";
  EventAction[EventAction["PostMessageToParent"] = 17] = "PostMessageToParent";
})(EventAction || (EventAction = {}));
;// ./node_modules/@kyvi/cobweb/src/event/index.js

;// ./node_modules/@kyvi/cobweb/src/map/map.js


class ViewMap {
  // 可视区域外框
  constructor(parent) {
    _defineProperty(this, "parent", void 0);
    _defineProperty(this, "box", void 0);
    _defineProperty(this, "boxWidth", 320);
    _defineProperty(this, "boxHeight", 180);
    _defineProperty(this, "ratio", this.boxWidth / this.boxHeight);
    _defineProperty(this, "padding", 5);
    _defineProperty(this, "img", void 0);
    _defineProperty(this, "isShow", void 0);
    _defineProperty(this, "isDown", void 0);
    _defineProperty(this, "view", void 0);
    _defineProperty(this, "onMouseDown", e => {
      e.preventDefault();
      e.stopPropagation();
      this.isDown = true;
    });
    _defineProperty(this, "onMouseMove", e => {
      e.preventDefault();
      e.stopPropagation();
      if (this.isDown) {
        try {
          this.parent.gotoView(e.offsetX / this.box.clientWidth, e.offsetY / this.box.clientHeight);
        } catch (e) {
          console.warn(e.message);
          this.isDown = false;
        }
      }
    });
    _defineProperty(this, "onMouseUp", e => {
      e.preventDefault();
      e.stopPropagation();
      try {
        this.parent.gotoView(e.offsetX / this.box.clientWidth, e.offsetY / this.box.clientHeight);
      } catch (e) {
        console.warn(e.message);
      } finally {
        this.isDown = false;
      }
    });
    _defineProperty(this, "onWheel", e => {
      //放大镜缩放
      let scaleOff = 0.015;
      if (this.parent.store.options.scaleOff) {
        scaleOff = this.parent.store.options.scaleOff;
        if (e.deltaY > 0) {
          scaleOff = -this.parent.store.options.scaleOff;
        }
      } else {
        let isMac = /mac os /i.test(navigator.userAgent);
        if (isMac) {
          if (!e.ctrlKey) {
            scaleOff *= e.wheelDeltaY / 240;
          } else if (e.deltaY > 0) {
            scaleOff *= -1;
          }
        } else {
          let offset = 0.2;
          if (e.deltaY.toString().indexOf('.') !== -1) {
            offset = 0.01;
          }
          if (e.deltaY > 0) {
            scaleOff = -offset;
          } else {
            scaleOff = offset;
          }
        }
      }
      let {
        offsetX: x,
        offsetY: y
      } = e;
      const width = this.parent.store.data.width || this.parent.store.options.width;
      const height = this.parent.store.data.height || this.parent.store.options.height;
      if (width && height) {
        //大屏
        x = x / this.boxWidth * width * this.parent.store.data.scale + this.parent.store.data.origin.x + this.parent.store.data.x;
        y = y / this.boxHeight * height * this.parent.store.data.scale + this.parent.store.data.origin.y + this.parent.store.data.y;
      } else {
        const rect = this.parent.parent.getRect();
        x = x / this.boxWidth * rect.width + rect.x + this.parent.store.data.x;
        y = y / this.boxHeight * rect.height + rect.y + this.parent.store.data.y;
      }
      this.parent.scale(this.parent.store.data.scale + scaleOff, {
        x,
        y
      });
    });
    this.parent = parent;
    this.box = document.createElement('div');
    this.img = new Image();
    this.view = document.createElement('div');
    this.box.appendChild(this.img);
    this.box.appendChild(this.view);
    this.parent.externalElements?.parentElement.appendChild(this.box);
    this.box.className = 'meta2d-map';
    this.box.onmousedown = this.onMouseDown;
    this.box.onmousemove = this.onMouseMove;
    this.box.onmouseup = this.onMouseUp;
    this.box.onwheel = this.onWheel;
    let sheet;
    for (let i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].title === 'le5le/map') {
        sheet = document.styleSheets[i];
      }
    }
    if (!sheet) {
      let style = document.createElement('style');
      style.type = 'text/css';
      style.title = 'le5le.com/map';
      document.head.appendChild(style);
      style = document.createElement('style');
      style.type = 'text/css';
      document.head.appendChild(style);
      sheet = style.sheet;
      sheet.insertRule(`.meta2d-map{display:flex;width:${this.boxWidth + 2 * this.padding}px;height:${this.boxHeight + 2 * this.padding}px;padding:${this.padding}px;background:#f4f4f4;border:1px solid #ffffff;box-shadow: 0px 0px 14px 0px rgba(0,10,38,0.30);border-radius:8px;position:absolute;z-index:9999;right:0;bottom:0;justify-content:center;align-items:center;cursor:default;user-select:none;overflow: hidden;}`);
      sheet.insertRule('.meta2d-map img{max-width:100%;max-height:100%;pointer-events: none;}');
      sheet.insertRule('.meta2d-map div{pointer-events: none;border:1px solid #1890ff;position:absolute}');
    }
  }
  show() {
    this.box.style.display = 'flex';
    const data = this.parent.store.data;
    if (data.pens.length) {
      this.img.style.display = 'block';
      this.img.src = this.parent.toPng();
      this.setView();
    } else {
      this.img.style.display = 'none';
    }
    this.isShow = true;
  }
  hide() {
    this.box.style.display = 'none';
    this.isShow = false;
  }
  setView() {
    const data = this.parent.store.data;
    if (data.pens.length) {
      let rect = getRect(data.pens);
      const vW = this.parent.store.data.width || this.parent.store.options.width;
      const vH = this.parent.store.data.height || this.parent.store.options.height;
      if (vW && vH) {
        //大屏
        rect = {
          x: this.parent.store.data.origin.x,
          y: this.parent.store.data.origin.y,
          width: vW * this.parent.store.data.scale,
          height: vH * this.parent.store.data.scale
        };
      }
      // rect += data.x y 得到相对坐标
      translateRect(rect, data.x, data.y);
      const rectRatio = rect.width / rect.height;
      if (rectRatio > this.ratio) {
        // 上下留白，扩大高度
        const height = rect.width / this.ratio;
        rect.y -= (height - rect.height) / 2;
        rect.height = height;
        rect_calcRightBottom(rect);
      } else {
        // 左右留白，扩大宽度
        const width = rect.height * this.ratio;
        rect.x -= (width - rect.width) / 2;
        rect.width = width;
        rect_calcRightBottom(rect);
      }
      const canvasRect = this.parent.canvasRect;
      let left = 0,
        top = 0;
      if (rect.x < 0) {
        left = -rect.x / rect.width;
      } else if (rect.x + rect.width > canvasRect.width) {
        let space = 0;
        if (canvasRect.width > rect.width) {
          // 均已左上角为起点，这种场景需要剪掉一个留白
          space = canvasRect.width - rect.width;
        }
        left = (-rect.x + space) / rect.width;
      }
      if (rect.y < 0) {
        top = -rect.y / rect.height;
      } else if (rect.y + rect.height > canvasRect.height) {
        let space = 0;
        if (canvasRect.height > rect.height) {
          space = canvasRect.height - rect.height;
        }
        top = (-rect.y + space) / rect.height;
      }
      const width = canvasRect.width > rect.width ? 1 : canvasRect.width / rect.width;
      const height = canvasRect.height > rect.height ? 1 : canvasRect.height / rect.height;
      this.view.style.left = this.padding + left * this.boxWidth + 'px';
      this.view.style.width = width * this.boxWidth + 'px';
      this.view.style.top = this.padding + top * this.boxHeight + 'px';
      this.view.style.height = height * this.boxHeight + 'px';
    }
  }
}
;// ./node_modules/@kyvi/cobweb/src/map/index.js

// EXTERNAL MODULE: ./node_modules/mqtt/dist/mqtt.min.js
var mqtt_min = __webpack_require__(5149);
;// ./node_modules/@kyvi/cobweb/src/core.js






















class Meta2d {
  constructor(parent, opts = {}) {
    _defineProperty(this, "store", void 0);
    _defineProperty(this, "canvas", void 0);
    _defineProperty(this, "websocket", void 0);
    _defineProperty(this, "mqttClient", void 0);
    _defineProperty(this, "websockets", void 0);
    _defineProperty(this, "mqttClients", void 0);
    _defineProperty(this, "penPluginMap", new Map());
    _defineProperty(this, "socketFn", void 0);
    _defineProperty(this, "events", {});
    _defineProperty(this, "map", void 0);
    _defineProperty(this, "mapTimer", void 0);
    _defineProperty(this, "facePen", facePen);
    _defineProperty(this, "getWords", getWords);
    _defineProperty(this, "calcTextLines", text_calcTextLines);
    _defineProperty(this, "calcTextRect", calcTextRect);
    _defineProperty(this, "calcTextDrawRect", calcTextDrawRect);
    _defineProperty(this, "register", register);
    _defineProperty(this, "registerCanvasDraw", registerCanvasDraw);
    _defineProperty(this, "registerAnchors", registerAnchors);
    _defineProperty(this, "websocketTimes", 0);
    _defineProperty(this, "mqttTimes", 0);
    _defineProperty(this, "httpTimer", void 0);
    _defineProperty(this, "httpTimerList", []);
    _defineProperty(this, "updateTimer", void 0);
    _defineProperty(this, "updateTimerList", []);
    _defineProperty(this, "onEvent", (eventName, e) => {
      switch (eventName) {
        case 'add':
          {
            e.forEach(pen => {
              pen.onAdd?.(pen);
            });
          }
          this.onSizeUpdate();
          break;
        case 'enter':
          e && e.onMouseEnter && e.onMouseEnter(e, this.canvas.mousePos);
          this.store.data.locked && this.doEvent(e, eventName);
          break;
        case 'leave':
          e && e.onMouseLeave && e.onMouseLeave(e, this.canvas.mousePos);
          this.store.data.locked && this.doEvent(e, eventName);
          break;
        case 'active':
        case 'inactive':
          {
            this.store.data.locked && e.forEach(pen => {
              this.doEvent(pen, eventName);
            });
          }
          break;
        case 'click':
          e.pen && e.pen.onClick && !e.pen.disabled && e.pen.onClick(e.pen, this.canvas.mousePos);
          this.store.data.locked && e.pen && !e.pen.disabled && this.doEvent(e.pen, eventName);
          break;
        case 'contextmenu':
          e.pen && e.pen.onContextmenu && !e.pen.disabled && e.pen.onContextmenu(e.pen, this.canvas.mousePos);
          this.store.data.locked && e.pen && !e.pen.disabled && this.doEvent(e.pen, eventName);
          break;
        case 'mousedown':
          e.pen && e.pen.onMouseDown && !e.pen.disabled && e.pen.onMouseDown(e.pen, this.canvas.mousePos);
          this.store.data.locked && e.pen && !e.pen.disabled && this.doEvent(e.pen, eventName);
          break;
        case 'mouseup':
          e.pen && e.pen.onMouseUp && !e.pen.disabled && e.pen.onMouseUp(e.pen, this.canvas.mousePos);
          this.store.data.locked && e.pen && !e.pen.disabled && this.doEvent(e.pen, eventName);
          break;
        case 'dblclick':
          this.store.data.locked && e.pen && !e.pen.disabled && this.doEvent(e.pen, eventName);
          break;
        case 'valueUpdate':
          this.store.data.locked && this.doEvent(e, eventName);
          this.canvas.tooltip.updateText(e);
          break;
        case 'update':
        case 'delete':
        case 'translatePens':
        case 'rotatePens':
        case 'resizePens':
          this.onSizeUpdate();
          break;
        case 'navigator':
          if (!this.store.data.id) {
            console.warn('请先保存当前图纸');
          }
          this.navigatorTo(e.params);
          break;
        case 'input':
          this.store.data.locked && e && !e.disabled && this.doEvent(e, eventName);
          break;
        case 'change':
          this.store.data.locked && e && !e.disabled && this.doEvent(e, eventName);
          break;
      }
      this.doMessageEvent(eventName);
    });
    _defineProperty(this, "doEvent", (pen, eventName) => {
      if (!pen) {
        return;
      }
      let old = false; //是否是旧的事件
      let indexArr = []; //事件条件成立的索引
      pen.events?.forEach((event, index) => {
        if (event.actions && event.actions.length) {
          if (event.name === eventName) {
            //条件成立
            let flag = false;
            if (event.conditions && event.conditions.length) {
              if (event.conditionType === 'and') {
                flag = event.conditions.every(condition => {
                  return this.judgeCondition(pen, condition.key, condition);
                });
              } else if (event.conditionType === 'or') {
                flag = event.conditions.some(condition => {
                  return this.judgeCondition(pen, condition.key, condition);
                });
              }
            } else {
              flag = true;
            }
            if (flag) {
              // event.actions.forEach((action) => {
              //   if (this.events[action.action]) {
              //     this.events[action.action](pen, action);
              //   }
              // });
              indexArr.push(index);
            }
          }
        } else {
          old = true;
          if (this.events[event.action] && event.name === eventName) {
            let can = !event.where?.type;
            if (event.where) {
              const {
                fn,
                fnJs,
                comparison,
                key,
                value
              } = event.where;
              if (fn) {
                can = fn(pen, {
                  meta2d: this
                });
              } else if (fnJs) {
                try {
                  event.where.fn = new Function('pen', 'context', fnJs);
                } catch (err) {
                  console.error('Error: make function:', err);
                }
                if (event.where.fn) {
                  can = event.where.fn(pen, {
                    meta2d: this
                  });
                }
              } else {
                let pValue = pen[key];
                if (['x', 'y', 'width', 'height'].includes(key)) {
                  pValue = this.getPenRect(pen)[key];
                }
                switch (comparison) {
                  case '>':
                    can = pValue > +value;
                    break;
                  case '>=':
                    can = pValue >= +value;
                    break;
                  case '<':
                    can = pValue < +value;
                    break;
                  case '<=':
                    can = pValue <= +value;
                    break;
                  case '=':
                  case '==':
                    can = pValue == value;
                    break;
                  case '!=':
                    can = pValue != value;
                    break;
                  case '[)':
                    can = valueInRange(+pValue, value);
                    break;
                  case '![)':
                    can = !valueInRange(+pValue, value);
                    break;
                  case '[]':
                    can = valueInArray(pValue, value);
                    break;
                  case '![]':
                    can = !valueInArray(pValue, value);
                    break;
                }
              }
            }
            // can && this.events[event.action](pen, event);
            if (can) {
              indexArr.push(index);
            }
          }
        }
      });
      //所有的条件判断后，再统一执行条件成立的事件
      if (old) {
        pen.events?.forEach((event, index) => {
          if (indexArr.includes(index)) {
            this.events[event.action](pen, event);
          }
        });
      } else {
        pen.events?.forEach((event, index) => {
          if (indexArr.includes(index)) {
            event.actions.forEach(action => {
              if (this.events[action.action]) {
                this.events[action.action](pen, action);
              }
            });
          }
        });
      }
      if (eventName === 'valueUpdate') {
        pen.realTimes?.forEach(realTime => {
          let indexArr = [];
          realTime.triggers?.forEach((trigger, index) => {
            let flag = false;
            if (trigger.conditions?.length) {
              if (trigger.conditionType === 'and') {
                flag = trigger.conditions.every(condition => {
                  return this.judgeCondition(pen, realTime.key, condition);
                });
              } else if (trigger.conditionType === 'or') {
                flag = trigger.conditions.some(condition => {
                  return this.judgeCondition(pen, realTime.key, condition);
                });
              }
            } else {
              //无条件
              flag = true;
            }
            if (flag) {
              indexArr.push(index);
              // trigger.actions?.forEach((event) => {
              //   this.events[event.action](pen, event);
              // });
            }
          });
          //执行
          realTime.triggers?.forEach((trigger, index) => {
            if (indexArr.includes(index)) {
              trigger.actions?.forEach(event => {
                this.events[event.action](pen, event);
              });
            }
          });
        });
        //全局
        let indexArr = [];
        this.store.globalTriggers[pen.id]?.forEach((trigger, index) => {
          let flag = false;
          if (trigger.conditions?.length) {
            if (trigger.conditionType === 'and') {
              flag = trigger.conditions.every(condition => {
                return this.judgeCondition(this.store.pens[condition.source], condition.key, condition);
              });
            } else if (trigger.conditionType === 'or') {
              flag = trigger.conditions.some(condition => {
                return this.judgeCondition(this.store.pens[condition.source], condition.key, condition);
              });
            }
          } else {
            //无条件
            flag = true;
          }
          if (flag) {
            indexArr.push(index);
          }
        });
        this.store.globalTriggers[pen.id]?.forEach((trigger, index) => {
          if (indexArr.includes(index)) {
            trigger.actions?.forEach(event => {
              this.events[event.action](pen, event);
            });
          }
        });
        //triggers
        if (pen.triggers?.length) {
          for (let trigger of pen.triggers) {
            if (trigger.status?.length) {
              for (let state of trigger.status) {
                let flag = false;
                if (state.conditions?.length) {
                  if (state.conditionType === 'and') {
                    flag = state.conditions.every(condition => {
                      return this.judgeCondition(pen, condition.key, condition);
                    });
                  } else if (state.conditionType === 'or') {
                    flag = state.conditions.some(condition => {
                      return this.judgeCondition(pen, condition.key, condition);
                    });
                  }
                } else {
                  //无条件
                  flag = true;
                }
                if (flag) {
                  state.actions?.forEach(event => {
                    this.events[event.action](pen, event);
                  });
                  break;
                }
              }
            }
          }
        }
      }
      // 事件冒泡，子执行完，父执行
      this.doEvent(this.store.pens[pen.parentId], eventName);
    });
    _defineProperty(this, "doDataEvent", datas => {
      if (!this.store.data.dataEvents?.length) {
        return;
      }
      const data = datas.reduce((accumulator, {
        dataId,
        id,
        value
      }) => {
        accumulator[id || dataId] = value;
        return accumulator;
      }, {});
      let indexArr = [];
      this.store.data.dataEvents?.forEach((event, index) => {
        let flag = false;
        if (event.conditions && event.conditions.length) {
          if (event.conditionType === 'and') {
            flag = event.conditions.every(condition => {
              return this.dataJudegeCondition(data, condition.key, condition);
            });
          } else if (event.conditionType === 'or') {
            flag = event.conditions.some(condition => {
              return this.dataJudegeCondition(data, condition.key, condition);
            });
          }
        } else {
          flag = true;
        }
        if (flag) {
          indexArr.push(index);
        }
      });
      this.store.data.dataEvents?.forEach((event, index) => {
        if (indexArr.includes(index)) {
          event.actions?.forEach(action => {
            this.events[action.action](data, action);
          });
        }
      });
    });
    _defineProperty(this, "renderPenRaw", renderPenRaw);
    _defineProperty(this, "setElemPosition", render_setElemPosition);
    _defineProperty(this, "setLifeCycleFunc", setLifeCycleFunc);
    this.store = useStore(s8());
    this.setOptions(opts);
    this.setDatabyOptions(opts);
    this.init(parent);
    this.register(commonPens());
    this.registerCanvasDraw({
      cube: cube
    });
    this.registerAnchors(commonAnchors());
    globalThis.meta2d = this;
    this.initEventFns();
    this.store.emitter.on('*', this.onEvent);
  }
  /**
   * @deprecated 改用 beforeAddPens
   */
  get beforeAddPen() {
    return this.canvas.beforeAddPen;
  }
  /**
   * @deprecated 改用 beforeAddPens
   */
  set beforeAddPen(fn) {
    this.canvas.beforeAddPen = fn;
  }
  get beforeAddPens() {
    return this.canvas.beforeAddPens;
  }
  set beforeAddPens(fn) {
    this.canvas.beforeAddPens = fn;
  }
  get beforeAddAnchor() {
    return this.canvas.beforeAddAnchor;
  }
  set beforeAddAnchor(fn) {
    this.canvas.beforeAddAnchor = fn;
  }
  get beforeRemovePens() {
    return this.canvas.beforeRemovePens;
  }
  set beforeRemovePens(fn) {
    this.canvas.beforeRemovePens = fn;
  }
  get beforeRemoveAnchor() {
    return this.canvas.beforeRemoveAnchor;
  }
  set beforeRemoveAnchor(fn) {
    this.canvas.beforeRemoveAnchor = fn;
  }
  setOptions(opts = {}) {
    if (opts.grid !== undefined || opts.gridColor !== undefined || opts.gridSize !== undefined) {
      // this.setGrid({
      //   grid: opts.grid,
      //   gridColor: opts.gridColor,
      //   gridSize: opts.gridSize,
      // });
      this.canvas && (this.canvas.canvasTemplate.bgPatchFlags = true);
    }
    if (opts.rule !== undefined || opts.ruleColor !== undefined || opts.ruleOptions !== undefined) {
      // this.setRule({
      //   rule: opts.rule,
      //   ruleColor: opts.ruleColor,
      // });
      this.store.patchFlagsTop = true;
      if (opts.ruleOptions) {
        if (this.store.options?.ruleOptions) {
          Object.assign(this.store.options.ruleOptions, opts.ruleOptions);
          opts.ruleOptions = this.store.options.ruleOptions;
        }
      }
    }
    if (opts.background !== undefined) {
      this.canvas && (this.canvas.canvasTemplate.bgPatchFlags = true);
    }
    if (opts.resizeMode !== undefined) {
      if (!opts.resizeMode) {
        this.canvas.hotkeyType = HotkeyType.None;
      }
    }
    if (opts.width !== undefined || opts.height !== undefined) {
      this.canvas && (this.canvas.canvasTemplate.bgPatchFlags = true);
      if (this.canvas && this.canvas.canvasTemplate.canvas.style.backgroundImage) {
        this.canvas.canvasTemplate.canvas.style.backgroundImage = '';
      }
    }
    this.store.options = Object.assign(this.store.options, opts);
    if (this.canvas && opts.scroll !== undefined) {
      if (opts.scroll) {
        !this.canvas.scroll && (this.canvas.scroll = new Scroll(this.canvas));
        this.canvas.scroll.show();
      } else {
        this.canvas.scroll && this.canvas.scroll.hide();
      }
    }
  }
  getOptions() {
    return this.store.options;
  }
  setTheme(theme) {
    this.store.data.theme = theme;
    this.setBackgroundColor(this.store.theme[theme].background);
    this.canvas.parentElement.style.background = this.store.theme[theme].parentBackground;
    this.store.data.color = this.store.theme[theme].color;
    this.setOptions({
      ruleColor: this.store.theme[theme].ruleColor,
      ruleOptions: this.store.theme[theme].ruleOptions
    });
    this.render();
  }
  setDatabyOptions(options = {}) {
    const {
      color,
      activeColor,
      activeBackground,
      grid,
      gridColor,
      gridSize,
      fromArrow,
      toArrow,
      rule,
      ruleColor,
      textColor,
      x = 0,
      y = 0
    } = options;
    this.setRule({
      rule,
      ruleColor
    });
    this.setGrid({
      grid,
      gridColor,
      gridSize
    });
    this.store.data = Object.assign(this.store.data, {
      textColor,
      color,
      activeColor,
      activeBackground,
      fromArrow,
      toArrow,
      x,
      y
    });
  }
  init(parent) {
    if (typeof parent === 'string') {
      this.canvas = new Canvas(this, document.getElementById(parent), this.store);
    } else {
      this.canvas = new Canvas(this, parent, this.store);
    }
    this.resize();
    this.canvas.listen();
  }
  initEventFns() {
    this.events[EventAction.Link] = (pen, e) => {
      if (window && e.value && typeof e.value === 'string') {
        window.open(e.value, e.params ?? '_blank');
        return;
      }
      console.warn('[meta2d] Link param is not a string');
    };
    this.events[EventAction.SetProps] = (pen, e) => {
      // TODO: 若频繁地触发，重复 render 可能带来性能问题，待考虑
      const value = e.value;
      if (value && typeof value === 'object') {
        const pens = e.params ? this.find(e.params) : this.find(pen.id);
        pens.forEach(pen => {
          if (value.hasOwnProperty('visible')) {
            if (pen.visible !== value.visible) {
              this.setVisible(pen, value.visible);
            }
          }
          this.setValue({
            id: pen.id,
            ...value
          }, {
            render: false,
            doEvent: false
          });
        });
        this.render();
        return;
      }
      console.warn('[meta2d] SetProps value is not an object');
    };
    this.events[EventAction.StartAnimate] = (pen, e) => {
      let _pen = pen;
      if (e.value) {
        _pen = this.findOne(e.value);
      }
      if (this.store.animates.has(_pen) && !_pen.calculative.pause) {
        return;
      }
      if (e.targetType && e.params) {
        this.startAnimate(e.value || [pen], e.params);
        return;
      }
      if (!e.value || typeof e.value === 'string') {
        this.startAnimate(e.value || [pen]);
        return;
      }
      console.warn('[meta2d] StartAnimate value is not a string');
    };
    this.events[EventAction.PauseAnimate] = (pen, e) => {
      if (!e.value || typeof e.value === 'string') {
        this.pauseAnimate(e.value || [pen]);
        return;
      }
      console.warn('[meta2d] PauseAnimate value is not a string');
    };
    this.events[EventAction.StopAnimate] = (pen, e) => {
      if (!e.value || typeof e.value === 'string') {
        if (e.value) {
          let _pen = this.findOne(e.value);
          if (!this.store.animates.has(_pen)) {
            return;
          }
        } else {
          if (!this.store.animates.has(pen)) {
            return;
          }
        }
        this.stopAnimate(e.value || [pen]);
        return;
      }
      console.warn('[meta2d] StopAnimate event value is not a string');
    };
    this.events[EventAction.StartVideo] = (pen, e) => {
      if (!e.value || typeof e.value === 'string') {
        this.startVideo(e.value || [pen]);
        return;
      }
      console.warn('[meta2d] StartVideo value is not a string');
    };
    this.events[EventAction.PauseVideo] = (pen, e) => {
      if (!e.value || typeof e.value === 'string') {
        this.pauseVideo(e.value || [pen]);
        return;
      }
      console.warn('[meta2d] PauseVideo value is not a string');
    };
    this.events[EventAction.StopVideo] = (pen, e) => {
      if (!e.value || typeof e.value === 'string') {
        this.stopVideo(e.value || [pen]);
        return;
      }
      console.warn('[meta2d] StopVideo event value is not a string');
    };
    this.events[EventAction.JS] = (pen, e) => {
      if (e.value && !e.fn) {
        try {
          if (typeof e.value !== 'string') {
            throw new Error('[meta2d] Function value must be string');
          }
          const fnJs = e.value;
          e.fn = new Function('pen', 'params', 'context', fnJs);
        } catch (err) {
          console.error('[meta2d]: Error on make a function:', err);
        }
      }
      e.fn?.(pen, e.params, {
        meta2d: this,
        eventName: e.name
      });
    };
    this.events[EventAction.GlobalFn] = (pen, e) => {
      if (typeof e.value !== 'string') {
        console.warn('[meta2d] GlobalFn value must be a string');
        return;
      }
      if (globalThis[e.value]) {
        globalThis[e.value](pen, e.params);
      }
    };
    this.events[EventAction.Emit] = (pen, e) => {
      if (typeof e.value !== 'string') {
        console.warn('[meta2d] Emit value must be a string');
        return;
      }
      this.store.emitter.emit(e.value, {
        pen,
        params: e.params,
        eventName: e.name
      });
    };
    this.events[EventAction.SendPropData] = (pen, e) => {
      const value = deepClone(e.value);
      if (value && typeof value === 'object') {
        const _pen = e.params ? this.findOne(e.params) : pen;
        for (let key in value) {
          if (value[key] === undefined || value[key] === '') {
            value[key] = _pen[key];
          }
        }
        value.id = _pen.id;
        this.doSendDataEvent(value, e.extend);
        return;
      }
      console.warn('[meta2d] SendPropData value is not an object');
    };
    this.events[EventAction.SendVarData] = (pen, e) => {
      const value = deepClone(e.value);
      if (value && typeof value === 'object') {
        const _pen = e.params ? this.findOne(e.params) : pen;
        let array = [];
        for (let key in value) {
          let obj = {
            dataId: key,
            value: value[key]
          };
          if (!obj.value) {
            let oneForm = _pen.form.find(_item => _item.dataIds && _item.dataIds.dataId === obj.dataId);
            if (oneForm) {
              obj.value = _pen[oneForm.key];
            }
          }
          array.push(obj);
        }
        this.doSendDataEvent(array, e.extend);
        return;
      }
      console.warn('[meta2d] SendVarData value is not an object');
    };
    this.events[EventAction.Navigator] = (pen, e) => {
      if (e.value && typeof e.value === 'string') {
        this.navigatorTo(e.value);
      }
    };
    this.events[EventAction.Dialog] = (pen, e) => {
      if (e.params && typeof e.params === 'string') {
        let url = e.params;
        if (e.params.includes('${')) {
          let keys = e.params.match(/(?<=\$\{).*?(?=\})/g);
          if (keys) {
            keys?.forEach(key => {
              url = url.replace(`\${${key}}`, pen[key]);
            });
          }
        }
        this.canvas.dialog.show(e.value, url, e.extend);
      }
    };
    this.events[EventAction.SendData] = (pen, e) => {
      const value = deepClone(e.value);
      if (value && typeof value === 'object') {
        if (e.targetType === 'id') {
          const _pen = e.params ? this.findOne(e.params) : pen;
          for (let key in value) {
            if (value[key] === undefined || value[key] === '') {
              value[key] = _pen[key];
            }
          }
          // value.id = _pen.id;
          if (_pen.deviceId) {
            value.deviceId = _pen.deviceId;
          }
          this.sendDataToNetWork(value, pen, e);
          return;
        }
      }
    };
    this.events[EventAction.PostMessage] = (pen, e) => {
      if (typeof e.value !== 'string') {
        console.warn('[meta2d] Emit value must be a string');
        return;
      }
      const _pen = e.params ? this.findOne(e.params) : pen;
      if (_pen.name !== 'iframe' || !_pen.iframe) {
        console.warn('不是嵌入页面');
        return;
      }
      let params = queryURLParams(_pen.iframe.split('?')[1]);
      _pen.calculative.singleton.div.children[0].contentWindow.postMessage(JSON.stringify({
        name: e.value,
        id: params.id
      }), '*');
      return;
    };
    this.events[EventAction.PostMessageToParent] = (pen, e) => {
      if (typeof e.value !== 'string') {
        console.warn('[meta2d] Emit value must be a string');
        return;
      }
      window.parent.postMessage(JSON.stringify(e.value), '*');
      return;
    };
  }
  navigatorTo(id) {
    if (!id) {
      return;
    }
    let href = window.location.href;
    let arr = href.split('id=');
    if (arr.length > 1) {
      let idx = arr[1].indexOf('&');
      if (idx === -1) {
        window.location.href = arr[0] + 'id=' + id;
      } else {
        window.location.href = arr[0] + 'id=' + id + arr[1].slice(idx);
      }
    }
  }
  doSendDataEvent(value, topics) {
    let data = JSON.stringify(value);
    if (this.mqttClient && this.mqttClient.connected) {
      if (topics) {
        topics.split(',').forEach(topic => {
          this.mqttClient.publish(topic, data);
        });
      } else {
        this.store.data.mqttTopics && this.store.data.mqttTopics.split(',').forEach(topic => {
          this.mqttClient.publish(topic, data);
        });
      }
    }
    if (this.websocket && this.websocket.readyState === 1) {
      this.websocket.send(data);
    }
    if (this.store.data.https || this.store.data.http) {
      this.sendDatabyHttp(data);
    }
    this.store.emitter.emit('sendData', data);
  }
  async sendDataToNetWork(value, pen, e) {
    const network = deepClone(e.network);
    if (network.data) {
      Object.assign(network, network.data);
      delete network.data;
    }
    if (!network.url) {
      return;
    }
    if (network.protocol === 'http') {
      if (typeof network.headers === 'object') {
        for (let i in network.headers) {
          if (typeof network.headers[i] === 'string') {
            let keys = network.headers[i].match(/(?<=\$\{).*?(?=\})/g);
            if (keys) {
              network.headers[i] = network.headers[i].replace(`\${${keys[0]}}`, this.getDynamicParam(keys[0]));
            }
          }
        }
      }
      let params = undefined;
      let url = network.url;
      if (network.method === 'GET') {
        params = '?' + Object.keys(value).map(key => key + '=' + value[key]).join('&');
      }
      if (network.method === 'POST') {
        if (url.indexOf('${') > -1) {
          let keys = url.match(/(?<=\$\{).*?(?=\})/g);
          if (keys) {
            keys.forEach(key => {
              url = url.replace(`\${${key}}`, getter(pen, key) || this.getDynamicParam(key));
            });
          }
        }
      }
      const res = await fetch(url + (params ? params : ''), {
        headers: network.headers || {},
        method: network.method,
        body: network.method === 'POST' ? JSON.stringify(value) : undefined
      });
      if (res.ok) {
        if (e.callback) {
          const data = await res.text();
          if (!e.fn) {
            try {
              if (typeof e.callback !== 'string') {
                throw new Error('[meta2d] Function callback must be string');
              }
              const fnJs = e.callback;
              e.fn = new Function('pen', 'data', 'context', fnJs);
            } catch (err) {
              console.error('[meta2d]: Error on make a function:', err);
            }
          }
          e.fn?.(pen, data, {
            meta2d: this,
            e
          });
        }
        console.info('http消息发送成功');
      }
    } else if (network.protocol === 'mqtt') {
      const clients = this.mqttClients.filter(client => client.options.href === network.url);
      if (clients && clients.length) {
        if (clients[0].connected) {
          network.topics.split(',').forEach(topic => {
            clients[0].publish(topic, value);
          });
        }
      } else {
        //临时建立连接
        let mqttClient = mqtt_min.connect(network.url, network.options);
        mqttClient.on('connect', () => {
          console.info('mqtt连接成功');
          network.topics.split(',').forEach(topic => {
            mqttClient.publish(topic, value);
            mqttClient?.end();
          });
        });
      }
    } else if (network.protocol === 'websocket') {
      const websockets = this.websockets.filter(socket => socket.url === network.url);
      if (websockets && websockets.length) {
        if (websockets[0].readyState === 1) {
          websockets[0].send(value);
        }
      } else {
        //临时建立连接
        let websocket = new WebSocket(network.url, network.protocols || undefined);
        websocket.onopen = function () {
          console.info('websocket连接成功');
          websocket.send(value);
          setTimeout(() => {
            websocket.close();
          }, 100);
        };
      }
    }
  }
  resize(width, height) {
    this.canvas.resize(width, height);
    this.render();
    this.store.emitter.emit('resize', {
      width,
      height
    });
    if (this.canvas.scroll && this.canvas.scroll.isShow) {
      this.canvas.scroll.init();
    }
  }
  /**
   *
   * @param emit 是否发送消息
   */
  async addPen(pen, history, emit = true) {
    return await this.canvas.addPen(pen, history, emit);
  }
  async addPens(pens, history) {
    return await this.canvas.addPens(pens, history);
  }
  render(patchFlags) {
    this.canvas?.render(patchFlags);
  }
  async setBackgroundImage(url, data) {
    let that = this;
    async function loadImage(url) {
      return new Promise(resolve => {
        const img = new Image();
        img.src = url;
        if (that.store.options.cdn && !(url.startsWith('http') || url.startsWith('//') || url.startsWith('data:image'))) {
          img.src = that.store.options.cdn + url;
        }
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          resolve(img);
        };
      });
    }
    this.store.data.bkImage = url;
    const width = data?.width || this.store.data?.width || this.store.options?.width;
    const height = data?.height || this.store.data?.height || this.store.options?.height;
    if (width && height) {
      this.canvas.canvasTemplate.canvas.style.backgroundImage = null;
      this.canvas && (this.canvas.canvasTemplate.bgPatchFlags = true);
    } else {
      this.canvas.canvasTemplate.canvas.style.backgroundImage = url ? `url('${url}')` : '';
    }
    if (url) {
      const img = await loadImage(url);
      // 用作 toPng 的绘制
      this.store.bkImg = img;
      if (width && height) {
        if (this.canvas) {
          this.canvas.canvasTemplate.init();
          this.render();
        }
      }
    } else {
      this.store.bkImg = null;
    }
  }
  setBackgroundColor(color = this.store.data.background) {
    this.store.data.background = color;
    // this.store.patchFlagsBackground = true;
    this.canvas && (this.canvas.canvasTemplate.bgPatchFlags = true);
  }
  setGrid({
    grid = this.store.data.grid,
    gridColor = this.store.data.gridColor,
    gridSize = this.store.data.gridSize,
    gridRotate = this.store.data.gridRotate
  } = {}) {
    this.store.data.grid = grid;
    this.store.data.gridColor = gridColor;
    this.store.data.gridSize = gridSize < 0 ? 0 : gridSize;
    this.store.data.gridRotate = gridRotate;
    // this.store.patchFlagsBackground = true;
    this.canvas && (this.canvas.canvasTemplate.bgPatchFlags = true);
  }
  setRule({
    rule = this.store.data.rule,
    ruleColor = this.store.data.ruleColor
  } = {}) {
    this.store.data.rule = rule;
    this.store.data.ruleColor = ruleColor;
    this.store.patchFlagsTop = true;
  }
  open(data, render = true) {
    this.clear(false, data?.template);
    this.canvas.autoPolylineFlag = true;
    if (data) {
      this.setBackgroundImage(data.bkImage, data);
      Object.assign(this.store.data, data);
      this.store.data.pens = [];
      // 第一遍赋初值
      for (const pen of data.pens) {
        if (!pen.id) {
          pen.id = s8();
        }
        !pen.calculative && (pen.calculative = {
          canvas: this.canvas
        });
        this.store.pens[pen.id] = pen;
      }
      for (const pen of data.pens) {
        this.canvas.makePen(pen);
      }
      //首次计算连线bug
      // for (const pen of data.pens) {
      //   this.canvas.updateLines(pen);
      // }
    }
    this.canvas.patchFlagsLines.forEach(pen => {
      if (pen.type) {
        this.canvas.initLineRect(pen);
      }
    });
    if (!this.store.data.template) {
      this.store.data.template = s8();
    }
    if (!render) {
      this.canvas.opening = true;
    }
    this.initBindDatas();
    this.initBinds();
    this.initMessageEvents();
    this.initGlobalTriggers();
    this.render();
    this.listenSocket();
    this.connectSocket();
    this.connectNetwork();
    this.startDataMock();
    this.startAnimate();
    this.startVideo();
    this.doInitJS();
    this.doInitFn();
    if (this.store.data.iconUrls) {
      for (const item of this.store.data.iconUrls) {
        loadCss(item, () => {
          this.render();
        });
      }
    }
    this.canvas.autoPolylineFlag = false;
    this.store.emitter.emit('opened');
    if (this.canvas.scroll && this.canvas.scroll.isShow) {
      this.canvas.scroll.init();
    }
  }
  cacheData(id) {
    if (id && this.store.options.cacheLength) {
      let index = this.store.cacheDatas.findIndex(item => item.data && item.data._id === id);
      if (index === -1) {
        this.store.cacheDatas.push({
          data: deepClone(this.store.data, true)
          // offscreen: new Array(2),
          // flag: new Array(2)
        });
        if (this.store.cacheDatas.length > this.store.options.cacheLength) {
          this.store.cacheDatas.shift();
        }
      } else {
        let cacheDatas = this.store.cacheDatas.splice(index, 1)[0];
        this.store.cacheDatas.push(cacheDatas);
      }
    }
  }
  loadCacheData(id) {
    let index = this.store.cacheDatas.findIndex(item => item.data && item.data._id === id);
    if (index === -1) {
      return;
    }
    // const ctx = this.canvas.canvas.getContext('2d');
    // ctx.clearRect(0, 0, this.canvas.canvas.width, this.canvas.canvas.height);
    // for (let offs of this.store.cacheDatas[index].offscreen) {
    //   if (offs) {
    //     ctx.drawImage(offs, 0, 0, this.canvas.width, this.canvas.height);
    //   }
    // }
    // ctx.clearRect(0, 0, this.canvas.canvas.width, this.canvas.canvas.height);
    this.store.data = this.store.cacheDatas[index].data;
    this.setBackgroundImage(this.store.data.bkImage);
    this.store.pens = {};
    this.store.data.pens.forEach(pen => {
      pen.calculative.canvas = this.canvas;
      this.store.pens[pen.id] = pen;
      globalStore.path2dDraws[pen.name] && this.store.path2dMap.set(pen, globalStore.path2dDraws[pen.name](pen));
      pen.type && this.store.path2dMap.set(pen, globalStore.path2dDraws[pen.name](pen));
      if (pen.image) {
        pen.calculative.imageDrawed = false;
        this.canvas.loadImage(pen);
      }
    });
    this.render();
  }
  initBindDatas() {
    this.store.bindDatas = {};
    this.store.data.pens.forEach(pen => {
      pen.form?.forEach(formItem => {
        let dataIds;
        if (formItem.dataIds) {
          if (Array.isArray(formItem.dataIds)) {
            dataIds = formItem.dataIds;
          } else {
            dataIds = [formItem.dataIds];
          }
        }
        dataIds?.forEach(item => {
          if (!this.store.bindDatas[item.dataId]) {
            this.store.bindDatas[item.dataId] = [];
          }
          this.store.bindDatas[item.dataId].push({
            id: pen.id,
            formItem
          });
        });
      });
    });
  }
  initBinds() {
    this.store.bind = {};
    this.store.data.pens.forEach(pen => {
      pen.realTimes?.forEach(realTime => {
        if (realTime.bind && realTime.bind.id) {
          if (!this.store.bind[realTime.bind.id]) {
            this.store.bind[realTime.bind.id] = [];
          }
          this.store.bind[realTime.bind.id].push({
            id: pen.id,
            key: realTime.key
          });
        }
      });
    });
  }
  connectSocket() {
    this.connectWebsocket();
    this.connectMqtt();
    this.connectHttp();
  }
  /**
   * open 后执行初始化 Js ，每个图纸可配置一个初始化 js
   */
  doInitJS() {
    const initJs = this.store.data.initJs;
    if (initJs && initJs.trim()) {
      try {
        const fn = new Function('context', initJs);
        fn({
          meta2d: this
        });
      } catch (e) {
        console.warn('initJs error', e);
      }
    }
  }
  doInitFn() {
    let params = queryURLParams();
    let binds = [];
    for (let key in params) {
      if (params.hasOwnProperty(key)) {
        if (key.startsWith('bind-')) {
          binds.push({
            id: key.replace('bind-', ''),
            dataId: key.replace('bind-', ''),
            value: params[key]
          });
        }
      }
    }
    if (binds.length) {
      this.setDatas(binds, {
        history: false
      });
    }
  }
  drawLine(lineName) {
    lineName && lockedError(this.store);
    this.canvas.drawingLineName = lineName;
  }
  alignPenToGrid(pen) {
    this.canvas.alignPenToGrid(pen);
  }
  drawingPencil() {
    this.canvas.drawingPencil();
  }
  stopPencil() {
    this.canvas.stopPencil();
  }
  lock(lock) {
    this.store.data.locked = lock;
    this.finishDrawLine(true);
    this.canvas.drawingLineName = '';
    this.stopPencil();
    //恢复可选状态
    this.store.data.pens.forEach(pen => {
      if (pen.externElement === true) {
        // pen.onMove && pen.onMove(pen);
        pen.calculative.singleton?.div && render_setElemPosition(pen, pen.calculative.singleton.div);
      }
    });
    if (lock > 0) {
      this.initMessageEvents();
    }
  }
  // end  - 当前鼠标位置，是否作为终点
  async finishDrawLine(end) {
    await this.canvas.finishDrawline(end);
  }
  async finishPencil() {
    await this.canvas.finishPencil();
  }
  updateLineType(pen, lineName) {
    if (!pen || pen.name != 'line' || !lineName || !this.canvas[lineName]) {
      return;
    }
    pen.lineName = lineName;
    const from = getFromAnchor(pen);
    const to = getToAnchor(pen);
    from.prev = undefined;
    from.next = undefined;
    to.prev = undefined;
    to.next = undefined;
    pen.calculative.worldAnchors = [from, to];
    pen.calculative.activeAnchor = from;
    this.canvas[lineName](this.store, pen, to);
    if (pen.lineName === 'curve') {
      from.prev = {
        penId: from.penId,
        x: from.x - 50,
        y: from.y
      };
      from.next = {
        penId: from.penId,
        x: from.x + 50,
        y: from.y
      };
      to.prev = {
        penId: to.penId,
        x: to.x - 50,
        y: to.y
      };
      to.next = {
        penId: to.penId,
        x: to.x + 50,
        y: to.y
      };
    }
    pen.calculative.activeAnchor = undefined;
    this.canvas.initLineRect(pen);
    this.render();
  }
  addDrawLineFn(fnName, fn) {
    this.canvas[fnName] = fn;
    this.canvas.drawLineFns.push(fnName);
  }
  removeDrawLineFn(fnName) {
    const index = this.canvas.drawLineFns.indexOf(fnName);
    if (index > -1) {
      this.canvas.drawLineFns.splice(index, 1);
    }
  }
  showMagnifier() {
    this.canvas.showMagnifier();
  }
  hideMagnifier() {
    this.canvas.hideMagnifier();
  }
  toggleMagnifier() {
    this.canvas.toggleMagnifier();
  }
  /**
   * 擦除画布，释放 store 上的 pens
   * @param render 是否重绘
   */
  clear(render = true, template) {
    for (const pen of this.store.data.pens) {
      pen.onDestroy?.(pen);
    }
    clearStore(this.store, template);
    this.hideInput();
    this.canvas.tooltip.hide();
    if (this.map && this.map.isShow) {
      this.map.show();
      this.map.setView();
    }
    this.canvas.clearCanvas();
    sessionStorage.removeItem('page');
    this.store.clipboard = undefined;
    if (!this.store.sameTemplate) {
      this.canvas.canvasTemplate.bgPatchFlags = true;
    }
    this.store.patchFlagsBackground = true;
    this.store.patchFlagsTop = true;
    this.setBackgroundImage(undefined);
    render && this.render();
  }
  emit(type, event) {
    this.store.emitter.emit(type, event);
  }
  on(type, handler) {
    this.store.emitter.on(type, handler);
    return this;
  }
  off(type, handler) {
    this.store.emitter.off(type, handler);
    return this;
  }
  // customeDock = (store, rect, pens, offset) => {xDock, yDock}
  // customDock return:
  // {
  //   xDock: {x, y, step, prev, penId},
  //   yDock: {x, y, step, prev, penId},
  // }
  // xDock，yDock - 水平或垂直方向的参考线
  // prev - 参考线的起点
  // x,y - 参考线的终点
  // step - 自动吸附需要的偏移量
  // penId - 参考线的笔
  registerMoveDock(dock) {
    this.canvas.customMoveDock = dock;
  }
  /**
   * 参数同方法 registerMoveDock ，最后一个参数由 offset 偏移修改成了当前 resize 的点
   */
  registerResizeDock(dock) {
    this.canvas.customResizeDock = dock;
  }
  find(idOrTag) {
    return this.canvas.find(idOrTag);
  }
  findOne(idOrTag) {
    return this.canvas.findOne(idOrTag);
  }
  getPenRect(pen) {
    return this.canvas.getPenRect(pen);
  }
  setPenRect(pen, rect, render = true) {
    this.canvas.setPenRect(pen, rect, render);
  }
  startAnimate(idOrTagOrPens, params) {
    this.stopAnimate(idOrTagOrPens);
    let pens;
    // 没有参数 则播放有自动播放属性的动画
    if (!idOrTagOrPens) {
      pens = this.store.data.pens.filter(pen => {
        return (pen.type || pen.frames) && pen.autoPlay || pen.animations && pen.animations.length && pen.animations.findIndex(i => i.autoPlay) !== -1;
      });
    } else if (typeof idOrTagOrPens === 'string') {
      pens = this.find(idOrTagOrPens);
    } else {
      pens = idOrTagOrPens;
    }
    if (!pens.length) {
      return;
    }
    pens.forEach(pen => {
      if (pen.calculative.pause) {
        const d = Date.now() - pen.calculative.pause;
        pen.calculative.pause = undefined;
        pen.calculative.frameStart += d;
        pen.calculative.frameEnd += d;
      } else {
        let index = -1;
        if (params !== undefined && pen.animations) {
          if (typeof params === 'string') {
            index = pen.animations.findIndex(animation => animation.name === params);
            if (index === -1) {
              return;
            }
          } else if (typeof params === 'number') {
            if (pen.animations.length > params) {
              index = params;
            } else {
              return;
            }
          }
        } else if (params === undefined) {
          index = pen.animations?.findIndex(i => i.autoPlay);
          if (index === -1 && pen.animations?.length) {
            //默认执行第0个动画
            index = 0;
          }
        }
        if (index !== -1 && index !== undefined) {
          const animate = deepClone(pen.animations[index]);
          delete animate.name;
          animate.currentAnimation = index;
          if (!pen.type && animate.frames) {
            animate.showDuration = this.calcAnimateDuration(animate);
          }
          //animations成立
          this.setValue({
            id: pen.id,
            ...animate
          }, {
            doEvent: false,
            history: false
          });
        }
        this.store.animates.add(pen);
        if (!pen.type) {
          this.store.animateMap.set(pen, pen.calculative.canvas.getFrameProps(pen));
        }
      }
    });
    // this.canvas.canvasImage.init();
    // this.canvas.canvasImageBottom.init();
    this.initImageCanvas(pens);
    this.canvas.animate();
  }
  pauseAnimate(idOrTagOrPens) {
    let pens = [];
    if (!idOrTagOrPens) {
      this.store.animates.forEach(pen => {
        pens.push(pen);
      });
    } else if (typeof idOrTagOrPens === 'string') {
      pens = this.find(idOrTagOrPens);
    } else {
      pens = idOrTagOrPens;
    }
    pens.forEach(pen => {
      if (!pen.calculative.pause) {
        pen.calculative.pause = Date.now();
      }
    });
  }
  stopAnimate(idOrTagOrPens) {
    let pens = [];
    if (!idOrTagOrPens) {
      this.store.animates.forEach(pen => {
        pens.push(pen);
      });
    } else if (typeof idOrTagOrPens === 'string') {
      pens = this.find(idOrTagOrPens);
    } else {
      pens = idOrTagOrPens;
    }
    pens.forEach(pen => {
      pen.currentAnimation = undefined;
      pen.calculative.pause = undefined;
      pen.calculative.start = undefined;
      pen.calculative.duration = undefined;
      pen.calculative.animatePos = 0;
      this.store.animates.delete(pen);
      this.canvas.restoreNodeAnimate(pen);
      this.canvas.updateLines(pen);
      this.store.animateMap.delete(pen);
    });
    this.initImageCanvas(pens);
    setTimeout(() => {
      this.canvas?.calcActiveRect();
      this.render();
    }, 20);
  }
  startVideo(idOrTagOrPens) {
    let pens;
    if (!idOrTagOrPens) {
      pens = this.store.data.pens.filter(pen => {
        return (pen.video || pen.audio) && pen.autoPlay;
      });
    } else if (typeof idOrTagOrPens === 'string') {
      pens = this.find(idOrTagOrPens);
    } else {
      pens = idOrTagOrPens;
    }
    pens.forEach(pen => {
      pen.calculative.media?.play();
      pen.onStartVideo?.(pen);
    });
  }
  pauseVideo(idOrTagOrPens) {
    let pens = [];
    if (!idOrTagOrPens) {
      //TODO 寻找所有 而不是正在播放的
      pens = this.store.data.pens.filter(pen => {
        return (pen.video || pen.audio) && pen.autoPlay;
      });
    } else if (typeof idOrTagOrPens === 'string') {
      pens = this.find(idOrTagOrPens);
    } else {
      pens = idOrTagOrPens;
    }
    pens.forEach(pen => {
      pen.calculative.media?.pause();
      pen.onPauseVideo?.(pen);
    });
  }
  stopVideo(idOrTagOrPens) {
    let pens = [];
    if (!idOrTagOrPens) {
      pens = this.store.data.pens.filter(pen => {
        return (pen.video || pen.audio) && pen.autoPlay;
      });
    } else if (typeof idOrTagOrPens === 'string') {
      pens = this.find(idOrTagOrPens);
    } else {
      pens = idOrTagOrPens;
    }
    pens.forEach(pen => {
      if (pen.calculative.media) {
        pen.calculative.media.currentTime = 0;
        pen.calculative.media.pause();
      }
      pen.onStopVideo?.(pen);
    });
  }
  calcAnimateDuration(pen) {
    return pen.frames.reduce((prev, frame) => prev + frame.duration, 0);
  }
  /**
   * 组合
   * @param pens 组合的画笔们
   * @param showChild 组合后展示第几个孩子
   */
  combine(pens = this.store.active, showChild) {
    if (!pens || !pens.length) {
      return;
    }
    const initPens = deepClone(pens);
    if (pens.length === 1 && pens[0].type) {
      pens[0].type = PenType.Node;
      this.canvas.active(pens);
      this.pushHistory({
        type: EditType.Update,
        initPens,
        pens: deepClone(pens, true)
      });
      this.render();
      return;
    }
    const rect = getRect(pens);
    let parent = {
      id: s8(),
      name: 'combine',
      ...rect,
      children: [],
      showChild
    };
    // const p = pens.find((pen) => {
    //   // TODO: js 计算误差，可能导致包含着其它的 pens 的最大 pen 无法计算出来
    //   return pen.width === rect.width && pen.height === rect.height;
    // });
    // // 其中一个认为是父节点
    // const oneIsParent = p && showChild == undefined;
    // if (oneIsParent) {
    //   if (!p.children) {
    //     p.children = [];
    //   }
    //   parent = p;
    // } else {
    // 若组合为状态，那么 parent 一定是 combine
    this.canvas.makePen(parent);
    // }
    const initParent = deepClone(parent);
    let minIndex = Infinity;
    pens.forEach(pen => {
      const index = this.store.data.pens.findIndex(_pen => _pen.id === pen.id);
      if (index < minIndex) {
        minIndex = index;
      }
      if (pen === parent || pen.parentId === parent.id || pen.id === parent.id) {
        return;
      }
      // pen 来自于 store.active ，不存在有 parentId 的情况
      parent.children.push(pen.id);
      pen.parentId = parent.id;
      const childRect = calcRelativeRect(pen.calculative.worldRect, rect);
      Object.assign(pen, childRect);
      pen.locked = pen.lockedOnCombine ?? LockState.DisableMove;
      pen.locked = pen.interaction || isInteraction.includes(pen.name) ? 0 : pen.locked;
    });
    //将组合后的父节点置底
    this.store.data.pens.splice(minIndex, 0, parent);
    this.store.data.pens.pop();
    this.canvas.active([parent]);
    let step = 1;
    // if (!oneIsParent) {
    //   step = 2;
    //   this.pushHistory({
    //     type: EditType.Add,
    //     pens: [parent],
    //     step,
    //   });
    //   this.store.emitter.emit('add', [parent]);
    // }
    this.pushHistory({
      type: EditType.Add,
      pens: [initParent],
      step: 3
    });
    this.pushHistory({
      type: EditType.Update,
      initPens: [initParent],
      pens: [parent],
      step: 3
    });
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens,
      step: 3
    });
    if (showChild != undefined) {
      pens.forEach(pen => {
        calcInView(pen, true);
      });
      this.initImageCanvas([parent]);
    }
    this.store.emitter.emit('combine', [parent]);
    this.render();
    return parent;
  }
  uncombine(pen) {
    if (!pen && this.store.active) {
      pen = this.store.active[0];
    }
    if (!pen || !pen.children) {
      return;
    }
    const children = pen.children.map(childId => this.store.pens[childId]);
    let initPens = deepClone(children);
    children.forEach(child => {
      child.parentId = undefined;
      child.x = child.calculative.worldRect.x;
      child.y = child.calculative.worldRect.y;
      child.width = child.calculative.worldRect.width;
      child.height = child.calculative.worldRect.height;
      child.locked = LockState.None;
      child.calculative.active = undefined;
      child.calculative.hover = false;
      this.setVisible(child, true); // 子节点的 visible 属性已经改变，需要恢复
    });
    const step = this.isCombine(pen) ? 3 : 2;
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens: children,
      step
    });
    initPens = [deepClone(pen)];
    pen.children = undefined;
    // 保存修改 children 的历史记录
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens: [pen],
      step
    });
    if (this.isCombine(pen)) {
      this.delete([pen]);
      // delete 会记录 history , 更改 step 即可
      this.store.histories[this.store.histories.length - 1].step = step;
    }
    this.inactive();
  }
  appendChild(pens = this.store.active) {
    if (!pens) {
      return;
    }
    if (pens.length < 2) {
      return;
    }
    const pIdx = pens.findIndex(pen => pen.name === 'combine' && pen.showChild !== undefined);
    if (pIdx !== -1) {
      let parent = pens[pIdx];
      // this.pushChildren(parent,[...pens.slice(0, pIdx), ...pens.slice(pIdx + 1)]);
      const rect = getRect(pens);
      Object.assign(parent, rect);
      Object.assign(parent.calculative.worldRect, rect);
      calcWorldAnchors(parent);
      parent.children.forEach(penId => {
        const pen = this.store.pens[penId];
        const childRect = calcRelativeRect(pen.calculative.worldRect, rect);
        Object.assign(pen, childRect);
      });
      pens.forEach(pen => {
        if (pen.id !== parent.id) {
          parent.children.push(pen.id);
          pen.parentId = parent.id;
          const childRect = calcRelativeRect(pen.calculative.worldRect, rect);
          Object.assign(pen, childRect);
          pen.locked = pen.lockedOnCombine ?? LockState.DisableMove;
          pen.locked = pen.interaction || isInteraction.includes(pen.name) ? 0 : pen.locked;
          calcInView(pen, true);
        }
      });
      this.initImageCanvas(pens);
      this.render();
    } else {
      console.warn('Invalid operation!');
    }
  }
  isCombine(pen) {
    if (pen.name === 'combine') {
      return true;
    }
    if (pen.children && pen.children.length > 0) {
      return true;
    }
    return false;
  }
  active(pens, emit = true) {
    this.canvas.active(pens, emit);
  }
  inactive() {
    this.canvas.inactive();
  }
  activeAll() {
    this.canvas.active(this.store.data.pens.filter(pen => !pen.parentId && pen.locked !== LockState.Disable));
    this.render();
  }
  /**
   * 删除画笔
   * @param pens 需要删除的画笔们
   * @param canDelLocked 是否删除已经锁住的画笔
   */
  delete(pens, canDelLocked = false, history = true) {
    this.canvas.delete(pens, canDelLocked, history);
  }
  scale(scale, center = {
    x: 0,
    y: 0
  }) {
    this.canvas.scale(scale, center);
  }
  translate(x, y) {
    this.canvas.translate(x, y);
  }
  translatePens(pens, x, y) {
    this.canvas.translatePens(pens, x, y);
  }
  getParent(pen, root) {
    return getParent(pen, root);
  }
  getAllChildren(pen) {
    return getAllChildren(pen, this.store);
  }
  getAllFollowers(pen) {
    return getAllFollowers(pen, this.store);
  }
  data() {
    const data = deepClone(this.store.data);
    const {
      pens,
      paths
    } = this.store.data;
    data.version = package_namespaceObject.rE;
    // TODO: 未在 delete 时清除，避免撤销等操作。
    // 清除一些未使用到的 paths
    data.paths = {};
    for (const pathId in paths) {
      if (Object.prototype.hasOwnProperty.call(paths, pathId)) {
        if (pens.find(pen => pen.pathId === pathId)) {
          data.paths[pathId] = paths[pathId];
        }
      }
    }
    data.dataPoints = [...Object.keys(this.store.bind), ...Object.keys(this.store.bindDatas)];
    return data;
  }
  copy(pens) {
    this.canvas.copy(pens);
  }
  cut(pens) {
    this.canvas.cut(pens);
  }
  paste() {
    this.canvas.paste();
  }
  undo() {
    this.canvas.undo();
  }
  redo() {
    this.canvas.redo();
  }
  listenSocket() {
    try {
      let socketFn;
      const socketCbJs = this.store.data.socketCbJs;
      if (socketCbJs) {
        socketFn = new Function('e', 'context', socketCbJs);
      }
      if (!socketFn) {
        this.socketFn = null;
        return false;
      }
      this.socketFn = socketFn;
    } catch (e) {
      console.error('Create the function for socket:', e);
      return false;
    }
    return true;
  }
  connectWebsocket(websocket) {
    this.closeWebsocket();
    if (websocket) {
      this.store.data.websocket = websocket;
    }
    if (this.store.data.websocket) {
      this.websocket = new WebSocket(this.store.data.websocket, this.store.data.websocketProtocols || undefined);
      this.websocket.onmessage = e => {
        this.socketCallback(e.data, {
          type: 'websocket',
          url: this.store.data.websocket
        });
      };
      this.websocket.onerror = error => {
        this.store.emitter.emit('error', {
          type: 'websocket',
          error
        });
      };
      this.websocket.onclose = () => {
        if (this.store.options.reconnetTimes) {
          this.websocketTimes++;
          if (this.websocketTimes >= this.store.options.reconnetTimes) {
            this.websocketTimes = 0;
            this.closeWebsocket();
            return;
          }
        }
        console.info('Canvas websocket closed and reconneting...');
        this.connectWebsocket();
      };
    }
  }
  closeWebsocket() {
    if (this.websocket) {
      this.websocket.onclose = undefined;
      this.websocket.close();
      this.websocket = undefined;
    }
  }
  connectMqtt(params) {
    this.closeMqtt();
    if (params) {
      this.store.data.mqtt = params.mqtt;
      this.store.data.mqttTopics = params.mqttTopics;
      this.store.data.mqttOptions = params.mqttOptions;
    }
    if (this.store.data.mqtt) {
      if (this.store.data.mqttOptions.clientId && !this.store.data.mqttOptions.customClientId) {
        this.store.data.mqttOptions.clientId = s8();
      }
      const mqttOptions = {
        ...this.store.data.mqttOptions
      };
      // 如果没有username/password或为空字符串则删除username/password
      if (!mqttOptions.username) {
        delete mqttOptions.username;
      }
      if (!mqttOptions.password) {
        delete mqttOptions.password;
      }
      const {
        username,
        password
      } = mqttOptions;
      // username 和 password 必须同时存在或者同时不存在才去建立mqtt连接
      if (username && password || !username && !password) {
        this.mqttClient = mqtt_min.connect(this.store.data.mqtt, mqttOptions);
        this.mqttClient.on('message', (topic, message) => {
          this.socketCallback(message.toString(), {
            topic,
            type: 'mqtt',
            url: this.store.data.mqtt
          });
        });
        this.mqttClient.on('error', error => {
          this.store.emitter.emit('error', {
            type: 'mqtt',
            error
          });
        });
        this.mqttClient.on('close', () => {
          if (this.store.options.reconnetTimes) {
            this.mqttTimes++;
            if (this.mqttTimes >= this.store.options.reconnetTimes) {
              this.mqttTimes = 0;
              this.closeMqtt();
            }
          }
        });
        if (this.store.data.mqttTopics) {
          this.mqttClient.subscribe(this.store.data.mqttTopics.split(','));
        }
      } else {
        console.warn('缺少用户名或密码');
      }
    }
  }
  closeMqtt() {
    this.mqttClient?.end();
  }
  connectHttp() {
    this.closeHttp();
    const {
      https
    } = this.store.data;
    if (https) {
      if (!this.store.data.cancelFirstConnect) {
        https.forEach(async item => {
          this.oldRequestHttp(item);
        });
      }
      https.forEach((item, index) => {
        if (item.http) {
          item.times = 0;
          this.httpTimerList[index] = setInterval(async () => {
            // 默认每一秒请求一次
            this.oldRequestHttp(item);
            if (this.store.options.reconnetTimes) {
              item.times++;
              if (item.times >= this.store.options.reconnetTimes) {
                item.times = 0;
                clearInterval(this.httpTimerList[index]);
                this.httpTimerList[index] = undefined;
              }
            }
          }, item.httpTimeInterval || 1000);
        }
      });
    } else {
      const {
        http,
        httpTimeInterval,
        httpHeaders
      } = this.store.data;
      if (http) {
        this.httpTimer = setInterval(async () => {
          // 默认每一秒请求一次
          const res = await fetch(http, {
            headers: httpHeaders
          });
          if (res.ok) {
            const data = await res.text();
            this.socketCallback(data, {
              type: 'http',
              url: http
            });
          }
        }, httpTimeInterval || 1000);
      }
    }
  }
  async oldRequestHttp(_req) {
    let req = deepClone(_req);
    if (req.http) {
      const res = await fetch(req.http, {
        headers: req.httpHeaders,
        method: req.method || 'GET',
        body: req.method === 'POST' ? JSON.stringify(req.body) : undefined
      });
      if (res.ok) {
        const data = await res.text();
        this.socketCallback(data, {
          type: 'http',
          url: req.http
        });
      } else {
        this.store.emitter.emit('error', {
          type: 'http',
          error: res
        });
      }
    }
  }
  async sendDatabyHttp(data) {
    const {
      https
    } = this.store.data;
    if (https) {
      https.forEach(async item => {
        if (item.http) {
          const res = await fetch(item.http, {
            method: 'post',
            body: data,
            headers: item.httpHeaders
          });
          if (res.ok) {
            console.info('http消息发送成功');
          }
        }
      });
    } else {
      const {
        http,
        httpHeaders
      } = this.store.data;
      if (http) {
        // 默认每一秒请求一次
        const res = await fetch(http, {
          method: 'post',
          body: data,
          headers: httpHeaders
        });
        if (res.ok) {
          console.info('http消息发送成功');
        }
      }
    }
  }
  closeHttp() {
    clearInterval(this.httpTimer);
    this.httpTimer = undefined;
    this.httpTimerList && this.httpTimerList.forEach(_httpTimer => {
      clearInterval(_httpTimer);
      _httpTimer = undefined;
    });
  }
  connectNetwork() {
    this.closeNetwork();
    const {
      networks
    } = this.store.data;
    const https = [];
    if (networks) {
      let mqttIndex = 0;
      this.mqttClients = [];
      let websocketIndex = 0;
      this.websockets = [];
      networks.forEach(net => {
        if (net.type === 'subscribe') {
          if (net.protocol === 'mqtt') {
            net.index = mqttIndex;
            if (net.options.clientId && !net.options.customClientId) {
              net.options.clientId = s8();
            }
            net.times = 0;
            this.mqttClients[mqttIndex] = mqtt_min.connect(net.url, net.options);
            this.mqttClients[mqttIndex].on('message', (topic, message) => {
              this.socketCallback(message.toString(), {
                topic,
                type: 'mqtt',
                url: net.url
              });
            });
            this.mqttClients[mqttIndex].on('error', error => {
              this.store.emitter.emit('error', {
                type: 'mqtt',
                error
              });
            });
            this.mqttClients[mqttIndex].on('close', () => {
              if (this.store.options.reconnetTimes) {
                net.times++;
                if (net.times >= this.store.options.reconnetTimes) {
                  net.times = 0;
                  this.mqttClients && this.mqttClients[net.index]?.end();
                }
              }
            });
            if (net.topics) {
              this.mqttClients[mqttIndex].subscribe(net.topics.split(','));
            }
            mqttIndex += 1;
          } else if (net.protocol === 'websocket') {
            net.index = websocketIndex;
            this.connectNetWebSocket(net);
            // this.websockets[websocketIndex] = new WebSocket(
            //   net.url,
            //   net.protocols || undefined
            // );
            // this.websockets[websocketIndex].onmessage = (e) => {
            //   this.socketCallback(e.data, { type: 'websocket', url: net.url });
            // };
            // this.websockets[websocketIndex].onerror = (error) => {
            //   this.store.emitter.emit('error', { type: 'websocket', error });
            // };
            // this.websockets[websocketIndex].onclose = () => {
            //   if (this.store.options.reconnetTimes) {
            //     net.times++;
            //     if (net.times >= this.store.options.reconnetTimes) {
            //       net.times = 0;
            //       this.websockets[net.index]?.close();
            //       return;
            //     }
            //   }
            // console.info('Canvas websocket closed and reconneting...');
            // };
            websocketIndex += 1;
          } else if (net.protocol === 'http') {
            https.push({
              url: net.url,
              interval: net.interval,
              headers: net.headers || undefined,
              method: net.method,
              body: net.body
            });
          }
        }
      });
    }
    this.onNetworkConnect(https);
  }
  connectNetWebSocket(net) {
    if (this.websockets[net.index]) {
      this.websockets[net.index].onclose = undefined;
      this.websockets[net.index]?.close();
      this.websockets[net.index] = undefined;
    }
    this.websockets[net.index] = new WebSocket(net.url, net.protocols || undefined);
    this.websockets[net.index].onmessage = e => {
      this.socketCallback(e.data, {
        type: 'websocket',
        url: net.url
      });
    };
    this.websockets[net.index].onerror = error => {
      this.store.emitter.emit('error', {
        type: 'websocket',
        error
      });
    };
    this.websockets[net.index].onclose = () => {
      if (this.store.options.reconnetTimes) {
        net.times++;
        if (net.times >= this.store.options.reconnetTimes) {
          net.times = 0;
          this.websockets[net.index].onclose = undefined;
          this.websockets[net.index]?.close();
          this.websockets[net.index] = undefined;
          return;
        }
      }
      setTimeout(() => {
        console.info('Canvas websocket closed and reconneting...');
        this.connectNetWebSocket(net);
      }, 2000);
    };
  }
  randomString(e) {
    e = e || 32;
    let t = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678',
      a = t.length,
      n = '';
    for (let i = 0; i < e; i++) {
      n += t.charAt(Math.floor(Math.random() * a));
    }
    return n;
  }
  mockValue(data) {
    let value = undefined;
    if (data.enableMock && data.mock !== undefined) {
      if (data.type === 'float') {
        if (data.mock && data.mock.indexOf(',') !== -1) {
          let arr = data.mock.split(',');
          let rai = Math.floor(Math.random() * arr.length);
          value = parseFloat(arr[rai]);
        } else if (data.mock && data.mock.indexOf('-') !== -1) {
          let max;
          let min;
          let len;
          let arr = data.mock.split('-');
          if (data.mock.charAt(0) === '-') {
            //负数
            if (arr.length === 4) {
              max = -parseFloat(arr[3]);
              min = -parseFloat(arr[1]);
              len = arr[3];
            } else {
              max = parseFloat(arr[2]);
              min = -parseFloat(arr[1]);
              len = arr[2];
            }
          } else {
            max = parseFloat(arr[1]);
            min = parseFloat(arr[0]);
            len = arr[1];
          }
          if ((len + '').indexOf('.') !== -1) {
            let length = (len + '').split('.')[1].length;
            value = (Math.random() * (max - min) + min).toFixed(length);
          } else {
            value = Math.random() * (max - min) + min;
          }
        } else {
          value = parseFloat(data.mock);
        }
      } else if (data.type === 'integer') {
        if (data.mock && data.mock.indexOf(',') !== -1) {
          let arr = data.mock.split(',');
          let rai = Math.floor(Math.random() * arr.length);
          value = parseInt(arr[rai]);
        } else if (data.mock && data.mock.indexOf('-') !== -1) {
          let max;
          let min;
          let arr = data.mock.split('-');
          if (data.mock.charAt(0) === '-') {
            if (arr.length === 4) {
              max = -parseFloat(arr[3]);
              min = -parseFloat(arr[1]);
            } else {
              max = parseFloat(arr[2]);
              min = -parseFloat(arr[1]);
            }
          } else {
            max = parseInt(arr[1]);
            min = parseInt(arr[0]);
          }
          value = parseInt(Math.random() * (max - min) + min + '');
        } else {
          value = parseInt(data.mock);
        }
      } else if (data.type === 'bool') {
        if (typeof data.mock === 'boolean') {
          value = data.mock;
        } else if ('true' === data.mock) {
          value = true;
        } else if ('false' === data.mock) {
          value = false;
        } else {
          value = Math.random() < 0.5;
        }
      } else if (data.type === 'object' || data.type === 'array') {
        if (data.mock) {
          //对象or数组 不mock
          // _d[realTime.key] = realTime.value;
        }
      } else {
        //if (realTime.type === 'string')
        if (data.mock && data.mock.indexOf(',') !== -1) {
          let str = data.mock.substring(1, data.mock.length - 1);
          let arr = str.split(',');
          let rai = Math.floor(Math.random() * arr.length);
          value = arr[rai];
        } else if (data.mock && data.mock.startsWith('[') && data.mock.endsWith(']')) {
          let len = parseInt(data.mock.substring(1, data.mock.length - 1));
          value = this.randomString(len);
        } else {
          value = data.mock;
        }
      }
    }
    return value;
  }
  //数据模拟
  dataMock() {
    let arr = [];
    this.store.data.dataset?.devices?.forEach(data => {
      let value = this.mockValue(data);
      if (value !== undefined) {
        arr.push({
          id: data.id,
          value
        });
      }
    });
    if (arr.length) {
      this.setDatas(arr, {
        render: true,
        doEvent: true,
        history: false
      });
    }
  }
  startDataMock() {
    let enable = this.store.data.enableMock;
    if (enable) {
      this.stopDataMock();
      this.initBinds();
      this.updateTimer = setInterval(() => {
        //本地调试
        this.store.data.pens.forEach(pen => {
          this.penMock(pen);
        });
        this.dataMock();
        this.render();
      }, this.store.data.networkInterval || 1000);
    }
  }
  stopDataMock() {
    clearInterval(this.updateTimer);
    this.updateTimer = undefined;
  }
  penMock(pen) {
    if (pen.realTimes) {
      let _d = {};
      pen.realTimes.forEach(realTime => {
        let value = this.mockValue(realTime);
        if (value !== undefined) {
          _d[realTime.key] = value;
        }
      });
      if (Object.keys(_d).length) {
        let data = pen.onBeforeValue ? pen.onBeforeValue(pen, _d) : _d;
        this.canvas.updateValue(pen, data);
        // this.store.emitter.emit('valueUpdate', pen);
        pen.onValue?.(pen);
        this.store.emitter.emit('valueUpdate', pen);
      }
    }
  }
  penNetwork(pen) {
    const penNetwork = {
      url: pen.apiUrl,
      method: pen.apiMethod,
      headers: pen.apiHeaders,
      body: pen.apiBody
    };
    //临时请求一次
    this.requestHttp(penNetwork);
    if (pen.apiEnable) {
      if (!this.store.pensNetwork) {
        this.store.pensNetwork = {};
      }
      this.store.pensNetwork[pen.id] = penNetwork;
    } else {
      delete this.store.pensNetwork[pen.id];
    }
  }
  //获取动态参数
  getDynamicParam(key) {
    function getCookie(name) {
      let arr;
      const reg = new RegExp('(^| )' + name + '=([^;]*)(;|$)');
      if (arr = document.cookie.match(reg)) {
        return decodeURIComponent(arr[2]);
      } else {
        return '';
      }
    }
    let params = queryURLParams();
    let value = params[key] || localStorage[key] || getCookie(key) || '';
    return value;
  }
  onNetworkConnect(https) {
    // let enable = this.store.data.enableMock;
    if (!(https && https.length)) {
      return;
    }
    if (this.store.pensNetwork) {
      for (let key in this.store.pensNetwork) {
        https.push(this.store.pensNetwork[key]);
      }
    }
    if (!this.store.data.cancelFirstConnect) {
      https.forEach(async _item => {
        this.requestHttp(_item);
      });
    }
    // if( enable ){
    //   this.updateTimer = setInterval(() => {
    //     //模拟数据
    //     this.store.data.pens.forEach((pen) => {
    //       this.penMock(pen);
    //     });
    //     // https.forEach(async (_item) => {
    //     //   this.requestHttp(_item);
    //     // });
    //     this.render();
    //   }, this.store.data.networkInterval || 1000);
    // }
    https.forEach((_item, index) => {
      _item.times = 0;
      this.updateTimerList[index] = setInterval(async () => {
        this.requestHttp(_item);
        if (this.store.options.reconnetTimes) {
          _item.times++;
          if (_item.times >= this.store.options.reconnetTimes) {
            _item.times = 0;
            clearInterval(this.updateTimerList[index]);
            this.updateTimerList[index] = undefined;
          }
        }
      }, _item.interval || 1000);
    });
  }
  async requestHttp(_req) {
    let req = deepClone(_req);
    if (req.url) {
      if (typeof req.headers === 'object') {
        for (let i in req.headers) {
          if (typeof req.headers[i] === 'string') {
            let keys = req.headers[i].match(/(?<=\$\{).*?(?=\})/g);
            if (keys) {
              req.headers[i] = req.headers[i].replace(`\${${keys[0]}}`, this.getDynamicParam(keys[0]));
            }
          }
        }
      }
      if (typeof req.body === 'object') {
        for (let i in req.body) {
          if (typeof req.body[i] === 'string') {
            let keys = req.body[i].match(/(?<=\$\{).*?(?=\})/g);
            if (keys) {
              req.body[i] = req.body[i].replace(`\${${keys[0]}}`, this.getDynamicParam(keys[0]));
            }
          }
        }
      }
      // 默认每一秒请求一次
      const res = await fetch(req.url, {
        headers: req.headers,
        method: req.method,
        body: req.method === 'GET' ? undefined : JSON.stringify(req.body)
      });
      if (res.ok) {
        const data = await res.text();
        this.socketCallback(data, {
          type: 'http',
          url: req.url
        });
      } else {
        this.store.emitter.emit('error', {
          type: 'http',
          error: res
        });
      }
    }
  }
  closeNetwork() {
    this.mqttClients && this.mqttClients.forEach(mqttClient => {
      mqttClient.end();
    });
    this.websockets && this.websockets.forEach(websocket => {
      if (websocket) {
        websocket.onclose = undefined;
        websocket.close();
        websocket = undefined;
      }
    });
    this.mqttClients = undefined;
    this.websockets = undefined;
    // clearInterval(this.updateTimer);
    // this.updateTimer = undefined;
    this.updateTimerList && this.updateTimerList.forEach(_updateTimer => {
      clearInterval(_updateTimer);
      _updateTimer = undefined;
    });
  }
  socketCallback(message, context) {
    this.store.emitter.emit('socket', {
      message,
      context
    });
    let _message = message;
    if (this.socketFn) {
      _message = this.socketFn(message, {
        meta2d: this,
        type: context.type,
        topic: context.topic,
        url: context.url
      });
      if (!_message) {
        return;
      }
    }
    if (_message === true) {
      _message = message;
    }
    let data;
    if (_message.constructor === Object || _message.constructor === Array) {
      data = _message;
    } else if (typeof _message === 'string') {
      try {
        data = JSON.parse(_message);
      } catch (error) {
        console.warn('Invalid socket data:', data, error);
      }
    } else {
      return;
    }
    if (!data) {
      return;
    }
    if (!Array.isArray(data)) {
      data = [data];
    }
    if (!data.length) {
      return;
    }
    if (data[0].dataId) {
      this.setDatas(data);
    } else {
      data.forEach(_data => {
        this.setValue(_data);
      });
    }
  }
  // 绑定变量方式更新组件数据
  setDatas(datas, {
    render = true,
    doEvent = true,
    history
  } = {}) {
    // 把{dataId: string; value: any}转成setValue格式数据
    const penValues = new Map();
    datas.forEach(v => {
      this.store.bindDatas[v.dataId]?.forEach(p => {
        const pen = this.store.pens[p.id];
        if (!pen) {
          return;
        }
        let penValue = penValues.get(pen);
        if (!pen.noOnBinds && typeof pen.onBinds === 'function') {
          // 已经计算了
          if (penValue) {
            return;
          }
          penValues.set(pen, pen.onBinds(pen, datas, p.formItem));
          return;
        }
        if (penValue) {
          penValue[p.formItem.key] = v.value;
        } else {
          penValue = {
            id: p.id,
            [p.formItem.key]: v.value
          };
          penValues.set(pen, penValue);
        }
      });
      this.store.bind[v.id]?.forEach(p => {
        const pen = this.store.pens[p.id];
        if (!pen) {
          return;
        }
        let penValue = penValues.get(pen);
        // if (typeof pen.onBinds === 'function') {
        //   // 已经计算了
        //   if (penValue) {
        //     return;
        //   }
        //   //TODO onBinds的情况
        //   penValues.set(pen, pen.onBinds(pen, datas));
        //   return;
        // }
        if (penValue) {
          penValue[p.key] = v.value;
        } else {
          penValue = {
            id: p.id,
            [p.key]: v.value
          };
          penValues.set(pen, penValue);
        }
      });
    });
    this.store.data.locked && this.doDataEvent(datas);
    let initPens;
    let pens;
    if (history) {
      initPens = [];
    }
    penValues.forEach((value, pen) => {
      this.setValue(value, {
        render: false,
        doEvent,
        history: false
      });
      if (history) {
        initPens.push(deepClone(pen, true));
        pens.push(pen);
      }
    });
    render && this.render();
    if (history) {
      this.pushHistory({
        type: EditType.Update,
        initPens,
        pens
      });
    }
  }
  setValue(data, {
    render = true,
    doEvent = true,
    history
  } = {}) {
    let pens = [];
    if (!data) {
      return;
    }
    if (data.id) {
      if (data.id === this.store.data.id) {
        this.setDatabyOptions(data);
        if (data.bkImage) {
          this.setBackgroundImage(data.bkImage);
        }
        if (data.background) {
          this.setBackgroundColor(data.background);
        }
        this.render();
        return;
      }
      const pen = this.store.pens[data.id];
      if (pen) {
        pens = [pen];
      } else {
        //bind 绑定变量的情况
        let bindArr = this.store.bind[data.id];
        if (bindArr && bindArr.length) {
          pens = [];
          this.setDatas([data], {
            render,
            doEvent,
            history
          });
          return;
        }
      }
    } else if (data.dataId) {
      pens = [];
      this.setDatas([data], {
        render,
        doEvent,
        history
      });
      return;
    } else if (data.tag) {
      pens = this.find(data.tag);
    } else {
      let binds = [];
      for (let key in data) {
        binds.push({
          dataId: key,
          id: key,
          value: data[key]
        });
      }
      ;
      if (binds.length) {
        this.setDatas(binds, {
          render,
          doEvent,
          history
        });
      }
      return;
    }
    history = history && !this.store.data.locked;
    let initPens;
    if (history) {
      initPens = deepClone(pens);
    }
    pens.forEach(pen => {
      const afterData = pen.onBeforeValue ? pen.onBeforeValue(pen, data) : data;
      if (data.frames) {
        this.stopAnimate([pen]);
        if (!data.showDuration) {
          data.showDuration = data.frames.reduce((total, item) => {
            return total + item.duration;
          }, 0);
        }
      }
      setChildValue(pen, afterData);
      this.canvas.updateValue(pen, afterData);
      pen.onValue?.(pen);
    });
    if (!this.store.data.locked && this.store.active.length && !this.canvas.movingPens) {
      // 移动过程中，不重算 activeRect
      this.canvas.calcActiveRect();
    }
    if (history) {
      let _pens = deepClone(pens);
      this.pushHistory({
        type: EditType.Update,
        initPens,
        pens: _pens
      });
    }
    doEvent && pens.forEach(pen => {
      this.store.emitter.emit('valueUpdate', pen);
    });
    render && this.render();
  }
  /**
   * @deprecated 改用 setValue
   */
  _setValue(data, history = false) {
    this.setValue(data, {
      history,
      render: false,
      doEvent: false
    });
  }
  pushHistory(action) {
    this.canvas.pushHistory(action);
  }
  showInput(pen, rect) {
    this.canvas.showInput(pen, rect);
  }
  hideInput() {
    this.canvas.hideInput();
  }
  clearDropdownList() {
    this.canvas.clearDropdownList();
  }
  clearRuleLines() {
    this.canvas.clearRuleLines();
  }
  doMessageEvent(eventName) {
    if (this.store.messageEvents[eventName]) {
      this.store.messageEvents[eventName].forEach(item => {
        let flag = false;
        if (item.event.conditions && item.event.conditions.length) {
          if (item.event.conditionType === 'and') {
            flag = item.event.conditions.every(condition => {
              return this.judgeCondition(item.pen, condition.key, condition);
            });
          } else if (item.event.conditionType === 'or') {
            flag = item.event.conditions.some(condition => {
              return this.judgeCondition(item.pen, condition.key, condition);
            });
          }
        } else {
          flag = true;
        }
        if (flag) {
          item.event.actions.forEach(action => {
            this.events[action.action](item.pen, action);
          });
        }
      });
    }
  }
  initGlobalTriggers() {
    this.store.globalTriggers = {};
    this.store.data.triggers?.forEach(trigger => {
      trigger.conditions.forEach(condition => {
        if (condition.source) {
          if (!this.store.globalTriggers[condition.source]) {
            this.store.globalTriggers[condition.source] = [];
          }
          if (!this.store.globalTriggers[condition.source].includes(trigger)) {
            this.store.globalTriggers[condition.source].push(trigger);
          }
        }
      });
    });
  }
  initMessageEvents() {
    this.store.messageEvents = {};
    this.store.data.pens.forEach(pen => {
      pen.events?.forEach(event => {
        if (event.name === 'message' && event.message) {
          if (!this.store.messageEvents[event.message]) {
            this.store.messageEvents[event.message] = [];
          }
          this.store.messageEvents[event.message].push({
            pen: pen,
            event: event
          });
        }
      });
    });
  }
  dataJudegeCondition(data, key, condition) {
    const {
      type,
      target,
      fnJs,
      fn,
      operator,
      valueType
    } = condition;
    let can = false;
    if (type === 'fn') {
      //方法
      if (fn) {
        can = fn(data, {
          meta2d: this
        });
      } else if (fnJs) {
        try {
          condition.fn = new Function('data', 'context', fnJs);
        } catch (err) {
          console.error('Error: make function:', err);
        }
        if (condition.fn) {
          can = condition.fn(data, {
            meta2d: this
          });
        }
      }
    } else {
      //TODO boolean类型 数字类型
      let value = condition.value;
      if (valueType === 'prop') {
        value = data[condition.value];
      }
      let compareValue = data[key];
      switch (operator) {
        case '>':
          can = compareValue > +value;
          break;
        case '>=':
          can = compareValue >= +value;
          break;
        case '<':
          can = compareValue < +value;
          break;
        case '<=':
          can = compareValue <= +value;
          break;
        case '=':
        case '==':
          can = compareValue == value;
          break;
        case '!=':
          can = compareValue != value;
          break;
        case '[)':
          can = valueInRange(+compareValue, value);
          break;
        case '![)':
          can = !valueInRange(+compareValue, value);
          break;
        case '[]':
          can = valueInArray(compareValue, value);
          break;
        case '![]':
          can = !valueInArray(compareValue, value);
          break;
      }
    }
    return can;
  }
  judgeCondition(pen, key, condition) {
    const {
      type,
      target,
      fnJs,
      fn,
      operator,
      valueType
    } = condition;
    let can = false;
    if (type === 'fn') {
      //方法
      if (fn) {
        can = fn(pen, {
          meta2d: this
        });
      } else if (fnJs) {
        try {
          condition.fn = new Function('pen', 'context', fnJs);
        } catch (err) {
          console.error('Error: make function:', err);
        }
        if (condition.fn) {
          can = condition.fn(pen, {
            meta2d: this
          });
        }
      }
    } else {
      //TODO boolean类型 数字类型
      let value = condition.value;
      if (valueType === 'prop') {
        value = this.store.pens[target][condition.value];
      }
      let compareValue = getter(pen, key);
      if (['x', 'y', 'width', 'height'].includes(key)) {
        compareValue = this.getPenRect(pen)[key];
      }
      switch (operator) {
        case '>':
          can = compareValue > +value;
          break;
        case '>=':
          can = compareValue >= +value;
          break;
        case '<':
          can = compareValue < +value;
          break;
        case '<=':
          can = compareValue <= +value;
          break;
        case '=':
        case '==':
          can = compareValue == value;
          break;
        case '!=':
          can = compareValue != value;
          break;
        case '[)':
          can = valueInRange(+compareValue, value);
          break;
        case '![)':
          can = !valueInRange(+compareValue, value);
          break;
        case '[]':
          can = valueInArray(compareValue, value);
          break;
        case '![]':
          can = !valueInArray(compareValue, value);
          break;
      }
    }
    return can;
  }
  pushChildren(parent, children) {
    const initUpdatePens = [deepClone(parent, true)];
    const addPens = [];
    if (!parent.children) {
      parent.children = [];
    }
    const updatePens = [];
    children.forEach(pen => {
      let oldPen = deepClone(pen, true);
      if (!pen.id || !this.store.pens[pen.id]) {
        // 不存在于 store 中
        this.canvas.makePen(pen);
        oldPen = null; // 添加操作
      }
      if (pen.parentId) {
        const oldParent = this.store.pens[pen.parentId];
        const i = oldParent.children.findIndex(id => id === pen.id);
        initUpdatePens.push(deepClone(oldParent, true));
        oldParent.children.splice(i, 1);
        updatePens.push(deepClone(oldParent, true));
      }
      parent.children.push(pen.id);
      pen.parentId = parent.id;
      const childRect = calcRelativeRect(pen.calculative.worldRect, parent.calculative.worldRect);
      Object.assign(pen, childRect);
      pen.locked = pen.lockedOnCombine ?? LockState.DisableMove;
      pen.locked = pen.interaction || isInteraction.includes(pen.name) ? 0 : pen.locked;
      if (!oldPen) {
        addPens.push(deepClone(pen, true));
      } else {
        initUpdatePens.push(oldPen);
        updatePens.push(deepClone(pen, true));
      }
    });
    updatePens.push(deepClone(parent, true));
    let step = 1;
    if (addPens.length) {
      step = 2;
      this.pushHistory({
        type: EditType.Add,
        pens: addPens,
        step
      });
    }
    this.pushHistory({
      type: EditType.Update,
      initPens: initUpdatePens,
      pens: updatePens,
      step
    });
  }
  toPng(padding, callback, containBkImg = false, maxWidth) {
    return this.canvas.toPng(padding, callback, containBkImg, maxWidth);
  }
  activeToPng(padding, maxWidth) {
    return this.canvas.activeToPng(padding, maxWidth);
  }
  pensToPng(pens = this.store.active, padding, maxWidth) {
    return this.canvas.pensToPng(pens, padding, maxWidth);
  }
  /**
   * 下载 png
   * @param name 传入参数自带文件后缀名 例如：'test.png'
   * @param padding 上右下左的内边距
   */
  downloadPng(name, padding, maxWidth) {
    for (const pen of this.store.data.pens) {
      if (pen.calculative.img || ['iframe'].includes(pen.name)) {
        //重新生成绘制图片
        pen.onRenderPenRaw?.(pen);
      }
    }
    setTimeout(() => {
      const a = document.createElement('a');
      a.setAttribute('download', (name || this.store.data.name || 'le5le.meta2d') + '.png');
      a.setAttribute('href', this.toPng(padding, undefined, true, maxWidth));
      const evt = document.createEvent('MouseEvents');
      evt.initEvent('click', true, true);
      a.dispatchEvent(evt);
    }, 1000);
  }
  downloadSvg() {
    if (!window.C2S) {
      console.error('请先加载乐吾乐官网下的canvas2svg.js', 'https://assets.le5lecdn.com/2d/canvas2svg.js');
      throw new Error('请先加载乐吾乐官网下的canvas2svg.js');
    }
    const rect = this.getRect();
    rect.x -= 10;
    rect.y -= 10;
    const ctx = new window.C2S(rect.width + 20, rect.height + 20);
    ctx.textBaseline = 'middle';
    for (const pen of this.store.data.pens) {
      if (pen.visible == false || !isShowChild(pen, this.store)) {
        continue;
      }
      renderPenRaw(ctx, pen, rect, true);
    }
    let mySerializedSVG = ctx.getSerializedSvg();
    if (this.store.data.background) {
      mySerializedSVG = mySerializedSVG.replace('{{bk}}', '');
      mySerializedSVG = mySerializedSVG.replace('{{bkRect}}', `<rect x="0" y="0" width="100%" height="100%" fill="${this.store.data.background}"></rect>`);
    } else {
      mySerializedSVG = mySerializedSVG.replace('{{bk}}', '');
      mySerializedSVG = mySerializedSVG.replace('{{bkRect}}', '');
    }
    mySerializedSVG = mySerializedSVG.replace(/--le5le--/g, '&#x');
    const urlObject = window.URL;
    const export_blob = new Blob([mySerializedSVG]);
    const url = urlObject.createObjectURL(export_blob);
    const a = document.createElement('a');
    a.setAttribute('download', `${this.store.data.name || 'le5le.meta2d'}.svg`);
    a.setAttribute('href', url);
    const evt = document.createEvent('MouseEvents');
    evt.initEvent('click', true, true);
    a.dispatchEvent(evt);
  }
  getRect(pens = this.store.data.pens) {
    return getRect(pens);
  }
  hiddenTemplate() {
    this.canvas.canvasTemplate.hidden();
  }
  showTemplate() {
    this.canvas.canvasTemplate.show();
  }
  lockTemplate(lock) {
    //锁定
    this.store.data.pens.forEach(pen => {
      // if (pen.template) {
      //   pen.locked = lock;
      // }
      if (pen.canvasLayer === CanvasLayer.CanvasTemplate) {
        pen.locked = lock;
      }
    });
  }
  /**
   * 放大到屏幕尺寸，并居中
   * @param fit true，填满但完整展示；false，填满，但长边可能截取（即显示不完整）
   */
  fitView(fit = true, viewPadding = 10) {
    // 默认垂直填充，两边留白
    if (!this.hasView()) return;
    // 1. 重置画布尺寸为容器尺寸
    const {
      canvas
    } = this.canvas;
    const {
      offsetWidth: width,
      offsetHeight: height
    } = canvas;
    this.resize(width, height);
    // 2. 获取设置的留白值
    const padding = formatPadding(viewPadding);
    // 3. 获取图形尺寸
    const rect = this.getRect();
    // 4. 计算缩放比例
    const w = (width - padding[1] - padding[3]) / rect.width;
    const h = (height - padding[0] - padding[2]) / rect.height;
    let ratio = w;
    if (fit) {
      // 完整显示取小的
      ratio = w > h ? h : w;
    } else {
      ratio = w > h ? w : h;
    }
    if (this.store.data.fits?.length) {
      this.canvas.opening = true;
    }
    // 该方法直接更改画布的 scale 属性，所以比率应该乘以当前 scale
    this.scale(ratio * this.store.data.scale);
    // 5. 居中
    this.centerView();
    if (this.store.data.fits?.length) {
      this.fillView();
    }
  }
  fillView() {
    const rect = this.getRect();
    const wGap = this.canvas.width - rect.width;
    const hGap = this.canvas.height - rect.height;
    //宽度拉伸
    if (Math.abs(wGap) > 10) {
      this.store.data.fits?.forEach(fit => {
        let pens = [];
        fit.children.forEach(id => {
          this.store.pens[id].locked = LockState.None;
          pens.push(this.store.pens[id]);
        });
        let r = wGap / 2;
        if (fit.left && fit.right) {
          //整体拉伸
          let left = fit.leftValue;
          let right = fit.rightValue;
          if (left) {
            left = Math.abs(left) < 1 ? left * this.canvas.width : left;
          } else {
            left = 0;
          }
          if (right) {
            right = Math.abs(right) < 1 ? right * this.canvas.width : right;
          } else {
            right = 0;
          }
          let ratio = (this.canvas.width - left - right) / (rect.width - left - right);
          pens.forEach(pen => {
            if (pen.image && pen.imageRatio) {
              if (pen.calculative.worldRect.width / this.canvas.width > 0.1) {
                pen.imageRatio = false;
              }
            }
            pen.calculative.worldRect.x = rect.x - wGap / 2 + left + (pen.calculative.worldRect.x - rect.x) * ratio; //(fit.leftValue || 0)+ (pen.calculative.worldRect.x + pen.calculative.worldRect.width/2)-( pen.calculative.worldRect.width*ratio)*(range/2- (fit.rightValue || 0))/(range- (fit.leftValue || 0)-(fit.rightValue || 0));
            pen.calculative.worldRect.width *= ratio;
            pen.calculative.worldRect.ex = pen.calculative.worldRect.x + pen.calculative.worldRect.width;
            pen.calculative.width = pen.calculative.worldRect.width;
            pen.calculative.x = pen.calculative.worldRect.x;
            pen.width = pen.calculative.worldRect.width;
            pen.x = pen.calculative.worldRect.x;
            this.canvas.updatePenRect(pen, {
              worldRectIsReady: false
            });
            if (pen.externElement) {
              pen.onResize?.(pen);
            }
          });
        } else if (fit.left) {
          //左移
          r = -r;
          if (fit.leftValue) {
            r += Math.abs(fit.leftValue) < 1 ? fit.leftValue * this.canvas.width : fit.leftValue;
          }
          this.translatePens(pens, r, 0);
        } else if (fit.right) {
          //右移
          if (fit.rightValue) {
            r = r - (Math.abs(fit.rightValue) < 1 ? fit.rightValue * this.canvas.width : fit.rightValue);
          }
          this.translatePens(pens, r, 0);
        }
      });
      const iframePens = this.store.data.pens.filter(pen => pen.name === 'iframe');
      iframePens?.forEach(pen => {
        const worldRect = pen.calculative.worldRect;
        if (worldRect.width / this.store.data.scale > rect.width * 0.8) {
          let bfW = worldRect.width;
          pen.calculative.worldRect.x = worldRect.x - wGap / 2;
          pen.calculative.worldRect.width = worldRect.width + wGap;
          pen.calculative.worldRect.ex = worldRect.ex + wGap;
          pen.operationalRect.x = pen.operationalRect.x * bfW / pen.calculative.worldRect.width;
          pen.operationalRect.width = (pen.calculative.worldRect.width - (1 - pen.operationalRect.width) * bfW) / pen.calculative.worldRect.width;
          pen.onBeforeValue?.(pen, {
            operationalRect: pen.operationalRect
          });
          pen.onResize?.(pen);
        }
      });
    }
    //高度拉伸
    if (Math.abs(hGap) > 10) {
      this.store.data.fits?.forEach(fit => {
        let pens = [];
        fit.children.forEach(id => {
          this.store.pens[id].locked = LockState.None;
          pens.push(this.store.pens[id]);
        });
        let r = hGap / 2;
        if (fit.top && fit.bottom) {
          let top = fit.topValue;
          let bottom = fit.bottomValue;
          if (top) {
            top = Math.abs(top) < 1 ? top * this.canvas.height : top;
          } else {
            top = 0;
          }
          if (bottom) {
            bottom = Math.abs(bottom) < 1 ? bottom * this.canvas.height : bottom;
          } else {
            bottom = 0;
          }
          let ratio = (this.canvas.height - top - bottom) / (rect.height - top - bottom);
          pens.forEach(pen => {
            if (pen.image && pen.imageRatio) {
              if (pen.calculative.worldRect.height / this.canvas.height > 0.1) {
                pen.imageRatio = false;
              }
            }
            pen.calculative.worldRect.y = rect.y - hGap / 2 + top + (pen.calculative.worldRect.y - rect.y) * ratio; //(fit.leftValue || 0)+ (pen.calculative.worldRect.x + pen.calculative.worldRect.width/2)-( pen.calculative.worldRect.width*ratio)*(range/2- (fit.rightValue || 0))/(range- (fit.leftValue || 0)-(fit.rightValue || 0));
            pen.calculative.worldRect.height *= ratio;
            pen.calculative.worldRect.ey = pen.calculative.worldRect.y + pen.calculative.worldRect.height;
            pen.calculative.height = pen.calculative.worldRect.height;
            pen.calculative.y = pen.calculative.worldRect.y;
            pen.height = pen.calculative.worldRect.height;
            pen.y = pen.calculative.worldRect.y;
            this.canvas.updatePenRect(pen, {
              worldRectIsReady: false
            });
            if (pen.externElement) {
              pen.onResize?.(pen);
            }
          });
        } else if (fit.top) {
          r = -r;
          if (fit.topValue) {
            r += Math.abs(fit.topValue) < 1 ? fit.topValue * this.canvas.height : fit.topValue;
          }
          this.translatePens(pens, 0, r);
        } else if (fit.bottom) {
          if (fit.bottomValue) {
            r = r - (Math.abs(fit.bottomValue) < 1 ? fit.bottomValue * this.canvas.height : fit.bottomValue);
          }
          this.translatePens(pens, 0, r);
        }
      });
      const iframePens = this.store.data.pens.filter(pen => pen.name === 'iframe');
      iframePens?.forEach(pen => {
        const worldRect = pen.calculative.worldRect;
        if (worldRect.height / this.store.data.scale > rect.height * 0.8) {
          let bfH = worldRect.height;
          pen.calculative.worldRect.y = worldRect.y - hGap / 2;
          pen.calculative.worldRect.height = worldRect.height + hGap;
          pen.calculative.worldRect.ey = worldRect.ey + hGap;
          pen.operationalRect.y = pen.operationalRect.y * bfH / pen.calculative.worldRect.width;
          pen.operationalRect.height = (pen.calculative.worldRect.height - (1 - pen.operationalRect.height) * bfH) / pen.calculative.worldRect.height;
          pen.onBeforeValue?.(pen, {
            operationalRect: pen.operationalRect
          });
          pen.onResize?.(pen);
        }
      });
    }
    this.canvas.canvasTemplate.init();
    this.canvas.canvasImage.init();
    this.canvas.canvasImageBottom.init();
    this.render(true);
  }
  trimPens() {
    //去除空连线
    let pens = this.store.data.pens.filter(pen => pen.name === 'line' && pen.anchors.length < 2);
    this.delete(pens);
  }
  /**
   * 放大到屏幕尺寸，并居中
   * @param fit true，填满但完整展示；false，填满，但长边可能截取（即显示不完整）
   */
  fitTemplateView(fit = true, viewPadding = 10) {
    //  默认垂直填充，两边留白
    if (!this.hasView()) return;
    // 1. 重置画布尺寸为容器尺寸
    const {
      canvas
    } = this.canvas;
    const {
      offsetWidth: width,
      offsetHeight: height
    } = canvas;
    // 2. 获取设置的留白值
    const padding = formatPadding(viewPadding);
    // 3. 获取图形尺寸
    const rect = this.getRect();
    // 4. 计算缩放比例
    const w = (width - padding[1] - padding[3]) / rect.width;
    const h = (height - padding[0] - padding[2]) / rect.height;
    let ratio = w;
    if (fit) {
      // 完整显示取小的
      ratio = w > h ? h : w;
    } else {
      ratio = w > h ? w : h;
    }
    // 该方法直接更改画布的 scale 属性，所以比率应该乘以当前 scale
    this.canvas.templateScale(ratio * this.store.data.scale);
    let _rect = this.getRect();
    let pens = this.store.data.pens.filter(pen => !pen.parentId);
    this.canvas.templateTranslatePens(pens, -_rect.x, -_rect.y);
    // 5. 居中
    this.store.data.pens.forEach(pen => {
      if (!pen.type) {
        this.canvas.updateLines(pen);
      } else {
        this.canvas.initLineRect(pen);
      }
    });
    this.centerView();
  }
  fitSizeView(fit = true, viewPadding = 10) {
    // 默认垂直填充，两边留白
    // if (!this.hasView()) return;
    // 1. 重置画布尺寸为容器尺寸
    const {
      canvas
    } = this.canvas;
    const {
      offsetWidth: width,
      offsetHeight: height
    } = canvas;
    this.resize(width, height);
    // 2. 获取设置的留白值
    const padding = formatPadding(viewPadding);
    const _width = (this.store.data.width || this.store.options.width) * this.store.data.scale;
    const _height = (this.store.data.height || this.store.options.height) * this.store.data.scale;
    // 4. 计算缩放比例
    const w = (width - padding[1] - padding[3]) / _width;
    const h = (height - padding[0] - padding[2]) / _height;
    let ratio = w;
    if (fit === 'width') {
      ratio = w;
    } else if (fit === 'height') {
      ratio = h;
    } else {
      if (fit) {
        // 完整显示取小的
        ratio = w > h ? h : w;
      } else {
        ratio = w > h ? w : h;
      }
    }
    if (this.store.data.fits?.length) {
      this.canvas.opening = true;
    }
    // 该方法直接更改画布的 scale 属性，所以比率应该乘以当前 scale
    this.scale(ratio * this.store.data.scale);
    // 5. 居中
    this.centerSizeView();
    if (this.store.data.fits?.length) {
      this.fillView();
    }
  }
  centerSizeView() {
    // if (!this.hasView()) return;
    const viewCenter = this.getViewCenter();
    //根据画布尺寸居中对齐
    const _width = this.store.data.width || this.store.options.width;
    const _height = this.store.data.height || this.store.options.height;
    const pensRect = {
      x: 0,
      y: 0,
      width: _width,
      height: _height
    };
    calcCenter(pensRect);
    const {
      center
    } = pensRect;
    const {
      scale,
      origin,
      x: dataX,
      y: dataY
    } = this.store.data;
    this.translate((viewCenter.x - origin.x) / scale - center.x - dataX / scale, (viewCenter.y - origin.y) / scale - center.y - dataY / scale);
    const {
      canvas
    } = this.canvas;
    const x = (canvas.scrollWidth - canvas.offsetWidth) / 2;
    const y = (canvas.scrollHeight - canvas.offsetHeight) / 2;
    canvas.scrollTo(x, y);
  }
  /**
   * 宽度放大到屏幕尺寸，并滚动到最顶部
   *
   */
  scrollView(viewPadding = 10, pageMode = false) {
    if (!this.hasView()) return;
    //滚动状态下
    if (!this.canvas.scroll) {
      return;
    }
    const {
      canvas
    } = this.canvas;
    const {
      offsetWidth: width,
      offsetHeight: height
    } = canvas;
    this.resize(width, height);
    const padding = formatPadding(viewPadding);
    const rect = this.getRect();
    const ratio = (width - padding[1] - padding[3]) / rect.width;
    this.scale(ratio * this.store.data.scale);
    this.topView(padding[0]);
    if (pageMode) {
      this.canvas.scroll.changeMode();
    }
  }
  screenView(viewPadding = 10, WorH = true) {
    if (!this.hasView()) return;
    const {
      canvas
    } = this.canvas;
    const {
      offsetWidth: width,
      offsetHeight: height
    } = canvas;
    this.resize(width, height);
    const padding = formatPadding(viewPadding);
    const rect = this.getRect();
    //默认宽度充满
    let ratio = (width - padding[1] - padding[3]) / rect.width;
    if (!WorH) {
      ratio = (height - padding[0] - padding[2]) / rect.height;
    }
    this.scale(ratio * this.store.data.scale);
    //height充满时是居中
    this.topView(padding[0]);
  }
  topView(paddingTop = 10) {
    if (!this.hasView()) return;
    const rect = this.getRect();
    const viewCenter = this.getViewCenter();
    const pensRect = this.getPenRect(rect);
    calcCenter(pensRect);
    const {
      center
    } = pensRect;
    const {
      scale,
      origin,
      x: dataX,
      y: dataY
    } = this.store.data;
    this.translate((viewCenter.x - origin.x) / scale - center.x - dataX / scale, (paddingTop - origin.y) / scale - pensRect.y - dataY / scale);
    const {
      canvas
    } = this.canvas;
    const x = (canvas.scrollWidth - canvas.offsetWidth) / 2;
    const y = (canvas.scrollHeight - canvas.offsetHeight) / 2;
    canvas.scrollTo(x, y);
  }
  centerView() {
    if (!this.hasView()) return;
    const rect = this.getRect();
    const viewCenter = this.getViewCenter();
    const pensRect = this.getPenRect(rect);
    calcCenter(pensRect);
    const {
      center
    } = pensRect;
    const {
      scale,
      origin,
      x: dataX,
      y: dataY
    } = this.store.data;
    // center 的值，在缩放和拖拽画布过程中不发生变化，是相对值
    // viewCenter 是一个绝对值，需要根据 origin 的值，来计算出相对的值
    // store.data.x 是画布偏移值，在 translate 方法中与 scale 相关，这里也需要计算
    this.translate((viewCenter.x - origin.x) / scale - center.x - dataX / scale, (viewCenter.y - origin.y) / scale - center.y - dataY / scale);
    const {
      canvas
    } = this.canvas;
    const x = (canvas.scrollWidth - canvas.offsetWidth) / 2;
    const y = (canvas.scrollHeight - canvas.offsetHeight) / 2;
    canvas.scrollTo(x, y);
  }
  /**
   * 画布是否有 画笔
   * RuleLine 不算
   */
  hasView() {
    return !!this.store.data.pens.filter(pen => !pen.isRuleLine).length;
  }
  getViewCenter() {
    const {
      width,
      height
    } = this.canvas;
    return {
      x: width / 2,
      y: height / 2
    };
  }
  /**
   * 大小相同
   * @param pens 画笔们
   */
  beSameByFirst(pens = this.store.data.pens, attribute) {
    const initPens = deepClone(pens); // 原 pens ，深拷贝一下
    // 1. 得到第一个画笔的 宽高
    const firstPen = pens[0];
    const {
      width,
      height
    } = this.getPenRect(firstPen);
    for (let i = 1; i < pens.length; i++) {
      const pen = pens[i];
      if (attribute === 'width') {
        this.setValue({
          id: pen.id,
          width
        }, {
          render: false,
          doEvent: false
        });
      } else if (attribute === 'height') {
        this.setValue({
          id: pen.id,
          height
        }, {
          render: false,
          doEvent: false
        });
      } else {
        this.setValue({
          id: pen.id,
          width,
          height
        }, {
          render: false,
          doEvent: false
        });
      }
    }
    this.render();
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens
    });
  }
  /**
   * 大小相同
   * @param pens 画笔们
   */
  beSameByLast(pens = this.store.data.pens, attribute) {
    const initPens = deepClone(pens); // 原 pens ，深拷贝一下
    // 1. 得到最后一个画笔的 宽高
    const lastPen = pens[pens.length - 1];
    const {
      width,
      height
    } = this.getPenRect(lastPen);
    for (let i = 0; i < pens.length - 1; i++) {
      const pen = pens[i];
      if (attribute === 'width') {
        this.setValue({
          id: pen.id,
          width
        }, {
          render: false,
          doEvent: false
        });
      } else if (attribute === 'height') {
        this.setValue({
          id: pen.id,
          height
        }, {
          render: false,
          doEvent: false
        });
      } else {
        this.setValue({
          id: pen.id,
          width,
          height
        }, {
          render: false,
          doEvent: false
        });
      }
    }
    this.render();
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens
    });
  }
  /**
   * 格式刷（样式相同，大小无需一致。）
   * @param pens 画笔们
   */
  formatPainterByFirst(pens = this.store.data.pens) {
    const initPens = deepClone(pens); // 原 pens ，深拷贝一下
    const firstPen = pens[0];
    // 格式刷修改的属性，除开宽高
    const attrs = {};
    formatAttrs.forEach(attr => {
      attrs[attr] = firstPen[attr];
    });
    for (let i = 1; i < pens.length; i++) {
      const pen = pens[i];
      this.setValue({
        id: pen.id,
        ...attrs
      }, {
        render: false,
        doEvent: false
      });
    }
    this.render();
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens
    });
  }
  /**
   * 格式刷（样式相同，大小无需一致。）
   * @param pens 画笔们
   */
  formatPainterByLast(pens = this.store.data.pens) {
    const initPens = deepClone(pens); // 原 pens ，深拷贝一下
    const firstPen = pens[pens.length - 1];
    // 格式刷修改的属性，除开宽高
    const attrs = {};
    formatAttrs.forEach(attr => {
      attrs[attr] = firstPen[attr];
    });
    for (let i = 0; i < pens.length - 1; i++) {
      const pen = pens[i];
      this.setValue({
        id: pen.id,
        ...attrs
      }, {
        render: false,
        doEvent: false
      });
    }
    this.render();
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens
    });
  }
  setFormatPainter() {
    const pens = this.store.active;
    const attrs = {};
    if (pens.length > 0) {
      const firstPen = pens[0];
      formatAttrs.forEach(attr => {
        attrs[attr] = firstPen[attr] !== undefined ? firstPen[attr] : this.store.options.defaultFormat[attr] || this.store.options[attr];
      });
    } else {
      //默认值
      const attrs = {};
      formatAttrs.forEach(attr => {
        attrs[attr] = this.store.options.defaultFormat[attr] || this.store.options[attr] || undefined;
      });
    }
    localStorage.setItem('meta2d-formatPainter', JSON.stringify(attrs));
  }
  formatPainter() {
    const pens = this.store.active;
    const initPens = deepClone(pens);
    const attrs = JSON.parse(localStorage.getItem('meta2d-formatPainter'));
    for (let i = 0; i < pens.length; i++) {
      const pen = pens[i];
      this.setValue({
        id: pen.id,
        ...attrs
      }, {
        render: false,
        doEvent: false
      });
    }
    this.render();
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens
    });
  }
  clearFormatPainter() {
    const pens = this.store.active;
    const initPens = deepClone(pens);
    formatAttrs.forEach(attr => {
      for (let i = 0; i < pens.length; i++) {
        const pen = pens[i];
        const {
          fontSize,
          lineHeight
        } = this.store.options;
        if (attr === 'lineWidth') {
          pen.lineWidth = 1;
          pen.calculative.lineWidth = 1;
        } else if (attr === 'fontSize') {
          pen.fontSize = fontSize;
          pen.calculative.fontSize = fontSize;
        } else if (attr === 'lineHeight') {
          pen.lineHeight = lineHeight;
          pen.calculative.lineHeight = lineHeight;
        } else {
          delete pen[attr];
          delete pen.calculative[attr];
        }
      }
    });
    this.render();
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens
    });
  }
  alignNodes(align, pens = this.store.data.pens, rect) {
    !rect && (rect = this.getPenRect(this.getRect(pens)));
    const initPens = deepClone(pens); // 原 pens ，深拷贝一下
    for (const item of pens) {
      this.alignPen(align, item, rect);
    }
    this.initImageCanvas(pens);
    this.initTemplateCanvas(pens);
    this.render();
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens
    });
  }
  //对齐大屏
  alignNodesV(align, pens = this.store.data.pens) {
    const width = this.store.data.width || this.store.options.width;
    const height = this.store.data.height || this.store.options.height;
    let rect = {
      x: 0,
      y: 0,
      width,
      height
    };
    const initPens = deepClone(pens); // 原 pens ，深拷贝一下
    for (const item of pens) {
      this.alignPen(align, item, rect);
    }
    this.initImageCanvas(pens);
    this.initTemplateCanvas(pens);
    this.render();
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens
    });
  }
  /**
   * 对齐画笔，基于第一个画笔
   * @param align 左对齐，右对齐，上对齐，下对齐，居中对齐
   * @param pens
   */
  alignNodesByFirst(align, pens = this.store.data.pens) {
    const initPens = deepClone(pens); // 原 pens ，深拷贝一下
    const firstPen = pens[0];
    const rect = this.getPenRect(firstPen);
    for (let i = 1; i < pens.length; i++) {
      const pen = pens[i];
      this.alignPen(align, pen, rect);
    }
    this.initImageCanvas(pens);
    this.initTemplateCanvas(pens);
    this.render();
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens
    });
  }
  /**
   * 对齐画笔，基于最后选中的画笔
   * @param align 左对齐，右对齐，上对齐，下对齐，居中对齐
   * @param pens
   */
  alignNodesByLast(align, pens = this.store.data.pens) {
    const initPens = deepClone(pens); // 原 pens ，深拷贝一下
    const lastPen = pens[pens.length - 1];
    const rect = this.getPenRect(lastPen);
    for (let i = 0; i < pens.length - 1; i++) {
      const pen = pens[i];
      this.alignPen(align, pen, rect);
    }
    this.initImageCanvas(pens);
    this.initTemplateCanvas(pens);
    this.render();
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens
    });
  }
  /**
   * 将画笔参照 rect 进行 align 对齐
   * @param align 左对齐，右对齐，上对齐，下对齐，居中对齐
   * @param pen 当前需要对齐的画笔
   * @param rect 参照矩形
   * @returns
   */
  alignPen(align, pen, rect) {
    const penRect = this.getPenRect(pen);
    switch (align) {
      case 'left':
        penRect.x = rect.x;
        break;
      case 'right':
        penRect.x = rect.x + rect.width - penRect.width;
        break;
      case 'top':
        penRect.y = rect.y;
        break;
      case 'bottom':
        penRect.y = rect.y + rect.height - penRect.height;
        break;
      case 'center':
        penRect.x = rect.x + rect.width / 2 - penRect.width / 2;
        break;
      case 'middle':
        penRect.y = rect.y + rect.height / 2 - penRect.height / 2;
        break;
    }
    this.setValue({
      id: pen.id,
      ...penRect
    }, {
      render: false,
      doEvent: false
    });
  }
  /**
   * 水平或垂直方向的均分
   * @param direction 方向，width 说明水平方向间距相同
   * @param pens 节点们，默认全部的
   * @param distance 总的宽 or 高
   */
  spaceBetweenByDirection(direction, pens = this.store.data.pens, distance) {
    //TODO 暂时修复，待优化
    // !distance && (distance = this.getPenRect(this.getRect(pens))[direction]);
    if (!distance) {
      let start = Infinity,
        end = -Infinity,
        key = direction === 'width' ? 'x' : 'y';
      pens.forEach(item => {
        start = Math.min(start, item.calculative.worldRect[key]);
        end = Math.max(end, item.calculative.worldRect['e' + key]);
      });
      distance = (end - start) / this.store.data.scale;
    }
    // 过滤出非父节点
    pens = pens.filter(item => !item.parentId);
    if (pens.length <= 2) {
      return;
    }
    const initPens = deepClone(pens); // 原 pens ，深拷贝一下
    // 计算间距
    const allDistance = pens.reduce((distance, currentPen) => {
      const currentPenRect = this.getPenRect(currentPen);
      return distance + currentPenRect[direction];
    }, 0);
    const space = (distance - allDistance) / (pens.length - 1);
    // 按照大小顺序排列画笔
    pens = pens.sort((a, b) => {
      if (direction === 'width') {
        return a.x - b.x;
      }
      return a.y - b.y;
    });
    const pen0Rect = this.getPenRect(pens[0]);
    let left = direction === 'width' ? pen0Rect.x : pen0Rect.y;
    for (const pen of pens) {
      const penRect = this.getPenRect(pen);
      direction === 'width' ? penRect.x = left : penRect.y = left;
      left += penRect[direction] + space;
      this.setValue({
        id: pen.id,
        ...penRect
      }, {
        render: false,
        doEvent: false
      });
    }
    this.initImageCanvas(pens);
    this.initTemplateCanvas(pens);
    this.render();
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens
    });
  }
  spaceBetween(pens, width) {
    this.spaceBetweenByDirection('width', pens, width);
  }
  spaceBetweenColumn(pens, height) {
    this.spaceBetweenByDirection('height', pens, height);
  }
  layout(pens = this.store.data.pens, width, space = 30) {
    const rect = this.getPenRect(getRect(pens));
    !width && (width = rect.width);
    // 1. 拿到全部节点中最大的高
    pens = pens.filter(item => !item.type && !item.parentId);
    const initPens = deepClone(pens); // 原 pens ，深拷贝一下
    let maxHeight = 0;
    pens.forEach(pen => {
      const penRect = this.getPenRect(pen);
      penRect.height > maxHeight && (maxHeight = penRect.height);
    });
    // 2. 遍历节点调整位置
    let currentX = rect.x;
    let currentY = rect.y;
    pens.forEach((pen, index) => {
      const penRect = this.getPenRect(pen);
      penRect.x = currentX;
      penRect.y = currentY + maxHeight / 2 - penRect.height / 2;
      this.setValue({
        id: pen.id,
        ...penRect
      }, {
        render: false,
        doEvent: false
      });
      if (index === pens.length - 1) {
        return;
      }
      const currentWidth = currentX + penRect.width - rect.x;
      const nextPenRect = this.getPenRect(pens[index + 1]);
      if (Math.round(width - currentWidth) >= Math.round(nextPenRect.width + space))
        // 当前行
        currentX += penRect.width + space;else {
        // 换行
        currentX = rect.x;
        currentY += maxHeight + space;
      }
    });
    this.initImageCanvas(pens);
    this.initTemplateCanvas(pens);
    this.render();
    this.pushHistory({
      type: EditType.Update,
      initPens,
      pens
    });
  }
  gotoView(pen) {
    const center = this.getViewCenter();
    const x = center.x - pen.calculative.worldRect.x - pen.calculative.worldRect.width / 2;
    const y = center.y - pen.calculative.worldRect.y - pen.calculative.worldRect.height / 2;
    if (this.canvas.scroll && this.canvas.scroll.isShow) {
      this.canvas.scroll.translate(x - this.store.data.x, y - this.store.data.y);
    }
    this.store.data.x = x;
    this.store.data.y = y;
    for (const pen of this.store.data.pens) {
      calcInView(pen);
    }
    this.canvas.canvasImage.init();
    this.canvas.canvasImageBottom.init();
    this.render();
  }
  showMap() {
    if (!this.map) {
      this.map = new ViewMap(this.canvas);
    }
    this.map.show();
  }
  hideMap() {
    this.map.hide();
  }
  onSizeUpdate() {
    if (this.mapTimer) {
      clearTimeout(this.mapTimer);
      this.mapTimer = undefined;
    }
    this.mapTimer = setTimeout(() => {
      if (this.map && this.map.isShow) {
        this.map.show();
      }
      if (this.canvas.scroll && this.canvas.scroll.isShow) {
        this.canvas.scroll.resize();
      }
    }, 500);
  }
  toggleAnchorMode() {
    this.canvas.toggleAnchorMode();
  }
  addAnchorHand() {
    this.canvas.addAnchorHand();
  }
  removeAnchorHand() {
    this.canvas.removeAnchorHand();
  }
  toggleAnchorHand() {
    this.canvas.toggleAnchorHand();
  }
  /**
   * 将该画笔置顶，即放到数组最后，最后绘制即在顶部
   * @param pens pen 置顶的画笔
   */
  top(pens) {
    if (!pens) pens = this.store.active;
    if (!Array.isArray(pens)) pens = [pens]; // 兼容
    for (const pen of pens) {
      const _pens = this.store.data.pens;
      // 获取它包含它的子节点
      const allIds = [...getAllChildren(pen, this.store), pen].map(p => p.id);
      const allPens = _pens.filter(p => allIds.includes(p.id));
      allPens.forEach(pen => {
        const index = _pens.findIndex(p => p.id === pen.id);
        if (index > -1) {
          _pens.push(_pens[index]);
          _pens.splice(index, 1);
          this.initTemplateCanvas([pen]);
          this.initImageCanvas([pen]);
        }
        this.specificLayerMove(pen, 'top');
      });
    }
    this.store.emitter.emit('layer', {
      type: 'top',
      pens
    });
  }
  /**
   * 若本次改变的画笔存在图片，并且在上层 or 下层，需要擦除上层 or 下层
   * 子节点中包含图片，也需要重绘
   * @param pens 本次改变的 pens
   */
  initImageCanvas(pens) {
    this.canvas.initImageCanvas(pens);
  }
  /**
   * 模版图元图层改变
   * @param pens 本次改变的 pens
   */
  initTemplateCanvas(pens) {
    this.canvas.initTemplateCanvas(pens);
  }
  /**
   * 该画笔置底，即放到数组最前，最后绘制即在底部
   * @param pens 画笔们，注意 pen 必须在该数组内才有效
   */
  bottom(pens) {
    if (!pens) pens = this.store.active;
    if (!Array.isArray(pens)) pens = [pens]; // 兼容
    for (const pen of pens) {
      const _pens = this.store.data.pens;
      const allIds = [...getAllChildren(pen, this.store), pen].map(p => p.id);
      const allPens = _pens.filter(p => allIds.includes(p.id));
      // 从后往前，保证 allPens 顺序不变
      for (let i = allPens.length - 1; i >= 0; i--) {
        const pen = allPens[i];
        const index = _pens.findIndex(p => p.id === pen.id);
        if (index > -1) {
          _pens.unshift(_pens[index]);
          _pens.splice(index + 1, 1);
          this.initTemplateCanvas([pen]);
          this.initImageCanvas([pen]);
        }
        this.specificLayerMove(pen, 'bottom');
      }
    }
    this.store.emitter.emit('layer', {
      type: 'bottom',
      pens
    });
  }
  /**
   * data.pens 决定了绘制顺序，即越后面的越在上层
   * 该方法通过区域重叠计算，找出该画笔之后第一个与其重叠的画笔，然后把该画笔放到找出的画笔之后
   * @param pen 画笔
   */
  upByArea(pen) {
    const index = this.store.data.pens.findIndex(p => p.id === pen.id);
    if (index === -1) {
      // 画笔不在画布上，不处理
      console.warn('upByArea: pen not in canvas');
      return;
    }
    const allPens = [pen, ...getAllChildren(pen, this.store)];
    let allIndexs = allPens.map(p => this.store.data.pens.findIndex(p2 => p2.id === p.id));
    if (allIndexs.includes(-1)) {
      // 画笔不在画布上，脏数据
      console.warn('upByArea: pen children not in canvas');
      allIndexs = allIndexs.filter(i => i !== -1);
    }
    const minIndex = Math.min(...allIndexs);
    const penRect = pen.calculative.worldRect;
    const nextHitIndex = this.store.data.pens.findIndex((p, i) => {
      if (i <= minIndex) {
        // 不考虑前面的
        return false;
      }
      if (p.id === pen.id || isAncestor(p, pen)) {
        // 不考虑后代和自身
        return false;
      }
      const currentRect = p.calculative.worldRect;
      return rectInRect(penRect, currentRect);
    });
    if (nextHitIndex === -1) {
      this.up(pen);
      return;
    }
    this.store.data.pens.splice(nextHitIndex + 1, 0, ...allPens);
    // 删除靠前的 allPens
    for (const pen of allPens) {
      const index = this.store.data.pens.findIndex(p => p.id === pen.id);
      if (index > -1) {
        this.store.data.pens.splice(index, 1);
      }
    }
    this.initImageCanvas([pen]);
  }
  //特殊图元层级处理
  specificLayerMove(pen, type) {
    //image
    if (pen.image && pen.name !== 'gif') {
      // let isBottom = false;
      // if (type === 'bottom' || type === 'down') {
      //   isBottom = true;
      // }
      // this.setValue(
      //   { id: pen.id, isBottom },
      //   { render: false, doEvent: false, history: false }
      // );
      let layer = CanvasLayer.CanvasImageBottom;
      if (type === 'top') {
        layer = CanvasLayer.CanvasImage;
      } else if (type === 'up' || type === 'down') {
        layer = CanvasLayer.CanvasMain;
      }
      this.setValue({
        id: pen.id,
        canvasLayer: layer
      }, {
        render: false,
        doEvent: false,
        history: false
      });
    } else if (pen.externElement || pen.name === 'gif') {
      let zIndex = 0;
      // let zIndex = pen.calculative.zIndex === undefined ? 5 : pen.calculative.zIndex + 1;
      if (type === 'top') {
        pen.calculative.canvas.maxZindex += 1;
        zIndex = pen.calculative.canvas.maxZindex;
      } else if (type === 'up') {
        zIndex = pen.calculative.zIndex === undefined ? 6 : pen.calculative.zIndex + 1;
      } else if (type === 'down') {
        zIndex = pen.calculative.zIndex === undefined ? 3 : pen.calculative.zIndex - 1;
        if (zIndex < 0) {
          zIndex = 0;
        }
      }
      this.setValue({
        id: pen.id,
        zIndex
      }, {
        render: false,
        doEvent: false,
        history: false
      });
      pen.calculative.singleton?.div && render_setElemPosition(pen, pen.calculative.singleton.div);
    }
  }
  /**
   * 该画笔上移，即把该画笔在数组中的位置向后移动一个
   * @param pens 画笔
   */
  up(pens) {
    if (!pens) pens = this.store.active;
    if (!Array.isArray(pens)) pens = [pens]; // 兼容
    for (const pen of pens) {
      const _pens = this.store.data.pens;
      if (pen.children && pen.children.length) {
        //组合图元
        const preMovePens = [...getAllChildren(pen, this.store), pen];
        //先保证组合图元的顺序正确。
        const orderPens = [];
        for (let index = 0; index < _pens.length; index++) {
          const _pen = _pens[index];
          if (preMovePens.findIndex(p => p.id === _pen.id) !== -1) {
            _pen.temIndex = index;
            orderPens.push(_pen);
          }
        }
        let lastIndex = -1;
        let offset = 0;
        orderPens.forEach(_pen => {
          _pen.temIndex -= offset;
          _pens.splice(_pen.temIndex, 1);
          offset += 1;
          lastIndex = _pen.temIndex;
          delete _pen.temIndex;
          this.specificLayerMove(_pen, 'up');
        });
        _pens.splice(lastIndex + 1, 0, ...orderPens);
        this.initTemplateCanvas(orderPens);
        this.initImageCanvas(orderPens);
      } else {
        const index = _pens.findIndex(p => p.id === pen.id);
        if (index > -1 && index !== _pens.length - 1) {
          _pens.splice(index + 2, 0, _pens[index]);
          _pens.splice(index, 1);
          this.initTemplateCanvas([pen]);
          this.initImageCanvas([pen]);
        }
        this.specificLayerMove(pen, 'up');
      }
    }
    this.store.emitter.emit('layer', {
      type: 'up',
      pens
    });
  }
  /**
   * 该画笔下移，即把该画笔在该数组中的位置前移一个
   * @param pen 画笔
   */
  down(pens) {
    if (!pens) pens = this.store.active;
    if (!Array.isArray(pens)) pens = [pens]; // 兼容
    for (const pen of pens) {
      const _pens = this.store.data.pens;
      if (pen.children && pen.children.length) {
        //组合图元
        const preMovePens = [...getAllChildren(pen, this.store), pen];
        //先保证组合图元的顺序正确。
        const orderPens = [];
        for (let index = 0; index < _pens.length; index++) {
          const _pen = _pens[index];
          if (preMovePens.findIndex(p => p.id === _pen.id) !== -1) {
            _pen.temIndex = index;
            orderPens.push(_pen);
          }
        }
        let firstIndex = -1;
        let offset = 0;
        orderPens.forEach((_pen, index) => {
          _pen.temIndex -= offset;
          _pens.splice(_pen.temIndex, 1);
          offset += 1;
          if (index === 0) {
            firstIndex = _pen.temIndex;
          }
          delete _pen.temIndex;
          this.specificLayerMove(_pen, 'down');
        });
        _pens.splice(firstIndex - 1, 0, ...orderPens);
        this.initTemplateCanvas(orderPens);
        this.initImageCanvas(orderPens);
      } else {
        const index = _pens.findIndex(p => p.id === pen.id);
        if (index > -1 && index !== 0) {
          _pens.splice(index - 1, 0, _pens[index]);
          _pens.splice(index + 1, 1);
          this.initTemplateCanvas([pen]);
          this.initImageCanvas([pen]);
        }
        this.specificLayerMove(pen, 'down');
      }
    }
    this.store.emitter.emit('layer', {
      type: 'down',
      pens
    });
  }
  setLayer(pen, toIndex, pens = this.store.data.pens) {
    const index = pens.findIndex(p => p.id === pen.id);
    if (index > -1) {
      if (index > toIndex) {
        // 原位置在后，新位置在前
        pens.splice(toIndex, 0, pens[index]);
        pens.splice(index + 1, 1);
      } else if (index < toIndex) {
        // 新位置在后
        pens.splice(toIndex, 0, pens[index]);
        pens.splice(index, 1);
      }
    }
  }
  changePenId(oldId, newId) {
    this.canvas.changePenId(oldId, newId);
  }
  /**
   * 得到与当前节点连接的线
   * @param node 节点，非连线
   * @param type 类型，全部的连接线/入线/出线
   */
  getLines(node, type = 'all') {
    if (node.type === PenType.Line) {
      return [];
    }
    const lines = [];
    node.connectedLines?.forEach(({
      lineId
    }) => {
      const line = this.store.pens[lineId];
      if (!line) {
        console.warn(node, 'node contain a error connectedLine');
        return;
      }
      if (lines.find(_line => _line.id === line.id)) {
        //去重
        return;
      }
      switch (type) {
        case 'all':
          lines.push(line);
          break;
        case 'in':
          // 进入该节点的线，即 线锚点的最后一个 connectTo 对应该节点
          getToAnchor(line).connectTo === node.id && lines.push(line);
          break;
        case 'out':
          // 从该节点出去的线，即 线锚点的第一个 connectTo 对应该节点
          getFromAnchor(line).connectTo === node.id && lines.push(line);
          break;
      }
    });
    return lines;
  }
  /**
   * 得到当前节点的下一个节点，即出口节点数组
   * 得到当前连线的出口节点
   * @param pen 节点或连线
   */
  nextNode(pen) {
    if (pen.type === PenType.Line) {
      const nextNode = this.store.pens[getToAnchor(pen).connectTo];
      return nextNode ? [nextNode] : [];
    } else {
      // 1. 得到所有的出线
      const lines = this.getLines(pen, 'out');
      const nextNodes = [];
      // 2. 遍历出线的 nextNode
      lines.forEach(line => {
        const lineNextNode = this.nextNode(line);
        for (const node of lineNextNode) {
          const have = nextNodes.find(next => next.id === node.id);
          // 3. 不重复的才加进去
          !have && nextNodes.push(node);
        }
      });
      return nextNodes;
    }
  }
  /**
   * 得到当前节点的上一个节点，即入口节点数组
   * 得到当前连线的入口节点
   * @param pen 节点或连线
   */
  previousNode(pen) {
    if (pen.type === PenType.Line) {
      const preNode = this.store.pens[getFromAnchor(pen).connectTo];
      return preNode ? [preNode] : [];
    } else {
      // 1. 得到所有的入线
      const lines = this.getLines(pen, 'in');
      const preNodes = [];
      // 2. 遍历入线的 preNode
      lines.forEach(line => {
        const linePreNode = this.previousNode(line);
        for (const node of linePreNode) {
          const have = preNodes.find(pre => pre.id === node.id);
          // 3. 不重复的才加进去
          !have && preNodes.push(node);
        }
      });
      return preNodes;
    }
  }
  /**
   * 获取节点所有的下一个连接关系
   * @param pen
   *
   */
  getNext(pen) {
    if (pen.type === PenType.Line) {
      console.warn('非连线节点');
      return;
    }
    const next = [];
    pen.connectedLines?.forEach(({
      lineId,
      anchor
    }) => {
      const fromAnchor = pen.anchors?.filter(_anchor => _anchor.id === anchor)[0];
      const line = this.findOne(lineId);
      if (line.anchors[0].connectTo == pen.id) {
        //from
        const connectTo = line.anchors[line.anchors.length - 1].connectTo;
        if (connectTo) {
          const _next = this.findOne(connectTo);
          const connectedLine = _next.connectedLines?.filter(item => item.lineId === line.id)[0];
          const penAnchor = _next.anchors.filter(_anchor => _anchor.id === connectedLine.anchor)[0];
          next.push({
            from: pen,
            fromAnchor,
            line,
            to: _next,
            toAnchor: penAnchor
          });
        }
      }
    });
    return next;
  }
  /**
   * 为画布添加锚点
   * @param pen 画笔
   * @param anchor 待添加锚点
   * @param index 连线类型 添加锚点到哪个位置
   */
  addAnchor(pen, anchor, index) {
    if (!pen) {
      return;
    }
    if (!pen.anchors) {
      pen.anchors = [];
    }
    if (!pen.calculative.worldAnchors) {
      pen.calculative.worldAnchors = [];
    }
    if (pen.type === PenType.Line) {
      if (index < 0) {
        index = pen.anchors.length + 1 + index;
      }
      if (index > pen.anchors.length) {
        index = pen.anchors.length;
      }
      if (index < 0) {
        index = 0;
      }
      if (index == 0 && pen.anchors[0].connectTo || index == pen.anchors.length && pen.anchors[index - 1].connectTo) {
        console.warn('端点存在连接关系');
        return;
      }
    }
    let _anchor = null;
    let _worldAnchor = null;
    if (anchor.x <= 1 && anchor.x >= 0 && anchor.y <= 1 && anchor.y >= 0) {
      //relative
      _worldAnchor = {
        id: anchor.id || s8(),
        penId: pen.id,
        x: pen.calculative.worldRect.x + pen.calculative.worldRect.width * anchor.x,
        y: pen.calculative.worldRect.y + pen.calculative.worldRect.height * anchor.y
      };
      if (pen.calculative.worldRect) {
        if (pen.rotate % 360) {
          rotatePoint(_worldAnchor, pen.rotate, pen.calculative.worldRect.center);
        }
      }
      _anchor = {
        id: _worldAnchor.id,
        penId: pen.id,
        x: anchor.x,
        y: anchor.y
      };
    } else {
      //absolute
      _worldAnchor = {
        id: anchor.id || s8(),
        penId: pen.id,
        x: anchor.x,
        y: anchor.y
      };
      if (pen.calculative.worldRect) {
        if (pen.rotate % 360) {
          rotatePoint(anchor, -pen.rotate, pen.calculative.worldRect.center);
        }
        _anchor = {
          id: _worldAnchor.id,
          penId: pen.id,
          x: (anchor.x - pen.calculative.worldRect.x) / pen.calculative.worldRect.width,
          y: (anchor.y - pen.calculative.worldRect.y) / pen.calculative.worldRect.height
        };
      }
    }
    if (pen.type === PenType.Line) {
      //Line
      pen.calculative.worldAnchors.splice(index, 0, _worldAnchor);
      pen.anchors.splice(index, 0, _anchor);
      this.canvas.updateLines(pen);
      this.canvas.initLineRect(pen);
      this.render();
    } else {
      //Node
      pen.calculative.worldAnchors.push(_worldAnchor);
      pen.anchors.push(_anchor);
    }
  }
  /**
   *
   * @param from 连接节点
   * @param fromAnchor 连接节点锚点
   * @param to 被连接节点
   * @param toAnchor 被连接节点锚点
   */
  connectLine(from, to, fromAnchor, toAnchor, render = true) {
    if (!fromAnchor) {
      const _worldRect = to.calculative.worldRect;
      fromAnchor = nearestAnchor(from, {
        x: _worldRect.x + _worldRect.width / 2,
        y: _worldRect.y + _worldRect.height / 2
      });
    }
    if (!toAnchor) {
      const _worldRect = from.calculative.worldRect;
      toAnchor = nearestAnchor(to, {
        x: _worldRect.x + _worldRect.width / 2,
        y: _worldRect.y + _worldRect.height / 2
      });
    }
    const absWidth = Math.abs(fromAnchor.x - toAnchor.x);
    const absHeight = Math.abs(fromAnchor.y - toAnchor.y);
    const line = {
      height: absHeight,
      lineName: 'line',
      lineWidth: 1,
      name: 'line',
      type: 1,
      width: absWidth,
      x: Math.min(fromAnchor.x, toAnchor.x),
      y: Math.min(fromAnchor.y, toAnchor.y),
      anchors: [{
        x: fromAnchor.x > toAnchor.x ? 1 : 0,
        y: fromAnchor.y > toAnchor.y ? 1 : 0,
        id: s8()
      }, {
        x: fromAnchor.x > toAnchor.x ? 0 : 1,
        y: fromAnchor.x > toAnchor.x ? 0 : 1,
        id: s8()
      }]
    };
    this.addPens([line]);
    connectLine(from, fromAnchor, line, line.calculative.worldAnchors[0]);
    connectLine(to, toAnchor, line, line.calculative.worldAnchors[1]);
    line.calculative.active = false;
    this.canvas.updateLines(line);
    this.canvas.updateLines(from);
    this.canvas.updateLines(to);
    this.canvas.initLineRect(line);
    if (render) {
      this.render();
    }
    return line;
  }
  /**
   * 生成一个拷贝组合后的 画笔数组（组合图形），不影响原画布画笔，常用作 二次复用的组件
   * @param pens 画笔数组
   * @param showChild 是否作为状态复用（参考 combine showChild）
   * @param anchor 是否产生默认的锚点
   * @returns 组合图形
   */
  toComponent(pens = this.store.data.pens, showChild, anchor) {
    if (pens.length === 1) {
      const pen = deepClone(pens[0]);
      pen.type = PenType.Node;
      pen.id = undefined;
      return [pen];
    }
    const components = deepClone(pens, true);
    const rect = getRect(components);
    let parent = {
      id: s8(),
      name: 'combine',
      ...rect,
      children: [],
      showChild
    };
    if (anchor) {
      parent.anchors = [{
        id: '0',
        penId: parent.id,
        x: 0.5,
        y: 0
      }, {
        id: '1',
        penId: parent.id,
        x: 1,
        y: 0.5
      }, {
        id: '2',
        penId: parent.id,
        x: 0.5,
        y: 1
      }, {
        id: '3',
        penId: parent.id,
        x: 0,
        y: 0.5
      }];
    }
    //如果本身就是 一个 组合图元
    const parents = components.filter(pen => !pen.parentId);
    const p = components.find(pen => {
      return pen.width === rect.width && pen.height === rect.height;
    });
    const oneIsParent = p && showChild === undefined;
    if (parents.length === 1) {
      parent = parents[0];
    } else if (oneIsParent) {
      if (!p.children) {
        p.children = [];
      }
      parent = p;
    } else {
      // 不影响画布数据，生成一个组合图形便于二次复用
      // this.canvas.makePen(parent);
    }
    components.forEach(pen => {
      if (pen === parent || pen.parentId === parent.id) {
        return;
      }
      if (pen.parentId) {
        // 已经是其它节点的子节点，x,y,w,h 已经是百分比了
        return;
      }
      parent.children.push(pen.id);
      pen.parentId = parent.id;
      const childRect = calcRelativeRect(pen.calculative.worldRect, rect);
      Object.assign(pen, childRect);
      pen.locked = pen.lockedOnCombine ?? LockState.DisableMove;
      // pen.type = PenType.Node;
    });
    return oneIsParent || parents.length === 1 ? deepClone(components) : deepClone([parent, ...components]);
  }
  // TODO 安装pen插件 此处是否应当进行相关的适配？不再让插件内部处理install的目标逻辑？
  /**
   * @description 安装插件方法
   * @param plugins 插件列表及其配置项
   * @param pen {string | Pen} 接受tag、name、或者Pen对象*/
  installPenPlugins(pen, plugins) {
    if (!pen.tag && !pen.name && !pen.id) return;
    let type;
    pen.id ? type = 'id' : pen.tag ? type = 'tag' : pen.name ? type = 'name' : '';
    plugins.forEach(pluginConfig => {
      let plugin = pluginConfig.plugin;
      let option = pluginConfig.options;
      if (!plugin) return;
      // 插件校验
      if (validationPlugin(plugin) && type) {
        plugin.install(pen, option);
        // 若当前不存在此插件
        if (!this.penPluginMap.has(plugin)) {
          this.penPluginMap.set(plugin, [{
            [type]: pen[type],
            option
          }]);
        } else {
          let op = this.penPluginMap.get(plugin).find(i => {
            return i[type] === pen[type];
          });
          // 存在替换
          if (op) {
            op.option = option;
          } else {
            this.penPluginMap.get(plugin).push({
              [type]: pen[type],
              option
            });
          }
        }
      }
    });
  }
  uninstallPenPlugins(pen, plugins) {
    let type;
    pen.id ? type = 'id' : pen.tag ? type = 'tag' : pen.name ? type = 'name' : '';
    if (!type) return;
    plugins.forEach(pluginConfig => {
      let plugin = pluginConfig.plugin;
      plugin.uninstall(pen, pluginConfig.options);
      let mapList = this.penPluginMap.get(plugin);
      let op = mapList.findIndex(i => i[type] === pen[type]);
      if (op !== -1) {
        mapList.splice(op, 1);
        // TODO 在运行时 插件卸载后是否需要移除？
        if (mapList.length === 0) {
          this.penPluginMap.delete(plugin);
        }
      }
    });
  }
  setVisible(pen, visible, render = true) {
    this.onSizeUpdate();
    this.setValue({
      id: pen.id,
      visible
    }, {
      render: false,
      doEvent: false
    });
    if (pen.children) {
      for (const childId of pen.children) {
        const child = this.store.pens[childId];
        child && this.setVisible(child, visible, false);
      }
    }
    let allPens = getAllChildren(pen, this.store);
    allPens.push(pen);
    this.initImageCanvas(allPens);
    render && this.render();
  }
  clearHover() {
    this.canvas.clearHover();
  }
  closeSocket() {
    this.closeWebsocket();
    this.closeMqtt();
    this.closeHttp();
  }
  destroy(onlyData) {
    this.clear(false);
    this.stopDataMock();
    this.closeSocket();
    this.closeNetwork();
    this.store.emitter.all.clear(); // 内存释放
    this.canvas.destroy();
    this.canvas = undefined;
    globalStore[this.store.id] = undefined;
    if (!onlyData) {
      for (const k in globalStore) {
        delete globalStore[k];
      }
      globalStore.path2dDraws = {};
      globalStore.canvasDraws = {};
      globalStore.anchors = {};
      globalStore.htmlElements = {};
    }
  }
}
;// ./node_modules/@kyvi/cobweb/index.js









// EXTERNAL MODULE: ./node_modules/speak-tts/lib/speak-tts.js
var speak_tts = __webpack_require__(4414);
;// ./src/package/Preview/alarm.js
/*
 * @Description:
 * @Author: Kevin
 * @Date: 2023-08-04 08:51:20
 * @LastEditors: Kevin
 * @LastEditTime: 2024-10-24 15:28:38
 */


/* harmony default export */ var alarm = ({
  data() {
    return {
      TIME: 1000 * 60 * 5,
      isFree: true,
      // 语音播报是否空闲
      warnObject: {},
      WarnMark: {},
      LevelTypes: [{
        label: '高报1级',
        value: 'g1'
      }, {
        label: '高报2级',
        value: 'g2'
      }, {
        label: '高报3级',
        value: 'g3'
      }, {
        label: '低报1级',
        value: 'd1'
      }, {
        label: '低报2级',
        value: 'd2'
      }, {
        label: '低报3级',
        value: 'd3'
      }]
    };
  },
  async created() {
    this.$notify.closeAll();
    this.speechInit();
    const that = this;
    window.warning = (id, warn) => {
      if (that.isFree && (!that.WarnMark[id] || Math.round(new Date()) - that.WarnMark[id] > that.TIME)) {
        that.WarnMark[id] = Math.round(new Date());
        that.isFree = false;
        that.doWarn(id, warn);
      }
    };
  },
  methods: {
    doWarn(id, warn) {
      this.warnObject = warn;
      const pen = window.cobweb.findOne(id);
      this.warnObject.val = pen?.text;
      const level = this.LevelTypes.find(item => item.value === warn.level)?.label;
      this.warnObject.label = level;
      this.warnObject.point = pen?.form?.length ? pen.form[0].dataIds?.name : '';
      this.warning();
    },
    warning(key) {
      const _this = this;
      const {
        point,
        label,
        val,
        start,
        end
      } = this.warnObject;
      const text = point + label;
      this.isFree = false;
      this.speakTtsSpeech(text.replace('_', ''), point);
      this.$notify({
        showClose: true,
        title: '报警提示',
        message: `报警点位：${point}; 报警等级：${label}；报警值：${val}；标准值：${start}-${end}`,
        position: 'top-right',
        type: 'warning',
        offset: 80,
        duration: 0,
        onClose() {
          _this.cancelSpeech(key);
        }
      });
    },
    // 语音读取报错信息
    speakTtsSpeech(text, key) {
      this.speech.speak({
        text: text.replace('#', '号'),
        listeners: {
          onend: () => {
            if (this.warnObject.point === key) {
              this.time = setTimeout(() => {
                this.speakTtsSpeech(text, key);
              }, 1000);
            }
          }
        }
      }).then(() => {
        console.log('读取成功');
      }).catch(e => {
        console.error('语音报警错误:', e);
      });
    },
    // 取消报警
    cancelSpeech() {
      this.isFree = true;
      this.speech.cancel();
    },
    // 语音报警初始化
    speechInit() {
      this.speech = new speak_tts/* default */.A();
      // this.speech.setLanguage('zh-CN')
      this.speech.init({
        'lang': 'zh-CN',
        'rate': 1.5,
        'pitch': 2,
        'splitSentences': true
      }).then(() => {
        // console.log('语音报警初始化成功')
      });
    }
  }
});
;// ./src/utils/xxtea.js


const _keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
const {
  error: _error
} = console;
/**
 * @class Base64Class 帮助基类
 */
class Base64Class {
  static init() {
    return new Base64Class();
  }

  // public method for encoding
  static encode(input) {
    let output = '';
    let chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    let i = 0;
    input = Base64Class._utf8_encode(input);
    while (i < input.length) {
      chr1 = input.charCodeAt(i++);
      chr2 = input.charCodeAt(i++);
      chr3 = input.charCodeAt(i++);
      enc1 = chr1 >> 2;
      enc2 = (chr1 & 3) << 4 | chr2 >> 4;
      enc3 = (chr2 & 15) << 2 | chr3 >> 6;
      enc4 = chr3 & 63;
      if (isNaN(chr2)) {
        enc3 = enc4 = 64;
      } else if (isNaN(chr3)) {
        enc4 = 64;
      }
      output += _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
    }
    return output;
  }

  // public method for decoding
  static decode(input) {
    let output = '';
    let chr1, chr2, chr3;
    let enc1, enc2, enc3, enc4;
    let i = 0;
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, ''); // eslint-disable-line

    while (i < input.length) {
      enc1 = _keyStr.indexOf(input.charAt(i++));
      enc2 = _keyStr.indexOf(input.charAt(i++));
      enc3 = _keyStr.indexOf(input.charAt(i++));
      enc4 = _keyStr.indexOf(input.charAt(i++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      output = output + String.fromCharCode(chr1);
      if (enc3 !== 64) {
        output = output + String.fromCharCode(chr2);
      }
      if (enc4 !== 64) {
        output = output + String.fromCharCode(chr3);
      }
    }
    output = this._utf8_decode(output);
    return output;
  }
  static encode64(input) {
    let output = '';
    let chr1;
    let chr2;
    let chr3 = '';
    let enc1;
    let enc2;
    let enc3;
    let enc4 = '';
    let i = 0;
    do {
      chr1 = input.charCodeAt(i++);
      chr2 = input.charCodeAt(i++);
      chr3 = input.charCodeAt(i++);
      enc1 = chr1 >> 2;
      enc2 = (chr1 & 3) << 4 | chr2 >> 4;
      enc3 = (chr2 & 15) << 2 | chr3 >> 6;
      enc4 = chr3 & 63;
      if (isNaN(chr2)) {
        enc3 = enc4 = 64;
      } else if (isNaN(chr3)) {
        enc4 = 64;
      }
      output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
      chr1 = chr2 = chr3 = '';
      enc1 = enc2 = enc3 = enc4 = '';
    } while (i < input.length);
    return output;
  }
  static decode64(input) {
    let output = '';
    let chr1;
    let chr2;
    let chr3 = '';
    let enc1;
    let enc2;
    let enc3;
    let enc4 = '';
    let i = 0;

    // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
    const base64test = /[^A-Za-z0-9\+\/\=\n]/g; // eslint-disable-line
    if (base64test.exec(input)) {
      _error('There were invalid base64 characters in the input text.\n' + "Valid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\n" + 'Expect errors in decoding.');
    }
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, ''); // eslint-disable-line

    do {
      enc1 = _keyStr.indexOf(input.charAt(i++));
      enc2 = _keyStr.indexOf(input.charAt(i++));
      enc3 = _keyStr.indexOf(input.charAt(i++));
      enc4 = _keyStr.indexOf(input.charAt(i++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      output = output + String.fromCharCode(chr1);
      if (enc3 !== 64) {
        output = output + String.fromCharCode(chr2);
      }
      if (enc4 !== 64) {
        output = output + String.fromCharCode(chr3);
      }
      chr1 = chr2 = chr3 = '';
      enc1 = enc2 = enc3 = enc4 = '';
    } while (i < input.length);
    return output;
  }
  // private method for UTF-8 encoding
  static _utf8_encode(string) {
    string = string.replace(/\r\n/g, '\n');
    let utftext = '';
    for (let n = 0; n < string.length; n++) {
      const c = string.charCodeAt(n);
      if (c < 128) {
        utftext += String.fromCharCode(c);
      } else if (c > 127 && c < 2048) {
        utftext += String.fromCharCode(c >> 6 | 192);
        utftext += String.fromCharCode(c & 63 | 128);
      } else {
        utftext += String.fromCharCode(c >> 12 | 224);
        utftext += String.fromCharCode(c >> 6 & 63 | 128);
        utftext += String.fromCharCode(c & 63 | 128);
      }
    }
    return utftext;
  }

  // private method for UTF-8 decoding
  static _utf8_decode(utftext) {
    let string = '';
    let i = 0;
    let c = 0;
    // let c1 = 0;
    let c2 = 0;
    let c3 = 0;
    while (i < utftext.length) {
      c = utftext.charCodeAt(i);
      if (c < 128) {
        string += String.fromCharCode(c);
        i++;
      } else if (c > 191 && c < 224) {
        c2 = utftext.charCodeAt(i + 1);
        string += String.fromCharCode((c & 31) << 6 | c2 & 63);
        i += 2;
      } else {
        c2 = utftext.charCodeAt(i + 1);
        c3 = utftext.charCodeAt(i + 2);
        string += String.fromCharCode((c & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
        i += 3;
      }
    }
    return string;
  }
}

/**
 * @class UtfParserClass类
 */
class UtfParserClass {
  /**
    * 用于对象实例化
    * @param {String} privateKey 用于加密的私钥
    * @returns {Object} 返回已经实例化完成的对象
    */
  static init() {
    const res = new UtfParserClass();
    return res;
  }

  // parms(str):string that you want to change
  static utf16to8(str) {
    let out, i, c;
    const len = str.length;
    out = '';
    for (i = 0; i < len; i++) {
      c = str.charCodeAt(i);
      if (c >= 0x0001 && c <= 0x007F) {
        out += str.charAt(i);
      } else if (c > 0x07FF) {
        out += String.fromCharCode(0xE0 | c >> 12 & 0x0F);
        out += String.fromCharCode(0x80 | c >> 6 & 0x3F);
        out += String.fromCharCode(0x80 | c >> 0 & 0x3F);
      } else {
        out += String.fromCharCode(0xC0 | c >> 6 & 0x1F);
        out += String.fromCharCode(0x80 | c >> 0 & 0x3F);
      }
    }
    return out;
  }

  // function:change utf8 to utf16
  // parms(str):string that you want to change
  static utf8to16(str) {
    str = str.toString();
    const len = str.length;
    let out, i, c;
    let char2, char3;
    out = '';
    i = 0;
    while (i < len) {
      c = str.charCodeAt(i++);
      switch (c >> 4) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
          // 0xxxxxxx
          out += str.charAt(i - 1);
          break;
        case 12:
        case 13:
          // 110x xxxx  10xx xxxx
          char2 = str.charCodeAt(i++);
          out += String.fromCharCode((c & 0x1F) << 6 | char2 & 0x3F);
          break;
        case 14:
          // 1110 xxxx  10xx xxxx  10xx xxxx
          char2 = str.charCodeAt(i++);
          char3 = str.charCodeAt(i++);
          out += String.fromCharCode((c & 0x0F) << 12 | (char2 & 0x3F) << 6 | (char3 & 0x3F) << 0);
          break;
      }
    }
    return out;
  }
  static utf8Encode(str) {
    // eslint-disable-next-line no-control-regex
    if (/^[\x00-\x7f]*$/.test(str)) {
      return str;
    }
    var buf = [];
    var n = str.length;
    for (var i = 0, j = 0; i < n; ++i, ++j) {
      var codeUnit = str.charCodeAt(i);
      if (codeUnit < 0x80) {
        buf[j] = str.charAt(i);
      } else if (codeUnit < 0x800) {
        buf[j] = String.fromCharCode(0xC0 | codeUnit >> 6, 0x80 | codeUnit & 0x3F);
      } else if (codeUnit < 0xD800 || codeUnit > 0xDFFF) {
        buf[j] = String.fromCharCode(0xE0 | codeUnit >> 12, 0x80 | codeUnit >> 6 & 0x3F, 0x80 | codeUnit & 0x3F);
      } else {
        if (i + 1 < n) {
          var nextCodeUnit = str.charCodeAt(i + 1);
          if (codeUnit < 0xDC00 && nextCodeUnit >= 0xDC00 && nextCodeUnit <= 0xDFFF) {
            var rune = ((codeUnit & 0x03FF) << 10 | nextCodeUnit & 0x03FF) + 0x010000;
            buf[j] = String.fromCharCode(0xF0 | rune >> 18 & 0x3F, 0x80 | rune >> 12 & 0x3F, 0x80 | rune >> 6 & 0x3F, 0x80 | rune & 0x3F);
            ++i;
            continue;
          }
        }
        throw new Error('Malformed string');
      }
    }
    return buf.join('');
  }
  static utf8DecodeShortString(bs, n) {
    var charCodes = new Array(n);
    var i = 0;
    var off = 0;
    for (var len = bs.length; i < n && off < len; i++) {
      var unit = bs.charCodeAt(off++);
      switch (unit >> 4) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
          charCodes[i] = unit;
          break;
        case 12:
        case 13:
          if (off < len) {
            charCodes[i] = (unit & 0x1F) << 6 | bs.charCodeAt(off++) & 0x3F;
          } else {
            throw new Error('Unfinished UTF-8 octet sequence');
          }
          break;
        case 14:
          if (off + 1 < len) {
            charCodes[i] = (unit & 0x0F) << 12 | (bs.charCodeAt(off++) & 0x3F) << 6 | bs.charCodeAt(off++) & 0x3F;
          } else {
            throw new Error('Unfinished UTF-8 octet sequence');
          }
          break;
        case 15:
          if (off + 2 < len) {
            var rune = ((unit & 0x07) << 18 | (bs.charCodeAt(off++) & 0x3F) << 12 | (bs.charCodeAt(off++) & 0x3F) << 6 | bs.charCodeAt(off++) & 0x3F) - 0x10000;
            if (rune >= 0 && rune <= 0xFFFFF) {
              charCodes[i++] = rune >> 10 & 0x03FF | 0xD800;
              charCodes[i] = rune & 0x03FF | 0xDC00;
            } else {
              throw new Error('Character outside valid Unicode range: 0x' + rune.toString(16));
            }
          } else {
            throw new Error('Unfinished UTF-8 octet sequence');
          }
          break;
        default:
          throw new Error('Bad UTF-8 encoding 0x' + unit.toString(16));
      }
    }
    if (i < n) {
      charCodes.length = i;
    }
    return String.fromCharCode.apply(String, charCodes);
  }
  static utf8DecodeLongString(bs, n) {
    var buf = [];
    var charCodes = new Array(0x8000);
    var i = 0;
    var off = 0;
    for (var len = bs.length; i < n && off < len; i++) {
      var unit = bs.charCodeAt(off++);
      switch (unit >> 4) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
          charCodes[i] = unit;
          break;
        case 12:
        case 13:
          if (off < len) {
            charCodes[i] = (unit & 0x1F) << 6 | bs.charCodeAt(off++) & 0x3F;
          } else {
            throw new Error('Unfinished UTF-8 octet sequence');
          }
          break;
        case 14:
          if (off + 1 < len) {
            charCodes[i] = (unit & 0x0F) << 12 | (bs.charCodeAt(off++) & 0x3F) << 6 | bs.charCodeAt(off++) & 0x3F;
          } else {
            throw new Error('Unfinished UTF-8 octet sequence');
          }
          break;
        case 15:
          if (off + 2 < len) {
            var rune = ((unit & 0x07) << 18 | (bs.charCodeAt(off++) & 0x3F) << 12 | (bs.charCodeAt(off++) & 0x3F) << 6 | bs.charCodeAt(off++) & 0x3F) - 0x10000;
            if (rune >= 0 && rune <= 0xFFFFF) {
              charCodes[i++] = rune >> 10 & 0x03FF | 0xD800;
              charCodes[i] = rune & 0x03FF | 0xDC00;
            } else {
              throw new Error('Character outside valid Unicode range: 0x' + rune.toString(16));
            }
          } else {
            throw new Error('Unfinished UTF-8 octet sequence');
          }
          break;
        default:
          throw new Error('Bad UTF-8 encoding 0x' + unit.toString(16));
      }
      if (i >= 0x7FFF - 1) {
        var size = i + 1;
        charCodes.length = size;
        buf[buf.length] = String.fromCharCode.apply(String, charCodes);
        n -= size;
        i = -1;
      }
    }
    if (i > 0) {
      charCodes.length = i;
      buf[buf.length] = String.fromCharCode.apply(String, charCodes);
    }
    return buf.join('');
  }

  // n is UTF16 length
  static utf8Decode(bs, n) {
    if (n === undefined || n === null || n < 0) n = bs.length;
    if (n === 0) return '';
    // eslint-disable-next-line no-control-regex
    if (/^[\x00-\x7f]*$/.test(bs) || !/^[\x00-\xff]*$/.test(bs)) {
      if (n === bs.length) return bs;
      return bs.substr(0, n);
    }
    return n < 0x7FFF ? UtfParserClass.utf8DecodeShortString(bs, n) : UtfParserClass.utf8DecodeLongString(bs, n);
  }
}

/**
 * @class XxteaClass类
 */
class XxteaClass {
  constructor(privateKey) {
    this._keyString = privateKey || _keyStr;
  }
  /**
    * 用于对象实例化
    * @param {String} privateKey 用于加密的私钥
    * @returns {Object} 返回已经实例化完成的对象
    */
  static init(privateKey) {
    const res = new XxteaClass(privateKey);
    return res;
  }
  _long2str(v, w) {
    const vl = v.length;
    let n = vl - 1 << 2;
    if (w) {
      const m = v[vl - 1];
      if (m < n - 3 || m > n) return null;
      n = m;
    }
    for (let i = 0; i < vl; i++) {
      v[i] = String.fromCharCode(v[i] & 0xff, v[i] >>> 8 & 0xff, v[i] >>> 16 & 0xff, v[i] >>> 24 & 0xff);
    }
    if (w) {
      return v.join('').substring(0, n);
    } else {
      return v.join('');
    }
  }
  _str2long(s, w) {
    const len = s.length;
    const v = [];
    for (let i = 0; i < len; i += 4) {
      v[i >> 2] = s.charCodeAt(i) | s.charCodeAt(i + 1) << 8 | s.charCodeAt(i + 2) << 16 | s.charCodeAt(i + 3) << 24;
    }
    if (w) {
      v[v.length] = len;
    }
    return v;
  }
  xxtea_encrypt(str) {
    if (!str) {
      return '';
    }
    str = Base64Class.encode64(UtfParserClass.utf8Encode(str));
    const v = this._str2long(str, true);
    const k = this._str2long(this._keyString, false);
    if (k.length < 4) {
      k.length = 4;
    }
    const n = v.length - 1;
    let z = v[n];
    let y = v[0];
    const delta = 0x9E3779B9;
    let mx;
    let e;
    let p;
    let q = Math.floor(6 + 52 / (n + 1));
    let sum = 0;
    while (q-- > 0) {
      sum = sum + delta & 0xffffffff;
      e = sum >>> 2 & 3;
      for (p = 0; p < n; p++) {
        y = v[p + 1];
        mx = (z >>> 5 ^ y << 2) + (y >>> 3 ^ z << 4) ^ (sum ^ y) + (k[p & 3 ^ e] ^ z);
        z = v[p] = v[p] + mx & 0xffffffff;
      }
      y = v[0];
      mx = (z >>> 5 ^ y << 2) + (y >>> 3 ^ z << 4) ^ (sum ^ y) + (k[p & 3 ^ e] ^ z);
      z = v[n] = v[n] + mx & 0xffffffff;
    }
    return Base64Class.encode64(this._long2str(v, false));
  }
  xxtea_decrypt(str) {
    if (!str) {
      return '';
    }
    str = Base64Class.decode64(str);
    const v = this._str2long(str, false);
    const k = this._str2long(this._keyString, false);
    if (k.length < 4) {
      k.length = 4;
    }
    const n = v.length - 1;
    let z = v[n - 1];
    let y = v[0];
    const delta = 0x9E3779B9;
    let mx;
    let e;
    let p;
    const q = Math.floor(6 + 52 / (n + 1));
    let sum = q * delta & 0xffffffff;
    while (sum !== 0) {
      e = sum >>> 2 & 3;
      for (p = n; p > 0; p--) {
        z = v[p - 1];
        mx = (z >>> 5 ^ y << 2) + (y >>> 3 ^ z << 4) ^ (sum ^ y) + (k[p & 3 ^ e] ^ z);
        y = v[p] = v[p] - mx & 0xffffffff;
      }
      z = v[n];
      mx = (z >>> 5 ^ y << 2) + (y >>> 3 ^ z << 4) ^ (sum ^ y) + (k[p & 3 ^ e] ^ z);
      y = v[0] = v[0] - mx & 0xffffffff;
      sum = sum - delta & 0xffffffff;
    }
    return UtfParserClass.utf8Decode(Base64Class.decode64(this._long2str(v, true)));
  }
}
/* harmony default export */ var xxtea = (new XxteaClass());
;// ./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/package/Preview/Index.vue?vue&type=script&lang=js
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ var Indexvue_type_script_lang_js = ({
  name: 'CobwebPreview',
  props: {
    cobweb: String
  },
  mixins: [alarm],
  data() {
    return {
      dataId: ''
    };
  },
  mounted() {
    window.cobweb = new Meta2d("cobweb", {
      rule: false
    });
    const json = xxtea.xxtea_decrypt(this.cobweb);
    if (!json) return;
    const data = JSON.parse(json);
    data.locked = 1;
    window.cobweb.open(data);
    window.cobweb.fitView();
    window.cobweb.on("click", this.lookTrend);
    window.cobweb.on("contextmenu", this.setThreshold);
  },
  destroy() {
    window.cobweb.destroy();
  },
  methods: {
    lookTrend(e) {
      if (!e.pen) return;
      if (e.pen?.form?.length && e.pen?.form[0]?.key === 'text') {
        const dataId = this.getDataId(e.pen);
        this.$emit('event', {
          type: 'click',
          id: dataId
        });
      }
    },
    getDataId(pen) {
      let dataId = pen.form?.find(item => item.key === 'text')?.dataIds?.dataId;
      if (dataId) return dataId;
      (pen.children || []).forEach(id => {
        const data = window.cobweb.find(id)?.form?.find(item => item.key === 'text')?.dataIds?.dataId;
        if (data) {
          dataId = data;
          return false;
        }
      });
    },
    setThreshold(e) {
      if (!e.pen) return;
      if (e.pen?.form?.length && e.pen?.form[0]?.key === 'text') {
        const dataId = e?.pen?.id ?? '';
        this.$emit('event', {
          type: 'contextmenu',
          id: dataId
        });
      }
    }
  }
});
;// ./src/package/Preview/Index.vue?vue&type=script&lang=js
 /* harmony default export */ var Preview_Indexvue_type_script_lang_js = (Indexvue_type_script_lang_js); 
;// ./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-12.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-12.use[1]!./node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-12.use[2]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/package/Preview/Index.vue?vue&type=style&index=0&id=36606a4d&prod&scoped=true&lang=css
// extracted by mini-css-extract-plugin

;// ./src/package/Preview/Index.vue?vue&type=style&index=0&id=36606a4d&prod&scoped=true&lang=css

;// ./node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent(
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */,
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options =
    typeof scriptExports === 'function' ? scriptExports.options : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) {
    // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
          injectStyles.call(
            this,
            (options.functional ? this.parent : this).$root.$options.shadowRoot
          )
        }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}

;// ./src/package/Preview/Index.vue



;


/* normalize component */

var component = normalizeComponent(
  Preview_Indexvue_type_script_lang_js,
  render,
  staticRenderFns,
  false,
  null,
  "36606a4d",
  null
  
)

/* harmony default export */ var Index = (component.exports);
;// ./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/package/Editor/Editor.vue?vue&type=template&id=127c7d23&scoped=true
var Editorvue_type_template_id_127c7d23_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"editor"},[_c('Editor',{attrs:{"cobweb":_vm.cobweb}})],1)}
var Editorvue_type_template_id_127c7d23_scoped_true_staticRenderFns = []


;// ./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/Editor.vue?vue&type=template&id=4aa8126b&scoped=true
var Editorvue_type_template_id_4aa8126b_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"canvas_content"},[_c('div',{attrs:{"id":"operation_center"}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.showMenu),expression:"showMenu"}],staticClass:"menu",style:(_vm.menuPosition)},[_c('el-menu',{attrs:{"theme":"dark","value":_vm.activeMenu,"defaultValue":"dashboard","height":"550px","width":"160px"}},[_c('el-menu-item',{attrs:{"value":"top"},on:{"click":_vm.top}},[_vm._v("置顶 ")]),_c('el-menu-item',{attrs:{"value":"bottom"},on:{"click":_vm.bottom}},[_vm._v("置底 ")]),_c('el-menu-item',{attrs:{"value":"up"},on:{"click":_vm.up}},[_vm._v("上一图层 ")]),_c('el-menu-item',{attrs:{"value":"down","divider":true},on:{"click":_vm.down}},[_vm._v(" 下一图层 ")]),_c('el-menu-item',{directives:[{name:"show",rawName:"v-show",value:(_vm.highlight.length > 1),expression:"highlight.length > 1"}],attrs:{"value":"combine"},on:{"click":_vm.combine}},[_vm._v("组合")]),_c('el-menu-item',{directives:[{name:"show",rawName:"v-show",value:(_vm.highlight.length > 1),expression:"highlight.length > 1"}],attrs:{"value":"combineStatus"},on:{"click":_vm.combineStatus}},[_vm._v(" 组合为状态 ")]),_c('el-menu-item',{directives:[{name:"show",rawName:"v-show",value:(
            _vm.highlight.length < 2 &&
            _vm.selections.pen &&
            _vm.selections.pen.name === 'combine'
          ),expression:"\n            highlight.length < 2 &&\n            selections.pen &&\n            selections.pen.name === 'combine'\n          "}],attrs:{"value":"unCombine"},on:{"click":_vm.uncombine}},[_vm._v(" 解除组合 ")]),_c('el-menu-item',{attrs:{"value":"deleteNode"},on:{"click":_vm.deleteNode}},[_vm._v("删除")])],1)],1)]),_c('div',{staticClass:"bottom-slider"},[_c('el-dropdown',{attrs:{"placement":"top","minColumnWidth":180,"trigger":"hover"}},[_c('i',{staticClass:"el-icon-question"}),_c('el-dropdown-menu',[_c('el-dropdown-item',[_c('div',{staticStyle:{"height":"100px","width":"100%","display":"grid","grid-template-columns":"1fr 1fr","gap":"10px","line-height":"14px"}},[_c('span',[_vm._v(" 撤销 Ctrl + Z ")]),_c('span',[_vm._v(" 恢复 Ctrl + Y")]),_c('span',[_vm._v(" 剪切 Ctrl + X")]),_c('span',[_vm._v(" 复制 Ctrl + C ")]),_c('span',[_vm._v("粘贴 Ctrl + V ")]),_c('span',[_vm._v("全选 Ctrl + A ")]),_c('span',[_vm._v("删除 DELETE ")])])])],1)],1),_c('el-dropdown',{attrs:{"placement":"top","trigger":"hover"},on:{"click":_vm.clickHandler}},[_c('span',[_vm._v(_vm._s(_vm.scale)+"%")]),_c('el-dropdown-menu',[_c('el-dropdown-item',{attrs:{"value":2}},[_vm._v(" 200% ")]),_c('el-dropdown-item',{attrs:{"value":1.5}},[_vm._v("150% ")]),_c('el-dropdown-item',{attrs:{"value":1}},[_vm._v(" 100% ")]),_c('el-dropdown-item',{attrs:{"value":0.5}},[_vm._v(" 50% ")]),_c('el-dropdown-item',{attrs:{"value":'auto'}},[_vm._v("自适应 ")])],1)],1)],1)])}
var Editorvue_type_template_id_4aa8126b_scoped_true_staticRenderFns = []


;// ./node_modules/@kyvi/flow-drag/src/comment.js
function flowComment(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    ey
  } = pen.calculative.worldRect;
  const offsetX = width / 4;
  path.moveTo(x + offsetX, y);
  path.lineTo(x, y);
  path.lineTo(x, ey);
  path.lineTo(x + offsetX, ey);
  if (path instanceof Path2D) return path;
}
function flowCommentAnchors(pen) {
  const points = [{
    x: 0.25,
    y: 0
  }, {
    x: 0.25,
    y: 1
  }, {
    x: 0,
    y: 0.5
  }];
  pen.anchors = points.map(({
    x,
    y
  }, index) => {
    return {
      id: index + '',
      x,
      y,
      penId: pen.id
    };
  });
}
;// ./node_modules/@kyvi/flow-drag/src/data.js
function flowData(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    ex,
    ey
  } = pen.calculative.worldRect;
  const penOffsetX = pen.offsetX;
  let offsetX = width / 7;
  if (penOffsetX > 1) {
    offsetX = penOffsetX;
  } else if (penOffsetX > 0) {
    offsetX = width * penOffsetX;
  }
  path.moveTo(x + offsetX, y);
  path.lineTo(ex, y);
  path.lineTo(x + width - offsetX, ey);
  path.lineTo(x, ey);
  path.closePath();
  if (path instanceof Path2D) return path;
}
function flowDataAnchors(pen) {
  const points = [{
    x: 0.5,
    y: 0
  }, {
    x: 13 / 14,
    y: 0.5
  }, {
    x: 0.5,
    y: 1
  }, {
    x: 1 / 14,
    y: 0.5
  }];
  pen.anchors = points.map(({
    x,
    y
  }, index) => {
    return {
      id: `${index}`,
      penId: pen.id,
      x,
      y
    };
  });
}
;// ./node_modules/@kyvi/flow-drag/src/db.js
function flowDb(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    height,
    ex,
    ey
  } = pen.calculative.worldRect;
  const offsetY = height / 7;
  path.moveTo(x, y + offsetY);
  path.bezierCurveTo(x, y - offsetY / 2 | 0, ex, y - offsetY / 2 | 0, ex, y + offsetY);
  path.lineTo(ex, ey - offsetY);
  path.bezierCurveTo(ex, ey + offsetY / 2 | 0, x, ey + offsetY / 2 | 0, x, ey - offsetY);
  path.closePath();
  path.moveTo(x, ey - offsetY);
  path.bezierCurveTo(x, ey - offsetY * 2 | 0, ex, ey - offsetY * 2 | 0, ex, ey - offsetY);
  //   path.closePath();
  if (path instanceof Path2D) return path;
}
;// ./node_modules/@kyvi/flow-drag/src/display.js
function flowDisplay(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height,
    ex,
    ey
  } = pen.calculative.worldRect;
  const offsetX = width / 8;
  path.moveTo(x + offsetX, y);
  path.lineTo(ex - offsetX, y);
  path.bezierCurveTo(ex + offsetX / 3, y, ex + offsetX / 3, ey, ex - offsetX, ey);
  path.lineTo(x + offsetX, ey);
  path.lineTo(x, y + height / 2);
  path.closePath();
  if (path instanceof Path2D) return path;
}
;// ./node_modules/@kyvi/flow-drag/src/document.js
function flowDocument(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height,
    ex,
    center
  } = pen.calculative.worldRect;
  const centerX = center.x;
  const rightBottomY = y + height * 6 / 7;
  const offsetY = height / 6;
  path.moveTo(x, y);
  path.lineTo(ex, y);
  path.lineTo(ex, rightBottomY);
  path.bezierCurveTo(ex - 20, rightBottomY - offsetY, centerX + width / 5, rightBottomY - offsetY, centerX, rightBottomY);
  path.bezierCurveTo(centerX - width / 5, rightBottomY + offsetY, x, rightBottomY + offsetY, x, rightBottomY);
  path.closePath();
  if (path instanceof Path2D) return path;
}
function flowDocumentAnchors(pen) {
  const points = [{
    x: 0.5,
    y: 0
  }, {
    x: 1,
    y: 0.5
  }, {
    x: 0.5,
    y: 6 / 7
  }, {
    x: 0,
    y: 0.5
  }];
  pen.anchors = points.map(({
    x,
    y
  }, index) => {
    return {
      id: `${index}`,
      penId: pen.id,
      x,
      y
    };
  });
}
;// ./node_modules/@kyvi/flow-drag/src/externStorage.js
function flowExternStorage(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    ex,
    ey
  } = pen.calculative.worldRect;
  const offsetX = width / 10;
  path.moveTo(x + offsetX * 2, y);
  path.bezierCurveTo(x - offsetX * 2 / 3, y, x - offsetX * 2 / 3, ey, x + offsetX * 2, ey);
  path.lineTo(ex, ey);
  path.bezierCurveTo(ex - offsetX, ey, ex - offsetX, y, ex, y);
  path.closePath();
  if (path instanceof Path2D) return path;
}
;// ./node_modules/@kyvi/flow-drag/src/internalStorage.js
function flowInternalStorage(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    ex,
    ey
  } = pen.calculative.worldRect;
  path.moveTo(x, y);
  path.lineTo(ex, y);
  path.lineTo(ex, ey);
  path.lineTo(x, ey);
  path.closePath();
  const offset = width / 7;
  path.moveTo(x, y + offset);
  path.lineTo(ex, y + offset);
  path.moveTo(x + offset, y);
  path.lineTo(x + offset, ey);
  if (path instanceof Path2D) return path;
}
;// ./node_modules/@kyvi/flow-drag/src/manually.js
function flowManually(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    height,
    ex,
    ey
  } = pen.calculative.worldRect;
  const offsetY = height / 4;
  path.moveTo(x, y + offsetY);
  path.lineTo(ex, y);
  path.lineTo(ex, ey);
  path.lineTo(x, ey);
  path.closePath();
  if (path instanceof Path2D) return path;
}
function flowManuallyAnchors(pen) {
  const points = [{
    x: 0.5,
    y: 0.125
  }, {
    x: 1,
    y: 0.5
  }, {
    x: 0.5,
    y: 1
  }, {
    x: 0,
    y: 0.5
  }];
  pen.anchors = points.map(({
    x,
    y
  }, index) => {
    return {
      id: `${index}`,
      penId: pen.id,
      x,
      y
    };
  });
}
;// ./node_modules/@kyvi/flow-drag/src/parallel.js
function flowParallel(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    ex,
    ey
  } = pen.calculative.worldRect;
  path.moveTo(x, y);
  path.lineTo(ex, y);
  path.moveTo(x, ey);
  path.lineTo(ex, ey);
  if (path instanceof Path2D) return path;
}
function flowParallelAnchors(pen) {
  const points = [{
    x: 0.5,
    y: 0
  }, {
    x: 0.5,
    y: 1
  }];
  pen.anchors = points.map(({
    x,
    y
  }, index) => {
    return {
      id: index + '',
      x,
      y,
      penId: pen.id
    };
  });
}
;// ./node_modules/@kyvi/flow-drag/src/queue.js
function flowQueue(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height,
    ex,
    ey
  } = pen.calculative.worldRect;
  path.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, Math.PI * 2);
  path.moveTo(x + width / 2, ey);
  path.lineTo(ex, ey);
  path.closePath();
  if (path instanceof Path2D) return path;
}
;// ./node_modules/@kyvi/flow-drag/src/subprocess.js
function flowSubprocess(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    ex,
    ey
  } = pen.calculative.worldRect;
  const offsetX = width / 7;
  path.moveTo(x, y);
  path.lineTo(ex, y);
  path.lineTo(ex, ey);
  path.lineTo(x, ey);
  path.closePath();
  path.moveTo(x + offsetX, y);
  path.lineTo(x + offsetX, ey);
  path.moveTo(ex - offsetX, y);
  path.lineTo(ex - offsetX, ey);
  if (path instanceof Path2D) return path;
}
;// ./node_modules/@kyvi/flow-drag/src/register.js











function flowPens() {
  return {
    flowComment: flowComment,
    flowData: flowData,
    flowDb: flowDb,
    flowDisplay: flowDisplay,
    flowDocument: flowDocument,
    flowExternStorage: flowExternStorage,
    flowInternalStorage: flowInternalStorage,
    flowManually: flowManually,
    flowParallel: flowParallel,
    flowQueue: flowQueue,
    flowSubprocess: flowSubprocess
  };
}
function flowAnchors() {
  return {
    flowDocument: flowDocumentAnchors,
    flowManually: flowManuallyAnchors,
    flowParallel: flowParallelAnchors,
    flowComment: flowCommentAnchors,
    flowData: flowDataAnchors
  };
}
;// ./node_modules/@kyvi/activity-drag/src/final.js
// 此方法只能绘制路径，在该图形不适用
// export function activityFinal(pen: Pen): Path2D {
//   const path1 = new Path2D();
//   const worldRect = pen.calculative.worldRect;
//   path1.ellipse(
//     worldRect.x + worldRect.width / 2,
//     worldRect.y + worldRect.height / 2,
//     worldRect.width / 2,
//     worldRect.height / 2,
//     0,
//     0,
//     Math.PI * 2
//   );
//   const path2 = new Path2D();
//   path2.ellipse(
//     worldRect.x + worldRect.width / 2,
//     worldRect.y + worldRect.height / 2,
//     worldRect.width / 4,
//     worldRect.height / 4,
//     0,
//     0,
//     Math.PI * 2
//   );
//   path1.addPath(path2);
//   return path1;
// }
function activityFinal(ctx, pen) {
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  ctx.beginPath();
  ctx.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, Math.PI * 2);
  ctx.stroke();
  ctx.beginPath();
  ctx.fillStyle = ctx.strokeStyle;
  ctx.ellipse(x + width / 2, y + height / 2, width / 4, height / 4, 0, 0, Math.PI * 2);
  ctx.fill();
}
;// ./node_modules/@kyvi/activity-drag/src/swimlaneH.js
function swimlaneH(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height,
    ey
  } = pen.calculative.worldRect;
  const lineLeft = pen.calculative.lineLeft || 0.08;
  let wr = pen.calculative.borderRadius || 0,
    hr = wr;
  if (wr < 1) {
    wr = width * wr;
    hr = height * wr;
  }
  let r = wr < hr ? wr : hr;
  if (width < 2 * r) {
    r = width / 2;
  }
  if (height < 2 * r) {
    r = height / 2;
  }
  path.moveTo(x + r, y);
  path.arcTo(x + width, y, x + width, y + height, r);
  path.arcTo(x + width, y + height, x, y + height, r);
  path.arcTo(x, y + height, x, y, r);
  path.arcTo(x, y, x + width, y, r);
  path.closePath();
  //   40 肯定是不合理的，TODO: 该处用宽度的部分值
  // TODO: 算上圆角后，该线可能超出在范围外
  path.moveTo(x + lineLeft * width, y);
  path.lineTo(x + lineLeft * width, ey);
  if (path instanceof Path2D) return path;
}
;// ./node_modules/@kyvi/activity-drag/src/swimlaneV.js
function swimlaneV(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height,
    ex
  } = pen.calculative.worldRect;
  const lineTop = pen.calculative.lineTop || 0.08;
  let wr = pen.calculative.borderRadius || 0,
    hr = wr;
  if (wr < 1) {
    wr = width * wr;
    hr = height * hr;
  }
  let r = wr < hr ? wr : hr;
  if (width < 2 * r) {
    r = width / 2;
  }
  if (height < 2 * r) {
    r = height / 2;
  }
  path.moveTo(x + r, y);
  path.arcTo(x + width, y, x + width, y + height, r);
  path.arcTo(x + width, y + height, x, y + height, r);
  path.arcTo(x, y + height, x, y, r);
  path.arcTo(x, y, x + width, y, r);
  path.closePath();
  //   40 肯定是不合理的，TODO: 该处用高度的部分值
  path.moveTo(x, y + lineTop * height);
  path.lineTo(ex, y + lineTop * height);
  if (path instanceof Path2D) return path;
}
;// ./node_modules/@kyvi/activity-drag/src/register.js




function activityDiagram() {
  return {
    forkV: rectangle,
    forkH: rectangle,
    swimlaneH: swimlaneH,
    swimlaneV: swimlaneV
  };
}
function activityDiagramByCtx() {
  return {
    activityFinal: activityFinal
  };
}
;// ./node_modules/@kyvi/activity-drag/index.js




;// ./node_modules/@kyvi/class-drag/src/interfaceClass.js
function interfaceClass(pen, ctx) {
  if (!pen.onDestroy) {
    pen.onDestroy = onDestroy;
    pen.onAdd = onAdd;
  }
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height,
    ex
  } = pen.calculative.worldRect;
  let wr = pen.calculative.borderRadius || 0,
    hr = wr;
  if (wr < 1) {
    wr *= width;
    hr *= height;
  }
  let r = wr < hr ? wr : hr;
  if (width < 2 * r) {
    r = width / 2;
  }
  if (height < 2 * r) {
    r = height / 2;
  }
  path.moveTo(x + r, y);
  path.arcTo(x + width, y, x + width, y + height, r);
  path.arcTo(x + width, y + height, x, y + height, r);
  path.arcTo(x, y + height, x, y, r);
  path.arcTo(x, y, x + width, y, r);
  const topHeight = 0.2 * height;
  path.moveTo(x, y + topHeight);
  path.lineTo(ex, y + topHeight);
  const secondHeight = y + topHeight + (height - topHeight) / 2;
  path.moveTo(x, secondHeight);
  path.lineTo(ex, secondHeight);
  path.closePath();
  if (path instanceof Path2D) return path;
}
function onAdd(pen) {
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  const list = pen.list;
  const childPen = {
    name: 'text',
    x: x,
    y: y + 0.2 * height,
    width,
    height: 0.4 * height,
    // text: list[0].text,
    textAlign: 'left',
    textBaseline: 'top',
    textLeft: 10,
    textTop: 10
  };
  const childPen1 = {
    name: 'text',
    x: x,
    y: y + 0.6 * height,
    width,
    height: 0.4 * height,
    // text: list[1].text,
    textAlign: 'left',
    textBaseline: 'top',
    textLeft: 10,
    textTop: 10
  };
  Object.assign(childPen, list[0]);
  Object.assign(childPen1, list[1]);
  pen.calculative.canvas.makePen(childPen);
  pen.calculative.canvas.makePen(childPen1);
  pen.calculative.canvas.parent.pushChildren(pen, [childPen]);
  pen.calculative.canvas.parent.pushChildren(pen, [childPen1]);
}
function onDestroy(pen) {
  const store = pen.calculative.canvas.store;
  pen.children.forEach(p => {
    const i = store.data.pens.findIndex(item => item.id === p);
    if (i > -1) {
      store.data.pens.splice(i, 1);
      store.pens[p] = undefined;
    }
  });
  pen.children = undefined;
}
;// ./node_modules/@kyvi/class-drag/src/simpleClass.js
function simpleClass(pen, ctx) {
  if (!pen.onDestroy) {
    pen.onDestroy = simpleClass_onDestroy;
    pen.onAdd = simpleClass_onAdd;
  }
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height,
    ex
  } = pen.calculative.worldRect;
  let wr = pen.calculative.borderRadius || 0,
    hr = wr;
  if (wr < 1) {
    wr = width * wr;
    hr = height * hr;
  }
  let r = wr < hr ? wr : hr;
  if (width < 2 * r) {
    r = width / 2;
  }
  if (height < 2 * r) {
    r = height / 2;
  }
  path.moveTo(x + r, y);
  path.arcTo(x + width, y, x + width, y + height, r);
  path.lineTo(x + width, y + height - r);
  path.arcTo(x + width, y + height, x, y + height, r);
  path.arcTo(x, y + height, x, y, r);
  path.arcTo(x, y, x + width, y, r);
  const topHeight = 0.2 * height;
  path.moveTo(x, y + topHeight);
  path.lineTo(ex, y + topHeight);
  path.closePath();
  if (path instanceof Path2D) return path;
}
function simpleClass_onAdd(pen) {
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  const list = pen.list;
  let childPen = {
    name: 'text',
    x: x,
    y: y + 0.2 * height,
    width,
    height: 0.8 * height,
    // text: list[0].text,
    textAlign: 'left',
    textBaseline: 'top',
    textLeft: 10,
    textTop: 10
  };
  Object.assign(childPen, list[0]);
  pen.calculative.canvas.makePen(childPen);
  pen.calculative.canvas.parent.pushChildren(pen, [childPen]);
}
function simpleClass_onDestroy(pen) {
  const store = pen.calculative.canvas.store;
  pen.children.forEach(p => {
    const i = store.data.pens.findIndex(item => item.id === p);
    if (i > -1) {
      store.data.pens.splice(i, 1);
      store.pens[p] = undefined;
    }
  });
  pen.children = [];
}
;// ./node_modules/@kyvi/class-drag/src/register.js


function classPens() {
  return {
    interfaceClass: interfaceClass,
    simpleClass: simpleClass
  };
}
;// ./node_modules/@kyvi/sequence-drag/src/focus.js
function focus_focus(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  path.rect(x, y, width, height);
  path.closePath();
  if (path instanceof Path2D) return path;
}
;// ./node_modules/@kyvi/sequence-drag/src/lifeline.js
function lifeline(ctx, pen) {
  const headHeight = pen.headHeight ?? 50;
  const {
    x,
    y,
    width,
    height,
    ey
  } = pen.calculative.worldRect;
  let wr = pen.calculative.borderRadius || 0,
    hr = wr;
  if (pen.calculative.borderRadius < 1) {
    wr *= width;
    hr *= height;
  }
  let r = wr < hr ? wr : hr;
  if (width < 2 * r) {
    r = width / 2;
  }
  if (headHeight < 2 * r) {
    r = headHeight / 2;
  }
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + width, y, x + width, y + headHeight, r);
  ctx.arcTo(x + width, y + headHeight, x, y + headHeight, r);
  ctx.arcTo(x, y + headHeight, x, y, r);
  ctx.arcTo(x, y, x + width, y, r);
  ctx.closePath();
  ctx.stroke();
  ctx.save();
  ctx.beginPath();
  ctx.lineWidth = 1;
  ctx.setLineDash([7, 7]);
  const middle = x + width / 2;
  ctx.moveTo(middle, y + headHeight + 1);
  ctx.lineTo(middle, ey);
  ctx.stroke();
  ctx.restore();
}
;// ./node_modules/@kyvi/sequence-drag/src/register.js


function sequencePens() {
  return {
    sequenceFocus: focus_focus
  };
}
function sequencePensbyCtx() {
  return {
    lifeline: lifeline
  };
}
;// ./node_modules/@kyvi/chart-drag/src/echarts.js


var ReplaceMode;
(function (ReplaceMode) {
  ReplaceMode[ReplaceMode["Add"] = 0] = "Add";
  ReplaceMode[ReplaceMode["Replace"] = 1] = "Replace";
  ReplaceMode[ReplaceMode["ReplaceAll"] = 2] = "ReplaceAll";
})(ReplaceMode || (ReplaceMode = {}));
let keyWords = ['fontSize', 'nameGap', 'margin', 'width' /*线条宽度*/, 'symbolSize' /*结点大小*/, 'itemWidth',
// 图例宽度
'itemHeight',
// 图例高度
'fontWeight', 'top', 'left', 'right', 'bottom', 'zoom', 'edgeSymbolSize', 'nodeWidth', 'nodeGap', 'distance', 'length', 'length2', 'offsetCenter', 'size', 'symbolOffset', 'padding', 'barWidth', 'symbolOffset', 'shadowOffsetY', 'shadowOffsetX'];
function echarts(pen) {
  let echarts = globalThis.echarts;
  if (!pen.echarts || !echarts) {
    return;
  }
  if (typeof pen.echarts === 'string') {
    try {
      pen.echarts = JSON.parse(pen.echarts);
    } catch (e) {}
  }
  keyWords = pen.calculative.canvas.store.options.diagramOptions['chart']?.keyWords || keyWords;
  if (!pen.onDestroy) {
    pen.onDestroy = echarts_destory;
    pen.onMove = echarts_move;
    pen.onResize = echarts_resize;
    pen.onRotate = echarts_move;
    pen.onValue = echarts_value;
    pen.onBeforeValue = echarts_beforeValue;
    pen.onBinds = binds;
    pen.onMouseEnter = echarts_move;
    // pen.onAdd = onAdd;
    pen.onRenderPenRaw = onRenderPenRaw;
  }
  if (!pen.calculative.singleton) {
    pen.calculative.singleton = {};
  }
  const path = new Path2D();
  const worldRect = pen.calculative.worldRect;
  if (!pen.calculative.singleton.div) {
    // 1. 创建父容器
    const div = document.createElement('div');
    div.style.position = 'absolute';
    div.style.outline = 'none';
    div.style.left = '-9999px';
    div.style.top = '-9999px';
    div.style.width = worldRect.width + 'px';
    div.style.height = worldRect.height + 'px';
    document.body.appendChild(div);
    // 2. 加载到div layer
    pen.calculative.canvas.externalElements?.parentElement.appendChild(div);
    render_setElemPosition(pen, div);
    // 3. 解析echarts数据
    pen.calculative.singleton.div = div;
    pen.calculative.singleton.echart = echarts.init(div, pen.echarts.theme);
    pen.calculative.singleton.echartsReady = true;
    if (pen.echarts.geoName && !echarts.getMap(pen.echarts.geoName)) {
      if (pen.echarts.geoJson) {
        echarts.registerMap(pen.echarts.geoName, pen.echarts.geoJson);
      } else if (pen.echarts.geoUrl) {
        pen.calculative.singleton.echartsReady = false;
        fetch(pen.echarts.geoUrl).then(e => {
          e.text().then(data => {
            if (typeof data === 'string') {
              try {
                data = JSON.parse(data);
              } catch {}
            }
            if (data.constructor !== Object && data.constructor !== Array) {
              console.warn('Invalid data:', data);
              return;
            }
            echarts.registerMap(pen.echarts.geoName, data);
            pen.calculative.singleton.echartsReady = true;
            pen.calculative.singleton.echart.setOption(updateOption(pen.echarts.option, pen.calculative.canvas.store.data.scale), true);
            pen.calculative.singleton.echart.resize();
            setTimeout(() => {
              onRenderPenRaw(pen);
            }, 300);
          });
        });
      }
    }
    // 4. 加载echarts
    if (pen.calculative.singleton.echartsReady) {
      // 初始化时，等待父div先渲染完成，避免初始图表控件太大。
      setTimeout(() => {
        pen.calculative.singleton.echart.setOption(updateOption(pen.echarts.option, pen.calculative.canvas.store.data.scale), true);
        setTimeout(() => onRenderPenRaw(pen), 300);
      });
    }
  }
  return path;
}
// function onAdd(pen: ChartPen) {
//   // pen.beforeScale = pen.calculative.canvas.store.data.scale;
// }
function echarts_destory(pen) {
  if (pen.calculative.singleton && pen.calculative.singleton.div) {
    pen.calculative.singleton.div.remove();
    let echarts = globalThis.echarts;
    echarts && echarts.dispose(pen.calculative.singleton.echart);
    delete pen.calculative.singleton.div;
    delete pen.calculative.singleton.echart;
  }
}
function echarts_move(pen) {
  pen.calculative.singleton.div && render_setElemPosition(pen, pen.calculative.singleton.div);
}
function echarts_resize(pen) {
  if (!pen.calculative.singleton.echart) {
    return;
  }
  let echarts = globalThis.echarts;
  render_setElemPosition(pen, pen.calculative.singleton.div);
  // let option = pen.echarts.option;
  // if (!pen.beforeScale) {
  //   pen.beforeScale = pen.calculative.canvas.store.data.scale;
  // }
  // let ratio: number = pen.calculative.canvas.store.data.scale / pen.beforeScale;
  // updateOption(option, ratio);
  if (pen.echarts.geoName && !echarts.getMap(pen.echarts.geoName)) return;
  pen.calculative.singleton.echart.setOption(updateOption(pen.echarts.option, pen.calculative.canvas.store.data.scale), true);
  // pen.beforeScale = pen.calculative.canvas.store.data.scale;
  pen.calculative.singleton.echart.resize();
}
function echarts_value(pen) {
  if (!pen.calculative.singleton.echart) {
    return;
  }
  render_setElemPosition(pen, pen.calculative.singleton.div);
  if (pen.calculative.singleton.echartsReady) {
    if (pen.calculative.partialOption) {
      //部分更新
      const option = pen.calculative.partialOption.echarts.option;
      pen.calculative.singleton.echart.setOption(deepClone(option));
    } else {
      pen.calculative.singleton.echart.setOption(updateOption(pen.echarts.option, pen.calculative.canvas.store.data.scale), true);
    }
  }
}
function echarts_beforeValue(pen, value) {
  pen.calculative.partialOption = null;
  if (value.echarts) {
    let echarts = globalThis.echarts;
    if (value.echarts.geoName && !echarts.getMap(value.echarts.geoName)) {
      if (value.echarts.geoJson) {
        echarts.registerMap(value.echarts.geoName, value.echarts.geoJson);
      } else if (value.echarts.geoUrl) {
        pen.calculative.singleton.echartsReady = false;
        fetch(value.echarts.geoUrl).then(e => {
          e.text().then(data => {
            if (typeof data === 'string') {
              try {
                data = JSON.parse(data);
              } catch {}
            }
            if (data.constructor !== Object && data.constructor !== Array) {
              console.warn('Invalid data:', data);
              return;
            }
            echarts.registerMap(value.echarts.geoName, data);
            pen.calculative.singleton.echartsReady = true;
            // @ts-ignore
            pen.onValue(pen);
            return false;
          });
        });
      }
    }
    // 整体传参，不做处理
    return value;
  }
  if (pen.realTimes && pen.realTimes.length) {
    const {
      xAxis,
      yAxis
    } = pen.echarts.option;
    const {
      max,
      replaceMode,
      timeFormat
    } = pen.echarts;
    let dataDotArr = []; //记录只更新一个点的数据
    let chartFlag = false;
    for (let key in value) {
      if (key.includes('echarts.option')) {
        chartFlag = true;
        let beforeV = getter(pen, key);
        if (Array.isArray(beforeV) && replaceMode === ReplaceMode.Add) {
          //追加
          beforeV.push(value[key]);
          if (max) {
            beforeV.splice(0, beforeV.length - max);
          }
          value[key] = beforeV;
          let _key = 'echarts.option.xAxis.data';
          if (Array.isArray(xAxis) && xAxis.length) {
            _key = 'echarts.option.xAxis.0.data';
          }
          let _value = getter(pen, _key);
          let _time = formatTime(timeFormat || '`${hours}:${minutes}:${seconds}`');
          _value.push(_time);
          if (max) {
            _value.splice(0, _value.length - max);
          }
          value[_key] = _value;
        }
        if (key.includes('.data.')) {
          //例如data.1 需要更新 data
          let _key = key.substring(0, key.indexOf('.data.') + 5);
          if (!dataDotArr.includes(_key)) {
            dataDotArr.push(_key);
          }
        }
      }
    }
    if (chartFlag) {
      const _value = deepClone(value);
      pen.calculative.partialOption = dotNotationToObject(_value);
      dataDotArr.forEach(key => {
        let value = getter(pen, key);
        setter(pen.calculative.partialOption, key, value);
      });
    }
    return value;
  }
  if (!value.dataX && !value.dataY) {
    return value;
  }
  // 1. 拿到老的 echarts
  const echarts = pen.echarts;
  const {
    max,
    replaceMode
  } = echarts;
  // 2. 特殊处理
  // x，y 需要判空, 此处不转换数组
  let x = value.dataX;
  let y = value.dataY;
  let dataArr = []; //记录只更新数据
  if (y) {
    dataArr.push('echarts.option.series');
  }
  const series = echarts.option.series;
  // 确认有几条线，即多折线的场景
  const length = series.length;
  const {
    xAxis,
    yAxis
  } = echarts.option;
  if (Array.isArray(xAxis) && xAxis.length > 1) {
    // 多 x 轴不考虑
    console.warn('echarts 只支持单 x 轴，多 x 轴将被忽略');
  }
  // 单 x 轴
  const oneXAxis = Array.isArray(xAxis) ? xAxis[0] : xAxis;
  const oneYAxis = Array.isArray(yAxis) ? yAxis[0] : yAxis;
  if (!replaceMode) {
    // 追加数据
    if (x) {
      // x 轴考虑只有一条
      !Array.isArray(x) && (x = [x]);
      // TODO: Y 轴是分类，x 轴是值，追加不考虑
      const xData = oneXAxis.data;
      xData.push(...x);
      // 删除开头的多余数据
      xData.splice(0, xData.length - max);
      dataArr.push('echarts.option.xAxis');
    }
    if (y) {
      if (length === 1) {
        !Array.isArray(y) && (y = [y]);
        const yData = series[0].data;
        yData.push(...y);
        // 删除开头的多余数据
        yData.splice(0, yData.length - max);
      } else {
        // 多条线
        series.forEach((serie, index) => {
          if (!Array.isArray(y[index])) {
            y[index] = [y[index]];
          }
          const yData = serie.data;
          yData.push(...y[index]);
          // 删除开头的多余数据
          yData.splice(0, yData.length - max);
        });
      }
    }
  } else if (replaceMode === ReplaceMode.Replace) {
    // 替换部分数据
    if (!oneXAxis && !oneYAxis) {
      /**
       * 饼图、仪表盘等
       */
      if (y) {
        if (length === 1) {
          !Array.isArray(y) && (y = [y]);
          // 单饼
          y.forEach((yItem, index) => {
            const part = series[0].data.find(part => part.name === yItem.name);
            part && (part.value = yItem.value);
          });
        } else {
          // 多饼图
          series.forEach((serie, index) => {
            if (!Array.isArray(y[index])) {
              y[index] = [y[index]];
            }
            y[index].forEach((yItem, index) => {
              const part = serie.data.find(part => part.name === yItem.name);
              part && (part.value = yItem.value);
            });
          });
        }
      }
    } else if (oneXAxis.type === 'category' || oneYAxis.type === 'category') {
      /**
       * dataX 中传的值用来找到对应的 y 轴值
       */
      if (x && y) {
        const categoryData = oneXAxis.type === 'category' ? oneXAxis.data : oneYAxis.data;
        !Array.isArray(x) && (x = [x]);
        !Array.isArray(y) && (y = [y]);
        if (oneXAxis.type === 'category') {
          dataArr.push('echarts.option.xAxis');
        } else {
          dataArr.push('echarts.option.yAxis');
        }
        if (length === 1) {
          y.forEach((yItem, index) => {
            const xIndex = categoryData.indexOf(x[index]);
            series[0].data[xIndex] = yItem;
          });
        } else {
          // 多条线
          series.forEach((serie, index) => {
            y[index].forEach((yItem, index) => {
              const xIndex = categoryData.indexOf(x[index]);
              serie.data[xIndex] = yItem;
            });
          });
        }
      }
    }
  } else if (replaceMode === ReplaceMode.ReplaceAll) {
    // 替换数据
    if (x) {
      // TODO: Y 轴是分类，x 轴是值，替换全部不考虑
      oneXAxis.data = x;
      oneXAxis.data.splice(0, oneXAxis.data.length - max);
      dataArr.push('echarts.option.xAxis');
    }
    if (y) {
      if (length === 1) {
        series[0].data = y;
        series[0].data.splice(0, series[0].data.length - max);
      } else {
        // 多条线
        series.forEach((serie, index) => {
          serie.data = y[index];
          serie.data.splice(0, serie.data.length - max);
        });
      }
    }
  }
  pen.calculative.partialOption = {};
  dataArr.forEach(key => {
    let value = getter(pen, key);
    setter(pen.calculative.partialOption, key, value);
  });
  delete value.dataX;
  delete value.dataY;
  return Object.assign(value, {
    echarts
  });
}
function binds(pen, values, formItem) {
  if (formItem.key !== 'dataY') {
    return;
  }
  // 1. 拿到老的 echarts
  const echarts = pen.echarts;
  const {
    xAxis,
    yAxis
  } = echarts.option;
  if (Array.isArray(xAxis) && xAxis.length > 1) {
    // 多 x 轴不考虑
    console.warn('echarts 只支持单 x 轴，多 x 轴将被忽略');
  }
  // 单 x 轴
  const oneXAxis = Array.isArray(xAxis) ? xAxis[0] : xAxis;
  const oneYAxis = Array.isArray(yAxis) ? yAxis[0] : yAxis;
  const series = echarts.option.series;
  if (!oneXAxis && !oneYAxis) {
    /**
     * 饼图、仪表盘等
     */
    const dataY = [];
    // 单个饼
    if (Array.isArray(series) && series.length === 1) {
      series[0].data.forEach(item => {
        const {
          dataId: id
        } = formItem.dataIds.find(dataId => dataId.name === item.name);
        if (id) {
          const value = values.find(value => value.dataId === id);
          if (value) {
            dataY.push({
              name: item.name,
              value: value.value
            });
          }
        }
      });
      return {
        id: pen.id,
        dataY
      };
    } else {
      // TODO: 多个饼待考虑
    }
  } else if (oneXAxis.type === 'category' || oneYAxis.type === 'category') {
    // 根据 x 轴的类型排序 dataY
    const dataY = [],
      dataX = [];
    const categoryData = oneXAxis.type === 'category' ? oneXAxis.data : oneYAxis.data;
    categoryData?.forEach(category => {
      const {
        dataId: id
      } = formItem.dataIds.find(dataId => dataId.name === category);
      if (id) {
        const value = values.find(value => value.dataId === id);
        if (value) {
          dataX.push(category);
          dataY.push(value.value);
        }
      }
    });
    return {
      id: pen.id,
      dataY,
      dataX
    };
  } else if (oneXAxis.type === 'time') {
    // TODO: Y 轴时间不考虑
    // x 轴时间
    const dataY = [];
    const now = +new Date();
    let hasValue = false;
    series.forEach((serie, index) => {
      const oneDataY = [];
      const {
        dataId: id
      } = formItem.dataIds.find(dataId => dataId.name === serie.name);
      if (id) {
        const value = values.find(value => value.dataId === id);
        if (value) {
          oneDataY.push([now, value.value]);
          hasValue = true;
        }
      }
      dataY[index] = oneDataY;
    });
    if (hasValue) {
      // 说明有线有值，无值的线补充一个原值，保证每条线每个时间点都有值
      dataY.forEach((oneDataY, index) => {
        if (!oneDataY || oneDataY.length === 0) {
          const last = series[index].data[series[index].data.length - 1];
          // series[index].data.at(-1) 92 版本 chrome 才支持
          // 0 时间， 1 值
          dataY[index] = [[now, last[1]]];
        }
      });
    } else {
      return;
    }
    return {
      id: pen.id,
      dataY: dataY.length === 1 ? dataY[0] : dataY
    };
  }
  return;
}
/**
 * 配置 echarts option, 并修改 replaceMode
 * @param pen 当前画笔
 * @param ids 绑定 id 数组
 * @param isTime 是否实时，用于折线图与柱状图，若实时多条线
 * @param isYCategory 是否 Y 轴为 category，用于折线图与柱状图
 */
function setEchartsOption(pen, ids, isTime = false, isYCategory = false) {
  if (pen.name !== 'echarts') {
    console.warn('当前画笔不是 echarts');
    return;
  }
  // 该画笔类型是 echarts
  const echarts = pen.echarts;
  const {
    xAxis,
    yAxis
  } = echarts.option;
  // 单 x 轴
  const oneXAxis = Array.isArray(xAxis) ? xAxis[0] : xAxis;
  const oneYAxis = Array.isArray(yAxis) ? yAxis[0] : yAxis;
  const series = echarts.option.series;
  if (!oneXAxis && !oneYAxis) {
    /**
     * 饼图、仪表盘等
     */
    // 单饼图
    echarts.option.legend = {};
    series[0].data = ids.map(id => {
      return {
        name: id.name,
        value: 100 // TODO: 该值为初始值
      };
    });
  } else {
    if (isTime) {
      // TODO: 时间类型，只可以 x 轴是时间
      // x 轴时间
      const yType = series[0].type; // 类型，折线或柱状
      const now = +new Date();
      // x 轴时间，若选择多个，即为多线图
      oneXAxis.type = 'time';
      oneXAxis.data = [];
      oneYAxis.type = 'value';
      oneYAxis.data = [];
      echarts.option.legend = {};
      echarts.option.series = ids.map(id => {
        return {
          name: id.name,
          type: yType,
          data: [[now, 0]] // TODO: 初始值
        };
      });
      echarts.replaceMode = ReplaceMode.Add; // 追加
    } else {
      // x 轴分类，或 y 轴分类
      const [categoryAxis, valueAxis] = isYCategory ? [oneYAxis, oneXAxis] : [oneXAxis, oneYAxis];
      categoryAxis.type = 'category';
      categoryAxis.data = ids.map(id => id.name);
      valueAxis.type = 'value';
      valueAxis.data = [];
      series.length = 1;
      series[0].data.length = ids.length;
      echarts.replaceMode = ReplaceMode.Replace; // 替换
    }
  }
  const meta2d = pen.calculative.canvas.parent;
  meta2d.setValue({
    id: pen.id,
    echarts
  }, {
    render: false,
    doEvent: false
  });
}
function onRenderPenRaw(pen) {
  const img = new Image();
  img.src = pen.calculative.singleton?.echart?.getDataURL({
    pixelRatio: 2
  });
  pen.calculative.img = img;
}
function updateOption(_option, ratio) {
  const option = deepClone(_option);
  // if (option.grid) {
  //   let props = ['top', 'bottom', 'left', 'right'];
  //   for (let i = 0; i < props.length; i++) {
  //     if (Array.isArray(option.grid)) {
  //       option.grid.forEach((item) => {
  //         if (!isNaN(item[props[i]])) {
  //           item[props[i]] *= ratio;
  //         }
  //       });
  //     } else {
  //       if (!isNaN(option.grid[props[i]])) {
  //         option.grid[props[i]] *= ratio;
  //       }
  //     }
  //   }
  // }
  if (option.dataZoom) {
    let props = ['right', 'top', 'width', 'height', 'left', 'bottom'];
    for (let i = 0; i < props.length; i++) {
      option.dataZoom.forEach(item => {
        if (!isNaN(item[props[i]])) {
          item[props[i]] *= ratio;
        }
      });
    }
  }
  deepSetValue(option, keyWords, ratio);
  return option;
}
function dotNotationToObject(dotNotationObj) {
  const result = {};
  Object.keys(dotNotationObj).forEach(dotNotationStr => {
    const keys = dotNotationStr.split('.');
    let current = result;
    keys.forEach((key, index) => {
      const isArrayIndex = !isNaN(parseInt(key));
      // 如果是最后一个 key，直接赋值
      if (index === keys.length - 1) {
        if (isArrayIndex) {
          if (!Array.isArray(current)) {
            current = [];
          }
          current[parseInt(key)] = dotNotationObj[dotNotationStr];
        } else {
          current[key] = dotNotationObj[dotNotationStr];
        }
      } else {
        if (isArrayIndex) {
          const arrayIndex = parseInt(key);
          if (!Array.isArray(current)) {
            if (!current[keys[index - 1]]) {}
          }
          if (!current[arrayIndex]) {
            current[arrayIndex] = {};
          }
          if (Array.isArray(current)) {
            //series 空数组问题
            for (let i = 0; i < parseInt(key); i++) {
              if (!current[i]) {
                current[i] = {};
              }
            }
          }
          current = current[arrayIndex];
        } else {
          if (!current[key]) {
            if (key === 'series') {
              current[key] = [];
            } else {
              current[key] = {};
            }
          }
          current = current[key];
        }
      }
    });
  });
  return result;
}
;// ./node_modules/@kyvi/chart-drag/src/highcharts.js



// TODO: 只引入 Chart 作为类型，开发时使用，上传需注释
// import { Chart } from 'highcharts';
function highcharts_highcharts(pen) {
  const Highcharts = globalThis.Highcharts;
  if (!Highcharts) {
    return;
  }
  if (typeof pen.highcharts === 'string') {
    try {
      pen.highcharts = JSON.parse(pen.highcharts.option);
    } catch (e) {}
  }
  if (!pen.highcharts) {
    return;
  }
  if (!pen.onDestroy) {
    pen.onDestroy = highcharts_destory;
    pen.onMove = highcharts_move;
    pen.onResize = highcharts_resize;
    pen.onRotate = highcharts_move;
    pen.onValue = highcharts_value;
    pen.onBeforeValue = highcharts_beforeValue;
    pen.onRenderPenRaw = highcharts_onRenderPenRaw;
  }
  if (!pen.calculative.singleton) {
    pen.calculative.singleton = {};
  }
  const path = new Path2D();
  const worldRect = pen.calculative.worldRect;
  if (!pen.calculative.singleton.div) {
    // 1. 创建父容器
    const div = document.createElement('div');
    div.style.position = 'absolute';
    div.style.outline = 'none';
    div.style.left = '-9999px';
    div.style.top = '-9999px';
    div.style.width = worldRect.width + 'px';
    div.style.height = worldRect.height + 'px';
    div.style.minWidth = '100px';
    div.style.minHeight = '100px';
    div.id = pen.id;
    document.body.appendChild(div);
    pen.calculative.singleton.div = div;
    setTimeout(() => {
      pen.calculative.singleton.highchart = Highcharts.chart(pen.id, pen.highcharts.option);
      //TODO 只有第一次的时候的资源
      const xml = pen.calculative.singleton.highchart.getSVG();
      const image = new Image();
      image.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(xml)));
      pen.calculative.img = image;
    });
    // 4. 加载到div layer
    pen.calculative.canvas.externalElements?.parentElement.appendChild(div);
    setElemPosition(pen, div);
  }
  // path.rect(worldRect.x, worldRect.y, worldRect.width, worldRect.height);
  if (pen.calculative.patchFlags && pen.calculative.singleton.div) {
    setElemPosition(pen, pen.calculative.singleton.div);
  }
  return path;
}
function highcharts_destory(pen) {
  if (pen.calculative.singleton && pen.calculative.singleton.div) {
    pen.calculative.singleton.div.remove();
    pen.calculative.singleton.highchart.destroy();
    delete pen.calculative.singleton.div;
    delete pen.calculative.singleton.highchart;
  }
}
function highcharts_move(pen) {
  if (!pen.calculative.singleton.div) {
    return;
  }
  setElemPosition(pen, pen.calculative.singleton.div);
}
function highcharts_resize(pen) {
  if (!pen.calculative.singleton.div) {
    return;
  }
  setElemPosition(pen, pen.calculative.singleton.div);
  setTimeout(() => {
    pen.calculative.singleton.highchart.reflow();
  }, 100);
}
function highcharts_value(pen) {
  if (!pen.calculative.singleton.div) {
    return;
  }
  setElemPosition(pen, pen.calculative.singleton.div);
}
function highcharts_beforeValue(pen, value) {
  if (value.highcharts) {
    const chart = pen.calculative.singleton.highchart;
    chart.update(value.highcharts.option);
    return value;
  } else if (!value.dataX && !value.dataY) {
    return value;
  }
  // 1. 拿到老的 echarts
  const highcharts = pen.highcharts;
  const max = highcharts.max; // 特殊处理，值不超过 max
  // 2. 特殊处理
  let x = value.dataX;
  let y = value.dataY;
  // 确认有几条线，即多折线的场景
  const length = highcharts.option.series.length;
  if (!value.overwrite) {
    // 追加数据
    // xs ys 适用与 addPoint
    let xs = [];
    // // [0] 是第一条线； [1] 是第二条线
    let ys = null;
    let isCategory = false;
    if (x) {
      // x 轴考虑只有一条
      if (!Array.isArray(x)) {
        x = [x];
      }
      // xAxis 存在数组的情况，只考虑 单 x 轴的情况
      const xAxis = highcharts.option.xAxis;
      const xData = Array.isArray(xAxis) ? xAxis[0].categories : xAxis.categories;
      if (xData) {
        // categories 存在，手动添加 category
        // 只更改数据，不更新视图
        xData.push(...x);
        // 删除开头的多余数据
        xData.splice(0, xData.length - max);
        isCategory = true;
      }
      // 记录 x ，后续用来更新视图
      xs = [...x];
    }
    if (y) {
      if (length === 1) {
        if (!Array.isArray(y)) {
          y = [y];
        }
        ys = [y];
      } else {
        // 多条线
        ys = [];
        highcharts.option.series.forEach((serie, index) => {
          if (!Array.isArray(y[index])) {
            y[index] = [y[index]];
          }
          ys.push(y[index]);
        });
      }
    }
    if (ys) {
      const chart = pen.calculative.singleton.highchart;
      chart.series.forEach((serie, index) => {
        ys[index].forEach((y, index2) => {
          let shift = false; // 是否扔掉第一个
          if (max && serie.data.length >= max) {
            shift = true;
          }
          const point = isCategory || xs[index2] == undefined ? y : [xs[index2], y];
          serie.addPoint(point, true, shift);
        });
      });
    }
  } else {
    // 替换数据
    if (x) {
      highcharts.option.xAxis.categories = x;
      highcharts.option.xAxis.categories.splice(0, highcharts.option.xAxis.categories.length - max);
    }
    if (y) {
      if (length === 1) {
        highcharts.option.series[0].data = y;
        highcharts.option.series[0].data.splice(0, highcharts.option.series[0].data.length - max);
      } else {
        // 多条线
        highcharts.option.series.forEach((serie, index) => {
          serie.data = y[index];
          serie.data.splice(0, serie.data.length - max);
        });
      }
    }
    // 更新视图
    const chart = pen.calculative.singleton.highchart;
    chart.update(highcharts.option);
  }
  // 3. 设置完后，清空
  delete value.dataX;
  delete value.dataY;
  delete value.overwrite;
  return Object.assign(value, {
    highcharts
  });
}
function highcharts_onRenderPenRaw(pen) {
  if (!pen.calculative?.singleton) {
    return;
  }
  const xml = pen.calculative.singleton.highchart.getSVG();
  const image = new Image();
  image.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(xml)));
  pen.calculative.img = image;
}
;// ./node_modules/@kyvi/chart-drag/src/LightningChart.js


function LightningChart_lightningCharts(pen) {
  let lightningChart = globalThis.lcjs;
  if (!pen.lightningCharts || !lightningChart) {
    return;
  }
  if (typeof pen.lightningCharts === 'string') {
    try {
      pen.lightningCharts = JSON.parse(pen.lightningCharts);
    } catch (e) {}
  }
  if (!pen.lightningCharts) {
    return;
  }
  if (!pen.onDestroy) {
    pen.onDestroy = LightningChart_destory;
    pen.onMove = LightningChart_move;
    pen.onResize = LightningChart_resize;
    pen.onRotate = LightningChart_move;
    pen.onValue = LightningChart_value;
    pen.onRenderPenRaw = LightningChart_onRenderPenRaw;
  }
  const path = new Path2D();
  const worldRect = pen.calculative.worldRect;
  if (!pen.calculative.singleton) {
    pen.calculative.singleton = {};
  }
  if (!pen.calculative.singleton.div) {
    // 1. 创建父容器
    const div = document.createElement('div');
    div.style.position = 'absolute';
    div.style.outline = 'none';
    div.style.left = '-9999px';
    div.style.top = '-9999px';
    div.style.width = worldRect.width + 'px';
    div.style.height = worldRect.height + 'px';
    div.id = pen.id;
    document.body.appendChild(div);
    pen.calculative.singleton.div = div;
    setTimeout(() => {
      setLightningCharts(pen);
    }, 100);
    // 加载到div layer
    setTimeout(() => {
      pen.calculative.canvas.externalElements && pen.calculative.canvas.externalElements.parentElement.appendChild(div);
      setElemPosition(pen, div);
      const img = new Image();
      img.src = pen.calculative.singleton.div.children[0].toDataURL();
      pen.calculative.img = img;
    }, 400);
  }
  // path.rect(worldRect.x, worldRect.y, worldRect.width, worldRect.height);
  if (pen.calculative.patchFlags && pen.calculative.singleton.div) {
    setElemPosition(pen, pen.calculative.singleton.div);
  }
  return path;
}
//将16进制格式和rgb格式转化为数字数组
function colorRgb(bcolor) {
  let color = bcolor.toLowerCase();
  const pattern = /^#([0-9|a-f]{3}|[0-9|a-f]{6})$/;
  const pattern2 = /rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/;
  if (color && pattern.test(color)) {
    if (color.length == 4) {
      // 将三位转换为六位
      color = '#' + color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
    }
    //处理六位的颜色值
    var colorNew = [];
    for (var i = 1; i < 7; i += 2) {
      colorNew.push(parseInt('0x' + color.slice(i, i + 2)));
    }
    return colorNew; //.join(',');
  } else if (color && pattern2.test(color)) {
    const first = color.match(/\(([^)]*)\)/)[1];
    let arr = first.split(',').map(item => {
      return parseInt(item);
    });
    return arr;
  }
  return color;
}
function setLightningCharts(pen) {
  const {
    lightningChart,
    PieChartTypes,
    LegendBoxBuilders,
    SliceLabelFormatters,
    Themes,
    GaugeChartTypes,
    SolidLine,
    SolidFill,
    ColorRGBA,
    UIOrigins,
    emptyLine,
    AutoCursorModes,
    AxisScrollStrategies,
    AxisTickStrategies,
    UIElementBuilders
  } = lcjs;
  const data = pen.lightningCharts.option.data;
  const title = pen.lightningCharts.option.title || 'Title';
  const theme = Themes[pen.lightningCharts.option.theme || 'lightNew'];
  pen.calculative.singleton.lightningChart = lightningChart();
  switch (pen.lightningCharts.option.type) {
    case 'line':
      const charts = pen.calculative.singleton.lightningChart.ChartXY({
        container: pen.id
      }).setTitle(title);
      data.forEach(item => {
        charts.addLineSeries().setName(item.name).add(item.data);
      });
      //   pen.calculative.singleton.lightningChart = charts;
      break;
    case 'bar':
      const lc = pen.calculative.singleton.lightningChart;
      let barChart;
      {
        barChart = options => {
          const figureThickness = 10;
          const figureGap = figureThickness * 0.25;
          const groupGap = figureGap * 3.0;
          const groups = [];
          const categories = [];
          const chart = lc.ChartXY(options).setTitle(title).setAutoCursorMode(AutoCursorModes.onHover).setMouseInteractions(false).setPadding({
            bottom: 30
          });
          const axisX = chart.getDefaultAxisX().setMouseInteractions(false).setScrollStrategy(undefined).setTickStrategy(AxisTickStrategies.Empty);
          const axisY = chart.getDefaultAxisY().setMouseInteractions(false).setTitle(pen.lightningCharts.option.yTitle).setInterval(0, 70).setScrollStrategy(AxisScrollStrategies.fitting);
          chart.setAutoCursor(cursor => cursor.disposePointMarker().disposeTickMarkerX().disposeTickMarkerY().setGridStrokeXStyle(emptyLine).setGridStrokeYStyle(emptyLine).setResultTable(table => {
            table.setOrigin(UIOrigins.CenterBottom);
          }));
          const createSeriesForCategory = category => {
            const series = chart.addRectangleSeries();
            series.setCursorResultTableFormatter((builder, series, figure) => {
              let entry = {
                name: category.name,
                value: category.data[category.figures.indexOf(figure)]
              };
              return builder.addRow('Department:', entry.name).addRow('# of employees:', String(entry.value));
            });
            return series;
          };
          const legendBox = chart.addLegendBox(LegendBoxBuilders.VerticalLegendBox).setAutoDispose({
            type: 'max-width',
            maxWidth: 0.2
          });
          const redraw = () => {
            let x = 0;
            for (let groupIndex = 0; groupIndex < groups.length; groupIndex++) {
              const group = groups[groupIndex];
              const xStart = x;
              for (const category of categories) {
                const value = category.data[groupIndex];
                if (value !== undefined) {
                  const figure = category.figures[groupIndex];
                  figure.setDimensions({
                    x,
                    y: 0,
                    width: figureThickness,
                    height: value
                  });
                  x += figureThickness + figureGap;
                }
              }
              group.tick.setValue((xStart + x - figureGap) / 2);
              x += groupGap;
            }
            axisX.setInterval(-(groupGap + figureGap), x);
          };
          const addGroups = names => {
            for (const name of names) groups.push({
              name,
              tick: axisX.addCustomTick(UIElementBuilders.AxisTick).setGridStrokeLength(0).setTextFormatter(_ => name)
            });
          };
          const addCategory = entry => {
            const series = createSeriesForCategory(entry).setName(entry.name);
            entry.figures = entry.data.map(value => series.add({
              x: 0,
              y: 0,
              width: 0,
              height: 0
            }));
            legendBox.add(series);
            categories.push(entry);
            redraw();
          };
          return {
            addCategory,
            addGroups
          };
        };
      }
      const chart = barChart({
        theme,
        container: pen.id
      });
      chart.addGroups(pen.lightningCharts.option.groups);
      const categories = pen.lightningCharts.option.categories;
      data.forEach((data, i) => chart.addCategory({
        name: categories[i],
        data
      }));
      //   pen.calculative.singleton.lightningChart = chart;
      break;
    case 'pie':
      const pie = pen.calculative.singleton.lightningChart.Pie({
        theme,
        container: pen.id
      }).setTitle(title).setAnimationsEnabled(true).setMultipleSliceExplosion(true);
      const slices = data.map(item => pie.addSlice(item.name, item.value));
      pie.setInnerRadius(pen.lightningCharts.option.innerRadius || 0).setLabelFormatter(SliceLabelFormatters.NamePlusRelativeValue);
      pie.addLegendBox(LegendBoxBuilders.VerticalLegendBox).setAutoDispose({
        type: 'max-width',
        maxWidth: 0.3
      }).add(pie);
      //   pen.calculative.singleton.lightningChart = pie;
      break;
    case 'gauge':
      const gauge = pen.calculative.singleton.lightningChart.Gauge({
        theme,
        container: pen.id
      }).setTitle(title).setThickness(20).setAngleInterval(pen.lightningCharts.option.startAngle || 225, pen.lightningCharts.option.endAngle || -45);
      let colorArry = colorRgb(pen.lightningCharts.option.background);
      const slice = gauge.getDefaultSlice().setInterval(pen.lightningCharts.option.min || 0, pen.lightningCharts.option.max || 100).setValue(data).setFillStyle(new SolidFill({
        color: ColorRGBA(colorArry[0], colorArry[1], colorArry[2])
      }));
      //   pen.calculative.singleton.lightningChart = gauge;
      break;
  }
}
function LightningChart_destory(pen) {
  if (pen.calculative.singleton && pen.calculative.singleton.div) {
    pen.calculative.singleton.div.remove();
    // pen.calculative.singleton.lightningChart.destory();
    delete pen.calculative.singleton.div;
    delete pen.calculative.singleton.lightningChart;
  }
}
function LightningChart_move(pen) {
  if (!pen.calculative.singleton.div) {
    return;
  }
  setElemPosition(pen, pen.calculative.singleton.div);
}
function LightningChart_resize(pen) {
  if (!pen.calculative.singleton.div) {
    return;
  }
  setElemPosition(pen, pen.calculative.singleton.div);
}
function LightningChart_value(pen) {
  if (!pen.calculative.singleton.div) {
    return;
  }
  setLightningCharts(pen);
  setElemPosition(pen, pen.calculative.singleton.div);
}
function LightningChart_onRenderPenRaw(pen) {
  if (!pen.calculative?.singleton) {
    return;
  }
  const img = new Image();
  img.src = pen.calculative.singleton.div.children[0].toDataURL();
  pen.calculative.img = img;
}
;// ./node_modules/@kyvi/chart-drag/src/register.js




function register_register(_echarts) {
  _echarts && (globalThis.echarts = _echarts);
  register({
    echarts: echarts
  });
}
function registerHighcharts(_highcharts) {
  _highcharts && (globalThis.Highcharts = _highcharts);
  meta2dRegister({
    highcharts
  });
}
function registerLightningChart(_lightningCharts) {
  _lightningCharts && (globalThis.lcjs = _lightningCharts);
  meta2dRegister({
    lightningCharts
  });
}
;// ./node_modules/@kyvi/chart-drag/index.js




;// ./node_modules/@kyvi/form-drag/src/table.js


function table(ctx, pen) {
  if (!pen.onAdd) {
    pen.onAdd = table_onAdd;
    pen.onMouseMove = onMouseMove;
    pen.onMouseLeave = onMouseLeave;
    pen.onMouseDown = onMouseDown;
    pen.onShowInput = onShowInput;
    pen.onInput = onInput;
    pen.onValue = onValue;
    pen.onBeforeValue = table_beforeValue;
  }
  const data = pen.calculative.canvas.store.data;
  const options = pen.calculative.canvas.store.options;
  pen.color = pen.color || data.color || options.color;
  pen.activeColor = pen.activeColor || options.activeColor;
  pen.hoverColor = pen.hoverColor || options.hoverColor;
  pen.activeBackground = pen.activeBackground || options.activeBackground;
  pen.hoverBackground = pen.hoverBackground || options.hoverBackground;
  // 画网格线
  drawGridLine(ctx, pen);
  // 画单元格
  drawCell(ctx, pen);
}
function initRect(pen) {
  const colPos = [];
  const rowPos = [];
  if (!pen.table.rowHeight) {
    pen.table.rowHeight = 40;
  }
  if (!pen.table.colWidth) {
    pen.table.colWidth = 150;
  }
  let width = 0;
  for (const item of pen.table.header.data) {
    width += item.width || pen.table.colWidth;
    colPos.push(width);
  }
  let height = 0;
  // 显示表头
  if (pen.table.header.show != false) {
    height += pen.table.header.height || pen.table.rowHeight;
    rowPos.push(height);
  }
  for (const item of pen.table.data) {
    height += item.height || pen.table.rowHeight;
    rowPos.push(height);
  }
  pen.colPos = colPos;
  pen.rowPos = rowPos;
  pen.tableWidth = width;
  pen.tableHeight = height;
  if (!pen.width) {
    pen.width = width;
    pen.height = height;
    pen.calculative.width = width;
    pen.calculative.height = height;
    pen.calculative.worldRect = {
      x: pen.x,
      y: pen.y,
      height: pen.height,
      width: pen.width
    };
    calcRightBottom(pen.calculative.worldRect);
  }
}
function drawGridLine(ctx, pen) {
  if (!pen.colPos) {
    return;
  }
  const worldRect = pen.calculative.worldRect;
  ctx.save();
  ctx.strokeStyle = pen.color;
  // 绘画最外框
  ctx.beginPath();
  ctx.rect(worldRect.x, worldRect.y, worldRect.width, worldRect.height);
  if (pen.background) {
    ctx.fillStyle = pen.background;
    ctx.fill();
  }
  ctx.stroke();
  // 绘画行的线
  let last = pen.rowPos[pen.rowPos.length - 1];
  for (const item of pen.rowPos) {
    if (item === last) {
      continue;
    }
    const y = item * pen.calculative.worldRect.height / pen.tableHeight;
    ctx.beginPath();
    ctx.moveTo(pen.calculative.worldRect.x, pen.calculative.worldRect.y + y);
    ctx.lineTo(pen.calculative.worldRect.ex, pen.calculative.worldRect.y + y);
    ctx.stroke();
  }
  // 绘画列的线
  last = pen.colPos[pen.colPos.length - 1];
  pen.colPos.forEach((item, i) => {
    if (item === last) {
      return;
    }
    const x = item * pen.calculative.worldRect.width / pen.tableWidth;
    ctx.beginPath();
    ctx.moveTo(pen.calculative.worldRect.x + x, pen.calculative.worldRect.y);
    ctx.lineTo(pen.calculative.worldRect.x + x, pen.calculative.worldRect.ey);
    ctx.stroke();
  });
  ctx.restore();
}
function drawCell(ctx, pen) {
  if (!pen.colPos) {
    return;
  }
  if (!pen.calculative.texts) {
    pen.calculative.texts = [];
  }
  // const textScale = Math.min(
  //   pen.calculative.worldRect.width / pen.tableWidth,
  //   pen.calculative.worldRect.height / pen.tableHeight
  // );
  const textScale = 1;
  for (let i = 0; i < pen.rowPos.length; i++) {
    for (let j = 0; j < pen.colPos.length; j++) {
      let cell = getCell(pen, i, j);
      let color = cell.color || pen.color;
      let background = cell.background;
      let activeColor;
      // 选中
      if (pen.calculative.activeCell?.row === i && pen.calculative.activeCell?.col === j) {
        color = pen.activeColor;
        background = pen.activeBackground;
        activeColor = color;
      }
      // hover
      if (pen.calculative.hoverCell?.row === i && pen.calculative.hoverCell?.col === j) {
        color = pen.hoverColor;
        background = pen.hoverBackground;
        activeColor = color;
      }
      const rect = getCellRect(pen, i, j);
      // 有背景
      if (background) {
        ctx.save();
        ctx.fillStyle = background;
        ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
        ctx.restore();
      }
      // 选中或hover
      if (activeColor) {
        ctx.save();
        ctx.strokeStyle = activeColor;
        ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
        ctx.restore();
      }
      // 绘画文本
      pen.calculative.worldTextRect = rect;
      let rowText = pen.calculative.texts[i];
      if (!pen.calculative.texts[i]) {
        rowText = [];
        pen.calculative.texts.push(rowText);
      }
      if (rowText[j] == null) {
        if (Array.isArray(cell)) {
          rowText[j] = '';
          //子节点创建后无需再计算位置
          if (!cell[0].id) {
            calcChildrenRect(pen, rect, cell);
            pen.calculative.canvas.parent.pushChildren(pen, cell);
          }
          continue;
        } else {
          rowText[j] = cell.text || cell + '';
        }
        if (!rowText[j]) {
          continue;
        }
        // 计算换行和省略号
        rowText[j] = calcTextLines(pen, rowText[j]);
      }
      if (!rowText[j]) {
        continue;
      }
      ctx.save();
      ctx.fillStyle = color;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = (pen.calculative.fontStyle || '') + ' normal ' + (pen.calculative.fontWeight || '') + ' ' + (pen.calculative.fontSize || 12) * textScale + 'px ' + pen.calculative.fontFamily;
      if (rowText[j].length === 1) {
        ctx.fillText(rowText[j][0], rect.x + rect.width / 2, rect.y + rect.height / 2);
      } else {
        const y = 0.55;
        const lineHeight = pen.calculative.fontSize * pen.calculative.lineHeight * textScale;
        const h = rowText[j].length * lineHeight;
        let top = (rect.height - h) / 2;
        rowText[j].forEach((text, i) => {
          ctx.fillText(text, rect.x + rect.width / 2, rect.y + top + (i + y) * lineHeight);
        });
      }
      ctx.restore();
    }
  }
}
// 添加table节点回调
function table_onAdd(pen) {
  initRect(pen);
}
function onShowInput(pen, e) {
  // 没有活动单元格
  if (!pen.calculative.hoverCell) {
    return;
  }
  const cell = getCell(pen, pen.calculative.hoverCell.row, pen.calculative.hoverCell.col);
  // 子节点，非文本
  if (Array.isArray(cell)) {
    return;
  }
  pen.calculative.inputCell = pen.calculative.hoverCell;
  const rect = getCellRect(pen, pen.calculative.hoverCell.row, pen.calculative.hoverCell.col);
  pen.calculative.tempText = cell.text || cell + '';
  pen.calculative.canvas.showInput(pen, rect, '#ffffff');
}
//将输入的数据写入到对应的data中
function onInput(pen, text) {
  if (!pen.calculative.inputCell) {
    return;
  }
  setCellText(pen, pen.calculative.inputCell.row, pen.calculative.inputCell.col, text);
  pen.calculative.canvas.render();
}
function onMouseMove(pen, e) {
  pen.calculative.hoverCell = getCellIndex(pen, e);
  pen.calculative.canvas.render();
}
function onMouseLeave(pen, e) {
  pen.calculative.hoverCell = undefined;
  pen.calculative.canvas.render();
}
function onMouseDown(pen, e) {
  pen.calculative.activeCell = getCellIndex(pen, e);
  pen.calculative.canvas.render();
}
// 根据坐标，计算在哪个cell
function getCellIndex(pen, e) {
  const scaleX = pen.calculative.worldRect.width / pen.tableWidth;
  const scaleY = pen.calculative.worldRect.height / pen.tableHeight;
  const pos = {
    row: 0,
    col: 0
  };
  for (let i = 0; i < pen.colPos.length; i++) {
    if (e.x > pen.calculative.worldRect.x + pen.colPos[i] * scaleX) {
      pos.col = i + 1;
    }
  }
  for (let i = 0; i < pen.rowPos.length; i++) {
    if (e.y > pen.calculative.worldRect.y + pen.rowPos[i] * scaleY) {
      pos.row = i + 1;
    }
  }
  return pos;
}
// 根据index获取cell
function getCell(pen, rowIndex, colIndex) {
  if (!pen.table.data || !Array.isArray(pen.table.data)) {
    return;
  }
  if (pen.table.header.show == false) {
    const row = pen.table.data[rowIndex];
    if (Array.isArray(row)) {
      return row[colIndex];
    } else if (!row.data || !Array.isArray(row.data)) {
      return;
    }
    return row.data[colIndex];
  }
  // 显示表头
  if (rowIndex === 0) {
    const cell = pen.table.header.data[colIndex];
    cell.fontWeight = pen.table.header.fontWeight;
    return cell;
  }
  const row = pen.table.data[rowIndex - 1];
  if (!row) {
    return;
  } else if (Array.isArray(row)) {
    return row[colIndex];
  } else if (!row.data || !Array.isArray(row.data)) {
    return;
  }
  return row.data[colIndex];
}
// 设置cell的文本
function setCellText(pen, rowIndex, colIndex, text) {
  if (!pen.table.data || !Array.isArray(pen.table.data)) {
    return;
  }
  //TODO 导致错误
  pen.calculative.texts = undefined;
  let rowData;
  // 没有表头
  if (pen.table.header.show == false) {
    rowData = pen.table.data[rowIndex];
    if (Array.isArray(rowData)) {
      // data: [[1,2,3],[a,b,c]]
    } else if (rowData.data && Array.isArray(rowData.data)) {
      // data: [{data:[1,2,3]}, {data:[1,2,3]}]
      rowData = rowData.data;
    }
  } else {
    // 有表头
    if (rowIndex === 0) {
      rowData = pen.table.header.data;
    } else {
      rowData = pen.table.data[rowIndex - 1];
      if (Array.isArray(rowData)) {
        // data: [[1,2,3],[a,b,c]]
      } else if (rowData.data && Array.isArray(rowData.data)) {
        // data: [{data:[1,2,3]}, {data:[1,2,3]}]
        rowData = rowData.data;
      }
    }
  }
  if (!rowData) {
    return;
  }
  if (rowData[colIndex] instanceof Object) {
    rowData[colIndex].text = text;
  } else {
    rowData[colIndex] = text;
  }
  pen.calculative.canvas.store.emitter.emit('valueUpdate', pen);
}
// 计算cell世界坐标区域
function getCellRect(pen, rowIndex, colIndex) {
  const scaleX = pen.calculative.worldRect.width / pen.tableWidth;
  const scaleY = pen.calculative.worldRect.height / pen.tableHeight;
  let x = 0;
  let ex = pen.colPos[colIndex] * scaleX;
  if (colIndex > 0) {
    x = pen.colPos[colIndex - 1] * scaleX;
  }
  let y = 0;
  let ey = pen.rowPos[rowIndex] * scaleY;
  if (rowIndex > 0) {
    y = pen.rowPos[rowIndex - 1] * scaleY;
  }
  return {
    x: pen.calculative.worldRect.x + x,
    y: pen.calculative.worldRect.y + y,
    ex: pen.calculative.worldRect.x + ex,
    ey: pen.calculative.worldRect.y + ey,
    width: ex - x,
    height: ey - y
  };
}
// 计算cell子节点的世界坐标区域
function calcChildrenRect(pen, rect, children) {
  const scaleX = pen.calculative.worldRect.width / pen.tableWidth;
  const scaleY = pen.calculative.worldRect.height / pen.tableHeight;
  // 计算子节点需要的宽高
  let height = 0;
  let lastX = 0;
  let lastY = 0;
  for (const item of children) {
    if (lastX + item.width * scaleX + 20 * scaleX < rect.width) {
      item.x = rect.x + lastX + 10 * scaleX;
      item.y = rect.y + lastY + 10 * scaleY;
      lastX += (item.width + 10) * scaleX;
      height = Math.max(height, lastY + (item.height + 10) * scaleY);
    } else {
      // 超出需要换行
      lastX = 0;
      lastY = height;
      item.x = rect.x + lastX + 10 * scaleX;
      item.y = rect.y + lastY + 10 * scaleY;
      height += (item.height + 10) * scaleY;
    }
  }
  // 垂直居中
  if (height + 20 * scaleY < rect.height) {
    const top = (rect.height - height - 10 * scaleY) / 2;
    for (const item of children) {
      item.y += top;
    }
  }
}
function onValue(pen) {
  pen.calculative.texts = undefined;
}
function table_beforeValue(pen, value) {
  if (value.table || value.col == undefined && value.row == undefined) {
    // 整体传参，不做处理
    return value;
  }
  setCellText(pen, value.row, value.col, value.value);
  pen.calculative.canvas.render();
  delete value.col;
  delete value.row;
  return value;
}
;// ./node_modules/@kyvi/form-drag/src/common.js


var common_ReplaceMode;
(function (ReplaceMode) {
  ReplaceMode[ReplaceMode["Add"] = 0] = "Add";
  ReplaceMode[ReplaceMode["Replace"] = 1] = "Replace";
  ReplaceMode[ReplaceMode["ReplaceAll"] = 2] = "ReplaceAll";
})(common_ReplaceMode || (common_ReplaceMode = {}));
function getTextLength(text, pen) {
  const textScale = pen.calculative.worldRect.height * 14 / 16;
  const chinese = text.match(/[\u4e00-\u9fa5]/g) || '';
  const chineseLen = chinese.length;
  const width = (text.length - chineseLen) * textScale * 0.6 + chineseLen * textScale;
  return width;
}
function initOptions(pen) {
  if (pen.direction == 'horizontal') {
    const optionPos = [];
    let textLength = 0;
    const h = pen.height;
    pen.checkboxHeight = h;
    pen.options.forEach((item, index) => {
      optionPos.push(index * (40 + h) + textLength);
      textLength += getTextLength(item.text, pen);
    });
    pen.optionPos = optionPos;
    const width = optionPos.length * (40 + h) + textLength;
    pen.checkboxWidth = width;
    pen.width = width;
    pen.calculative.width = width;
    pen.calculative.worldRect = {
      x: pen.x,
      y: pen.y,
      height: pen.height,
      width: pen.width,
      center: {
        x: pen.x + pen.width / 2,
        y: pen.y + pen.height / 2
      }
    };
    rect_calcRightBottom(pen.calculative.worldRect);
  } else if (pen.direction == 'vertical') {
    if (pen.optionInterval == undefined) {
      pen.optionInterval = 20;
    }
    if (!pen.optionHeight) {
      pen.optionHeight = 20;
    }
    const optionPos = [];
    pen.options.forEach((item, index) => {
      optionPos.push(index * (pen.optionInterval + pen.optionHeight));
    });
    pen.optionPos = optionPos;
    const height = optionPos[optionPos.length - 1] + pen.optionHeight;
    pen.checkboxHeight = height;
    if (!pen.width) {
      pen.height = height;
      pen.calculative.height = height;
      pen.calculative.worldRect = {
        x: pen.x,
        y: pen.y,
        height: pen.height,
        width: pen.width,
        center: {
          x: pen.x + pen.width / 2,
          y: pen.y + pen.height / 2
        }
      };
      rect_calcRightBottom(pen.calculative.worldRect);
    }
  }
}
;// ./node_modules/@kyvi/form-drag/src/table2.js



function table2(ctx, pen) {
  if (!pen.onAdd) {
    pen.onAdd = table2_onAdd;
    if (!pen.rowPos || !pen.colPos || !pen.calculative.maxOffsetY) {
      pen.onAdd(pen);
    }
    pen.onMouseMove = table2_onMouseMove;
    pen.onMouseLeave = table2_onMouseLeave;
    pen.onMouseDown = table2_onMouseDown;
    pen.onShowInput = table2_onShowInput;
    pen.onInput = table2_onInput;
    pen.onValue = table2_onValue;
    pen.onBeforeValue = table2_beforeValue;
    pen.onMouseEnter = onMouseEnter;
    pen.onWheel = onWheel;
    pen.onDestroy = table2_onDestroy;
  }
  if (pen.data.length !== pen.rowPos.length) {
    pen.initWorldRect = null;
    pen.calculative.isUpdateData = true;
    pen.onValue(pen);
  }
  if (pen.data[0].length !== pen.colPos.length) {
    pen.initWorldRect = null;
    pen.calculative.isUpdateData = true;
    pen.onValue(pen);
  }
  const data = pen.calculative.canvas.store.data;
  const options = pen.calculative.canvas.store.options;
  pen.color = pen.color || data.color || options.color;
  pen.textColor = pen.textColor || pen.color || data.textColor || options.textColor;
  pen.activeColor = pen.activeColor || options.activeColor;
  pen.hoverColor = pen.hoverColor || options.hoverColor;
  pen.activeBackground = pen.activeBackground || options.activeBackground;
  pen.hoverBackground = pen.hoverBackground || options.hoverBackground;
  if (!pen.hasHeader) {
    ctx.save();
    ctx.beginPath();
    const {
      x,
      y,
      width,
      height
    } = pen.calculative.worldRect;
    ctx.fillStyle = '#fff0';
    ctx.rect(x - 1, y - 1, width + 2, height + 2);
    ctx.fill();
    ctx.clip();
  }
  // 画网格线
  table2_drawGridLine(ctx, pen);
  // 画单元格
  table2_drawCell(ctx, pen);
  // 画title
  drawNote(ctx, pen);
  ctx.restore();
  pen.isFirstTime = false;
}
function drawNote(ctx, pen) {
  if (!pen.calculative.hover) {
    return;
  }
  if (!pen.calculative.hoverCell) {
    return;
  }
  if (pen.calculative.isInput) {
    return;
  }
  if (!pen.calculative.isHover) {
    return;
  }
  let rect = pen.calculative.worldRect;
  let mousePos = pen.calculative.canvas.mousePos;
  if (!(mousePos.x > rect.x && mousePos.x < rect.x + rect.width && mousePos.y > rect.y && mousePos.y < rect.y + rect.height)) {
    pen.calculative.hover = false;
    pen.calculative.isHover = false;
    pen.calculative.hoverCell = undefined;
    return;
  }
  const {
    row,
    col
  } = pen.calculative.hoverCell;
  const {
    x,
    y
  } = pen.calculative.canvas.mousePos;
  if (!pen.data[row]) {
    return;
  }
  let text = pen.data[row][col];
  if (typeof text === 'object' || !text) {
    return;
  }
  ctx.save();
  ctx.beginPath();
  ctx.textAlign = 'start';
  ctx.textBaseline = 'middle';
  ctx.font = ctx.font = (pen.calculative.fontStyle || '') + ' normal ' + (pen.calculative.fontWeight || '') + ' ' + (pen.calculative.fontSize || 12) + 'px ' + pen.calculative.fontFamily;
  const noteWidth = ctx.measureText(text).width;
  ctx.beginPath();
  ctx.fillStyle = '#fff';
  ctx.strokeStyle = '#000';
  ctx.moveTo(x, y);
  ctx.rect(x - 10, y, noteWidth + 20, 20);
  ctx.fill();
  ctx.stroke();
  ctx.beginPath();
  ctx.fillStyle = '#000';
  ctx.fillText(text, x, y + 10);
  ctx.restore();
}
function table2_initRect(pen) {
  const colPos = [];
  const rowPos = [];
  const colStyle = {};
  if (!pen.rowHeight) {
    pen.rowHeight = 40;
  }
  if (!pen.colWidth) {
    pen.colWidth = 150;
  }
  let width = 0;
  //获取所有col width
  const _col = pen.styles && pen.styles.filter(item => {
    return item.col !== undefined && item.row === undefined && item.width;
  });
  let _colWidthMap = {};
  _col && _col.forEach(_c => {
    _colWidthMap[_c.col] = _c.width;
  });
  for (let i = 0; i < pen.data[0].length; i++) {
    width += (_colWidthMap[i] || pen.colWidth) * pen.calculative.canvas.store.data.scale;
    colPos.push(width);
    let style = pen.styles && pen.styles.filter(item => {
      return item.col === i && item.row === undefined;
    });
    if (style) {
      colStyle[i] = style[0];
    }
  }
  let height = 0;
  //获取所有row height
  const _row = pen.styles && pen.styles.filter(item => {
    return item.col === undefined && item.row !== undefined && item.height;
  });
  let _rowHeightMap = {};
  _row && _row.forEach(_r => {
    _rowHeightMap[_r.row] = _r.height;
  });
  // 显示表头
  let finalHight = height;
  for (let j = 0; j < pen.data.length; j++) {
    height += (_rowHeightMap[j] || pen.rowHeight) * pen.calculative.canvas.store.data.scale;
    rowPos.push(height);
    if (j < pen.maxNum) {
      finalHight = height;
    }
  }
  pen.calculative.maxOffsetY = (height - finalHight) / pen.calculative.canvas.store.data.scale;
  if (pen.initWorldRect) {
    return;
  }
  pen.colPos = colPos;
  pen.rowPos = rowPos;
  pen.colStyle = colStyle;
  pen.initScale = pen.calculative.canvas.store.data.scale;
  pen.tableWidth = width;
  pen.tableHeight = finalHight || height;
  //   if (!pen.width) {
  pen.calculative.width = width;
  pen.calculative.height = finalHight || height;
  pen.calculative.width = width;
  pen.calculative.height = finalHight || height;
  if (!pen.height) {
    pen.height = pen.calculative.height;
  }
  if (!pen.width) {
    pen.width = pen.calculative.width;
  }
  let x = pen.x;
  let y = pen.y;
  if (pen.parentId) {
    let parentPen = pen.calculative.canvas.store.pens[pen.parentId];
    x = parentPen.calculative.worldRect.x + parentPen.calculative.worldRect.width * pen.x;
    y = parentPen.calculative.worldRect.y + parentPen.calculative.worldRect.height * pen.y;
  }
  pen.calculative.worldRect = {
    x,
    y,
    height: pen.calculative.height,
    width: pen.calculative.width,
    center: {
      x: pen.x + pen.calculative.width / 2,
      y: pen.y + pen.calculative.height / 2
    }
  };
  pen.width = pen.calculative.width;
  pen.height = pen.calculative.height;
  if (!pen.initWorldRect) {
    pen.initWorldRect = {
      width: pen.calculative.worldRect.width,
      height: pen.calculative.worldRect.height
    };
  }
  rect_calcRightBottom(pen.calculative.worldRect);
  //   }
}
function table2_drawGridLine(ctx, pen) {
  if (!pen.colPos) {
    return;
  }
  // const worldRect = pen.calculative.worldRect;
  const {
    x,
    y,
    width,
    height,
    ex,
    ey
  } = pen.calculative.worldRect;
  ctx.save();
  ctx.beginPath();
  ctx.strokeStyle = pen.color;
  // 绘画最外框
  // ctx.beginPath();
  // ctx.rect(worldRect.x, worldRect.y, worldRect.width, worldRect.height);
  let wr = pen.calculative.borderRadius || 0,
    hr = wr;
  if (wr < 1) {
    wr = width * wr;
    hr = height * hr;
  }
  let r = wr < hr ? wr : hr;
  if (width < 2 * r) {
    r = width / 2;
  }
  if (height < 2 * r) {
    r = height / 2;
  }
  ctx.moveTo(x + r, y);
  ctx.arcTo(ex, y, ex, ey, r);
  ctx.arcTo(ex, ey, x, ey, r);
  ctx.arcTo(x, ey, x, y, r);
  ctx.arcTo(x, y, ex, y, r);
  if (pen.background) {
    ctx.fillStyle = pen.background;
    ctx.fill();
  }
  if (pen.bordered !== false) {
    ctx.strokeStyle = pen.borderColor || '#424B61';
    ctx.stroke();
  }
  if (pen.hLine !== false) {
    // 绘画行的线
    let last = pen.rowPos[pen.rowPos.length - 1];
    if (pen.hasHeader) {
      ctx.beginPath();
      ctx.moveTo(pen.calculative.worldRect.x, pen.calculative.worldRect.y + pen.rowPos[0] * pen.calculative.worldRect.height / pen.tableHeight);
      ctx.lineTo(pen.calculative.worldRect.ex, pen.calculative.worldRect.y + pen.rowPos[0] * pen.calculative.worldRect.height / pen.tableHeight);
      ctx.strokeStyle = pen.borderColor || '#424B61';
      ctx.stroke();
    }
    for (const item of pen.rowPos) {
      if (item === last) {
        continue;
      }
      const y = item * pen.calculative.worldRect.height / pen.tableHeight - pen.offsetY * pen.calculative.canvas.store.data.scale;
      if (pen.hasHeader) {
        if (y < 0 + pen.rowPos[0] || y > pen.calculative.worldRect.height) {
          continue;
        }
      } else {
        if (y < 0 || y > pen.calculative.worldRect.height) {
          continue;
        }
      }
      ctx.beginPath();
      ctx.moveTo(pen.calculative.worldRect.x, pen.calculative.worldRect.y + y);
      ctx.lineTo(pen.calculative.worldRect.ex, pen.calculative.worldRect.y + y);
      ctx.strokeStyle = pen.borderColor || '#424B61';
      ctx.stroke();
    }
  }
  if (pen.vLine !== false) {
    // 绘画列的线
    let last = pen.colPos[pen.colPos.length - 1];
    pen.colPos.forEach((item, i) => {
      if (item === last) {
        return;
      }
      const x = item * pen.calculative.worldRect.width / pen.tableWidth;
      ctx.beginPath();
      ctx.moveTo(pen.calculative.worldRect.x + x, pen.calculative.worldRect.y);
      ctx.lineTo(pen.calculative.worldRect.x + x, pen.calculative.worldRect.ey);
      ctx.strokeStyle = pen.borderColor || '#424B61';
      ctx.stroke();
    });
  }
  ctx.restore();
}
function table2_drawCell(ctx, pen) {
  if (!pen.colPos) {
    return;
  }
  if (!pen.calculative.texts) {
    pen.calculative.texts = [];
  }
  const textScale = 1;
  for (let i = 0; i < pen.rowPos.length; i++) {
    if (pen.hasHeader && i === 1) {
      ctx.save();
      ctx.beginPath();
      const {
        x,
        y,
        width,
        height
      } = pen.calculative.worldRect;
      ctx.fillStyle = '#fff0';
      ctx.rect(x - 1, y + pen.rowPos[0] * pen.calculative.worldRect.height / pen.tableHeight - 1, width + 2, height - pen.rowPos[0] * pen.calculative.worldRect.height / pen.tableHeight + 2);
      ctx.fill();
      ctx.clip();
    }
    let {
      style: rowStyle
    } = getRow(pen, i);
    for (let j = 0; j < pen.colPos.length; j++) {
      let {
        value: cell,
        style: cellStyle
      } = table2_getCell(pen, i, j);
      let isSuccess = true;
      //样式条件成立
      if (Array.isArray(cellStyle) && cellStyle.length > 0) {
        let successIdx = 0;
        cellStyle.forEach((item, idx) => {
          if (item.wheres) {
            let success = item.wheres.every(where => {
              const fn = new Function('attr', `return attr ${where.comparison} ${where.value}`);
              return fn(cell);
            });
            if (success) {
              successIdx = idx;
            }
          }
        });
        cellStyle = cellStyle[successIdx];
      } else {
        if (cellStyle.wheres && Array.isArray(cellStyle.wheres)) {
          isSuccess = false;
          isSuccess = cellStyle.wheres.every(function (where) {
            const fn = new Function('attr', `return attr ${where.comparison} ${where.value}`);
            return fn(cell);
          });
        }
      }
      let color = pen.color;
      let textColor = pen.textColor || pen.color;
      let background = null;
      let fontSize = null;
      let fontWeight = null;
      let fontStyle = null;
      if (isSuccess) {
        color = cellStyle.color || rowStyle.color || pen.color;
        textColor = cellStyle.textColor || rowStyle.textColor || pen.textColor;
        background = cellStyle.background || rowStyle.background;
        fontSize = (cellStyle.fontSize || rowStyle.fontSize || 0) * pen.calculative.canvas.store.data.scale;
        fontWeight = cellStyle.fontWeight || rowStyle.fontWeight;
        fontStyle = cellStyle.fontStyle || rowStyle.fontStyle;
      }
      let activeColor;
      if (pen.stripe) {
        if (pen.hasHeader !== false) {
          if (i % 2 === 1) {
            background = background || pen.stripeColor || '#407FFF1F';
          }
        } else {
          if (i % 2 === 0) {
            background = background || pen.stripeColor || '#407FFF1F';
          }
        }
      }
      // 选中
      if (pen.calculative.active && pen.calculative.activeCell?.row === i && pen.calculative.activeCell?.col === j) {
        color = pen.activeColor;
        background = pen.activeBackground;
        activeColor = color;
        textColor = pen.activeTextColor || pen.activeColor;
      }
      // hover
      if (pen.calculative.hover && pen.calculative.hoverCell?.row === i && pen.calculative.hoverCell?.col === j) {
        color = pen.hoverColor;
        background = pen.hoverBackground;
        textColor = pen.hoverTextColor || pen.hoverColor;
        activeColor = color;
      }
      const rect = table2_getCellRect(pen, i, j);
      if (rect.y + rect.height < pen.calculative.worldRect.y || rect.y > pen.calculative.worldRect.height + pen.calculative.worldRect.y) {
        continue;
      }
      // 有背景
      if (background) {
        ctx.save();
        ctx.beginPath();
        ctx.fillStyle = background;
        ctx.fillRect(rect.x, rect.y, rect.width + 0.25 * pen.calculative.canvas.store.data.scale, rect.height);
        ctx.restore();
      }
      // 选中或hover
      if (activeColor) {
        ctx.save();
        ctx.beginPath();
        ctx.strokeStyle = activeColor;
        ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
        ctx.restore();
      }
      // 绘画文本
      pen.calculative.worldTextRect = rect;
      let rowText = pen.calculative.texts[i];
      if (!pen.calculative.texts[i]) {
        rowText = [];
        pen.calculative.texts.push(rowText);
      }
      if (rowText[j] == null) {
        if (typeof cell === 'object') {
          // TODO 配置 {} 代表添加节点 考虑是否有表头
          const _colPen = pen.styles && pen.styles.filter(item => {
            return item.col === j && item.row === undefined && item.pens;
          });
          if (_colPen.length > 0) {
            rowText[j] = '';
            if (pen.isFirstTime) {
              if (pen.maxNum) {
                if (pen.hasHeader && i >= pen.maxNum) {
                  cell.visible = false;
                }
              }
              let childrenPen = JSON.parse(JSON.stringify(_colPen[0].pens));
              childrenPen.forEach(item => {
                Object.assign(item, {
                  row: i,
                  col: j
                }, cell);
                item.activeBackground = item.background;
                item.hoverBackground = item.background;
                item.activeColor = item.color;
                item.hoverColor = item.color;
                item.activeTextColor = item.textColor;
                item.hoverTextColor = item.textColor;
                item.height *= pen.calculative.canvas.store.data.scale;
                item.width *= pen.calculative.canvas.store.data.scale;
              });
              table2_calcChildrenRect(pen, rect, childrenPen);
              pen.calculative.canvas.parent.pushChildren(pen, childrenPen);
            }
            continue;
          }
        } else if (cell === undefined) {
          rowText[j] = '';
        } else {
          rowText[j] = cell.text || cell + '';
        }
        if (!rowText[j]) {
          continue;
        }
        // 计算换行和省略号
        rowText[j] = text_calcTextLines(pen, rowText[j]);
      }
      if (!rowText[j]) {
        continue;
      }
      ctx.save();
      ctx.beginPath();
      ctx.fillStyle = textColor;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = (fontStyle || pen.calculative.fontStyle || '') + ' normal ' + (fontWeight || pen.calculative.fontWeight || '') + ' ' + (fontSize || pen.calculative.fontSize || 12) * textScale + 'px ' + pen.calculative.fontFamily;
      let textAlign = pen.colStyle && pen.colStyle[j]?.textAlign;
      if (textAlign) {
        ctx.textAlign = textAlign;
      }
      if (rowText[j].length === 1) {
        if (textAlign === 'left') {
          ctx.fillText(rowText[j][0], rect.x, rect.y + rect.height / 2);
        } else if (textAlign === 'right') {
          ctx.fillText(rowText[j][0], rect.x + rect.width, rect.y + rect.height / 2);
        } else {
          ctx.fillText(rowText[j][0], rect.x + rect.width / 2, rect.y + rect.height / 2);
        }
      } else {
        const y = 0.55;
        const lineHeight = (fontSize || pen.calculative.fontSize) * pen.calculative.lineHeight * textScale;
        const h = rowText[j].length * lineHeight;
        let top = (rect.height - h) / 2;
        if (textAlign === 'left') {
          rowText[j].forEach((text, i) => {
            ctx.fillText(text, rect.x, rect.y + top + (i + y) * lineHeight);
          });
        } else if (textAlign === 'right') {
          rowText[j].forEach((text, i) => {
            ctx.fillText(text, rect.x + rect.width, rect.y + top + (i + y) * lineHeight);
          });
        } else {
          rowText[j].forEach((text, i) => {
            ctx.fillText(text, rect.x + rect.width / 2, rect.y + top + (i + y) * lineHeight);
          });
        }
      }
      ctx.restore();
    }
  }
}
// 添加table节点回调
function table2_onAdd(pen) {
  createInterval(pen);
  if (!pen.children?.length) {
    pen.isFirstTime = true;
  }
  if (!pen.offsetY) {
    pen.offsetY = 0;
  }
  table2_initRect(pen);
}
function table2_onShowInput(pen, e) {
  // 没有活动单元格
  if (!pen.calculative.hoverCell) {
    return;
  }
  const {
    value: cell
  } = table2_getCell(pen, pen.calculative.hoverCell.row, pen.calculative.hoverCell.col);
  // 子节点，非文本
  if (typeof cell === 'object') {
    return;
  }
  pen.calculative.isHover = false;
  pen.calculative.isInput = true;
  pen.calculative.canvas.render();
  pen.calculative.inputCell = pen.calculative.hoverCell;
  const rect = table2_getCellRect(pen, pen.calculative.hoverCell.row, pen.calculative.hoverCell.col);
  pen.calculative.tempText = cell.text || cell + '';
  pen.calculative.canvas.showInput(pen, rect, '#ffffff');
}
//将输入的数据写入到对应的data中
function table2_onInput(pen, text) {
  if (!pen.calculative.inputCell) {
    return;
  }
  table2_setCellText(pen, pen.calculative.inputCell.row, pen.calculative.inputCell.col, text);
  pen.calculative.isInput = false;
  pen.calculative.isHover = true;
  pen.calculative.canvas.render();
}
function table2_onMouseMove(pen, e) {
  if (pen.timer) {
    pen.calculative.isHover = false;
    clearTimeout(pen.timer);
  }
  pen.timer = setTimeout(() => {
    pen.calculative.isHover = true;
    pen.calculative.canvas.render();
  }, 500);
  pen.calculative.hoverCell = table2_getCellIndex(pen, e);
  pen.calculative.canvas.render();
}
function table2_onMouseLeave(pen, e) {
  createInterval(pen);
  pen.calculative.hoverCell = undefined;
  //   pen.calculative.activeCell = undefined;
  pen.calculative.canvas.render();
}
function table2_onMouseDown(pen, e) {
  pen.calculative.activeCell = table2_getCellIndex(pen, e);
  pen.calculative.canvas.render();
}
// 根据坐标，计算在哪个cell
function table2_getCellIndex(pen, e) {
  const scaleX = pen.calculative.worldRect.width / pen.tableWidth;
  const scaleY = pen.calculative.worldRect.height / pen.tableHeight;
  const pos = {
    row: 0,
    col: 0
  };
  for (let i = 0; i < pen.colPos.length; i++) {
    if (e.x > pen.calculative.worldRect.x + pen.colPos[i] * scaleX) {
      pos.col = i + 1;
    }
  }
  for (let i = 0; i < pen.rowPos.length; i++) {
    if (e.y > pen.calculative.worldRect.y + pen.rowPos[i] * scaleY - pen.offsetY * pen.calculative.canvas.store.data.scale) {
      pos.row = i + 1;
    }
  }
  return pos;
}
// 根据index获取cell
function table2_getCell(pen, rowIndex, colIndex) {
  if (!pen.data || !Array.isArray(pen.data)) {
    return;
  }
  const row = pen.data[rowIndex];
  //TODO 没有获取单独设置 某行 某列 的样式
  const style = pen.styles && pen.styles.filter(item => {
    return item.row === rowIndex && item.col === colIndex;
  });
  if (Array.isArray(row)) {
    return {
      value: row[colIndex],
      style: style?.length > 0 ? style.length > 1 ? style : style[0] : {}
    };
  } else if (!row.data || !Array.isArray(row.data)) {
    return;
  }
}
// 根据index获取getRow
function getRow(pen, rowIndex) {
  if (!pen.data || !Array.isArray(pen.data)) {
    return;
  }
  const row = pen.data[rowIndex];
  //TODO 没有获取单独设置 某行 某列 的样式
  const style = pen.styles && pen.styles.filter(item => {
    return item.row === rowIndex && !item.col;
  });
  if (Array.isArray(row)) {
    return {
      value: row,
      style: style?.length > 0 ? style[0] : {}
    };
  } else if (!row.data || !Array.isArray(row.data)) {
    return;
  }
}
// 设置cell的文本
function table2_setCellText(pen, rowIndex, colIndex, text) {
  if (!pen.data || !Array.isArray(pen.data)) {
    return;
  }
  pen.isFirstTime = false;
  pen.calculative.texts = undefined;
  let rowData = pen.data[rowIndex];
  if (!rowData) {
    return;
  }
  if (rowData[colIndex] instanceof Object) {} else {
    rowData[colIndex] = text;
  }
  pen.calculative.canvas.store.emitter.emit('valueUpdate', pen);
}
// 计算cell世界坐标区域
function table2_getCellRect(pen, rowIndex, colIndex) {
  const scaleX = pen.calculative.worldRect.width / pen.tableWidth;
  const scaleY = pen.calculative.worldRect.height / pen.tableHeight;
  let x = 0;
  let ex = pen.colPos[colIndex] * scaleX;
  if (colIndex > 0) {
    x = pen.colPos[colIndex - 1] * scaleX;
  }
  let y = 0;
  let ey = pen.rowPos[rowIndex] * scaleY;
  if (rowIndex > 0) {
    y = pen.rowPos[rowIndex - 1] * scaleY;
  }
  let offset = pen.offsetY * pen.calculative.canvas.store.data.scale;
  if (rowIndex === 0 && pen.hasHeader) {
    offset = 0;
  }
  return {
    x: pen.calculative.worldRect.x + x,
    y: pen.calculative.worldRect.y + y - offset,
    ex: pen.calculative.worldRect.x + ex,
    ey: pen.calculative.worldRect.y + ey - offset,
    width: ex - x,
    height: ey - y
  };
}
// 计算cell子节点的世界坐标区域
function table2_calcChildrenRect(pen, rect, children) {
  if (!(children && children.length)) {
    return;
  }
  const scaleX = pen.calculative.worldRect.width / pen.tableWidth;
  const scaleY = pen.calculative.worldRect.height / pen.tableHeight;
  let resizeX = 1;
  let resizeY = 1;
  if (pen.initWorldRect) {
    if (pen.calculative.worldRect.width !== pen.initWorldRect.width) {
      resizeX = pen.calculative.worldRect.width / pen.initWorldRect.width;
    }
    if (pen.calculative.worldRect.height !== pen.initWorldRect.height) {
      resizeY = pen.calculative.worldRect.height / pen.initWorldRect.height;
    }
  }
  // 计算子节点需要的宽高
  let height = 0;
  let lastX = 0;
  let lastY = 0;
  const scale = pen.calculative.canvas.store.data.scale;
  if (children.length > 1) {
    for (const item of children) {
      if (lastX + item.width * scaleX + 20 * scale * scaleX < rect.width) {
        item.x = rect.x + lastX + 10 * scale * scaleX;
        item.y = rect.y + lastY + 10 * scale * scaleY;
        lastX += (item.width + 10 * scale) * scaleX;
        height = Math.max(height, lastY + (item.height + 10 * scale) * scaleY);
      } else {
        // 超出需要换行
        lastX = 0;
        lastY = height;
        item.x = rect.x + lastX + 10 * scale * scaleX;
        item.y = rect.y + lastY + 10 * scale * scaleY;
        height += (item.height + 10 * scale) * scaleY;
      }
    }
    // 垂直居中
    if (height + 20 * scale * scaleY < rect.height) {
      const top = (rect.height - height - 10 * scale * scaleY) / 2;
      for (const item of children) {
        item.y += top;
      }
    }
  } else {
    //一个子图元默认水平垂直居中
    children[0].x = rect.x + (rect.width - children[0].width) / 2;
    children[0].y = rect.y + (rect.height - children[0].height) / 2;
  }
  children.forEach(item => {
    item.width = item.width * resizeX;
    item.height = item.height * resizeY;
  });
}
function table2_onValue(pen) {
  if (pen.calculative.isUpdateData) {
    delete pen.calculative.isUpdateData;
    let temChildren = deepClone(pen.children);
    pen.children = [];
    table2_onAdd(pen);
    temChildren && temChildren.forEach(child => {
      pen.calculative.canvas.delForce(pen.calculative.canvas.findOne(child));
    });
    pen.calculative.texts = undefined;
    // pen.calculative.canvas.active([pen]);
  }
}
function table2_beforeValue(pen, value) {
  pen.calculative.isUpdateData = false;
  if (pen.swiper !== undefined) {
    if (pen.swiper) {
      createInterval(pen);
    } else {
      delInterval(pen);
    }
  }
  if (value.styles) {
    pen.initWorldRect = undefined;
  }
  if (value.table || value.col == undefined && value.row == undefined) {
    if (value.dataY) {
      const replaceMode = pen.replaceMode;
      let data = [];
      if (!replaceMode) {
        //追加
        data = pen.data.concat(value.dataY);
      } else if (replaceMode === common_ReplaceMode.Replace) {
        //替换
        data = pen.data;
        value.dataX && value.dataX.forEach((item, index) => {
          data[item] = value.dataY[index];
        });
      } else if (replaceMode === common_ReplaceMode.ReplaceAll) {
        //替换指定
        if (value.dataX) {
          data[0] = value.dataX;
        } else {
          data[0] = pen.data[0];
        }
        data = data.concat(value.dataY);
      }
      delete value.dataX;
      delete value.dataY;
      pen.calculative.isUpdateData = true;
      return Object.assign(value, {
        data
      });
    }
    if (value.data || value.styles || value.maxNum || value.rowHeight || value.colWidth) {
      pen.calculative.isUpdateData = true;
      pen.initWorldRect = null;
    }
    for (let key of Object.keys(value)) {
      if (key.includes('data.')) {
        pen.calculative.isUpdateData = true;
      }
    }
    return value;
  }
  let rowData = pen.data[value.row];
  if (!rowData) {
    return value;
  }
  if (rowData[value.col] instanceof Object) {} else {
    rowData[value.col] = value.value;
  }
  table2_setCellText(pen, value.row, value.col, value.value);
  pen.calculative.canvas.render();
  delete value.col;
  delete value.row;
  return value;
}
//鼠标滚动
function onWheel(pen, e) {
  if (!pen.locked && !pen.calculative.canvas.store.data.locked) {
    return;
  }
  if (!pen.maxNum) {
    return;
  }
  let offset = 0;
  if (e.deltaY > 0) {
    offset = 4;
  } else {
    offset = -4;
  }
  table2_scroll(pen, offset);
}
//滚动处理
function table2_scroll(pen, offset) {
  if (!pen.offsetY) {
    pen.offsetY = 0;
  }
  pen.offsetY += offset;
  //滚动的最大偏移值
  if (pen.offsetY > pen.calculative.maxOffsetY) {
    pen.offsetY = pen.calculative.maxOffsetY;
  }
  if (pen.offsetY < 0) {
    pen.offsetY = 0;
  }
  //子节点
  pen.children?.forEach(item => {
    const _pen = pen.calculative.canvas.store.pens[item];
    changeChildVisible(pen, _pen);
  });
  pen.calculative.canvas.render();
}
//控制子节点
function changeChildVisible(pen, _pen) {
  if (!_pen) {
    return;
  }
  if (!_pen.oldY) {
    _pen.oldY = _pen.y;
  }
  const {
    y,
    height
  } = _pen.calculative.worldRect;
  const {
    y: penY,
    height: penH
  } = pen.calculative.worldRect;
  const scale = pen.calculative.canvas.store.data.scale;
  const scaleY = pen.calculative.worldRect.height / pen.tableHeight;
  const rowHeight = pen.rowHeight; //*scale;
  //y值更新
  _pen.y = _pen.oldY - pen.offsetY * scale / pen.calculative.worldRect.height;
  const oldOffset = rowHeight * (pen.initScale || 1) / pen.tableHeight * pen.maxNum;
  pen.calculative.canvas.updatePenRect(_pen);
  if (pen.hasHeader) {
    if (_pen.y < pen.rowPos[0] / pen.tableHeight) {
      //显示/隐藏
      _pen.calculative.visible = false;
      _pen.visible = false;
      //颜色及位置更新
      if (_pen.y < pen.rowPos[0] / pen.tableHeight / 2) {
        _pen.oldY += oldOffset;
        let row = _pen.row + pen.maxNum;
        if (!pen.data[row]) {
          return;
        }
        let rowStyle = deepClone(pen.data[row][_pen.col]);
        if (rowStyle.background) {
          rowStyle.activeBackground = rowStyle.background;
          rowStyle.hoverBackground = rowStyle.background;
        }
        if (rowStyle.color) {
          rowStyle.hoverColor = rowStyle.color;
          rowStyle.activeColor = rowStyle.color;
        }
        if (rowStyle.textColor) {
          rowStyle.activeTextColor = rowStyle.textColor;
          rowStyle.hoverTextColor = rowStyle.textColor;
        }
        Object.assign(_pen, rowStyle, {
          row: row
        });
        Object.assign(_pen.calculative, rowStyle, {
          row: row
        });
      }
    } else if (_pen.y + _pen.height > 1) {
      //显示/隐藏
      _pen.calculative.visible = false;
      _pen.visible = false;
      //颜色及位置更新
      if (_pen.y + _pen.height / 2 > 1) {
        _pen.oldY -= oldOffset;
        let row = _pen.row - pen.maxNum;
        if (!pen.data[row]) {
          return;
        }
        let rowStyle = deepClone(pen.data[row][_pen.col]);
        if (rowStyle.background) {
          rowStyle.activeBackground = rowStyle.background;
          rowStyle.hoverBackground = rowStyle.background;
        }
        if (rowStyle.color) {
          rowStyle.hoverColor = rowStyle.color;
          rowStyle.activeColor = rowStyle.color;
        }
        if (rowStyle.textColor) {
          rowStyle.activeTextColor = rowStyle.textColor;
          rowStyle.hoverTextColor = rowStyle.textColor;
        }
        Object.assign(_pen, rowStyle, {
          row: row
        });
        Object.assign(_pen.calculative, rowStyle, {
          row: row
        });
      }
    } else {
      _pen.visible = true;
      _pen.calculative.visible = true;
    }
  } else {
    if (_pen.y < 0) {
      _pen.calculative.visible = false;
      _pen.visible = false;
      if (_pen.y < -rowHeight / pen.tableHeight / 2) {
        _pen.oldY += oldOffset;
        let row = _pen.row + pen.maxNum;
        if (!pen.data[row]) {
          return;
        }
        let rowStyle = deepClone(pen.data[row][_pen.col]);
        if (rowStyle.background) {
          rowStyle.activeBackground = rowStyle.background;
          rowStyle.hoverBackground = rowStyle.background;
        }
        if (rowStyle.color) {
          rowStyle.hoverColor = rowStyle.color;
          rowStyle.activeColor = rowStyle.color;
        }
        if (rowStyle.textColor) {
          rowStyle.activeTextColor = rowStyle.textColor;
          rowStyle.hoverTextColor = rowStyle.textColor;
        }
        Object.assign(_pen, rowStyle, {
          row: row
        });
        Object.assign(_pen.calculative, rowStyle, {
          row: row
        });
      }
    } else if (_pen.y + _pen.height > 1) {
      _pen.calculative.visible = false;
      _pen.visible = false;
      if (_pen.y + _pen.height / 2 > 1) {
        _pen.oldY -= oldOffset;
        let row = _pen.row - pen.maxNum;
        if (!pen.data[row]) {
          return;
        }
        let rowStyle = deepClone(pen.data[row][_pen.col]);
        if (rowStyle.background) {
          rowStyle.activeBackground = rowStyle.background;
          rowStyle.hoverBackground = rowStyle.background;
        }
        if (rowStyle.color) {
          rowStyle.hoverColor = rowStyle.color;
          rowStyle.activeColor = rowStyle.color;
        }
        if (rowStyle.textColor) {
          rowStyle.activeTextColor = rowStyle.textColor;
          rowStyle.hoverTextColor = rowStyle.textColor;
        }
        Object.assign(_pen, rowStyle, {
          row: row
        });
        Object.assign(_pen.calculative, rowStyle, {
          row: row
        });
      }
    } else {
      _pen.calculative.visible = true;
      _pen.visible = true;
    }
  }
}
function table2_onDestroy(pen) {
  delInterval(pen);
}
function delInterval(pen) {
  if (pen.interval) {
    globalThis.clearInterval(pen.interval);
    pen.interval = null;
  }
}
function createInterval(pen) {
  if (pen.maxNum && pen.swiper) {
    if (pen.interval) {
      return;
    }
    pen.interval = globalThis.setInterval(() => {
      if (pen.offsetY >= pen.calculative.maxOffsetY) {
        pen.offsetY = 0;
        initChildrenStyle(pen);
      } else {
        if (!(pen.offsetY % pen.rowHeight)) {
          //完整一行 停顿
          if (!pen.calculative.stap) {
            pen.calculative.stap = 0;
          }
          pen.calculative.stap += 1;
          if (pen.calculative.stap == 12) {
            pen.calculative.stap = 0;
            table2_scroll(pen, 1);
          }
        } else {
          table2_scroll(pen, 1);
        }
      }
    }, 50);
  }
}
function initChildrenStyle(pen) {
  pen.children?.forEach(item => {
    const rowHeight = pen.rowHeight; //*scale;
    const _pen = pen.calculative.canvas.store.pens[item];
    if (!_pen) {
      return;
    }
    const oldOffset = rowHeight * (pen.initScale || 1) / pen.tableHeight * pen.maxNum;
    _pen.oldY -= oldOffset;
    const row = _pen.row - pen.maxNum;
    if (!pen.data[row]) {
      return;
    }
    let rowStyle = deepClone(pen.data[row][_pen.col]);
    if (rowStyle.background) {
      rowStyle.activeBackground = rowStyle.background;
      rowStyle.hoverBackground = rowStyle.background;
    }
    if (rowStyle.color) {
      rowStyle.hoverColor = rowStyle.color;
      rowStyle.activeColor = rowStyle.color;
    }
    if (rowStyle.textColor) {
      rowStyle.activeTextColor = rowStyle.textColor;
      rowStyle.hoverTextColor = rowStyle.textColor;
    }
    _pen.calculative.visible = true;
    _pen.visible = true;
    Object.assign(_pen, rowStyle, {
      row: row
    });
    Object.assign(_pen.calculative, rowStyle, {
      row: row
    });
  });
  pen.calculative.canvas.render();
}
function onMouseEnter(pen) {
  delInterval(pen);
}
;// ./node_modules/@kyvi/form-drag/src/switch.js

function le5leSwitch(ctx, pen) {
  if (!pen.onClick) {
    pen.onClick = switch_click;
  }
  let x = pen.calculative.worldRect.x;
  let y = pen.calculative.worldRect.y;
  let w = pen.calculative.worldRect.width;
  let h = pen.calculative.worldRect.height;
  if (w < h * 1.5) {
    w = 1.5 * h;
  }
  ctx.beginPath();
  ctx.arc(x + h / 2, y + h / 2, h / 2, Math.PI / 2, Math.PI * 3 / 2);
  ctx.lineTo(x + w - h / 2, y);
  ctx.arc(x + w - h / 2, y + h / 2, h / 2, -Math.PI / 2, Math.PI / 2);
  ctx.lineTo(x + h / 2, y + h);
  if (pen.checked) {
    ctx.fillStyle = pen.onColor;
    if (pen.disabled || pen.disable) {
      ctx.fillStyle = pen.disableOnColor || pSBC(0.6, pen.onColor);
    }
    if (pen.lineWidth) {
      ctx.strokeStyle = pen.onStrokeColor;
      ctx.stroke();
    }
    ctx.fill();
    ctx.closePath();
    ctx.beginPath();
    ctx.fillStyle = '#ffffff';
    ctx.moveTo(x + h * 2, y + h / 2);
    ctx.arc(x + w - h / 2, y + h / 2, h / 2 > 2 ? h / 2 - 2 : 1, 0, Math.PI * 2);
    ctx.fill();
  } else {
    ctx.fillStyle = pen.offColor;
    if (pen.disabled || pen.disable) {
      ctx.fillStyle = pen.disableOffColor || pSBC(0.6, pen.offColor);
    }
    if (pen.lineWidth) {
      ctx.strokeStyle = pen.offStrokeColor;
      ctx.stroke();
    }
    ctx.fill();
    ctx.closePath();
    ctx.beginPath();
    ctx.fillStyle = '#ffffff';
    ctx.moveTo(x + h, y + h / 2);
    ctx.arc(x + h / 2, y + h / 2, h / 2 > 2 ? h / 2 - 2 : 1, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.closePath();
}
function switch_click(pen) {
  if (pen.disabled || pen.disable) {
    return;
  }
  pen.checked = !pen.checked;
  pen.calculative.canvas.store.emitter.emit('valueUpdate', pen);
  pen.calculative.canvas.render();
}
;// ./node_modules/@kyvi/form-drag/src/slider.js

function slider(ctx, pen) {
  if (!pen.onAdd) {
    pen.onAdd = slider_initRect;
    pen.onResize = slider_initRect;
    pen.onMove = slider_initRect;
    pen.onMouseMove = slider_mouseMove;
    pen.onMouseDown = mouseDown;
    pen.onValue = slider_onValue;
    pen.onBeforeValue = slider_beforeValue;
  }
  if (!pen.calculative.barRect) {
    slider_initRect(pen);
    // return;
  }
  const data = pen.calculative.canvas.store.data;
  const options = pen.calculative.canvas.store.options;
  // calcBallRect(pen);
  // draw bar
  let background = pen.background;
  if (pen.disabled) {
    background = pen.disabledBackground || pSBC(0.6, background);
  }
  ctx.fillStyle = background;
  ctx.beginPath();
  let x = pen.calculative.worldRect.x + pen.calculative.barRect.x;
  let y = pen.calculative.worldRect.y + pen.calculative.barRect.y;
  let w = pen.calculative.barRect.width;
  let h = pen.calculative.barRect.height;
  let r = h / 2;
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, pen.x, pen.y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.fill();
  // draw active bar
  // ctx.fillStyle = pen.activeColor || data.activeColor || options.activeColor;
  let activeColor = pen.activeColor || options.activeColor;
  if (pen.disabled) {
    activeColor = pen.disabledColor || pSBC(0.6, activeColor);
  }
  ctx.fillStyle = activeColor;
  ctx.beginPath();
  w = pen.calculative.ballRect.x;
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, pen.x, pen.y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.fill();
  // draw ball
  ctx.fillStyle = pen.btnBackground || '#fff';
  ctx.strokeStyle = activeColor;
  ctx.lineWidth = 2;
  ctx.beginPath();
  x = pen.calculative.worldRect.x + pen.calculative.ballRect.x;
  y = pen.calculative.worldRect.y + pen.calculative.ballRect.y + pen.calculative.ballRect.height / 2;
  ctx.lineWidth = pen.calculative.ballRect.width / 10;
  ctx.arc(x, y, pen.calculative.ballRect.width / 2, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();
}
function slider_initRect(pen) {
  if (!pen._textWidth) {
    pen._textWidth = pen.textWidth || 50;
    pen._fontSize = pen.fontSize || 12;
  }
  pen.textWidth = pen.calculative.worldRect.width;
  pen.calculative.textWidth = pen.textWidth;
  if (!pen.unit) {
    pen.unit = '%';
  }
  if (!pen.sliderWidth) {
    pen.sliderWidth = pen.width;
  }
  if (!pen.sliderHeight) {
    pen.sliderHeight = pen.height;
  }
  if (!pen.calculative.worldRect) {
    return;
  }
  const scaleX = pen.calculative.worldRect.width / pen.sliderWidth;
  const scaleY = pen.calculative.worldRect.height / pen.sliderHeight;
  const textScale = Math.min(scaleX, scaleY);
  pen.fontSize = pen._fontSize * textScale;
  const barWidth = pen.calculative.worldRect.width - pen._textWidth * textScale;
  pen.textLeft = barWidth + 10 * textScale;
  pen.calculative.textLeft = pen.textLeft;
  pen.calculative.barRect = {
    x: 0,
    y: (pen.calculative.worldRect.height - pen.barHeight * scaleY) / 2,
    width: barWidth,
    height: pen.barHeight * scaleY
  };
  rect_calcRightBottom(pen.calculative.barRect);
  calcBallRect(pen);
}
function calcBallRect(pen) {
  const height = pen.calculative.barRect.height * 3.5;
  const progress = pen.calculative.barRect.width * pen.value / 100;
  pen.calculative.ballRect = {
    x: progress,
    y: (pen.calculative.worldRect.height - height) / 2,
    width: height,
    height
  };
  rect_calcRightBottom(pen.calculative.ballRect);
  pen.calculative.text = pen.value + pen.unit;
  calcTextRect(pen);
}
function mouseDown(pen, e) {
  if (pen.disabled) {
    return;
  }
  const pos = e.x - pen.calculative.worldRect.x;
  if (pos > pen.calculative.barRect.width) {
    return;
  }
  let value = Math.round(pos / pen.calculative.barRect.width * 100);
  if (value < pen.min || value > pen.max) {
    return;
  }
  if (value < 0 || value > 100) {
    return;
  }
  pen.value = value;
  calcBallRect(pen);
  pen.calculative.text = pen.value + pen.unit;
  calcTextRect(pen);
  pen.calculative.canvas.store.emitter.emit('valueUpdate', pen);
  pen.calculative.canvas.render();
}
function slider_mouseMove(pen, e) {
  if (pen.calculative.canvas.mouseDown) {
    mouseDown(pen, e);
  }
}
function slider_onValue(pen) {
  if (pen.calculative.isUpdateData) {
    delete pen.calculative.isUpdateData;
    slider_initRect(pen);
  }
  calcBallRect(pen);
}
function slider_beforeValue(pen, value) {
  pen.calculative.isUpdateData = false;
  if (value.textWidth || value.barHeight) {
    if (value.textWidth) {
      pen._textWidth = 0;
    }
    pen.calculative.isUpdateData = true;
  }
  return value;
}
;// ./node_modules/@kyvi/form-drag/src/checkbox.js


function checkbox_checkbox(ctx, pen) {
  if (!pen.onMouseDown) {
    pen.onMouseDown = onMousedown;
  }
  if (!pen.options) {
    pen.options = pen.data;
  }
  let x = pen.calculative.worldRect.x;
  let y = pen.calculative.worldRect.y;
  let h = pen.calculative.worldRect.height;
  let w = pen.calculative.worldRect.width;
  const {
    fontStyle,
    fontWeight,
    fontSize,
    fontFamily,
    lineHeight
  } = pen.calculative;
  let r = 2;
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.arcTo(x + h, y, x + h, y + h, r);
  ctx.arcTo(x + h, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + h, y, r);
  ctx.strokeStyle = '#d9d9d9';
  ctx.fillStyle = '#ffffff00';
  if (pen.checked) {
    ctx.fillStyle = pen.background || '#1890ff';
    ctx.strokeStyle = pen.background || '#1890ff';
  }
  if (pen.isForbidden || pen.disabled) {
    ctx.fillStyle = pen.disabledBackground || pSBC(0.6, pen.background) || '#ebebeb';
    ctx.strokeStyle = pen.disabledColor || pSBC(0.6, pen.color) || '#d9d9d9';
  }
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  ctx.save();
  if (pen.checked) {
    ctx.beginPath();
    ctx.lineWidth = h / 10;
    ctx.strokeStyle = '#ffffff';
    ctx.moveTo(x + 102 / 506 * h, y + h / 2);
    ctx.lineTo(x + 220 / 506 * h, y + 346 / 460 * h);
    ctx.lineTo(x + 404 / 506 * h, y + 142 / 460 * h);
    ctx.stroke();
  }
  ctx.restore();
  //文字
  ctx.save();
  ctx.fillStyle = pen.disabled || pen.isForbidden ? pen.disabledTextColor || pSBC(0.6, pen.textColor || pen.color) || '#00000040' : getTextColor(pen, pen.calculative.canvas.parent.store) || '#000000d9';
  ctx.textAlign = 'start';
  ctx.textBaseline = 'middle';
  // ctx.font =
  //   (pen.calculative.fontStyle || '') +
  //   ' normal ' +
  //   (pen.calculative.fontWeight || '') +
  //   ' ' +
  //   pen.fontSize +
  //   'px ' +
  //   pen.calculative.fontFamily;
  ctx.font = getFont({
    fontStyle,
    fontWeight,
    fontFamily: fontFamily || pen.calculative.canvas.parent.store.options.fontFamily,
    fontSize,
    lineHeight
  });
  ctx.fillText(pen.value + '', x + h + 10, y + h / 2);
  ctx.restore();
}
function onMousedown(pen, e) {
  if (!pen.isForbidden) {
    pen.checked = !pen.checked;
    pen.calculative.canvas.store.emitter.emit('valueUpdate', pen);
    pen.calculative.canvas.render();
  }
}
;// ./node_modules/@kyvi/form-drag/src/radio.js



function radio_radio(ctx, pen) {
  if (!pen.options) {
    pen.options = pen.data;
  }
  if (!pen.onAdd) {
    pen.onAdd = radio_onAdd;
    if (!pen.optionPos) {
      pen.onAdd(pen);
      pen.calculative.canvas.parent.active([pen]);
    }
    pen.onMouseDown = radio_onMousedown;
    pen.onValue = radio_onValue;
  }
  let x = pen.calculative.worldRect.x;
  let y = pen.calculative.worldRect.y;
  let h = pen.calculative.worldRect.height;
  let w = pen.calculative.worldRect.width;
  if (!pen.optionPos) {
    return;
  }
  const {
    fontStyle,
    fontWeight,
    fontSize,
    fontFamily,
    lineHeight
  } = pen.calculative;
  if (pen.direction == 'horizontal') {
    // const optionHeight = (pen.optionHeight * h) / pen.checkboxHeight;
    for (let i = 0; i < pen.optionPos.length; i++) {
      const gap = pen.optionPos[i] * w / pen.checkboxWidth;
      const isForbidden = pen.options[i].isForbidden || pen.disabled;
      ctx.beginPath();
      ctx.arc(x + gap + h / 2, y + h / 2, h / 2, 0, Math.PI * 2);
      ctx.strokeStyle = '#d9d9d9';
      ctx.fillStyle = '#ffffff00';
      if (pen.options[i].text === pen.checked) {
        ctx.strokeStyle = pen.options[i].background || pen.background || '#1890ff';
      }
      if (isForbidden) {
        ctx.fillStyle = pen.disabledBackground || pSBC(0.6, pen.background) || '#ebebeb';
        ctx.strokeStyle = pen.disabledColor || pSBC(0.6, pen.color) || '#d9d9d9';
        if (pen.options[i].text === pen.checked) {
          ctx.fillStyle = '#ffffff00';
        }
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.save();
      if (pen.options[i].text === pen.checked) {
        ctx.beginPath();
        ctx.strokeStyle = pen.options[i].background ? pen.options[i].background + '20' : pen.background || '#1890ff20';
        if (isForbidden) {
          ctx.strokeStyle = pen.disabledBackground || pSBC(0.6, pen.background) || '#ebebeb';
        }
        ctx.arc(x + h / 2 + gap, y + h / 2, h / 2 + 1.5, 0, Math.PI * 2);
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath();
        ctx.fillStyle = pen.options[i].background || pen.background || '#1890ff';
        if (isForbidden) {
          ctx.fillStyle = pen.disabledBackground || pSBC(0.6, pen.background) || '#ebebeb';
        }
        ctx.arc(x + h / 2 + gap, y + h / 2, h / 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();
      }
      ctx.restore();
      //文字
      ctx.save();
      ctx.fillStyle = isForbidden ? pen.disabledTextColor || '#00000040' : getTextColor(pen, pen.calculative.canvas.parent.store) || '#000000d9';
      const textScale = pen.calculative.worldRect.height * 14 / 16;
      ctx.textAlign = 'start';
      ctx.textBaseline = 'middle';
      ctx.font = getFont({
        fontStyle,
        fontWeight,
        fontFamily: fontFamily || pen.calculative.canvas.parent.store.options.fontFamily,
        fontSize: textScale,
        lineHeight
      });
      ctx.fillText(pen.options[i].text, x + h + gap + 10 / pen.checkboxWidth * w, y + h / 2);
      ctx.restore();
    }
  } else if (pen.direction == 'vertical') {
    const optionHeight = pen.optionHeight * h / pen.checkboxHeight;
    for (let i = 0; i < pen.optionPos.length; i++) {
      const gap = pen.optionPos[i] * h / pen.checkboxHeight;
      const isForbidden = pen.options[i].isForbidden;
      ctx.beginPath();
      ctx.arc(x + optionHeight / 2, y + optionHeight / 2 + gap, optionHeight / 2, 0, Math.PI * 2);
      ctx.strokeStyle = '#d9d9d9';
      ctx.fillStyle = '#ffffff00';
      if (pen.options[i].text === pen.checked) {
        ctx.strokeStyle = pen.options[i].background || '#1890ff';
      }
      if (isForbidden) {
        ctx.fillStyle = '#ebebeb';
        ctx.strokeStyle = '#d9d9d9';
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.save();
      if (!isForbidden && pen.options[i].text === pen.checked) {
        ctx.beginPath();
        ctx.strokeStyle = pen.options[i].background ? pen.options[i].background + '20' : '#1890ff20';
        ctx.arc(x + optionHeight / 2, y + optionHeight / 2 + gap, optionHeight / 2 + 1.5, 0, Math.PI * 2);
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath();
        ctx.fillStyle = pen.options[i].background || '#1890ff';
        ctx.arc(x + optionHeight / 2, y + optionHeight / 2 + gap, optionHeight / 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();
      }
      ctx.restore();
      //文字
      ctx.save();
      ctx.fillStyle = isForbidden ? '#00000040' : getTextColor(pen, pen.calculative.canvas.parent.store) || '#000000d9';
      const textScale = 14 * pen.calculative.worldRect.height / pen.checkboxHeight;
      ctx.textAlign = 'start';
      ctx.textBaseline = 'middle';
      // ctx.font =
      //   (pen.calculative.fontStyle || '') +
      //   ' normal ' +
      //   (pen.calculative.fontWeight || '') +
      //   ' ' +
      //   textScale +
      //   'px ' +
      //   pen.calculative.fontFamily;
      ctx.font = getFont({
        fontStyle,
        fontWeight,
        fontFamily: fontFamily || pen.calculative.canvas.parent.store.options.fontFamily,
        fontSize: textScale,
        lineHeight
      });
      ctx.fillText(pen.options[i].text, x + optionHeight + 10, y + optionHeight / 2 + gap);
      ctx.restore();
    }
  }
}
function radio_onAdd(pen) {
  initOptions(pen);
}
function radio_onMousedown(pen, e) {
  if (pen.direction == 'horizontal') {
    // let checkedIndex = -1;
    for (let i = 0; i < pen.optionPos.length; i++) {
      if (!pen.options[i].isForbidden && e.x > pen.calculative.worldRect.x + pen.optionPos[i] * pen.calculative.worldRect.width / pen.checkboxWidth && e.x < pen.calculative.worldRect.x + (pen.optionPos[i] + pen.height) / pen.checkboxWidth * pen.calculative.worldRect.width + getTextLength(pen.options[i].text, pen) + 10 / pen.checkboxWidth * pen.calculative.worldRect.width) {
        // pen.options[i].isChecked = true;
        pen.checked = pen.options[i].text;
        // checkedIndex = i;
        pen.calculative.canvas.store.emitter.emit('valueUpdate', pen);
      }
    }
    // if (checkedIndex !== -1) {
    //   pen.options.forEach((item: any, index: number) => {
    //     if (index !== checkedIndex) {
    //       item.isChecked = false;
    //     }
    //   });
    // }
  } else if (pen.direction == 'vertical') {
    const scaleY = pen.calculative.worldRect.height / pen.checkboxHeight;
    // let checkedIndex = -1;
    for (let i = 0; i < pen.optionPos.length; i++) {
      if (!pen.options[i].isForbidden && e.y > pen.calculative.worldRect.y + pen.optionPos[i] * scaleY && e.y < pen.calculative.worldRect.y + (pen.optionPos[i] + pen.optionHeight) * scaleY) {
        // pen.options[i].isChecked = true;
        pen.checked = pen.options[i].text;
        // checkedIndex = i;
        pen.calculative.canvas.store.emitter.emit('valueUpdate', pen);
      }
    }
    // if (checkedIndex !== -1) {
    //   pen.options.forEach((item: any, index: number) => {
    //     if (index !== checkedIndex) {
    //       item.isChecked = false;
    //     }
    //   });
    // }
  }
  pen.calculative.canvas.render();
}
function radio_onValue(pen) {
  initOptions(pen);
}
;// ./node_modules/@kyvi/form-drag/src/register.js






function formPens() {
  return {
    radio: radio_radio,
    switch: le5leSwitch,
    slider: slider,
    checkbox: checkbox_checkbox,
    table: table2,
    table2: table2
  };
}
function formPath2DPens() {
  return {
    time
  };
}
;// ./node_modules/@kyvi/form-drag/index.js







;// ./node_modules/@kyvi/cobweb-charts/src/normalizedAxis.js
// 双精度浮点数有效数字为15位
const maxDecimal = 15;
/**
 * 解决js的浮点数存在精度问题，在计算出最后结果时可以四舍五入一次，刻度太小也没有意义
 *
 * @export
 * @param {(number | string)} num
 * @param {number} [decimal=8]
 * @returns {number}
 */
function fixedNum(num, decimal = maxDecimal) {
  let str = '' + num;
  if (str.indexOf('.') >= 0) str = Number.parseFloat(str).toFixed(decimal);
  return Number.parseFloat(str);
}
/**
 * 判断非Infinity非NaN的number
 *
 * @export
 * @param {*} num
 * @returns {num is number}
 */
function numberValid(num) {
  return typeof num === 'number' && Number.isFinite(num);
}
/**
 * 计算理想的刻度值，刻度区间大小一般是[10, 15, 20, 25, 30, 40, 50, 60, 70, 80, 90, 100]中某个数字的整10倍
 *
 * @export
 * @param {ScaleOption} option
 * @returns {ScaleResult}
 */
function scaleCompute(option) {
  option = {
    max: null,
    min: null,
    splitNumber: 4,
    // splitNumber建议取4或者5等这种容易被整除的数字
    symmetrical: false,
    deviation: false,
    preferZero: false,
    ...option
  };
  const magics = [10, 15, 20, 25, 30, 40, 50, 60, 70, 80, 90, 100, 150]; // 加入150形成闭环
  // tslint:disable-next-line: prefer-const
  let {
    max: dataMax,
    min: dataMin,
    splitNumber,
    symmetrical,
    deviation,
    preferZero
  } = option;
  if (!numberValid(dataMax) || !numberValid(dataMin) || dataMax < dataMin) {
    return {
      splitNumber
    };
  } else if (dataMax === dataMin && dataMax === 0) {
    return {
      max: fixedNum(magics[0] * splitNumber),
      min: dataMin,
      interval: magics[0],
      splitNumber
    };
  } else if (dataMax === dataMin) {
    preferZero = true;
  }
  if (!numberValid(splitNumber) || splitNumber <= 0) splitNumber = 4;
  if (preferZero && dataMax * dataMin > 0) {
    if (dataMax < 0) dataMax = 0;else dataMin = 0;
  }
  const tempGap = (dataMax - dataMin) / splitNumber;
  let multiple = Math.floor(Math.log10(tempGap) - 1); // 指数
  multiple = Math.pow(10, multiple);
  const tempStep = tempGap / multiple;
  let expectedStep = magics[0] * multiple;
  let storedMagicsIndex = -1;
  let index; // 当前魔数下标
  for (index = 0; index < magics.length; index++) {
    if (magics[index] > tempStep) {
      expectedStep = magics[index] * multiple; // 取出第一个大于tempStep的魔数，并乘以multiple作为期望得到的最佳间隔
      break;
    }
  }
  let axisMax = dataMax;
  let axisMin = dataMin;
  function countDegree(step) {
    axisMax = parseInt('' + (dataMax / step + 1)) * step; // parseInt令小数去尾 -1.8 -> -1
    axisMin = parseInt('' + (dataMin / step - 1)) * step;
    if (dataMax === 0) axisMax = 0; // 优先0刻度
    if (dataMin === 0) axisMin = 0;
    if (symmetrical && axisMax * axisMin < 0) {
      const tm = Math.max(Math.abs(axisMax), Math.abs(axisMin));
      axisMax = tm;
      axisMin = -tm;
    }
  }
  countDegree(expectedStep);
  if (deviation) {
    return {
      max: fixedNum(axisMax),
      min: fixedNum(axisMin),
      interval: fixedNum(expectedStep),
      splitNumber: Math.round((axisMax - axisMin) / expectedStep)
    };
  } else if (!symmetrical || axisMax * axisMin > 0) {
    let tempSplitNumber;
    out: do {
      tempSplitNumber = Math.round((axisMax - axisMin) / expectedStep);
      if ((index - storedMagicsIndex) * (tempSplitNumber - splitNumber) < 0) {
        // 出现死循环
        while (tempSplitNumber < splitNumber) {
          if (axisMin - dataMin <= axisMax - dataMax && axisMin !== 0 || axisMax === 0) {
            axisMin -= expectedStep;
          } else {
            axisMax += expectedStep;
          }
          tempSplitNumber++;
          if (tempSplitNumber === splitNumber) break out;
        }
      }
      if (index >= magics.length - 1 || index <= 0 || tempSplitNumber === splitNumber) break;
      storedMagicsIndex = index;
      if (tempSplitNumber > splitNumber) expectedStep = magics[++index] * multiple;else expectedStep = magics[--index] * multiple;
      countDegree(expectedStep);
    } while (tempSplitNumber !== splitNumber);
  }
  axisMax = fixedNum(axisMax);
  axisMin = fixedNum(axisMin);
  const interval = fixedNum((axisMax - axisMin) / splitNumber);
  return {
    max: axisMax,
    min: axisMin,
    interval,
    splitNumber
  };
}
;// ./node_modules/@kyvi/cobweb-charts/src/coordinateAxis.js



//用于绘制坐标轴
function coordinateAxis(ctx, pen) {
  const x = pen.calculative.worldRect.x;
  const y = pen.calculative.worldRect.y;
  const w = pen.calculative.worldRect.width;
  const h = pen.calculative.worldRect.height;
  // 缩放比例
  let r = w / 2;
  let scale = pen.calculative.canvas.store.data.scale;
  let series = [];
  if (pen.echarts) {
    for (let i = 0; i < pen.echarts.option.series.length; i++) {
      series.push(pen.echarts.option.series[i].data);
    }
  } else {
    series = pen.data;
  }
  let collection_data = [];
  for (let i = 0; i < series.length; i++) {
    collection_data = collection_data.concat(series[i]);
  }
  let initOption = {
    max: Math.max.apply(null, collection_data),
    min: Math.min.apply(null, collection_data),
    splitNumber: 5
  };
  let normalizedOption = scaleCompute(initOption);
  let num = pen.echarts ? pen.echarts.option.xAxis.data.length : pen.xAxisData.length;
  ctx.beginPath();
  ctx.strokeStyle = '#BFBFBF';
  ctx.lineWidth = 6 * scale;
  ctx.lineCap = 'butt';
  let dash = (w - 1 * (num + 1)) / num;
  ctx.setLineDash([1, dash]);
  ctx.moveTo(x, y + h + 3 * scale);
  ctx.lineTo(x + w, y + h + 3 * scale);
  ctx.stroke();
  ctx.closePath();
  //x轴绘制
  ctx.beginPath();
  ctx.lineWidth = 1 * scale;
  ctx.setLineDash([]);
  ctx.moveTo(x, y + h);
  ctx.lineTo(x + w, y + h);
  ctx.stroke();
  ctx.closePath();
  //y轴绘制
  ctx.beginPath();
  ctx.fillStyle = '#BFBFBF';
  ctx.strokeStyle = '#E9E9E9';
  ctx.setLineDash([2, 2]);
  let fontOptions = {
    fontStyle: pen.yAxis?.axisLabel?.fontStyle || pen.fontStyle,
    textDecoration: pen.yAxis?.axisLabel?.textDecoration,
    fontWeight: pen.yAxis?.axisLabel?.fontWeight || pen.fontWeight,
    fontFamily: pen.yAxis?.axisLabel?.fontFamily || pen.fontFamily,
    fontSize: pen.yAxis?.axisLabel?.fontSize || pen.fontSize,
    lineHeight: pen.yAxis?.axisLabel?.lineHeight || pen.lineHeight
  };
  ctx.fillStyle = pen.yAxis?.axisLabel?.fontColor || pen.color;
  for (let i = 0; i < normalizedOption.splitNumber + 1; i++) {
    let temH = i * h / normalizedOption.splitNumber;
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    ctx.font = getFont(fontOptions); //r / 10 +'px AlibabaPuHuiTi-Regular, Alibaba PuHuiTi';
    ctx.fillText(normalizedOption.max - i * normalizedOption.interval + '', x - 10 * scale, y + temH);
    ctx.fill();
    if (i < normalizedOption.splitNumber) {
      ctx.beginPath();
      ctx.moveTo(x, y + temH);
      ctx.lineTo(x + w, y + temH);
      ctx.stroke();
    }
  }
  ctx.closePath();
  //x轴下标绘制
  ctx.beginPath();
  ctx.strokeStyle = '#BFBFBF';
  let xData = pen.echarts ? pen.echarts.option.xAxis.data : pen.xAxisData;
  let xdataX = 0;
  for (let i = 0; i < xData.length; i++) {
    xdataX = x + (1 + dash / 2) + (dash + 1) * i;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    let fontOptions = {
      fontStyle: pen.xAxis?.axisLabel?.fontStyle || pen.calculative.fontStyle,
      textDecoration: pen.xAxis?.axisLabel?.textDecoration,
      fontWeight: pen.xAxis?.axisLabel?.fontWeight || pen.calculative.fontWeight,
      fontFamily: pen.xAxis?.axisLabel?.fontFamily || pen.calculative.fontFamily,
      fontSize: pen.xAxis?.axisLabel?.fontSize || pen.calculative.fontSize,
      lineHeight: pen.xAxis?.axisLabel?.lineHeight || pen.calculative.lineHeight
    };
    ctx.font = getFont(fontOptions); //r / 10 +'px AlibabaPuHuiTi-Regular, Alibaba PuHuiTi';
    ctx.fillStyle = pen.xAxis?.axisLabel?.fontColor || pen.calculative.color;
    ctx.fillText(xData[i], xdataX, y + h + 10 * scale);
    ctx.fill();
  }
  ctx.closePath();
  ctx.setLineDash([]);
  return {
    dash: dash,
    normalizedOption: normalizedOption
  };
}
;// ./node_modules/@kyvi/cobweb-charts/src/common.js
function getValidValue(num, value) {
  if (isNaN(num)) {
    return;
  }
  if (value === -1) {
    return num;
  }
  // return num - parseInt(num) == 0 ? num : Number(num).toFixed(value);
  // return Number(num).toFixed(value);
  return Math.round(Number(num) * 1000) / 1000;
}
var src_common_ReplaceMode;
(function (ReplaceMode) {
  ReplaceMode[ReplaceMode["Add"] = 0] = "Add";
  ReplaceMode[ReplaceMode["Replace"] = 1] = "Replace";
  ReplaceMode[ReplaceMode["ReplaceAll"] = 2] = "ReplaceAll";
})(src_common_ReplaceMode || (src_common_ReplaceMode = {}));
;// ./node_modules/@kyvi/cobweb-charts/src/lineChart.js



//折线图
function lineChart(ctx, pen) {
  if (!pen.onBeforeValue) {
    pen.onBeforeValue = lineChart_beforeValue;
  }
  const x = pen.calculative.worldRect.x;
  const y = pen.calculative.worldRect.y;
  const w = pen.calculative.worldRect.width;
  const h = pen.calculative.worldRect.height;
  let scale = pen.calculative.canvas.store.data.scale;
  let series = [];
  if (pen.echarts && !pen.echarts.option.color) {
    pen.echarts.option.color = ['#1890ff', '#2FC25B', '#FACC14', '#c23531', '#2f4554', '#61a0a8', '#d48265'];
  }
  let coordinate = coordinateAxis(ctx, pen);
  let dash = coordinate.dash;
  let normalizedOption = coordinate.normalizedOption;
  //数据值绘制
  const smooth = (pen.echarts ? pen.echarts.option.series[0].smooth : pen.smooth) ? true : false;
  let coordinateValue = [];
  if (pen.echarts) {
    for (let i = 0; i < pen.echarts.option.series.length; i++) {
      series.push(pen.echarts.option.series[i].data);
    }
  } else {
    series = pen.data;
  }
  for (let j = 0; j < series.length; j++) {
    ctx.beginPath();
    let data = series[j];
    ctx.strokeStyle = pen.echarts ? pen.echarts.option.color[j] : pen.chartsColor[j];
    ctx.fillStyle = pen.echarts ? pen.echarts.option.color[j] : pen.chartsColor[j];
    let currentX = x + (1 + dash / 2);
    let currentY = y + h - (data[0] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
    ctx.moveTo(currentX, currentY);
    coordinateValue.push({
      x: currentX,
      y: currentY
    });
    if (smooth) {
      //平滑的曲线
      if (data.length <= 2) {
        //小于两个点的情况无法构成贝塞尔
        for (let i = 1; i < data.length; i++) {
          currentX = x + (1 + dash / 2) + (dash + 1) * i;
          currentY = y + h - (data[i] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
          ctx.lineTo(currentX, currentY);
          coordinateValue.push({
            x: currentX,
            y: currentY
          });
        }
      } else {
        let cAx, cAy, cBx, cBy;
        data.forEach((item, index) => {
          currentX = x + (1 + dash / 2) + (dash + 1) * index;
          currentY = y + h - (data[index] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
          let last1x = x + (1 + dash / 2) + (dash + 1) * (index + 1);
          let last1y = y + h - (data[index + 1] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
          let before1x = x + (1 + dash / 2) + (dash + 1) * (index - 1);
          let before1y = y + h - (data[index - 1] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
          let last2x = x + (1 + dash / 2) + (dash + 1) * (index + 2);
          let last2y = y + h - (data[index + 2] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
          if (index === 0) {
            //第一个节点 用自己代替前一个节点
            before1x = x + (1 + dash / 2) + (dash + 1) * index;
            before1y = y + h - (data[index] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
          } else if (index === data.length - 2) {
            //倒数第二个节点 用下一个节点替代下下个节点
            last2x = x + (1 + dash / 2) + (dash + 1) * (index + 1);
            last2y = y + h - (data[index + 1] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
          }
          coordinateValue.push({
            x: currentX,
            y: currentY
          });
          cAx = currentX + (last1x - before1x) / 4;
          cAy = currentY + (last1y - before1y) / 4;
          cBx = last1x - (last2x - currentX) / 4;
          cBy = last1y - (last2y - currentY) / 4;
          ctx.bezierCurveTo(cAx, cAy, cBx, cBy, last1x, last1y);
          //绘制到下一个节点的贝塞尔曲线
        });
      }
    } else {
      for (let i = 1; i < data.length; i++) {
        currentX = x + (1 + dash / 2) + (dash + 1) * i;
        currentY = y + h - (data[i] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
        ctx.lineTo(currentX, currentY);
        coordinateValue.push({
          x: currentX,
          y: currentY
        });
      }
    }
    ctx.stroke();
    ctx.closePath();
    ctx.save();
    coordinateValue.forEach((item, index) => {
      ctx.beginPath();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2 * scale;
      ctx.arc(item.x, item.y, 4 * scale, 0, Math.PI * 2);
      ctx.stroke();
      ctx.fill();
      ctx.closePath();
    });
    ctx.restore();
    coordinateValue = [];
  }
}
function lineChart_beforeValue(pen, value) {
  if (value.xAxisData || value.data || !value.dataX && !value.dataY) {
    // 整体传参，不做处理
    return value;
  }
  const _xAxisData = pen.xAxisData;
  const _data = pen.data;
  const replaceMode = pen.replaceMode;
  let xAxisData = [];
  let data = [];
  if (!replaceMode) {
    //追加
    xAxisData = [..._xAxisData, ...value.dataX];
    _data.forEach((item, index) => {
      let _item = [...item, ...value.dataY[index]];
      data.push(_item);
    });
  } else if (replaceMode === src_common_ReplaceMode.Replace) {
    //替换部分
    value.dataX.forEach((item, i) => {
      let _index = _xAxisData.indexOf(item);
      _data.forEach((d, index) => {
        d[_index] = value.dataY[index][i];
      });
    });
    xAxisData = _xAxisData;
    data = _data;
  } else if (replaceMode === src_common_ReplaceMode.ReplaceAll) {
    //全部替换
    xAxisData = value.dataX;
    data = value.dataY;
  }
  delete value.dataX;
  delete value.dataY;
  return Object.assign(value, {
    xAxisData,
    data
  });
}
;// ./node_modules/@kyvi/cobweb-charts/src/pieChart.js



//饼状图
function pieChart(ctx, pen) {
  if (!pen.onBeforeValue) {
    pen.onBeforeValue = pieChart_beforeValue;
  }
  // 缩放模式
  let scale = pen.calculative.canvas.store.data.scale;
  const x = pen.calculative.worldRect.x;
  const y = pen.calculative.worldRect.y;
  const w = pen.calculative.worldRect.width;
  const h = pen.calculative.worldRect.height;
  const isEcharts = pen.echarts ? true : false;
  // if (pen.echarts && !pen.echarts.option.color) {
  //   pen.echarts.option.color = [
  //     '#1890ff',
  //     '#2FC25B',
  //     '#FACC14',
  //     '#c23531',
  //     '#2f4554',
  //     '#61a0a8',
  //     '#d48265',
  //   ];
  // } else {
  //   pen.chartsColor = [
  //     '#1890ff',
  //     '#2FC25B',
  //     '#FACC14',
  //     '#c23531',
  //     '#2f4554',
  //     '#61a0a8',
  //     '#d48265',
  //   ];
  // }
  if (pen.echarts) {
    if (!pen.echarts.option.color) {
      pen.echarts.option.color = ['#1890ff', '#2FC25B', '#FACC14', '#c23531', '#2f4554', '#61a0a8', '#d48265'];
    }
    pen.chartsColor = pen.echarts.option.color;
  } else {
    if (!pen.chartsColor) {
      pen.chartsColor = ['#1890ff', '#2FC25B', '#FACC14', '#c23531', '#2f4554', '#61a0a8', '#d48265'];
    }
  }
  const seriesArray = isEcharts ? pen.echarts.option.series : pen.data;
  let beforeSeriesLength = 0;
  for (let ser = 0; ser < seriesArray.length; ser++) {
    let series = seriesArray[ser];
    let r = w / 2;
    if (h < w) {
      r = h / 2;
    }
    const centerX = x + w / 2;
    const centerY = y + h / 2;
    let sum = 0;
    if (isEcharts) {
      sum = series.data.reduce((prev, curr) => {
        return prev + curr.value;
      }, 0);
    } else {
      sum = series.reduce((prev, curr) => {
        return prev + curr.value;
      }, 0);
    }
    const fromR = r * parseFloat(isEcharts ? series.radius[0] : pen.chartsRadius[ser][0]) / 100;
    const toR = r * parseFloat(isEcharts ? series.radius[1] : pen.chartsRadius[ser][1]) / 100;
    if (fromR > toR) {
      return;
    }
    let beforeAngle = 0;
    let afterAngle = 0;
    ctx.strokeStyle = isEcharts ? series.itemStyle?.borderColor || '#fff' : '#fff';
    ctx.lineWidth = (isEcharts ? series.itemStyle?.borderWidth || 2 : 2) * scale;
    const data = isEcharts ? series.data : series;
    data.forEach((item, index) => {
      afterAngle += Math.PI * 2 * item.value / sum;
      ctx.beginPath();
      let colorLength = beforeSeriesLength + index;
      if (colorLength >= pen.chartsColor.length) {
        colorLength = colorLength % pen.chartsColor.length;
      }
      ctx.fillStyle = isEcharts ? pen.echarts.option.color[colorLength] : pen.chartsColor[colorLength];
      ctx.moveTo(centerX + fromR * Math.sin(afterAngle), centerY - fromR * Math.cos(afterAngle));
      ctx.arc(centerX, centerY, fromR, -Math.PI / 2 + afterAngle, -Math.PI / 2 + beforeAngle, true);
      ctx.lineTo(centerX + toR * Math.sin(beforeAngle), centerY - toR * Math.cos(beforeAngle));
      ctx.arc(centerX, centerY, toR, -Math.PI / 2 + beforeAngle, -Math.PI / 2 + afterAngle);
      ctx.lineTo(centerX + fromR * Math.sin(afterAngle), centerY - fromR * Math.cos(afterAngle));
      ctx.stroke();
      ctx.fill();
      ctx.closePath();
      //绘制label
      let centerAngle = (beforeAngle + afterAngle) / 2;
      let temX = centerX + (toR + 10 * scale) * Math.sin(centerAngle);
      let temY = centerY - (toR + 10 * scale) * Math.cos(centerAngle);
      let temFillStyle = ctx.fillStyle;
      if (!series.label) {
        series.label = {
          position: 'outside',
          show: true
        };
      }
      if (isEcharts && ['inner', 'inside'].includes(series.label.position)) {
        ctx.fillStyle = '#ffffff';
        temX = centerX + (toR - fromR) / 2 * Math.sin(centerAngle);
        temY = centerY - (toR - fromR) / 2 * Math.cos(centerAngle);
      } else if (isEcharts && series.label.position == 'outside') {}
      if (!series.labelLine) {
        series.labelLine = {
          show: true
        };
      }
      if (isEcharts && series.labelLine.show !== false || !isEcharts) {
        ctx.beginPath();
        ctx.strokeStyle = isEcharts ? pen.echarts.option.color[beforeSeriesLength + index] : pen.chartsColor[beforeSeriesLength + index];
        ctx.moveTo(centerX + toR * Math.sin(centerAngle), centerY - toR * Math.cos(centerAngle));
        ctx.lineTo(temX, temY);
      }
      let fontOption = {
        fontStyle: pen.tickLabel?.fontStyle || pen.calculative.fontStyle,
        fontWeight: pen.tickLabel?.fontWeight || pen.calculative.fontWeight,
        fontFamily: pen.tickLabel?.fontFamily || pen.calculative.fontFamily,
        lineHeight: pen.tickLabel?.lineHeight || pen.calculative.lineHeight,
        fontSize: (pen.tickLabel?.fontSize || pen.calculative.fontSize) * scale
      };
      ctx.font = getFont(fontOption); // r / 10 + 'px AlibabaPuHuiTi-Regular, Alibaba PuHuiTi';
      ctx.textBaseline = 'middle';
      ctx.textAlign = 'center';
      // 写入文字
      if (centerAngle > Math.PI) {
        if (isEcharts && series.label.position === 'outside' || !isEcharts) {
          ctx.textAlign = 'end';
        }
        if (isEcharts && series.labelLine.show !== false || !isEcharts && (pen.tickLabel?.labelLine?.show ?? true)) {
          ctx.lineTo(temX - 5 * scale, temY);
        }
        if (isEcharts && series.label.show !== false || !isEcharts && (pen.tickLabel?.show ?? true)) {
          ctx.fillText(item.name, temX - 5 * scale, temY);
        }
      } else {
        if (isEcharts && series.label.position === 'outside' || !isEcharts) {
          ctx.textAlign = 'start';
        }
        if (isEcharts && series.labelLine.show !== false || !isEcharts) {
          ctx.lineTo(temX + 5 * scale, temY);
        }
        if (isEcharts && series.label.show !== false || !isEcharts && (pen.tickLabel?.show ?? true)) {
          ctx.fillText(item.name, temX + 5 * scale, temY);
        }
      }
      ctx.stroke();
      ctx.closePath();
      ctx.fillStyle = temFillStyle;
      ctx.strokeStyle = isEcharts ? series.itemStyle?.borderColor || '#fff' : '#fff';
      beforeAngle = afterAngle;
    });
    beforeSeriesLength += data.length;
  }
}
function pieChart_beforeValue(pen, value) {
  if (value.data || !value.dataX && !value.dataY) {
    // 整体传参，不做处理
    return value;
  }
  const _data = pen.data;
  const replaceMode = pen.replaceMode;
  let data = [];
  if (!replaceMode) {
    //追加
    _data.forEach((item, index) => {
      let _item = [...item, ...value.dataY[index]];
      data.push(_item);
    });
  } else if (replaceMode === src_common_ReplaceMode.Replace) {
    //替换部分
    value.dataY.forEach((item, index) => {
      item.forEach((_innerItem, _innderIndex) => {
        let _filterItem = _data[index].filter(_i => _i.name === _innerItem.name);
        if (_filterItem.length > 0) {
          _filterItem[0].value = _innerItem.value;
        }
      });
    });
    data = _data;
  } else if (replaceMode === src_common_ReplaceMode.ReplaceAll) {
    //全部替换
    data = value.dataY;
  }
  delete value.dataX;
  delete value.dataY;
  return Object.assign(value, {
    data
  });
}
;// ./node_modules/@kyvi/cobweb-charts/src/histogram.js



//柱状图
function histogram(ctx, pen) {
  if (!pen.onBeforeValue) {
    pen.onBeforeValue = lineChart_beforeValue;
  }
  let scale = pen.calculative.canvas.store.data.scale;
  const x = pen.calculative.worldRect.x;
  const y = pen.calculative.worldRect.y;
  const w = pen.calculative.worldRect.width;
  const h = pen.calculative.worldRect.height;
  let series = [];
  if (pen.echarts && !pen.echarts.option.color) {
    pen.echarts.option.color = ['#1890ff', '#2FC25B', '#FACC14', '#c23531', '#2f4554', '#61a0a8', '#d48265'];
  }
  if (pen.echarts) {
    for (let i = 0; i < pen.echarts.option.series.length; i++) {
      series.push(pen.echarts.option.series[i].data);
    }
  } else {
    series = pen.data;
  }
  let coordinate = coordinateAxis(ctx, pen);
  let dash = coordinate.dash;
  let normalizedOption = coordinate.normalizedOption;
  let itemWidth = dash * 4 / 5 / series.length;
  // ctx.strokeStyle = '#ffffff';
  for (let j = 0; j < series.length; j++) {
    ctx.beginPath();
    let data = series[j];
    ctx.fillStyle = pen.echarts ? pen.echarts.option.color[j] : pen.chartsColor[j];
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1 * scale;
    let currentX = 0;
    let currentY = 0;
    let currentH = 0;
    for (let i = 0; i < data.length; i++) {
      currentX = x + (1 + 0.1 * dash) + (dash + 1) * i + itemWidth * j;
      currentH = (data[i] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
      currentY = y + h - currentH;
      //宽度-1是为了数据之间的间距 高度-1是为了坐标轴不被覆盖
      ctx.rect(currentX, currentY, itemWidth - 1, currentH - 1);
      ctx.stroke();
      ctx.fill();
    }
    ctx.closePath();
  }
  // let;
}
;// ./node_modules/@kyvi/cobweb-charts/src/gauge.js


//仪表全盘
function gauge(ctx, pen) {
  if (!pen.onAdd) {
    pen.onAdd = gauge_onAdd;
    pen.onDestroy = gauge_onDestroy;
    pen.onClick = gauge_onclick;
    if (pen.clockInterval) {
      pen.onDestroy(pen);
      pen.onAdd(pen);
    }
  }
  const x = pen.calculative.worldRect.x;
  const y = pen.calculative.worldRect.y;
  const w = pen.calculative.worldRect.width;
  const h = pen.calculative.worldRect.height;
  let scale = pen.calculative.canvas.store.data.scale;
  let basicConfigure = {
    startAngle: 225,
    endAngle: -45,
    min: 0,
    max: 100,
    splitNumber: 10
  };
  //对echarts写法做兼容性处理
  if (pen.echarts && pen.echarts.option) {
    let series = pen.echarts.option.series[0];
    pen.startAngle = series.startAngle || basicConfigure.startAngle;
    pen.endAngle = series.endAngle || basicConfigure.endAngle;
    pen.min = series.min || basicConfigure.min;
    pen.max = series.max || basicConfigure.max;
    pen.axisLine = series.axisLine.lineStyle.color;
    pen.unit = series.detail.formatter.replace('{value}', '');
    pen.value = series.data[0].value;
    pen.splitNumber = series.splitNumber || basicConfigure.splitNumber;
  }
  pen = {
    ...basicConfigure,
    ...pen
  };
  let r = w > h ? h / 2 * 9 / 10 : w / 2 * 9 / 10;
  let centerX = x + w / 2;
  let centerY = y + h / 2;
  let value = pen.echarts ? pen.echarts.option.series[0].data[0].value : pen.value;
  let pointColor;
  let gap = pen.startAngle - pen.endAngle;
  let bgColor = pen.background || '#E6EBF8';
  //绘制背景
  ctx.strokeStyle = bgColor;
  let bgLineWidth = r / 10;
  ctx.lineWidth = bgLineWidth;
  ctx.beginPath();
  ctx.lineCap = 'round';
  ctx.arc(centerX, centerY, r, -pen.startAngle / 180 * Math.PI, -pen.endAngle / 180 * Math.PI);
  ctx.stroke();
  ctx.closePath();
  let bili = 0;
  if (pen.axisLine && !pen.isClock) {
    for (let i = pen.axisLine.length - 1; i >= 0; i--) {
      if (pen.axisLine[i][0] * (pen.max - pen.min) < value) {
        bili = pen.axisLine[i][0];
      } else {
        bili = (value - pen.min) / (pen.max - pen.min);
        pointColor = pen.axisLine[i][1];
      }
      ctx.beginPath();
      ctx.strokeStyle = pen.axisLine[i][1];
      ctx.arc(centerX, centerY, r, -pen.startAngle / 180 * Math.PI, (-pen.startAngle + bili * gap) / 180 * Math.PI);
      ctx.stroke();
      ctx.closePath();
    }
  }
  ctx.lineCap = 'butt';
  //主刻度线
  let dashWidth = 2 * scale;
  let mainR = r - bgLineWidth;
  if (mainR < 0) {
    mainR = 0;
  }
  let arcLength = gap / 180 * Math.PI * mainR;
  let dash = (arcLength - dashWidth * pen.splitNumber) / pen.splitNumber;
  let offsetAngle = gap / 180 * Math.PI * dashWidth / 2 / arcLength;
  ctx.beginPath();
  ctx.strokeStyle = pen.color || '#999999';
  ctx.lineWidth = r / 20;
  ctx.setLineDash([dashWidth, dash]);
  ctx.arc(centerX, centerY, mainR, -pen.startAngle / 180 * Math.PI - offsetAngle, -pen.endAngle / 180 * Math.PI + offsetAngle);
  ctx.stroke();
  ctx.closePath();
  //从刻度线
  let fromDashWidth = 1 * scale;
  let fromR = r - bgLineWidth;
  if (fromR < 0) {
    fromR = 0;
  }
  let fromArcLength = gap / 180 * Math.PI * fromR;
  let fromDash = (fromArcLength - fromDashWidth * 5 * pen.splitNumber) / 5 / pen.splitNumber;
  let fromOffsetAngle = gap / 180 * Math.PI * fromDashWidth / 2 / fromArcLength;
  ctx.beginPath();
  ctx.strokeStyle = pen.color || '#999999';
  ctx.lineWidth = r / 40;
  ctx.setLineDash([fromDashWidth, fromDash]);
  ctx.arc(centerX, centerY, fromR, -pen.startAngle / 180 * Math.PI - fromOffsetAngle, -pen.endAngle / 180 * Math.PI + fromOffsetAngle);
  ctx.stroke();
  ctx.closePath();
  //绘制文字
  ctx.beginPath();
  let valueGap = pen.max - pen.min;
  let interval = valueGap / pen.splitNumber;
  let fontOption = {
    fontStyle: pen.tickLabel?.fontStyle || pen.calculative.fontStyle,
    textDecoration: pen.tickLabel?.textDecoration || pen.textDecoration,
    fontWeight: pen.tickLabel?.fontWeight || pen.calculative.fontWeight,
    fontFamily: pen.tickLabel?.fontFamily || pen.calculative.fontFamily,
    fontSize: (pen.tickLabel?.fontSize || pen.calculative.fontSize) * scale,
    lineHeight: pen.tickLabel?.lineHeight || pen.calculative.lineHeight
  };
  ctx.font = getFont(fontOption);
  let textR = r - bgLineWidth - r / 20;
  for (let i = 0; i <= pen.splitNumber; i++) {
    if (Math.abs(pen.startAngle) + Math.abs(pen.endAngle) === 360) {
      //形成一个圆形
      if (i == 0) continue;
    }
    let angle = pen.startAngle - interval * i / valueGap * gap;
    let width = Math.cos(angle / 180 * Math.PI);
    let height = Math.sin(angle / 180 * Math.PI);
    ctx.fillStyle = pen.tickLabel?.color || '#999999';
    if (width > 0.02) {
      ctx.textAlign = 'end';
    } else if (width < -0.02) {
      ctx.textAlign = 'start';
    } else {
      ctx.textAlign = 'center';
    }
    if (height > 0.02) {
      ctx.textBaseline = 'top';
    } else if (height < -0.02) {
      ctx.textBaseline = 'bottom';
    } else {
      ctx.textBaseline = 'middle';
    }
    ctx.fillText(getValidValue(interval * i + pen.min, 1), centerX + textR * width, centerY - textR * height);
    ctx.fill();
  }
  ctx.closePath();
  //绘制指针
  let pointNum = 1;
  let valueArray = ['value'];
  if (pen.isClock) {
    pointNum = 3;
    valueArray = ['hourvalue', 'minutevalue', 'secondvalue'];
  }
  if (pen.isClock) {
    for (let i = 0; i < pointNum; i++) {
      let currentAngle = (pen.startAngle - (pen[valueArray[i]] - pen.min) / (pen.max - pen.min) * gap) / 180 * Math.PI;
      if (i > 0) {
        currentAngle = (pen.startAngle - (pen[valueArray[i]] - pen.min) / (pen.max * 5 - pen.min) * gap) / 180 * Math.PI;
      }
      let pointerR = 4 / 5 * r;
      if (valueArray[i] === 'hourvalue') {
        pointerR = 3 / 5 * r;
      }
      if (valueArray[i] === 'minutevalue') {
        pointerR = 3.5 / 5 * r;
      }
      let pointerHalfW = r * 1 / 40;
      ctx.beginPath();
      ctx.setLineDash([]);
      ctx.lineWidth = r / (i + 1) / 20;
      ctx.strokeStyle = pen.color || '#999999';
      ctx.moveTo(centerX - pointerHalfW * 3 * Math.cos(currentAngle), centerY + pointerHalfW * 3 * Math.sin(currentAngle));
      ctx.lineTo(centerX + pointerR * Math.cos(currentAngle), centerY - pointerR * Math.sin(currentAngle));
      ctx.stroke();
    }
  } else {
    let currentAngle = (pen.startAngle - (value - pen.min) / (pen.max - pen.min) * gap) / 180 * Math.PI;
    let pointerR = 4 / 5 * r;
    let pointerHalfW = r * 1 / 40;
    ctx.beginPath();
    ctx.setLineDash([]);
    ctx.lineWidth = 2;
    ctx.fillStyle = pointColor;
    ctx.moveTo(centerX - pointerHalfW * 3 * Math.cos(currentAngle), centerY + pointerHalfW * 3 * Math.sin(currentAngle));
    ctx.lineTo(centerX + pointerHalfW * Math.cos(currentAngle - Math.PI / 2), centerY - pointerHalfW * Math.sin(currentAngle - Math.PI / 2));
    ctx.lineTo(centerX + pointerR * Math.cos(currentAngle), centerY - pointerR * Math.sin(currentAngle));
    ctx.lineTo(centerX + pointerHalfW * Math.cos(currentAngle + Math.PI / 2), centerY - pointerHalfW * Math.sin(currentAngle + Math.PI / 2));
    ctx.lineTo(centerX - pointerHalfW * 3 * Math.cos(currentAngle), centerY + pointerHalfW * 3 * Math.sin(currentAngle));
    ctx.fill();
  }
  //文字描述
  ctx.beginPath();
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  let titleOption = {
    fontStyle: pen.titleLabel?.fontStyle || pen.calculative.fontStyle,
    textDecoration: pen.titleLabel?.textDecoration || pen.textDecoration,
    fontWeight: pen.titleLabel?.fontWeight || pen.calculative.fontWeight,
    fontFamily: pen.titleLabel?.fontFamily || pen.calculative.fontFamily,
    fontSize: (pen.titleLabel?.fontSize || pen.calculative.fontSize) * scale,
    lineHeight: pen.titleLabel?.lineHeight || pen.calculative.lineHeight
  };
  ctx.font = getFont(titleOption);
  ctx.fillStyle = pen.titleLabel?.color || pointColor;
  if (pen.isClock) {
    ctx.fillText(('0' + parseInt(pen.hourvalue)).slice(-2) + ':' + ('0' + parseInt(pen.minutevalue)).slice(-2) + ':' + ('0' + parseInt(pen.secondvalue)).slice(-2), centerX, centerY + r / 2);
  } else {
    ctx.fillText(value + ' ' + (pen.unit || ''), centerX, centerY + r / 2);
  }
  ctx.fill();
  if (pen.isClock) {
    ctx.beginPath();
    ctx.fillStyle = pen.color || '#999999';
    ctx.strokeStyle = '#ffffff';
    ctx.arc(centerX, centerY, r / 20, 0, Math.PI * 2);
    ctx.stroke();
    ctx.fill();
    ctx.closePath();
  }
}
function gauge_onAdd(pen) {
  if (pen.isClock) {
    pen.clockInterval = setInterval(() => {
      let date = new Date();
      let second = date.getSeconds();
      let minute = date.getMinutes() + second / 60;
      let hour = date.getHours() % 12 + minute / 60;
      pen.calculative.canvas.parent.setValue({
        id: pen.id,
        hourvalue: hour,
        minutevalue: minute,
        secondvalue: second
      }, {
        render: true,
        doEvent: false
      });
    }, 1000);
  } else {
    const tem = pen.value;
    pen.value = 0;
    pen.frames = [{
      duration: 2000,
      value: tem
    }];
    pen.calculative.canvas.parent.startAnimate(pen.id);
    setTimeout(() => {
      pen.value = tem;
    }, 1000);
  }
}
function gauge_onDestroy(pen) {
  if (pen.clockInterval) {
    clearInterval(pen.clockInterval);
    pen.clockInterval = undefined;
  }
}
function gauge_onclick(pen) {
  if (pen.isClock) {
    pen.onDestroy(pen);
    pen.onAdd(pen);
  }
}
;// ./node_modules/@kyvi/cobweb-charts/src/register.js




function chartsPens() {
  return {
    lineChart: lineChart,
    histogram: histogram,
    pieChart: pieChart,
    gauge: gauge
  };
}
;// ./node_modules/@kyvi/cobweb-charts/index.js
//le5le charts





;// ./node_modules/@kyvi/fta-drag/src/andGate.js
function andGate(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  const myh = height / 6;
  const myw = width / 4;
  path.moveTo(x + myw * 2, y + 0);
  path.lineTo(x + myw * 2, y + myh);
  path.moveTo(x, y + myh + myw * 2);
  path.arc(x + myw * 2, y + myh + myw * 2, myw * 2, Math.PI * 1, Math.PI * 2, false);
  path.lineTo(x + myw * 4, y + myh * 5);
  path.lineTo(x, y + myh * 5);
  path.lineTo(x, y + myh + myw * 2);
  path.moveTo(x + myw, y + myh * 5);
  path.lineTo(x + myw, y + myh * 6);
  path.moveTo(x + myw * 2, y + myh * 5);
  path.lineTo(x + myw * 2, y + myh * 6);
  path.moveTo(x + myw * 3, y + myh * 5);
  path.lineTo(x + myw * 3, y + myh * 6);
  path.closePath();
  if (path instanceof Path2D) return path;
}
function andGateAnchors(pen) {
  const points = [{
    x: 0.5,
    y: 0
  }, {
    x: 0.25,
    y: 1
  }, {
    x: 0.5,
    y: 1
  }, {
    x: 0.75,
    y: 1
  }];
  pen.anchors = points.map(({
    x,
    y
  }, index) => {
    return {
      id: `${index}`,
      penId: pen.id,
      x,
      y
    };
  });
}
;// ./node_modules/@kyvi/fta-drag/src/basicEvent.js
function basicEvent(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  const vlineL = height - width;
  const radius = 0.5 * width;
  path.moveTo(x + width / 2, y);
  path.lineTo(x + width / 2, y + vlineL);
  path.moveTo(x + width, y + radius + vlineL);
  path.arc(x + width / 2, y + radius + vlineL, radius, 0, Math.PI * 2, false);
  path.closePath();
  if (path instanceof Path2D) return path;
}
function basicEventAnchors(pen) {
  const points = [{
    x: 0.5,
    y: 0
  }, {
    x: 0.5,
    y: 1
  }];
  pen.anchors = points.map(({
    x,
    y
  }, index) => {
    return {
      id: `${index}`,
      penId: pen.id,
      x,
      y
    };
  });
}
;// ./node_modules/@kyvi/fta-drag/src/conditionalEvent.js
function conditionalEvent(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  const myh = height / 2;
  const myw = width / 5;
  path.moveTo(x, y + myh);
  path.lineTo(x + myw, y + myh);
  path.moveTo(x + myw * 5, y + myh);
  path.ellipse(x + myw * 3, y + myh, 2 * myw, myh, 0, 0, Math.PI * 2);
  path.closePath();
  if (path instanceof Path2D) return path;
}
function conditionalEventAnchors(pen) {
  const points = [{
    x: 0.6,
    y: 0
  }, {
    x: 1,
    y: 0.5
  }, {
    x: 0.6,
    y: 1
  }, {
    x: 0,
    y: 0.5
  }];
  pen.anchors = points.map(({
    x,
    y
  }, index) => {
    return {
      id: `${index}`,
      penId: pen.id,
      x,
      y
    };
  });
}
;// ./node_modules/@kyvi/fta-drag/src/event.js
function event_event(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  const myh = height / 4;
  const myw = 0.5 * width;
  path.moveTo(x + myw, y);
  path.lineTo(x + myw, y + myh);
  path.moveTo(x, y + myh);
  path.rect(x, y + myh, myw * 2, myh * 2);
  path.moveTo(x + myw, y + 3 * myh);
  path.lineTo(x + myw, y + 4 * myh);
  path.closePath();
  if (path instanceof Path2D) return path;
}
;// ./node_modules/@kyvi/fta-drag/src/forbiddenGate.js
function forbiddenGate(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  const myh = height / 8;
  const myw = 0.25 * width;
  path.moveTo(x + myw * 2, y);
  path.lineTo(x + myw * 2, y + myh * 2);
  path.lineTo(x + myw * 3, y + myh * 3);
  path.lineTo(x + myw * 3, y + myh * 5);
  path.lineTo(x + myw * 2, y + myh * 6);
  path.lineTo(x + myw * 1, y + myh * 5);
  path.lineTo(x + myw * 1, y + myh * 3);
  path.lineTo(x + myw * 2, y + myh * 2);
  path.moveTo(x + myw * 3, y + myh * 4);
  path.lineTo(x + myw * 4, y + myh * 4);
  path.moveTo(x + myw * 2, y + myh * 6);
  path.lineTo(x + myw * 2, y + myh * 8);
  path.closePath();
  if (path instanceof Path2D) return path;
}
function forbiddenGateAnchors(pen) {
  const points = [{
    x: 0.5,
    y: 0
  }, {
    x: 1,
    y: 0.5
  }, {
    x: 0.5,
    y: 1
  }];
  pen.anchors = points.map(({
    x,
    y
  }, index) => {
    return {
      id: `${index}`,
      penId: pen.id,
      x,
      y
    };
  });
}
;// ./node_modules/@kyvi/fta-drag/src/orGate.js
function orGate(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  const myw = width / 2;
  const myh = height / 10;
  path.moveTo(x + myw, y);
  path.lineTo(x + myw, y + myh);
  path.moveTo(x + myw, y + myh);
  path.quadraticCurveTo(x + myw * 2, y + myh, x + myw * 2, y + myh * 9);
  path.moveTo(x + myw, y + myh);
  path.quadraticCurveTo(x, y + myh, x, y + myh * 9);
  path.quadraticCurveTo(x + myw, y + myh * 6, x + myw * 2, y + myh * 9);
  path.moveTo(x + myw, y + height * 3 / 4);
  path.lineTo(x + myw, y + height);
  path.moveTo(x + myw * 2 / 5, y + height * 201 / 250);
  path.lineTo(x + myw * 2 / 5, y + height);
  path.moveTo(x + myw * 8 / 5, y + height * 201 / 250);
  path.lineTo(x + myw * 8 / 5, y + height);
  path.closePath();
  if (path instanceof Path2D) return path;
}
function orGateAnchors(pen) {
  const points = [{
    x: 0.5,
    y: 0
  }, {
    x: 0.2,
    y: 1
  }, {
    x: 0.5,
    y: 1
  }, {
    x: 0.8,
    y: 1
  }];
  pen.anchors = points.map(({
    x,
    y
  }, index) => {
    return {
      id: `${index}`,
      penId: pen.id,
      x,
      y
    };
  });
}
;// ./node_modules/@kyvi/fta-drag/src/priorityAndGate.js
function priorityAndGate(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  const myh = height / 6;
  const myw = width / 4;
  path.moveTo(x + myw * 2, y + 0);
  path.lineTo(x + myw * 2, y + myh);
  path.moveTo(x, y + myh + myw * 2);
  path.arc(x + myw * 2, y + myh + myw * 2, myw * 2, Math.PI * 1, Math.PI * 2, false);
  path.lineTo(x + myw * 4, y + myh * 5);
  path.lineTo(x, y + myh * 5);
  path.lineTo(x, y + myh + myw * 2);
  path.moveTo(x, y + myh * 5 - myh / 3);
  path.lineTo(x + myw * 4, y + myh * 5 - myh / 3);
  path.moveTo(x + myw, y + myh * 5);
  path.lineTo(x + myw, y + myh * 6);
  path.moveTo(x + myw * 2, y + myh * 5);
  path.lineTo(x + myw * 2, y + myh * 6);
  path.moveTo(x + myw * 3, y + myh * 5);
  path.lineTo(x + myw * 3, y + myh * 6);
  path.closePath();
  if (path instanceof Path2D) return path;
}
;// ./node_modules/@kyvi/fta-drag/src/switchEvent.js
function switchEvent(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  const myh = height / 4;
  const myw = 0.5 * width;
  path.moveTo(x + myw, y);
  path.lineTo(x + myw, y + myh);
  path.lineTo(x + myw * 2, y + myh * 2);
  path.lineTo(x + myw * 2, y + myh * 4);
  path.lineTo(x, y + myh * 4);
  path.lineTo(x, y + myh * 2);
  path.lineTo(x + myw, y + myh);
  path.closePath();
  if (path instanceof Path2D) return path;
}
;// ./node_modules/@kyvi/fta-drag/src/transferSymbol.js
function transferSymbol(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  const myh = height / 4;
  const myw = width / 2;
  path.moveTo(x + myw, y);
  path.lineTo(x + myw, y + myh);
  path.lineTo(x + myw * 2, y + myh * 4);
  path.lineTo(x, y + myh * 4);
  path.lineTo(x + myw, y + myh);
  path.closePath();
  if (path instanceof Path2D) return path;
}
;// ./node_modules/@kyvi/fta-drag/src/unexpandedEvent.js
function unexpandedEvent(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  const myh = height / 3;
  const myw = 0.5 * width;
  path.moveTo(x + myw, y);
  path.lineTo(x + myw, y + myh);
  path.lineTo(x + width, y + 2 * myh);
  path.lineTo(x + myw, y + height);
  path.lineTo(x, y + 2 * myh);
  path.lineTo(x + myw, y + myh);
  path.closePath();
  if (path instanceof Path2D) return path;
}
function unexpandedEventAnchors(pen) {
  const points = [{
    x: 0.5,
    y: 0
  }, {
    x: 1,
    y: 2 / 3
  }, {
    x: 0.5,
    y: 1
  }, {
    x: 0,
    y: 2 / 3
  }];
  pen.anchors = points.map(({
    x,
    y
  }, index) => {
    return {
      id: `${index}`,
      penId: pen.id,
      x,
      y
    };
  });
}
;// ./node_modules/@kyvi/fta-drag/src/votingGate.js
function votingGate(ctx, pen) {
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  const myw = width / 2;
  const myh = height / 10;
  ctx.beginPath();
  ctx.moveTo(x + myw, y);
  ctx.lineTo(x + myw, y + myh);
  ctx.moveTo(x + myw, y + myh);
  ctx.quadraticCurveTo(x + myw * 2, y + myh, x + myw * 2, y + myh * 9);
  ctx.moveTo(x + myw, y + myh);
  ctx.quadraticCurveTo(x, y + myh, x, y + myh * 9);
  ctx.quadraticCurveTo(x + myw, y + myh * 6, x + myw * 2, y + myh * 9);
  ctx.moveTo(x + myw, y + height * 3 / 4);
  ctx.lineTo(x + myw, y + height * 9 / 10);
  ctx.moveTo(x + myw * 2 / 5, y + height * 201 / 250);
  ctx.lineTo(x + myw * 2 / 5, y + height * 9 / 10);
  ctx.moveTo(x + myw * 8 / 5, y + height * 201 / 250);
  ctx.lineTo(x + myw * 8 / 5, y + height * 9 / 10);
  ctx.stroke();
  ctx.closePath();
  ctx.beginPath();
  const fontSize = myw * 2 > myh * 10 ? myh : myw / 5;
  ctx.fillStyle = '#333333';
  ctx.font = fontSize + 'px Arial';
  ctx.textBaseline = 'bottom';
  ctx.textAlign = 'center';
  ctx.fillText('o', x + myw, y + height);
  ctx.fillText('m', x + myw * 2 / 5, y + height);
  ctx.fillText('o', x + myw * 8 / 5, y + height);
  ctx.closePath();
}
;// ./node_modules/@kyvi/fta-drag/src/xorGate.js
function xorGate(pen, ctx) {
  const path = !ctx ? new Path2D() : ctx;
  const {
    x,
    y,
    width,
    height
  } = pen.calculative.worldRect;
  let myw = width / 2;
  let myh = height / 10;
  path.moveTo(x + myw, y);
  path.lineTo(x + myw, y + myh);
  path.moveTo(x + myw, y + myh);
  path.quadraticCurveTo(x + myw * 2, y + myh, x + myw * 2, y + myh * 9);
  path.moveTo(x + myw, y + myh);
  path.quadraticCurveTo(x, y + myh, x, y + myh * 9);
  path.quadraticCurveTo(x + myw, y + myh * 6, x + myw * 2, y + myh * 9);
  path.moveTo(x, y + myh * 10);
  path.quadraticCurveTo(x + myw, y + myh * 7, x + myw * 2, y + myh * 10);
  path.moveTo(x + myw * 2 / 5, y + height * 201 / 250 + myh);
  path.lineTo(x + myw * 2 / 5, y + height);
  path.moveTo(x + myw * 8 / 5, y + height * 201 / 250 + myh);
  path.lineTo(x + myw * 8 / 5, y + height);
  path.closePath();
  if (path instanceof Path2D) return path;
}
function xorGateAnchors(pen) {
  const points = [{
    x: 0.5,
    y: 0
  }, {
    x: 1 / 5,
    y: 1
  }, {
    x: 4 / 5,
    y: 1
  }];
  pen.anchors = points.map(({
    x,
    y
  }, index) => {
    return {
      id: `${index}`,
      penId: pen.id,
      x,
      y
    };
  });
}
;// ./node_modules/@kyvi/fta-drag/src/register.js












function ftaPens() {
  return {
    andGate: andGate,
    basicEvent: basicEvent,
    conditionalEvent: conditionalEvent,
    event: event_event,
    forbiddenGate: forbiddenGate,
    orGate: orGate,
    priorityAndGate: priorityAndGate,
    switchEvent: switchEvent,
    transferSymbol: transferSymbol,
    unexpandedEvent: unexpandedEvent,
    xorGate: xorGate
  };
}
function ftaPensbyCtx() {
  return {
    votingGate: votingGate
  };
}
function ftaAnchors() {
  return {
    andGate: andGateAnchors,
    orGate: orGateAnchors,
    priorityAndGate: andGateAnchors,
    votingGate: orGateAnchors,
    xorGate: xorGateAnchors,
    forbiddenGate: forbiddenGateAnchors,
    basicEvent: basicEventAnchors,
    unexpandedEvent: unexpandedEventAnchors,
    conditionalEvent: conditionalEventAnchors,
    transferSymbol: basicEventAnchors
  };
}
;// ./src/utils/selections.js
/*
 * @Description: 
 * @Author: Kevin
 * @Date: 2024-10-29 09:22:39
 * @LastEditors: Kevin
 * @LastEditTime: 2024-10-29 11:28:13
 */

const selections = {
  // 选中对象类型：0 - 画布；1 - 单个图元
  mode: 1,
  pen: undefined
};
const useSelection = () => {
  const select = (pens = []) => {
    if (!pens || pens.length !== 1) {
      selections.mode = 0;
      selections.pen = undefined;
      return;
    }
    selections.mode = 1;
    selections.pen = pens[0];
  };
  return {
    selections,
    select
  };
};
;// ./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/Editor.vue?vue&type=script&lang=js
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//












const {
  selections: Editorvue_type_script_lang_js_selections,
  select: Editorvue_type_script_lang_js_select
} = useSelection();
/* harmony default export */ var Editorvue_type_script_lang_js = ({
  name: 'Editor-drag',
  props: {
    cobweb: String
  },
  data() {
    return {
      scale: 0,
      selections: Editorvue_type_script_lang_js_selections,
      highlight: [],
      menuPosition: {},
      activeMenu: '',
      showMenu: false
    };
  },
  // 处理推送数据
  mounted() {
    // 创建实例
    window.cobweb = new Meta2d("operation_center", {
      rule: false
    });
    const timer = setInterval(() => {
      if (window.cobweb) {
        clearInterval(timer);
        // 获取初始缩放比例
        this.scaleSubscriber(window.cobweb.store.data.scale);
        window.cobweb.setOptions();
        // 监听缩放
        window.cobweb.on("scale", val => this.scaleSubscriber(val));
      }
    }, 200);

    // 按需注册图形库
    // 以下为自带基础图形库
    register(flowPens());
    registerAnchors(flowAnchors());
    register(activityDiagram());
    registerCanvasDraw(activityDiagramByCtx());
    register(classPens());
    register(sequencePens());
    registerCanvasDraw(sequencePensbyCtx());
    register_register();
    registerCanvasDraw(formPens());
    registerCanvasDraw(chartsPens());
    register(ftaPens());
    registerCanvasDraw(ftaPensbyCtx());
    registerAnchors(ftaAnchors());

    // 注册其他自定义图形库
    let data = xxtea.xxtea_decrypt(this.cobweb);
    if (data) {
      data = JSON.parse(data);
      data.locked = 0;
      window.cobweb.open(data);
    } else {
      window.cobweb.open({
        name: '新建可视化应用',
        pens: []
      });
    }
    window.cobweb.on("active", this.active);
    window.cobweb.on("inactive", this.inactive);
    // 右键菜单
    window.cobweb.on("contextmenu", this.showContextMenu);
    // 点击画布
    window.cobweb.on("click", this.hideContextMenu);
  },
  methods: {
    // 
    clickHandler(data) {
      if (data.value === "auto") {
        window.cobweb.fitView();
        return;
      }
      window.cobweb.centerView();
      window.cobweb.scale(data.value);
    },
    // 缩放监听
    scaleSubscriber(val) {
      this.scale = Math.round(val * 100);
    },
    active(pens) {
      console.log(pens[0]);
      if (pens?.length) {
        this.highlight = pens || [];
        Editorvue_type_script_lang_js_select(pens);
      }
    },
    showContextMenu(val) {
      this.showMenu = true;
      this.menuPosition = {
        top: val.e.clientY - val.clientRect.top + "px",
        left: val.e.clientX - val.clientRect.left + 20 + "px"
      };
    },
    hideContextMenu() {
      this.showMenu = false;
      this.activeMenu = "";
    },
    inactive() {
      Editorvue_type_script_lang_js_select();
    },
    deleteNode() {
      window.cobweb.delete();
      this.hideContextMenu();
    },
    top() {
      window.cobweb.top();
      window.cobweb.render();
      this.hideContextMenu();
    },
    bottom() {
      window.cobweb.bottom();
      window.cobweb.render();
      this.hideContextMenu();
    },
    up() {
      window.cobweb.up();
      window.cobweb.render();
      this.hideContextMenu();
    },
    down() {
      window.cobweb.down();
      window.cobweb.render();
      this.hideContextMenu();
    },
    // 组合为状态
    combineStatus() {
      window.cobweb.combine(this.highlight, 0);
      this.hideContextMenu();
    },
    // 组合
    combine() {
      window.cobweb.combine(this.highlight);
      this.hideContextMenu();
    },
    // 组合解除
    uncombine() {
      window.cobweb.uncombine(Editorvue_type_script_lang_js_selections.pen);
      this.hideContextMenu();
    },
    distoryed() {
      window.cobweb.destroy();
    }
  }
});
;// ./src/components/Editor.vue?vue&type=script&lang=js
 /* harmony default export */ var components_Editorvue_type_script_lang_js = (Editorvue_type_script_lang_js); 
;// ./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-22.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-22.use[1]!./node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-22.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-22.use[3]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/Editor.vue?vue&type=style&index=0&id=4aa8126b&prod&scoped=true&lang=scss
// extracted by mini-css-extract-plugin

;// ./src/components/Editor.vue?vue&type=style&index=0&id=4aa8126b&prod&scoped=true&lang=scss

;// ./src/components/Editor.vue



;


/* normalize component */

var Editor_component = normalizeComponent(
  components_Editorvue_type_script_lang_js,
  Editorvue_type_template_id_4aa8126b_scoped_true_render,
  Editorvue_type_template_id_4aa8126b_scoped_true_staticRenderFns,
  false,
  null,
  "4aa8126b",
  null
  
)

/* harmony default export */ var Editor = (Editor_component.exports);
;// ./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/package/Editor/Editor.vue?vue&type=script&lang=js
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ var Editor_Editorvue_type_script_lang_js = ({
  name: "CobwebEditor",
  components: {
    Editor: Editor
  },
  props: {
    cobweb: String
  },
  data() {
    return {};
  },
  computed: {},
  watch: {},
  created() {},
  mounted() {},
  methods: {}
});
;// ./src/package/Editor/Editor.vue?vue&type=script&lang=js
 /* harmony default export */ var package_Editor_Editorvue_type_script_lang_js = (Editor_Editorvue_type_script_lang_js); 
;// ./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-22.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-22.use[1]!./node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-22.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-22.use[3]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/package/Editor/Editor.vue?vue&type=style&index=0&id=127c7d23&prod&scoped=true&lang=scss
// extracted by mini-css-extract-plugin

;// ./src/package/Editor/Editor.vue?vue&type=style&index=0&id=127c7d23&prod&scoped=true&lang=scss

;// ./src/package/Editor/Editor.vue



;


/* normalize component */

var Editor_Editor_component = normalizeComponent(
  package_Editor_Editorvue_type_script_lang_js,
  Editorvue_type_template_id_127c7d23_scoped_true_render,
  Editorvue_type_template_id_127c7d23_scoped_true_staticRenderFns,
  false,
  null,
  "127c7d23",
  null
  
)

/* harmony default export */ var Editor_Editor = (Editor_Editor_component.exports);
;// ./src/package/index.js
/*
 * @Description: 
 * @Author: Kevin
 * @Date: 2024-10-18 15:08:45
 * @LastEditors: Kevin
 * @LastEditTime: 2024-10-29 11:23:24
 */
//package/index.js


const com = [Index, Editor_Editor];
const install = function (Vue) {
  com.forEach(com => {
    Vue.component(com.name, com);
  });
};
/* harmony default export */ var src_package = (install);
;// ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js


/* harmony default export */ var entry_lib = (src_package);


}();
module.exports = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=cobweb-preview.common.js.map